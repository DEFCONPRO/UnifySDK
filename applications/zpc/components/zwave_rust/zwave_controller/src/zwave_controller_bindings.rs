/* automatically generated by rust-bindgen 0.59.1 */

pub type sl_status_t = u32;
#[doc = " Node mask"]
pub type zwave_nodemask_t = [u8; 501usize];
#[doc = " Z-Wave NodeID type"]
pub type zwave_node_id_t = u16;
#[doc = " Z-Wave HomeID type"]
pub type zwave_home_id_t = u32;
#[repr(u32)]
#[doc = " @brief Z-Wave Inclusion Protocol (Z-Wave / Z-Wave Long Range)."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum zwave_protocol {
    #[doc = " Node is operating on the Z-Wave PHY/MAC/NWK"]
    #[doc = ""]
    PROTOCOL_ZWAVE = 0,
    #[doc = " Node is operating on the Z-Wave Long Range PHY/MAC/NWK"]
    #[doc = ""]
    PROTOCOL_ZWAVE_LONG_RANGE = 1,
    #[doc = " We do not know the protocol of that node."]
    #[doc = ""]
    PROTOCOL_UNKNOWN = 2,
}
#[doc = " @brief Z-Wave Inclusion Protocol (Z-Wave / Z-Wave Long Range)."]
pub use self::zwave_protocol as zwave_protocol_t;
#[repr(u32)]
#[doc = " @name zwapi_rf_region_t"]
#[doc = " These definitions represent possible rf settings for the Z-Wave module"]
#[doc = " RF region values used with zwapi_set_rf_region() and zwapi_get_rf_region()"]
#[doc = "@{"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum zwave_rf_region_t {
    ZWAVE_RF_REGION_EU = 0,
    ZWAVE_RF_REGION_US = 1,
    ZWAVE_RF_REGION_ANZ = 2,
    ZWAVE_RF_REGION_HK = 3,
    ZWAVE_RF_REGION_IN = 5,
    ZWAVE_RF_REGION_IL = 6,
    ZWAVE_RF_REGION_RU = 7,
    ZWAVE_RF_REGION_CN = 8,
    ZWAVE_RF_REGION_US_LR = 9,
    ZWAVE_RF_REGION_JP = 32,
    ZWAVE_RF_REGION_KR = 33,
    ZWAVE_RF_REGION_UNDEFINED = 254,
}
pub type zwave_dsk_t = [u8; 16usize];
pub type zwave_node_list_t = zwave_nodemask_t;
pub type zwave_multicast_group_id_t = u8;
pub use self::zwave_rf_region_t as zwave_controller_region_t;
pub type zwave_endpoint_id_t = u8;
pub type zwave_command_class_t = u16;
#[doc = " @brief Structure holding a Z-Wave node info frame."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zwave_node_info_t {
    #[doc = " This represents the first byte of the NIF, also known as \"capability\""]
    #[doc = " It is composed of several subfields that can be read using the"]
    #[doc = " ZWAVE_NODE_INFO_LISTENING_PROTOCOL_* masks. For a complete field"]
    #[doc = " description, refer to @ref application_cc_spec, section Node Information Frame."]
    pub listening_protocol: u8,
    #[doc = " This represents the first byte of the NIF, also known as \"security\""]
    #[doc = " It is composed of several subfields that can be read using the"]
    #[doc = " ZWAVE_NODE_INFO_OPTIONAL_PROTOCOL_* masks. For a complete field"]
    #[doc = " description, refer to @ref application_cc_spec, section Node Information Frame."]
    pub optional_protocol: u8,
    #[doc = " This field indicates the Basic Device Class of the actual node."]
    #[doc = " The Basic Device Classes are listed in @ref device_class_spec."]
    #[doc = " This byte is omitted by End Nodes and will be set to 0x00 in this case."]
    pub basic_device_class: u8,
    #[doc = " This field indicates the Generic Device Class of the actual node."]
    #[doc = " The Generic Device Classes are listed in @ref device_class_spec for"]
    #[doc = " Z-Wave and @ref device_type_spec_v2, @ref device_type_spec for Z-Wave Plus"]
    pub generic_device_class: u8,
    #[doc = " This field indicates the Specific Device Class of the actual node."]
    #[doc = " The Specific Device Classes are listed in @ref device_class_spec for"]
    #[doc = " Z-Wave and @ref device_type_spec, @ref device_type_spec_v2 for Z-Wave Plus"]
    pub specific_device_class: u8,
    #[doc = " Length of the command class list"]
    pub command_class_list_length: u8,
    #[doc = " List of command classes supported by the device."]
    #[doc = ""]
    pub command_class_list: [zwave_command_class_t; 150usize],
}
#[test]
fn bindgen_test_layout_zwave_node_info_t() {
    assert_eq!(
        ::std::mem::size_of::<zwave_node_info_t>(),
        306usize,
        concat!("Size of: ", stringify!(zwave_node_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<zwave_node_info_t>(),
        2usize,
        concat!("Alignment of ", stringify!(zwave_node_info_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_node_info_t>())).listening_protocol as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_node_info_t),
            "::",
            stringify!(listening_protocol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_node_info_t>())).optional_protocol as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_node_info_t),
            "::",
            stringify!(optional_protocol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_node_info_t>())).basic_device_class as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_node_info_t),
            "::",
            stringify!(basic_device_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_node_info_t>())).generic_device_class as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_node_info_t),
            "::",
            stringify!(generic_device_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_node_info_t>())).specific_device_class as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_node_info_t),
            "::",
            stringify!(specific_device_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_node_info_t>())).command_class_list_length as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_node_info_t),
            "::",
            stringify!(command_class_list_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_node_info_t>())).command_class_list as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_node_info_t),
            "::",
            stringify!(command_class_list)
        )
    );
}
impl Default for zwave_node_info_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " Encapsulation schemes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum zwave_controller_encapsulation_scheme_t {
    #[doc = " Network Scheme"]
    #[doc = ""]
    ZWAVE_CONTROLLER_ENCAPSULATION_NETWORK_SCHEME = 0,
    #[doc = " Unencrypted"]
    #[doc = ""]
    ZWAVE_CONTROLLER_ENCAPSULATION_NONE = 1,
    #[doc = " Security Scheme 0"]
    #[doc = ""]
    ZWAVE_CONTROLLER_ENCAPSULATION_SECURITY_0 = 2,
    #[doc = " Security 2, unauthenticated"]
    #[doc = ""]
    ZWAVE_CONTROLLER_ENCAPSULATION_SECURITY_2_UNAUTHENTICATED = 3,
    #[doc = " Security 2, authenticated"]
    #[doc = ""]
    ZWAVE_CONTROLLER_ENCAPSULATION_SECURITY_2_AUTHENTICATED = 4,
    #[doc = " Security 2, access"]
    #[doc = ""]
    ZWAVE_CONTROLLER_ENCAPSULATION_SECURITY_2_ACCESS = 5,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct zwave_controller_endpoint_t {
    pub __bindgen_anon_1: zwave_controller_endpoint_t__bindgen_ty_1,
    #[doc = " Endpoint Id. Set to 0 if a message is sent or received  without"]
    #[doc = " Multi Channel encapsulation"]
    #[doc = " Note that bit 7 is a multi-endpoint mask addressing. If bit 7 is set to 1"]
    #[doc = " the endpoint_id field MUST be interpreted as a bitmask, with bit 0"]
    #[doc = " representing endpoint 1, bit 1, representing endpoint 2, ...,"]
    #[doc = " bit 6 representing endpoint 7."]
    pub endpoint_id: zwave_endpoint_id_t,
    #[doc = " This flag is set to true if should be sent as a multicast frame"]
    #[doc = " S2 Multicasts or unencrypted broadcasts must not use this bit and"]
    #[doc = " simply set the remote.node_id to ZWAVE_BROADCAST_NODE_ID."]
    pub is_multicast: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union zwave_controller_endpoint_t__bindgen_ty_1 {
    #[doc = " Node Id"]
    #[doc = ""]
    pub node_id: zwave_node_id_t,
    #[doc = " Multicast group to use when sending multicast messages"]
    #[doc = ""]
    pub multicast_group: zwave_multicast_group_id_t,
}
#[test]
fn bindgen_test_layout_zwave_controller_endpoint_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<zwave_controller_endpoint_t__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(zwave_controller_endpoint_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<zwave_controller_endpoint_t__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(zwave_controller_endpoint_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_endpoint_t__bindgen_ty_1>())).node_id
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_endpoint_t__bindgen_ty_1),
            "::",
            stringify!(node_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_endpoint_t__bindgen_ty_1>())).multicast_group
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_endpoint_t__bindgen_ty_1),
            "::",
            stringify!(multicast_group)
        )
    );
}
impl Default for zwave_controller_endpoint_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_zwave_controller_endpoint_t() {
    assert_eq!(
        ::std::mem::size_of::<zwave_controller_endpoint_t>(),
        4usize,
        concat!("Size of: ", stringify!(zwave_controller_endpoint_t))
    );
    assert_eq!(
        ::std::mem::align_of::<zwave_controller_endpoint_t>(),
        2usize,
        concat!("Alignment of ", stringify!(zwave_controller_endpoint_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_endpoint_t>())).endpoint_id as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_endpoint_t),
            "::",
            stringify!(endpoint_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_endpoint_t>())).is_multicast as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_endpoint_t),
            "::",
            stringify!(is_multicast)
        )
    );
}
impl Default for zwave_controller_endpoint_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Structure holding information about the source and destination"]
#[doc = " when transmitting and receiving Z-Wave frames."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct zwave_controller_connection_info {
    #[doc = " Local end of this connection, ie this device"]
    #[doc = ""]
    pub local: zwave_controller_endpoint_t,
    #[doc = " remote end of this connection, ie not this device."]
    #[doc = ""]
    pub remote: zwave_controller_endpoint_t,
    #[doc = " The encapsulation used by the sender. When transmitting"]
    #[doc = " the sender is this device."]
    #[doc = ""]
    pub encapsulation: zwave_controller_encapsulation_scheme_t,
}
#[test]
fn bindgen_test_layout_zwave_controller_connection_info() {
    assert_eq!(
        ::std::mem::size_of::<zwave_controller_connection_info>(),
        12usize,
        concat!("Size of: ", stringify!(zwave_controller_connection_info))
    );
    assert_eq!(
        ::std::mem::align_of::<zwave_controller_connection_info>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(zwave_controller_connection_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_connection_info>())).local as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_connection_info),
            "::",
            stringify!(local)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_connection_info>())).remote as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_connection_info),
            "::",
            stringify!(remote)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_connection_info>())).encapsulation as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_connection_info),
            "::",
            stringify!(encapsulation)
        )
    );
}
impl Default for zwave_controller_connection_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Structure holding information about the source and destination"]
#[doc = " when transmitting and receiving Z-Wave frames."]
pub type zwave_controller_connection_info_t = zwave_controller_connection_info;
#[doc = " @brief Describing receive parameters of a frame."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zwave_rx_receive_options_t {
    #[doc = " Received frame status flags"]
    #[doc = ""]
    #[doc = " - RECEIVE_STATUS_ROUTED_BUSY A response route is locked by the application"]
    #[doc = " - RECEIVE_STATUS_LOW_POWER Received at low output power level"]
    #[doc = " - RECEIVE_STATUS_TYPE_SINGLE Received a single cast frame"]
    #[doc = " - RECEIVE_STATUS_TYPE_BROAD Received a broadcast frame"]
    #[doc = " - RECEIVE_STATUS_TYPE_MULTI Received a multicast frame"]
    #[doc = " - RECEIVE_STATUS_TYPE_EXPLORE Received an explore frame"]
    #[doc = " - RECEIVE_STATUS_FOREIGN_FRAME The received frame is not addressed to this"]
    #[doc = "   node (Only valid in promiscuous mode)"]
    #[doc = " - RECEIVE_STATUS_FOREIGN_HOMEID The received frame is received from a"]
    #[doc = "   foreign HomeID. Only Controllers in Smart Start AddNode mode can receive this"]
    pub status_flags: u8,
    #[doc = " RSSI measurement of the received frame This is a signed 8-bit value."]
    #[doc = ""]
    #[doc = " Values from RSSI_RESERVED_START to 124 are reserved."]
    #[doc = " - All values below RSSI_RESERVED_START are received power in dBm."]
    #[doc = " - RSSI_NOT_AVAILABLE - RSSI measurement not available"]
    #[doc = " - RSSI_MAX_POWER_SATURATED - Receiver saturated. RSSI too high to measure precisely"]
    #[doc = " - RSSI_BELOW_SENSITIVITY - No signal detected. The RSSI is too low to measure precisely."]
    pub rssi: i8,
    #[doc = " Node list for z-wave multicast frames."]
    #[doc = ""]
    pub nodes_in_multicast: zwave_node_list_t,
}
#[test]
fn bindgen_test_layout_zwave_rx_receive_options_t() {
    assert_eq!(
        ::std::mem::size_of::<zwave_rx_receive_options_t>(),
        503usize,
        concat!("Size of: ", stringify!(zwave_rx_receive_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<zwave_rx_receive_options_t>(),
        1usize,
        concat!("Alignment of ", stringify!(zwave_rx_receive_options_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_rx_receive_options_t>())).status_flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_rx_receive_options_t),
            "::",
            stringify!(status_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zwave_rx_receive_options_t>())).rssi as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_rx_receive_options_t),
            "::",
            stringify!(rssi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_rx_receive_options_t>())).nodes_in_multicast as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_rx_receive_options_t),
            "::",
            stringify!(nodes_in_multicast)
        )
    );
}
impl Default for zwave_rx_receive_options_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " @brief States of the Network Management module."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum zwave_network_management_state_t {
    #[doc = " Idle state."]
    NM_IDLE = 0,
    #[doc = " Add mode state."]
    #[doc = " Direct range/NWI, S2, or Smart Start."]
    #[doc = ""]
    #[doc = " Waiting for protocol.  On \\ref NM_EV_ADD_NODE_FOUND, go to \\ref NM_NODE_FOUND."]
    NM_WAITING_FOR_ADD = 1,
    #[doc = " Add mode state."]
    #[doc = " Direct range/NWI, S2, Smart Start, Proxy Inclusion, or Proxy Replace."]
    #[doc = ""]
    #[doc = " Waiting for protocol to receive node info from a node.  On \\ref"]
    #[doc = " NM_EV_ADD_CONTROLLER or \\ref NM_EV_ADD_END_NODE, cache the node"]
    #[doc = " id and node info and go to \\ref NM_WAIT_FOR_PROTOCOL."]
    NM_NODE_FOUND = 2,
    #[doc = " Add mode state."]
    #[doc = " Direct range/NWI, S2, Smart Start, Proxy Inclusion, or Proxy Replace."]
    #[doc = ""]
    #[doc = " Waiting for protocol to assign node ID and home ID to the new node."]
    #[doc = ""]
    #[doc = " On \\ref NM_EV_ADD_PROTOCOL_DONE, send an ADD_NODE_STOP to"]
    #[doc = " protocol.  On \\ref NM_EV_ADD_NODE_STATUS_DONE, register the new"]
    #[doc = " node in \\ref node_db and go to \\ref NM_WAIT_FOR_SECURE_ADD.  If"]
    #[doc = " GW is handling inclusion, start security processing the new node"]
    #[doc = " (S2 or S0 inclusion).  Otherwise, start a 2 s timer and go to \\ref"]
    #[doc = " NM_PREPARE_SUC_INCLISION."]
    NM_WAIT_FOR_PROTOCOL = 3,
    #[doc = " Learn mode state (exclusion).  Also used if GW is processing DEFAULT_SET."]
    #[doc = ""]
    #[doc = " Waiting for NetworkManagement_mdns_exited() to be called from"]
    #[doc = " \\ref ZIP_Router.  Post \\ref ZIP_EVENT_RESET to \\ref ZIP_Router"]
    #[doc = " and call SendReplyWhenNetworkIsUpdated() to go to \\ref"]
    #[doc = " NM_WAITING_FOR_PROBE.  SendReplyWhenNetworkIsUpdated() sets up a"]
    #[doc = " trigger to bring NMS back to \\ref NM_IDLE when the gateway reset"]
    #[doc = " is completed."]
    #[doc = ""]
    #[doc = " \\note When changing to this state, we MUST call rd_exit() to advance"]
    #[doc = " the state machine."]
    NM_SET_DEFAULT = 4,
    #[doc = " Learn mode state."]
    #[doc = ""]
    #[doc = " GW is processing LEARN_SET, waiting for protocol."]
    #[doc = ""]
    #[doc = " On callback (LearnModeStatus()) with LEARN_MODE_STARTED, go to \\ref"]
    #[doc = " NM_LEARN_MODE_STARTED, Lock RD probe machine, invalidate"]
    #[doc = " MyNodeID, and start S2 learn-mode state machine."]
    #[doc = ""]
    #[doc = " Can be canceled or time out.  This will trigger a partial"]
    #[doc = " re-initialization of the gateway (ApplicationInitNIF()), unlock RD"]
    #[doc = " probe.  ResetState() from nm_send_reply() with the"]
    #[doc = " LEARN_MODE_FAILED will bring NMS back to \\ref NM_IDLE."]
    NM_LEARN_MODE = 5,
    #[doc = " Learn mode state."]
    #[doc = ""]
    #[doc = " The gateway is processing LEARN_SET and has received"]
    #[doc = " LEARN_MODE_STARTED from protocol.  Now the protocol is committed"]
    #[doc = " and the gateway waits for protocol completion."]
    #[doc = ""]
    #[doc = " On protocol callback (LearnModeStatus()) with LEARN_MODE_DONE,"]
    #[doc = " the gateway has been assigned a node ID and home ID.  Go to \\ref"]
    #[doc = " NM_WAIT_FOR_SECURE_LEARN, detect new environment and reset"]
    #[doc = " gateway accordingly."]
    #[doc = ""]
    #[doc = " Cannot be interrupted because the gateway properties have changed"]
    #[doc = " and we are waiting on the protocol."]
    NM_LEARN_MODE_STARTED = 6,
    #[doc = " Add mode state."]
    #[doc = " Direct range/NWI, S2, Smart Start, Proxy Inclusion, Proxy Replace."]
    #[doc = ""]
    #[doc = " Waiting for the S2 inclusion state machine to complete.  On \\ref"]
    #[doc = " NM_EV_SECURITY_DONE, go to \\ref NM_WAIT_FOR_PROBE_AFTER_ADD and"]
    #[doc = " start probe."]
    #[doc = ""]
    #[doc = " If Smart Start security fails, start a"]
    #[doc = " #SMART_START_SELF_DESTRUCT_TIMEOUT sec. timer and go to"]
    #[doc = " #NM_WAIT_FOR_SELF_DESTRUCT."]
    NM_WAIT_FOR_SECURE_ADD = 7,
    #[doc = " Remove node state."]
    #[doc = ""]
    #[doc = " SL_STATUS OK return value of zwapi_remove_node_from_network() bring NMS"]
    #[doc = " to this state. Here we set time of ADD_REMOVE_TIMEOUT (60 seconds) to wait"]
    #[doc = " for callback on_remove_node_status_update()"]
    #[doc = ""]
    #[doc = " On timeout or callback status"]
    #[doc = " REMOVE_NODE_STATUS_FAILED (NM_EV_NODE_REMOVE_FAILED)"]
    #[doc = " NMS is brought back to NMS_IDLE state"]
    #[doc = ""]
    NM_WAITING_FOR_NODE_REMOVAL = 8,
    #[doc = " Remove failed node state."]
    #[doc = ""]
    #[doc = " Waiting for protocol after call to zwapi_remove_failed_node()"]
    #[doc = " In callback on_remove_failed_status_update(),"]
    #[doc = " - ZW_NODE_OK / ZW_FAILED_NODE_NOT_REMOVED /"]
    #[doc = "   NM_WAITING_FOR_FAILED_NODE_REMOVAL : (NM_EV_REMOVE_FAILED_FAIL)"]
    #[doc = "   reports error in node deletion with"]
    #[doc = "   zwave_controller_on_error("]
    #[doc = "     ZWAVE_NETWORK_MANAGEMENT_ERROR_FAILED_NODE_REMOVE_FAIL);"]
    #[doc = ""]
    #[doc = " - ZW_FAILED_NODE_REMOVED (NM_EV_REMOVE_FAILED_OK) or on timeout"]
    #[doc = "   Reports node is delete with zwave_controller_on_node_deleted()"]
    #[doc = ""]
    #[doc = " next state of NMS after this is NM_IDLE."]
    NM_WAITING_FOR_FAILED_NODE_REMOVAL = 9,
    #[doc = " Learn mode state."]
    #[doc = ""]
    #[doc = " The gateway has received #LEARN_MODE_DONE from protocol."]
    #[doc = ""]
    #[doc = " In case of inclusion, Network Management is waiting for S2/S0"]
    #[doc = " learn mode to complete.  On \\ref NM_EV_SECURITY_DONE, go to \\ref"]
    #[doc = " NM_WAIT_FOR_MDNS and call rd_exit() to reset the gateway for a"]
    #[doc = " new network."]
    #[doc = ""]
    #[doc = " In case of #NM_EV_ADD_SECURITY_KEY_CHALLENGE, accept."]
    #[doc = " In case of NM_EV_LEARN_SET/DISABLE, abort S2."]
    #[doc = ""]
    #[doc = " In case of exclusion, controller replication, and controller"]
    #[doc = " shift, #NM_EV_SECURITY_DONE is triggered synchronously in NMS and"]
    #[doc = " state is changed synchronously when #LEARN_MODE_DONE is"]
    #[doc = " received to either #NM_SET_DEFAULT or #NM_WAIT_FOR_MDNS."]
    NM_WAIT_FOR_SECURE_LEARN = 10,
    #[doc = " Learn mode state."]
    #[doc = " TODO: do we need this?"]
    #[doc = " Only used with #NMS_FLAG_LEARNMODE_NEW."]
    #[doc = ""]
    #[doc = " After learn mode, the gateway must wait for the SIS to probe"]
    #[doc = " before resetting.  So we stay in #NM_WAIT_FOR_PROBE_BY_SIS, and"]
    #[doc = " restart the 6 s timer every time a frame is received."]
    #[doc = ""]
    #[doc = " On timeout, i.e., when no frames have been received for at least"]
    #[doc = " 6 s, we assume the SIS is done, post \\ref ZIP_EVENT_RESET to \\ref"]
    #[doc = " ZIP_Router and go to \\ref NM_WAIT_FOR_OUR_PROBE."]
    NM_WAIT_FOR_PROBE_BY_SIS = 11,
    #[doc = " Replace failed state."]
    #[doc = ""]
    #[doc = " Replace and replace S2."]
    #[doc = ""]
    #[doc = " On \\ref NM_EV_REPLACE_FAILED_DONE, if GW is handling inclusion, go to"]
    #[doc = " \\ref NM_WAIT_FOR_SECURE_ADD.  Otherwise go to"]
    #[doc = " \\ref NM_PREPARE_SUC_INCLISION."]
    NM_REPLACE_FAILED_REQ = 12,
    #[doc = " Add mode state."]
    #[doc = ""]
    #[doc = " Direct range/NWI, S2, Smart Start, Replace Failed, Proxy Inclusion, or"]
    #[doc = " Proxy Replace."]
    #[doc = ""]
    #[doc = " Wait for timeout to let protocol finish up its add by sending a"]
    #[doc = " transfer end to SUC. Then go to \\ref NM_WIAT_FOR_SUC_INCLUSION"]
    #[doc = " and request handover."]
    NM_PREPARE_SUC_INCLISION = 13,
    #[doc = " Add mode state."]
    #[doc = ""]
    #[doc = " Direct range/NWI, S2, Smart Start, Replace Failed, Proxy Inclusion, or"]
    #[doc = " Proxy Replace."]
    #[doc = ""]
    #[doc = " Waiting for the SUC to complete the secure part of inclusion."]
    #[doc = ""]
    #[doc = " On \\ref NM_EV_PROXY_COMPLETE, go to \\ref NM_WAIT_FOR_SECURE_ADD"]
    #[doc = " and post \\ref NM_EV_SECURITY_DONE."]
    NM_WAIT_FOR_SUC_INCLUSION = 14,
    #[doc = " Add mode state."]
    #[doc = " Proxy inclusion and proxy replace."]
    #[doc = ""]
    #[doc = " Safe-guarded by a timer, on timeout, go to \\ref NM_IDLE."]
    #[doc = ""]
    #[doc = " On \\ref NM_EV_NODE_INFO, inclusion goes to \\ref NM_NODE_FOUND and fakes"]
    #[doc = " \\ref NM_EV_ADD_CONTROLLER and \\ref NM_EV_ADD_NODE_STATUS_DONE.  Replace"]
    #[doc = " goes to \\ref NM_REPLACE_FAILED_REQ and fakes"]
    #[doc = " \\ref NM_EV_REPLACE_FAILED_DONE."]
    NM_PROXY_INCLUSION_WAIT_NIF = 15,
    #[doc = " Add mode state."]
    #[doc = " Smart Start."]
    #[doc = ""]
    #[doc = " The gateway must send NOPs to a failing node and wait for the"]
    #[doc = " result, before doing ZW_RemoveFailed()."]
    #[doc = ""]
    #[doc = " The NOP is sent before entering this state.  Now the gateway"]
    #[doc = " waits for protocol callback nop_send_done() to trigger \\ref"]
    #[doc = " NM_EV_TX_DONE_SELF_DESTRUCT.  Then we start a timer, call"]
    #[doc = " ZW_RemoveFailedNode() and go to \\ref"]
    #[doc = " NM_WAIT_FOR_SELF_DESTRUCT_REMOVAL."]
    NM_WAIT_FOR_TX_TO_SELF_DESTRUCT = 16,
    #[doc = " Add mode state."]
    #[doc = " Smart Start."]
    #[doc = ""]
    #[doc = " Waiting for protocol to complete the ZW_RemoveFailedNode() (or"]
    #[doc = " for timeout).  Protocol callback RemoveSelfDestructStatus()"]
    #[doc = " triggers sending status to unsolicited destinations with"]
    #[doc = " #ResetState() callback.  Timeout calls #ResetState() directly."]
    NM_WAIT_FOR_SELF_DESTRUCT_REMOVAL = 17,
    #[doc = " Failed node remove state."]
    #[doc = ""]
    #[doc = "  NMS sends NOP to failing node before coming to this state and waits for"]
    #[doc = "  callback nop_send_done() and calls zwapi_remove_failed_node(). If"]
    #[doc = "  zwapi_remove_failed_node() does not return ZW_FAILED_NODE_REMOVE_STARTED"]
    #[doc = "  its callback (on_remove_failed_status_update) is called with"]
    #[doc = "  ZW_FAILED_NODE_NOT_REMOVED()"]
    NM_FAILED_NODE_REMOVE = 18,
    #[doc = " Failed node remove state."]
    #[doc = "  Add node state (smart start self destruct)"]
    #[doc = ""]
    #[doc = "  NMS Sends NOP in this state and next state is set according to if entry"]
    #[doc = "  was due to timeout event or NM_EV_REMOVE_FAILED event from NM_IDLE."]
    NM_SEND_NOP = 19,
}
pub type zwave_keyset_t = u8;
extern "C" {
    #[doc = " @brief Get the hight encapsulation supported by a given key set."]
    #[doc = ""]
    #[doc = " @param keyset @ref zwave_keyset_t representing the set of"]
    #[doc = "                granted keys to a node"]
    #[doc = " @returns zwave_controller_encapsulation_scheme_t value representing"]
    #[doc = "          the highest granted key. Note that"]
    #[doc = "          @ref ZWAVE_CONTROLLER_ENCAPSULATION_NETWORK_SCHEME will not"]
    #[doc = "          be returned."]
    pub fn zwave_controller_get_highest_encapsulation(
        keyset: zwave_keyset_t,
    ) -> zwave_controller_encapsulation_scheme_t;
}
extern "C" {
    #[doc = " @brief Function to tell whether scheme k is greater or equal to scheme v."]
    #[doc = ""]
    #[doc = " @param k The first @ref zwave_controller_encapsulation_scheme_t variable."]
    #[doc = " @param v The second @ref zwave_controller_encapsulation_scheme_t variable."]
    #[doc = ""]
    #[doc = " @return bool True if k is greater or equal to v; otherwise false"]
    pub fn zwave_controller_encapsulation_scheme_greater_equal(
        k: zwave_controller_encapsulation_scheme_t,
        v: zwave_controller_encapsulation_scheme_t,
    ) -> bool;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum zwave_network_management_error_t {
    #[doc = " The process failed, no new node was added in the network."]
    #[doc = ""]
    ZWAVE_NETWORK_MANAGEMENT_ERROR_NODE_ADD_FAIL = 0,
    #[doc = " Node has been included but the security bootstrapping failed."]
    #[doc = ""]
    ZWAVE_NETWORK_MANAGEMENT_ERROR_NODE_ADD_SECURITY_FAIL = 1,
    #[doc = " The remove process failed (no node was removed)"]
    #[doc = ""]
    ZWAVE_NETWORK_MANAGEMENT_ERROR_NODE_REMOVE_FAIL = 2,
    #[doc = " The learn process failed in some general way"]
    #[doc = ""]
    ZWAVE_NETWORK_MANAGEMENT_ERROR_NODE_LEARN_MODE_FAIL = 3,
    #[doc = " The learn process is complete and the controller was included in a network but"]
    #[doc = " security bootstrapping failed. The node is not operating securely."]
    ZWAVE_NETWORK_MANAGEMENT_ERROR_NODE_LEARN_MODE_SECURITY_FAIL = 4,
    #[doc = " The node responded to a NOP; thus the node is no longer failing."]
    #[doc = ""]
    ZWAVE_NETWORK_MANAGEMENT_ERROR_FAILED_NODE_REMOVE_FAIL = 5,
    #[doc = " The node responded to a NOP; thus the node is no longer failing."]
    #[doc = ""]
    ZWAVE_NETWORK_MANAGEMENT_ERROR_NODE_REPLACE_FAIL = 6,
}
#[repr(u32)]
#[doc = " @brief Error codes used in S2 inclusion"]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum zwave_kex_fail_type_t {
    #[doc = " Bootstrapping was successful"]
    #[doc = ""]
    ZWAVE_NETWORK_MANAGEMENT_KEX_FAIL_NONE = 0,
    #[doc = " Key failure indicating that no match exists between requested/granted"]
    #[doc = " keys in the network."]
    ZWAVE_NETWORK_MANAGEMENT_KEX_FAIL_KEX_KEY = 1,
    #[doc = "Scheme failure indicating that no scheme is supported by"]
    #[doc = "controller or joining node specified an invalid scheme."]
    ZWAVE_NETWORK_MANAGEMENT_KEX_FAIL_KEX_SCHEME = 2,
    #[doc = "Scheme failure indicating that no scheme is supported by"]
    #[doc = "controller or joining node specified an invalid scheme."]
    ZWAVE_NETWORK_MANAGEMENT_KEX_FAIL_KEX_CURVES = 3,
    #[doc = " Node failed to decrypt received frame."]
    #[doc = ""]
    ZWAVE_NETWORK_MANAGEMENT_KEX_FAIL_DECRYPT = 4,
    #[doc = " User has canceled the S2 bootstrapping."]
    #[doc = ""]
    ZWAVE_NETWORK_MANAGEMENT_KEX_FAIL_CANCEL = 5,
    #[doc = " The Echo KEX Set/Report frame did not match the earlier"]
    #[doc = " exchanged frame."]
    ZWAVE_NETWORK_MANAGEMENT_KEX_FAIL_AUTH = 6,
    #[doc = " The joining node has requested a key, which was not granted by"]
    #[doc = " the including node at an earlier stage."]
    ZWAVE_NETWORK_MANAGEMENT_KEX_FAIL_KEY_GET = 7,
    #[doc = " Including node failed to decrypt and hence verify the received"]
    #[doc = " frame encrypted with exchanged key."]
    ZWAVE_NETWORK_MANAGEMENT_KEX_FAIL_KEY_VERIFY = 8,
    #[doc = " The including node has transmitted a frame containing a"]
    #[doc = " different key than what is currently being exchanged."]
    ZWAVE_NETWORK_MANAGEMENT_KEX_FAIL_KEY_REPORT = 9,
    #[doc = " Unknown KEX fail type."]
    ZWAVE_NETWORK_MANAGEMENT_KEX_FAIL_UNKNOWN = 10,
}
#[doc = " @brief The following structure holds all the callbacks this module will emit."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct zwave_controller_callbacks_t {
    #[doc = " This function is called when the network management state changes"]
    #[doc = ""]
    pub on_state_updated:
        ::std::option::Option<unsafe extern "C" fn(state: zwave_network_management_state_t)>,
    #[doc = " This function is called when an error occurs in a network management"]
    #[doc = " operation"]
    pub on_error:
        ::std::option::Option<unsafe extern "C" fn(error: zwave_network_management_error_t)>,
    #[doc = " This function is called when a node has been added to the network and has"]
    #[doc = " been assigned a node ID. Secure provisioning had not yet completed"]
    #[doc = " when this function is called"]
    #[doc = " @param node_id        NodeID of the newly included node."]
    #[doc = " @param included_by_us Set to true if we included the node, false if another controller included it."]
    pub on_node_id_assigned:
        ::std::option::Option<unsafe extern "C" fn(node_id: zwave_node_id_t, included_by_us: bool)>,
    #[doc = " A node has been deleted from the network"]
    #[doc = " @param node_id NodeID of the node that was removed from our network."]
    #[doc = "                The value 0 can be used and indicates that a node has been"]
    #[doc = "                excluded from a foreign network."]
    #[doc = ""]
    pub on_node_deleted: ::std::option::Option<unsafe extern "C" fn(node_id: zwave_node_id_t)>,
    #[doc = " This function is called when a node has been assigned its security keys."]
    #[doc = " This is the end of the protocol part of the inclusion process."]
    #[doc = " This function is trigged both on initiated with the and_node, add_node_with_dsk"]
    #[doc = " add_node_proxy_inclusion."]
    #[doc = " @param status Status of the provisioning"]
    #[doc = " @param nif_length length of the node information structure"]
    #[doc = " @param nif points to a node information structure"]
    #[doc = " @param node_id Node ID of the new node."]
    #[doc = " @param dsk DSK of the new node."]
    #[doc = " @param granted_keys is used to indicate which network keys were granted during bootstrapping."]
    #[doc = " @param kex_fail_type This field is used to indicate which error occurred in case S2"]
    #[doc = " bootstrapping was not successful"]
    pub on_node_added: ::std::option::Option<
        unsafe extern "C" fn(
            status: sl_status_t,
            nif: *const zwave_node_info_t,
            node_id: zwave_node_id_t,
            dsk: *mut u8,
            granted_keys: zwave_keyset_t,
            kex_fail_type: zwave_kex_fail_type_t,
            inclusion_protocol: zwave_protocol_t,
        ),
    >,
    #[doc = " This function is called then the controller enters a new network."]
    #[doc = " this can happen either after a controller set_default or after"]
    #[doc = " a learn mode operation."]
    #[doc = ""]
    #[doc = " @param home_id Home ID of the new network."]
    #[doc = " @param node_id Node ID in the new network."]
    #[doc = " @param granted_keys is used to indicate which network keys were granted during bootstrapping."]
    #[doc = " @param kex_fail_type This field is used to indicate which error occurred in case S2"]
    #[doc = " bootstrapping was not successful"]
    pub on_new_network_entered: ::std::option::Option<
        unsafe extern "C" fn(
            home_id: zwave_home_id_t,
            node_id: zwave_node_id_t,
            granted_keys: zwave_keyset_t,
            kex_fail_type: zwave_kex_fail_type_t,
        ),
    >,
    #[doc = " This function is used to inform which S2 keys have been requested"]
    #[doc = " during S2 bootstrapping, the receiver must call"]
    #[doc = " zwave_network_management_keys_set with the granted keys"]
    #[doc = ""]
    #[doc = " @param csa This field is used to indicate if the joining node is"]
    #[doc = " requesting CSA"]
    #[doc = " @param keys This field is used to advertise the requested keys by"]
    #[doc = " the joining node."]
    pub on_keys_report:
        ::std::option::Option<unsafe extern "C" fn(csa: bool, keys: zwave_keyset_t)>,
    #[doc = " This function is called durring a S2 inclusion, the receiver must"]
    #[doc = " call zwave_network_management_dsk_set with the full dsk of the node"]
    #[doc = " @param input_length Number of leading bytes in the dsk which has been"]
    #[doc = " blanked out."]
    #[doc = " @param dsk The dsk reported by the device, which input_length bytes"]
    #[doc = " set to zero."]
    #[doc = " @param keys This field is used to advertise the requested keys by"]
    #[doc = " the joining node."]
    pub on_dsk_report: ::std::option::Option<
        unsafe extern "C" fn(input_length: u8, dsk: *mut u8, keys: zwave_keyset_t),
    >,
    #[doc = " This callback is fired when a frame has beed received and"]
    #[doc = " de-encapsulated."]
    #[doc = ""]
    #[doc = " @param connection_info Information about the source and destination"]
    #[doc = "                        node if the frame, as well as information about"]
    #[doc = "                        how the frame was encapsulated"]
    #[doc = ""]
    #[doc = " @param rx_options      Receive specific information"]
    #[doc = ""]
    #[doc = " @param frame_data      Pointer to de-encapsulated data"]
    #[doc = ""]
    #[doc = " @param frame_length    Length of data"]
    #[doc = ""]
    pub on_frame_received: ::std::option::Option<
        unsafe extern "C" fn(
            connection_info: *const zwave_controller_connection_info_t,
            rx_options: *const zwave_rx_receive_options_t,
            frame_data: *const u8,
            frame_length: u16,
        ),
    >,
    #[doc = " A smart start inclusion request was received."]
    #[doc = ""]
    #[doc = " @param home_id           Smart Start DSK derived HomeId of the Smart"]
    #[doc = "                          Start node wanting to be included"]
    #[doc = " @param already_included  Node is already included into another network."]
    #[doc = ""]
    #[doc = " @param node_info         Node information frame of the sending node."]
    #[doc = ""]
    #[doc = " @param inclusion_protocol Used to indicate which protocol is intended for inclusion"]
    #[doc = ""]
    pub on_smart_start_inclusion_request: ::std::option::Option<
        unsafe extern "C" fn(
            home_id: u32,
            already_included: bool,
            node_info: *const zwave_node_info_t,
            inclusion_protocol: zwave_protocol_t,
        ),
    >,
    #[doc = " node has sent its node info either unsolicited or as a response to a"]
    #[doc = " ZW_RequestNodeInfo call"]
    #[doc = " @param node_id The source of the node information frame."]
    #[doc = ""]
    #[doc = " @param node_info         Node information frame of the sending node."]
    #[doc = ""]
    pub on_node_information: ::std::option::Option<
        unsafe extern "C" fn(node_id: zwave_node_id_t, node_info: *const zwave_node_info_t),
    >,
    #[doc = " The SIS node Id was updated"]
    #[doc = " @param suc_node_id Node id of the new SUC"]
    #[doc = ""]
    pub on_new_suc: ::std::option::Option<unsafe extern "C" fn(suc_node_id: zwave_node_id_t)>,
    #[doc = " Node Info Request has failed"]
    #[doc = " @param node_id NodeID for which the node info request failed"]
    pub on_node_info_req_failed:
        ::std::option::Option<unsafe extern "C" fn(node_id: zwave_node_id_t)>,
    #[doc = " Frame Transmission to given node is failed"]
    #[doc = " @param node_id NodeID for which frame transmission failed"]
    pub on_frame_transmission_failed:
        ::std::option::Option<unsafe extern "C" fn(node_id: zwave_node_id_t)>,
    #[doc = " Successful Frame Transmission to given node"]
    #[doc = " @param node_id NodeID for which frame transmission is successful"]
    pub on_frame_transmission_success:
        ::std::option::Option<unsafe extern "C" fn(node_id: zwave_node_id_t)>,
    #[doc = " Z-Wave TX Group was deleted."]
    #[doc = " @param group_id Group ID that was deleted."]
    pub on_multicast_group_deleted:
        ::std::option::Option<unsafe extern "C" fn(group_id: zwave_multicast_group_id_t)>,
    #[doc = " Request Node Neighbor Discovery"]
    #[doc = " @param status represents Neighbor Discovery Status"]
    pub on_request_neighbor_update: ::std::option::Option<unsafe extern "C" fn(status: u8)>,
}
#[test]
fn bindgen_test_layout_zwave_controller_callbacks_t() {
    assert_eq!(
        ::std::mem::size_of::<zwave_controller_callbacks_t>(),
        136usize,
        concat!("Size of: ", stringify!(zwave_controller_callbacks_t))
    );
    assert_eq!(
        ::std::mem::align_of::<zwave_controller_callbacks_t>(),
        8usize,
        concat!("Alignment of ", stringify!(zwave_controller_callbacks_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_callbacks_t>())).on_state_updated as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_callbacks_t),
            "::",
            stringify!(on_state_updated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_callbacks_t>())).on_error as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_callbacks_t),
            "::",
            stringify!(on_error)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_callbacks_t>())).on_node_id_assigned as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_callbacks_t),
            "::",
            stringify!(on_node_id_assigned)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_callbacks_t>())).on_node_deleted as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_callbacks_t),
            "::",
            stringify!(on_node_deleted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_callbacks_t>())).on_node_added as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_callbacks_t),
            "::",
            stringify!(on_node_added)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_callbacks_t>())).on_new_network_entered
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_callbacks_t),
            "::",
            stringify!(on_new_network_entered)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_callbacks_t>())).on_keys_report as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_callbacks_t),
            "::",
            stringify!(on_keys_report)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_callbacks_t>())).on_dsk_report as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_callbacks_t),
            "::",
            stringify!(on_dsk_report)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_callbacks_t>())).on_frame_received as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_callbacks_t),
            "::",
            stringify!(on_frame_received)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_callbacks_t>()))
                .on_smart_start_inclusion_request as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_callbacks_t),
            "::",
            stringify!(on_smart_start_inclusion_request)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_callbacks_t>())).on_node_information as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_callbacks_t),
            "::",
            stringify!(on_node_information)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_callbacks_t>())).on_new_suc as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_callbacks_t),
            "::",
            stringify!(on_new_suc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_callbacks_t>())).on_node_info_req_failed
                as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_callbacks_t),
            "::",
            stringify!(on_node_info_req_failed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_callbacks_t>())).on_frame_transmission_failed
                as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_callbacks_t),
            "::",
            stringify!(on_frame_transmission_failed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_callbacks_t>())).on_frame_transmission_success
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_callbacks_t),
            "::",
            stringify!(on_frame_transmission_success)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_callbacks_t>())).on_multicast_group_deleted
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_callbacks_t),
            "::",
            stringify!(on_multicast_group_deleted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_callbacks_t>())).on_request_neighbor_update
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_callbacks_t),
            "::",
            stringify!(on_request_neighbor_update)
        )
    );
}
#[doc = " Function type for a Z-Wave Controller reset step"]
#[doc = " The function MUST return SL_STATUS_OK if it will invoke the zwave_controller_on_reset_step_complete later."]
#[doc = " Any other status if it will not invoke the zwave_controller_on_reset_step_complete"]
pub type zwave_controller_reset_step_t =
    ::std::option::Option<unsafe extern "C" fn() -> sl_status_t>;
extern "C" {
    #[doc = " @brief Let another component register its callbacks for Z-Wave Controller"]
    #[doc = " events."]
    #[doc = ""]
    #[doc = " This function will register the pointer of a ' \\ref"]
    #[doc = " zwave_controller_callbacks_t variable passed by another component."]
    #[doc = ""]
    #[doc = " Another component registering callbacks must provide a valid/allocated"]
    #[doc = " pointer. \\ref zwave_controller_callbacks_t members left to NULL will not be"]
    #[doc = " called."]
    #[doc = ""]
    #[doc = " Callbacks must not take a long time. If they need further processing or to"]
    #[doc = " trigger a long procedure, they must copy the data to their respective"]
    #[doc = " component and/or trigger an asynchronous \\ref contiki event."]
    #[doc = ""]
    #[doc = " @param callbacks \\ref callbacks pointer for the zwave_controller component."]
    #[doc = " All callbacks are executed in the context of the zwave_controller process."]
    #[doc = ""]
    #[doc = " The caller may provide a callback struct pointer containing a set of NULL and"]
    #[doc = " valid functions. The \\ref zwave_controller Component keeps the pointer value,"]
    #[doc = " so a component can subsequently deregister a function by changing it to NULL"]
    #[doc = " or a new value in its zwave_controller_callbacks_t variable."]
    #[doc = ""]
    #[doc = " If all functions are NULL in a zwave_controller_callbacks_t variable, the"]
    #[doc = " component should deregister its callback variable by calling \\ref"]
    #[doc = " zwave_controller_deregister_callbacks."]
    #[doc = ""]
    #[doc = " Components must deregister their callbacks before shutting down and"]
    #[doc = " destroying the zwave_controller_callbacks_t variables passed to this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " @returns  \\ref SL_STATUS_OK if the callback pointer has been registered."]
    #[doc = " @returns  \\ref SL_STATUS_FAIL if the callback pointer is invalid"]
    #[doc = " @returns  \\ref SL_STATUS_NO_MORE_RESOURCE if the maximum number of"]
    #[doc = "           subscribers registered callbacks."]
    pub fn zwave_controller_register_callbacks(
        callbacks: *const zwave_controller_callbacks_t,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Let another component deregister its callbacks for Z-Wave Controller"]
    #[doc = " events"]
    #[doc = ""]
    #[doc = " This function will deregister a pointer to a \\ref"]
    #[doc = " zwave_controller_callbacks_t array."]
    #[doc = " @param callbacks \\ref zwave_controller_callbacks_t callbacks pointer."]
    #[doc = ""]
    #[doc = " @returns \\ref SL_STATUS_OK if the callback pointer has been deregistered or"]
    #[doc = "          was already unregistered."]
    #[doc = " @returns \\ref SL_STATUS_FAIL if an error happened e.g. invalid value."]
    pub fn zwave_controller_deregister_callbacks(
        callbacks: *const zwave_controller_callbacks_t,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Let another component register a step to perform when being reset"]
    #[doc = ""]
    #[doc = " This function will register a pointer to a \\ref"]
    #[doc = " zwave_controller_reset_step_t array."]
    #[doc = " @param step_function \\ref zwave_controller_reset_step_t function to invoke"]
    #[doc = " when being reset."]
    #[doc = " @param priority      Priority of the step. Step 0 is executed first,"]
    #[doc = "                      step 1 second, etc. This value MUST be between 0 and"]
    #[doc = "                      ZWAVE_CONTROLLER_MAXIMUM_CALLBACK_SUBSCRIBERS - 1"]
    #[doc = ""]
    #[doc = " @returns SL_STATUS_OK if the callback pointer has been registered with the"]
    #[doc = "          requested priority"]
    #[doc = "          SL_STATUS_FAIL if an error happened,"]
    #[doc = "          e.g. 2 steps with the same priority are registered."]
    pub fn zwave_controller_register_reset_step(
        step_function: zwave_controller_reset_step_t,
        priority: i32,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Informs the Z-Wave Controller that a Reset Step is completed."]
    #[doc = ""]
    #[doc = " @param priority      Priority of the step that was just completed."]
    #[doc = ""]
    pub fn zwave_controller_on_reset_step_complete(priority: i32);
}
extern "C" {
    #[doc = " @brief Reset all callback structures."]
    #[doc = ""]
    pub fn zwave_controller_callbacks_init();
}
extern "C" {
    #[doc = " @brief Set the application part of the node information frame (NIF)."]
    #[doc = ""]
    #[doc = " This sets the application part of the node information frame. The full"]
    #[doc = " node information frame may include additional command classes such as"]
    #[doc = " - COMMAND_CLASS_SECURITY"]
    #[doc = " - COMMAND_CLASS_SECURITY2"]
    #[doc = " - COMMAND_CLASS_TRANSPORT_SERVICE"]
    #[doc = " - COMMAND_CLASS_CRC16"]
    #[doc = " which will added to the actual NIF."]
    #[doc = ""]
    #[doc = " @param command_classes List of command classes"]
    #[doc = " @param command_classes_length Length of command class list"]
    pub fn zwave_controller_set_application_nif(
        command_classes: *const u8,
        command_classes_length: u8,
    );
}
extern "C" {
    #[doc = " @brief Set the secure node information."]
    #[doc = ""]
    #[doc = " This sets the secure node information command class list. This list is"]
    #[doc = " the contents of the SECURE_COMMANDS_SUPPORTED frames for S0 and S2."]
    #[doc = ""]
    #[doc = " @param command_classes List of command classes"]
    #[doc = " @param command_classes_length Length of command class list"]
    pub fn zwave_controller_set_secure_application_nif(
        command_classes: *const u8,
        command_classes_length: u8,
    );
}
extern "C" {
    #[doc = " @brief Retrieve the DSK of the controller."]
    #[doc = ""]
    #[doc = " @param[out] dsk The DSK"]
    pub fn zwave_controller_get_dsk(dsk: *mut zwave_dsk_t);
}
extern "C" {
    #[doc = " @brief Instructs the Z-Wave Controller to initiate a Set Default / Reset"]
    #[doc = " operation"]
    #[doc = ""]
    pub fn zwave_controller_reset();
}
#[doc = " RSSI value array used in zwapi_tx_report_t. Each value is an RSSI feedback"]
#[doc = " constant defined above."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rssi_val {
    pub incoming: [::std::os::raw::c_schar; 5usize],
}
#[test]
fn bindgen_test_layout_rssi_val() {
    assert_eq!(
        ::std::mem::size_of::<rssi_val>(),
        5usize,
        concat!("Size of: ", stringify!(rssi_val))
    );
    assert_eq!(
        ::std::mem::align_of::<rssi_val>(),
        1usize,
        concat!("Alignment of ", stringify!(rssi_val))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rssi_val>())).incoming as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rssi_val),
            "::",
            stringify!(incoming)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _S_ROUTE_LINK_ {
    pub from: u8,
    pub to: u8,
}
#[test]
fn bindgen_test_layout__S_ROUTE_LINK_() {
    assert_eq!(
        ::std::mem::size_of::<_S_ROUTE_LINK_>(),
        2usize,
        concat!("Size of: ", stringify!(_S_ROUTE_LINK_))
    );
    assert_eq!(
        ::std::mem::align_of::<_S_ROUTE_LINK_>(),
        1usize,
        concat!("Alignment of ", stringify!(_S_ROUTE_LINK_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_S_ROUTE_LINK_>())).from as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_S_ROUTE_LINK_),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_S_ROUTE_LINK_>())).to as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_S_ROUTE_LINK_),
            "::",
            stringify!(to)
        )
    );
}
pub type S_ROUTE_LINK = _S_ROUTE_LINK_;
#[repr(u32)]
#[doc = " Transport routing scheme state define definitions"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _E_ROUTING_SCHEME_ {
    ROUTINGSCHEME_IDLE = 0,
    #[doc = "< Direct"]
    ROUTINGSCHEME_DIRECT = 1,
    #[doc = "< ApplicationStaticRoute"]
    ROUTINGSCHEME_CACHED_ROUTE_SR = 2,
    #[doc = "< ResponseRoute/lastworkingRoute"]
    ROUTINGSCHEME_CACHED_ROUTE = 3,
    ROUTINGSCHEME_CACHED_ROUTE_NLWR = 4,
    #[doc = "< ReturnRoute/controllerAutoRoute"]
    ROUTINGSCHEME_ROUTE = 5,
    #[doc = "< directResort"]
    ROUTINGSCHEME_RESORT_DIRECT = 6,
    #[doc = "< Explore"]
    ROUTINGSCHEME_RESORT_EXPLORE = 7,
}
#[doc = " Transport routing scheme state define definitions"]
pub use self::_E_ROUTING_SCHEME_ as E_ROUTING_SCHEME;
#[doc = " @brief Detailed report and data about Z-Wave transmissions"]
#[doc = ""]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zwapi_tx_report {
    #[doc = "< Passed 10 ms ticks"]
    pub wTransmitTicks: u16,
    #[doc = "< Repeaters in route, zero for direct range"]
    pub bRepeaters: u8,
    #[doc = " rssi_values per hop for direct and routed frames. Contains repeaters + 1"]
    #[doc = " values."]
    pub rssi_values: rssi_val,
    pub bACKChannelNo: u8,
    pub bLastTxChannelNo: u8,
    pub bRouteSchemeState: E_ROUTING_SCHEME,
    pub pLastUsedRoute: [u8; 5usize],
    pub bRouteTries: u8,
    pub bLastFailedLink: S_ROUTE_LINK,
}
#[test]
fn bindgen_test_layout_zwapi_tx_report() {
    assert_eq!(
        ::std::mem::size_of::<zwapi_tx_report>(),
        24usize,
        concat!("Size of: ", stringify!(zwapi_tx_report))
    );
    assert_eq!(
        ::std::mem::align_of::<zwapi_tx_report>(),
        4usize,
        concat!("Alignment of ", stringify!(zwapi_tx_report))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zwapi_tx_report>())).wTransmitTicks as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zwapi_tx_report),
            "::",
            stringify!(wTransmitTicks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zwapi_tx_report>())).bRepeaters as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(zwapi_tx_report),
            "::",
            stringify!(bRepeaters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zwapi_tx_report>())).rssi_values as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(zwapi_tx_report),
            "::",
            stringify!(rssi_values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zwapi_tx_report>())).bACKChannelNo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zwapi_tx_report),
            "::",
            stringify!(bACKChannelNo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwapi_tx_report>())).bLastTxChannelNo as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(zwapi_tx_report),
            "::",
            stringify!(bLastTxChannelNo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwapi_tx_report>())).bRouteSchemeState as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(zwapi_tx_report),
            "::",
            stringify!(bRouteSchemeState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zwapi_tx_report>())).pLastUsedRoute as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zwapi_tx_report),
            "::",
            stringify!(pLastUsedRoute)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zwapi_tx_report>())).bRouteTries as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(zwapi_tx_report),
            "::",
            stringify!(bRouteTries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zwapi_tx_report>())).bLastFailedLink as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(zwapi_tx_report),
            "::",
            stringify!(bLastFailedLink)
        )
    );
}
impl Default for zwapi_tx_report {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Detailed report and data about Z-Wave transmissions"]
#[doc = ""]
#[doc = ""]
pub type zwapi_tx_report_t = zwapi_tx_report;
#[repr(u32)]
#[doc = " @name zwapi_nodeid_basetype_t"]
#[doc = " These definitions represent possible node id basetype settings for the Z-Wave module"]
#[doc = " They are used with zwapi_set_node_id_basetype()"]
#[doc = "@{"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum zwave_node_id_basetype_t {
    NODEID_8BITS = 1,
    NODEID_16BITS = 2,
}
impl rf_power_level_t {
    pub const MINIMUM_POWER: rf_power_level_t = rf_power_level_t::MINUS_9_DBM;
}
#[repr(u32)]
#[doc = " RF power level values used with zwapi_set_rf_power_level() and"]
#[doc = " zwapi_get_rf_power_level()"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rf_power_level_t {
    #[doc = "< Max power possible"]
    NORMAL_POWER = 0,
    #[doc = "< Normal power - 1dB (mapped to minus2dB)"]
    MINUS_1_DBM = 1,
    #[doc = "< Normal power - 2dB"]
    MINUS_2_DBM = 2,
    #[doc = "< Normal power - 3dB (mapped to minus4dB)"]
    MINUS_3_DBM = 3,
    #[doc = "< Normal power - 4dB"]
    MINUS_4_DBM = 4,
    #[doc = "< Normal power - 5dB (mapped to minus6dB)"]
    MINUS_5_DBM = 5,
    #[doc = "< Normal power - 6dB"]
    MINUS_6_DBM = 6,
    #[doc = "< Normal power - 7dB (mapped to minus8dB)"]
    MINUS_7_DBM = 7,
    #[doc = "< Normal power - 8dB"]
    MINUS_8_DBM = 8,
    #[doc = "< Normal power - 9dB (mapped to minus10dB)"]
    MINUS_9_DBM = 9,
}
#[doc = " @brief Handle that can be used for aborting ongoing transmissions"]
#[doc = " or identifying TX Queue elements."]
pub type zwave_tx_session_id_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zwave_tx_options {
    #[doc = " The \\ref zwave_tx_process will wait for the expected responses to a frame before"]
    #[doc = " transmitting the next frame. It will time out and resume TX operations after a"]
    #[doc = " recommended backoff time for the expected number of responses"]
    #[doc = " If S2 uses the VERIFY_DELIVERY mechanism, the number of expected responses should be"]
    #[doc = " equal or greater than 1."]
    #[doc = " If is possible to specify that multiple responses are expected."]
    #[doc = " In case of Supervision with status update flag, the number_of_responses should"]
    #[doc = " be set to 1, as only one frame will be returned immediately for sure, the other(s) one will"]
    #[doc = " come later after an arbitrary time."]
    #[doc = " If the use_parent_frame_options and valid_parent_session_id fields are set to true"]
    #[doc = " and a valid parent_session_id is provided in the parent_session_id, this value will"]
    #[doc = " be overwritten with the number_of_responses value of the parent."]
    pub number_of_responses: u8,
    #[doc = " Maximum time in ms this transmission is allowed to spend in queue waiting"]
    #[doc = " to be processed before it is dropped. Discard timeout of 0 means to never"]
    #[doc = " drop the frame."]
    #[doc = " If the use_parent_frame_options and valid_parent_session_id fields are set to true"]
    #[doc = " and a valid parent_session_id is provided in the parent_session_id, this value will"]
    #[doc = " be overwritten with the discard_timeout_ms value of the parent."]
    pub discard_timeout_ms: u32,
    #[doc = " Priority of transmission element. Frames with higher numbers are sent"]
    #[doc = " first."]
    #[doc = " If the valid_parent_session_id field is set to true and a valid parent_session_id is"]
    #[doc = " provided in the parent_session_id, this value will be overwritten with the"]
    #[doc = " qos_priority value of the parent + 1."]
    pub qos_priority: u32,
    #[doc = " This flag indicates if the message should be attempted to be sent without"]
    #[doc = " beaming or route resolution. This option should only be used for FL nodes."]
    #[doc = " If the transmission fails, the message will be re-queued and attempted"]
    #[doc = " again later."]
    pub fasttrack: bool,
    #[doc = " zwave_tx_session_id_t of the parent frame. A parent frame is a frame that caused"]
    #[doc = " this frame to be added to the queue. Child frames are sent before their parent."]
    pub parent_session_id: zwave_tx_session_id_t,
    #[doc = " This flag indicates if the parent_session_id field is supposed to contain"]
    #[doc = " a valid value."]
    #[doc = " If this field is set to true, qos_priority will be overwritten so that the"]
    #[doc = " frame is sent before the parent."]
    pub valid_parent_session_id: bool,
    #[doc = " This flag indicates if the number_of_responses and discard_timeout_ms"]
    #[doc = " fields should be determined from the parent_session_id"]
    #[doc = " If the valid_parent_session_id field is additionally set to true,"]
    #[doc = " the number_of_responses and discard_timeout_ms and will be overwritten."]
    pub use_parent_frame_options: bool,
    #[doc = " This flag indicates if the frame is to be sent as a test frame"]
    #[doc = " Test frame was intended to be used to test link reliability, the"]
    #[doc = " Z-Wave API will send a test frame without any routing and with 9600 kbit/s"]
    #[doc = " transmission speed. The payload will also be ignored."]
    pub is_test_frame: bool,
    #[doc = " This value indicates if the a test frame must be sent"]
    #[doc = " with a particular Tx Power. This value will be ignored if the"]
    #[doc = " is_test_frame flag is set to false."]
    pub rf_power: rf_power_level_t,
    #[doc = " This flag can be used for tracking multicast/singlecast follow-ups"]
    #[doc = " transmissions."]
    #[doc = " For Singlecast messages (remote.is_multicast = false), this must be set"]
    #[doc = " to ZWAVE_TX_INVALID_GROUP if the frame is not a follow-up frame, else to"]
    #[doc = " the group_id for which it is a follow-up."]
    #[doc = " For Multicast messages (remote.is_multicast = true), if this field is"]
    #[doc = " set with a group_id different than 0, the Tx Queue will use the"]
    #[doc = " TRANSMIT_OPTION_MULTICAST_AS_BROADCAST and the multicast will be"]
    #[doc = " sent as a \"singlecast to the broadcast destination\""]
    pub group_id: zwave_multicast_group_id_t,
    #[doc = " Is this the first Singlecast follow-up frame ?"]
    #[doc = " Only set this to true if queuing the first follow-up frame. User components"]
    #[doc = " SHOULD always set this to false and let the Tx Queue handle the singlecast"]
    #[doc = " follow-ups."]
    pub is_first_follow_up: bool,
    #[doc = " The TX Queue can automatically queue Follow-up messages following a"]
    #[doc = " multicast. If you wish to activate this functionality, set this field"]
    #[doc = " to true."]
    pub send_follow_ups: bool,
}
#[test]
fn bindgen_test_layout_zwave_tx_options() {
    assert_eq!(
        ::std::mem::size_of::<zwave_tx_options>(),
        40usize,
        concat!("Size of: ", stringify!(zwave_tx_options))
    );
    assert_eq!(
        ::std::mem::align_of::<zwave_tx_options>(),
        8usize,
        concat!("Alignment of ", stringify!(zwave_tx_options))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_tx_options>())).number_of_responses as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_tx_options),
            "::",
            stringify!(number_of_responses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_tx_options>())).discard_timeout_ms as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_tx_options),
            "::",
            stringify!(discard_timeout_ms)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zwave_tx_options>())).qos_priority as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_tx_options),
            "::",
            stringify!(qos_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zwave_tx_options>())).fasttrack as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_tx_options),
            "::",
            stringify!(fasttrack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_tx_options>())).parent_session_id as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_tx_options),
            "::",
            stringify!(parent_session_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_tx_options>())).valid_parent_session_id as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_tx_options),
            "::",
            stringify!(valid_parent_session_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_tx_options>())).use_parent_frame_options as *const _
                as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_tx_options),
            "::",
            stringify!(use_parent_frame_options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zwave_tx_options>())).is_test_frame as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_tx_options),
            "::",
            stringify!(is_test_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zwave_tx_options>())).rf_power as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_tx_options),
            "::",
            stringify!(rf_power)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zwave_tx_options>())).group_id as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_tx_options),
            "::",
            stringify!(group_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_tx_options>())).is_first_follow_up as *const _ as usize
        },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_tx_options),
            "::",
            stringify!(is_first_follow_up)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_tx_options>())).send_follow_ups as *const _ as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_tx_options),
            "::",
            stringify!(send_follow_ups)
        )
    );
}
impl Default for zwave_tx_options {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type zwave_tx_options_t = zwave_tx_options;
#[doc = " @brief Callback function of zwave_tx_send_data(), indicating the result of the operation"]
#[doc = ""]
#[doc = " This function is called when an element in the TX Queue has been transmitted"]
#[doc = " (or attempted to be transmitted) and indicates the status of the operation."]
#[doc = ""]
#[doc = " @param status  Indicates how the transmission operation was completed."]
#[doc = "                Refer for \\ref zwapi_transmit_complete_codes for details."]
#[doc = " @param tx_info zwapi_tx_report_t reported by the \\ref ZWAPI. It"]
#[doc = "                contains transmission details, refer to \\ref zwapi_tx_report_t."]
#[doc = " @param user    User pointer provided in \\ref zwave_tx_send_data()"]
pub type on_zwave_tx_send_data_complete_t = ::std::option::Option<
    unsafe extern "C" fn(
        status: u8,
        tx_info: *const zwapi_tx_report_t,
        user: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " see @ref zwave_controller_callbacks_t"]
    pub fn zwave_controller_on_state_updated(state: zwave_network_management_state_t);
}
extern "C" {
    #[doc = " see @ref zwave_controller_callbacks_t"]
    pub fn zwave_controller_on_error(error: zwave_network_management_error_t);
}
extern "C" {
    #[doc = " see @ref zwave_controller_callbacks_t"]
    pub fn zwave_controller_on_node_id_assigned(node_id: zwave_node_id_t, included_by_us: bool);
}
extern "C" {
    #[doc = " see @ref zwave_controller_callbacks_t"]
    pub fn zwave_controller_on_node_deleted(node_id: zwave_node_id_t);
}
extern "C" {
    #[doc = " see @ref zwave_controller_callbacks_t"]
    pub fn zwave_controller_on_node_info_req_failed(node_id: zwave_node_id_t);
}
extern "C" {
    #[doc = " see @ref zwave_controller_callbacks_t"]
    pub fn zwave_controller_on_frame_transmission_failed(node_id: zwave_node_id_t);
}
extern "C" {
    #[doc = " see @ref zwave_controller_callbacks_t"]
    pub fn zwave_controller_on_frame_transmission_success(node_id: zwave_node_id_t);
}
extern "C" {
    #[doc = " see @ref zwave_controller_callbacks_t"]
    pub fn zwave_controller_on_node_added(
        status: sl_status_t,
        nif: *const zwave_node_info_t,
        node_id: zwave_node_id_t,
        dsk: *mut u8,
        granted_keys: zwave_keyset_t,
        kex_fail_type: zwave_kex_fail_type_t,
        inclusion_protocol: zwave_protocol_t,
    );
}
extern "C" {
    #[doc = " see @ref zwave_controller_callbacks_t"]
    pub fn zwave_controller_on_new_network_entered(
        home_id: zwave_home_id_t,
        node_id: zwave_node_id_t,
        granted_keys: zwave_keyset_t,
        kex_fail_type: zwave_kex_fail_type_t,
    );
}
extern "C" {
    #[doc = " see @ref zwave_controller_callbacks_t"]
    pub fn zwave_controller_on_keys_report(csa: bool, keys: zwave_keyset_t);
}
extern "C" {
    #[doc = " see @ref zwave_controller_callbacks_t"]
    pub fn zwave_controller_on_dsk_report(input_length: u8, dsk: *mut u8, keys: zwave_keyset_t);
}
extern "C" {
    #[doc = " see @ref zwave_controller_callbacks_t"]
    pub fn zwave_controller_on_frame_received(
        connection_info: *const zwave_controller_connection_info_t,
        rx_options: *const zwave_rx_receive_options_t,
        frame_data: *const u8,
        frame_length: u16,
    );
}
extern "C" {
    #[doc = " see @ref zwave_controller_callbacks_t"]
    pub fn zwave_controller_on_smart_start_inclusion_request(
        home_id: u32,
        already_included: bool,
        node_info: *const zwave_node_info_t,
        inclusion_protocol: zwave_protocol_t,
    );
}
extern "C" {
    #[doc = " see @ref zwave_controller_callbacks_t"]
    pub fn zwave_controller_on_node_information(
        node_id: zwave_node_id_t,
        node_info: *const zwave_node_info_t,
    );
}
extern "C" {
    #[doc = " see @ref zwave_controller_callbacks_t"]
    pub fn zwave_controller_on_new_suc(suc_node_id: zwave_node_id_t);
}
extern "C" {
    #[doc = " see @ref zwave_controller_callbacks_t"]
    pub fn zwave_controller_on_multicast_group_deleted(group_id: zwave_multicast_group_id_t);
}
extern "C" {
    #[doc = " see @ref zwave_controller_callbacks_t"]
    pub fn zwave_controller_on_request_neighbor_update(status: u8);
}
extern "C" {
    #[doc = " @brief Send a frame with transport plugin system"]
    #[doc = ""]
    #[doc = " This function sends a frame with the transport system. It will return"]
    #[doc = " SL_STATUS_OK if the frame is consumed"]
    #[doc = ""]
    #[doc = " @param connection see @ref  zwave_tx_send_data"]
    #[doc = " @param data_length see @ref  zwave_tx_send_data"]
    #[doc = " @param data  see @ref  zwave_tx_send_data"]
    #[doc = " @param tx_options see @ref  zwave_tx_send_data"]
    #[doc = " @param on_send_complete see @ref  zwave_tx_send_data"]
    #[doc = " @param user see @ref  zwave_tx_send_data"]
    #[doc = " @param session see @ref  zwave_tx_send_data"]
    #[doc = " @returns sl_status_t         Indicating the processing of the frame."]
    #[doc = "  - SL_STATUS_OK              indicates that the frame was accepted and"]
    #[doc = "                              encapsulated"]
    #[doc = "  - SL_STATUS_NOT_SUPPORTED   indicates that transport has nothing to"]
    #[doc = "                              encapsulate, the frame is ready the Z-Wave API."]
    #[doc = "  - SL_STATUS_WOULD_OVERFLOW  indicates that transport should encapsulate the"]
    #[doc = "                              frame but cannot. Frame should be dropped."]
    #[doc = "  - Any other error code      (SL_STATUS_BUSY, SL_STATUS_FAIL, etc.) indicating"]
    #[doc = "                              that the frame should be encapsulated,"]
    #[doc = "                              but could not due to an error."]
    pub fn zwave_controller_transport_send_data(
        connection: *const zwave_controller_connection_info_t,
        data_length: u16,
        data: *const u8,
        tx_options: *const zwave_tx_options_t,
        on_send_complete: on_zwave_tx_send_data_complete_t,
        user: *mut ::std::os::raw::c_void,
        session: zwave_tx_session_id_t,
    ) -> sl_status_t;
}
#[doc = " @brief Hold information about a transport plugin."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct zwave_controller_transport {
    #[doc = " @brief Priority of this plugin, transports with lowest number priority is"]
    #[doc = " executed last when encoding."]
    #[doc = " Decoding order is made based on the Command Class identifier"]
    #[doc = " (first frame byte)."]
    #[doc = ""]
    #[doc = " Recommended priorities:"]
    #[doc = " - 1 Transport Service: TBD: Connection info should have fields with"]
    #[doc = "                        \"segmentation settings\" or something like this"]
    #[doc = "                        Else the transport can't really know if this is"]
    #[doc = "                        supported by the destination"]
    #[doc = " - 2 Security 2"]
    #[doc = " - 3 Security 0"]
    #[doc = " - 4 CRC 16"]
    #[doc = " - 5 Multi Channel"]
    #[doc = ""]
    pub priority: u32,
    #[doc = " @brief Which Z-Wave command class this transport is serving"]
    #[doc = ""]
    pub command_class: zwave_command_class_t,
    #[doc = " @brief The command class version of the command class that this transport"]
    #[doc = " is implementing."]
    #[doc = ""]
    pub version: u8,
    #[doc = " @brief Send function to use when encapsulating with this transport."]
    #[doc = ""]
    #[doc = " @note: It is important for sender function not to pass the parent_session"]
    #[doc = " to the zwave_tx send_data function."]
    #[doc = ""]
    #[doc = " Functions registered as send_data handlers MUST return status"]
    #[doc = " codes according to the following:"]
    #[doc = "  - SL_STATUS_OK              indicates that the frame was accepted and"]
    #[doc = "                              encapsulated"]
    #[doc = "  - SL_STATUS_NOT_SUPPORTED   indicates that transport has nothing to"]
    #[doc = "                              encapsulate for this frame."]
    #[doc = "  - SL_STATUS_WOULD_OVERFLOW  indicates that the frame is supported but cannot"]
    #[doc = "                              be handled, so it should not be attempted again"]
    #[doc = "  - Any other error code      (SL_STATUS_BUSY, SL_STATUS_FAIL, etc.) indicating"]
    #[doc = "                              that the frame should be encapsulated,"]
    #[doc = "                              but could not due to an error."]
    pub send_data: ::std::option::Option<
        unsafe extern "C" fn(
            connection: *const zwave_controller_connection_info_t,
            data_length: u16,
            data: *const u8,
            tx_options: *const zwave_tx_options_t,
            on_send_complete: on_zwave_tx_send_data_complete_t,
            user: *mut ::std::os::raw::c_void,
            parent_session: zwave_tx_session_id_t,
        ) -> sl_status_t,
    >,
    #[doc = " @brief Command handler to of the transport"]
    #[doc = ""]
    #[doc = " Functions registered as on_frame_received transport MUST return status"]
    #[doc = " codes according to the following:"]
    #[doc = " - SL_STATUS_NOT_FOUND    Indicates that the frame has no more"]
    #[doc = "                          encapsulation and must be passed manually to the"]
    #[doc = "                          upper layers by the Z-Wave Controller."]
    #[doc = " - Any other code         (SL_STATUS_OK, SL_STATUS_FAIL, etc.) indicating"]
    #[doc = "                          that the frame was \"consumed\" by the"]
    #[doc = "                          on_frame_received handler and that the handler"]
    #[doc = "                          has passed the frame to the Z-Wave Controller"]
    #[doc = "                          again if decapsulation was applied (i.e. called"]
    #[doc = "                          zwave_controller_on_frame_received())"]
    pub on_frame_received: ::std::option::Option<
        unsafe extern "C" fn(
            connection_info: *const zwave_controller_connection_info_t,
            rx_options: *const zwave_rx_receive_options_t,
            frame_data: *const u8,
            frame_length: u16,
        ) -> sl_status_t,
    >,
}
#[test]
fn bindgen_test_layout_zwave_controller_transport() {
    assert_eq!(
        ::std::mem::size_of::<zwave_controller_transport>(),
        24usize,
        concat!("Size of: ", stringify!(zwave_controller_transport))
    );
    assert_eq!(
        ::std::mem::align_of::<zwave_controller_transport>(),
        8usize,
        concat!("Alignment of ", stringify!(zwave_controller_transport))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_transport>())).priority as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_transport),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_transport>())).command_class as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_transport),
            "::",
            stringify!(command_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_transport>())).version as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_transport),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_transport>())).send_data as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_transport),
            "::",
            stringify!(send_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_controller_transport>())).on_frame_received as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_controller_transport),
            "::",
            stringify!(on_frame_received)
        )
    );
}
#[doc = " @brief Hold information about a transport plugin."]
#[doc = ""]
pub type zwave_controller_transport_t = zwave_controller_transport;
extern "C" {
    #[doc = " @brief Must be called to register a transport."]
    #[doc = ""]
    #[doc = " There can only be one transport pr command class and only one pr. priority."]
    #[doc = ""]
    #[doc = " @param transport"]
    #[doc = " @return sl_status_t"]
    pub fn zwave_controller_transport_register(
        transport: *const zwave_controller_transport_t,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief check if a command class is registered as an encapsulation cc in"]
    #[doc = "        Z-Wave controller transport framework. If it does, the module will"]
    #[doc = "        retrun the version of the encapsulation command class."]
    #[doc = ""]
    #[doc = " @param  command_class Z-Wave Command Class"]
    #[doc = ""]
    #[doc = " @return zero if the command class is not registered as an encapsulation cc"]
    #[doc = "              in the Z-Wave transport plugin framework."]
    pub fn zwave_controller_transport_is_encapsulation_cc(
        command_class: zwave_command_class_t,
    ) -> u8;
}
extern "C" {
    #[doc = " @brief Verify whether a node/endpoint supports a Command Class"]
    #[doc = " using the attribute Store."]
    #[doc = ""]
    #[doc = " @param command_class The Command Class identifier to look for."]
    #[doc = " @param node_id       The NodeID to verify for support."]
    #[doc = " @param endpoint_id   The Endpoint to verify for support."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = " - true if the node/endpoint supports the Command Class"]
    #[doc = " - false if the node/endpoint does not support the Command Class"]
    pub fn zwave_node_supports_command_class(
        command_class: zwave_command_class_t,
        node_id: zwave_node_id_t,
        endpoint_id: zwave_endpoint_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Return the version of a Command Class implemented by a node."]
    #[doc = ""]
    #[doc = " @param command_class The Command Class identifier for which the version"]
    #[doc = "                      is requested."]
    #[doc = " @param node_id       The NodeID for which the version is requested."]
    #[doc = " @param endpoint_id   The Endpoint for which the version is requested."]
    #[doc = ""]
    #[doc = " @returns the version number of the Command Class. 0 if it is"]
    #[doc = "          neither supported nor controlled."]
    pub fn zwave_node_get_command_class_version(
        command_class: zwave_command_class_t,
        node_id: zwave_node_id_t,
        endpoint_id: zwave_endpoint_id_t,
    ) -> u8;
}
