/* automatically generated by rust-bindgen 0.59.1 */

pub type sl_status_t = u32;
#[doc = " Z-Wave NodeID type"]
pub type zwave_node_id_t = u16;
pub type zwave_multicast_group_id_t = u8;
pub type zwave_endpoint_id_t = u8;
pub type zwave_command_class_t = u16;
#[doc = " @brief This is the function which will be executed when the frame of"]
#[doc = " a given Command Class is received."]
#[doc = ""]
#[doc = " The handler MUST return a \\ref sl_status_t status code."]
#[doc = ""]
#[doc = " @param connection_info Info about the connection properties of this frame."]
#[doc = " @param frame_data The data payload of this frame."]
#[doc = " @param frame_length The length of this frame."]
#[doc = ""]
#[doc = " @returns SL_STATUS_OK    The command was handled by the command handler."]
#[doc = "                          Supervision will return SUCCESS in this case"]
#[doc = " @returns SL_STATUS_FAIL  The command handler was unable to parse the command"]
#[doc = "                          or was busy carring another operation."]
#[doc = "                          Supervision Command Class returns FAIL."]
#[doc = " @returns SL_STATUS_IN_PROGRESS   The command handler is processing the command"]
#[doc = "                                  Supervision Command Class returns WORKING."]
#[doc = " @returns SL_STATUS_NOT_SUPPORTED The command handler does not support this"]
#[doc = "                                  Command or Command Class."]
#[doc = "                                  Supervision Command Class returns NO_SUPPORT."]
#[doc = " @returns Any other status: Supervision Command Class returns FAIL."]
pub type zwave_command_class_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *const zwave_controller::zwave_controller_connection_info_t,
        frame_data: *const u8,
        frame_length: u16,
    ) -> sl_status_t,
>;
#[doc = " @brief Z-Wave Command Class handler object"]
#[doc = ""]
#[doc = " This structure is a package allowing the Z-Wave Command Class dispatch to accept or"]
#[doc = " reject Command frames from the Z-Wave radio and dispatch them to the right handler, if"]
#[doc = " they are supported."]
#[repr(C)]
pub struct zwave_command_handler_t {
    #[doc = " Handler for supported frames."]
    #[doc = ""]
    pub support_handler: zwave_command_class_handler_t,
    #[doc = " Handler for controlled frames."]
    #[doc = ""]
    pub control_handler: zwave_command_class_handler_t,
    #[doc = " The minimal security level which this command is supported on."]
    #[doc = " This is ignored for the control_handler."]
    #[doc = ""]
    pub minimal_scheme: zwave_controller::zwave_controller_encapsulation_scheme_t,
    #[doc = " command class that this handler implements"]
    #[doc = ""]
    pub command_class: zwave_command_class_t,
    #[doc = " Name of the Command Class (not including Command Class)"]
    #[doc = ""]
    pub command_class_name: *const ::std::os::raw::c_char,
    #[doc = " Comments for the Command Class implemenation, that is printed to the log"]
    #[doc = ""]
    pub comments: *const ::std::os::raw::c_char,
    #[doc = " version of the implemented command class"]
    #[doc = ""]
    pub version: u8,
    #[doc = " Use manual-security filtering for incoming frames"]
    #[doc = " If set to true, the command class dispatch handler will send frames to the"]
    #[doc = " handler without validating their security level."]
    #[doc = " If set to false, the command class handler can assume that the frame has"]
    #[doc = " been received at an approved security level."]
    pub manual_security_validation: bool,
}
#[test]
fn bindgen_test_layout_zwave_command_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<zwave_command_handler_t>(),
        48usize,
        concat!("Size of: ", stringify!(zwave_command_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<zwave_command_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(zwave_command_handler_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_command_handler_t>())).support_handler as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_command_handler_t),
            "::",
            stringify!(support_handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_command_handler_t>())).control_handler as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_command_handler_t),
            "::",
            stringify!(control_handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_command_handler_t>())).minimal_scheme as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_command_handler_t),
            "::",
            stringify!(minimal_scheme)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_command_handler_t>())).command_class as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_command_handler_t),
            "::",
            stringify!(command_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_command_handler_t>())).command_class_name as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_command_handler_t),
            "::",
            stringify!(command_class_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_command_handler_t>())).comments as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_command_handler_t),
            "::",
            stringify!(comments)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zwave_command_handler_t>())).version as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_command_handler_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zwave_command_handler_t>())).manual_security_validation
                as *const _ as usize
        },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(zwave_command_handler_t),
            "::",
            stringify!(manual_security_validation)
        )
    );
}
impl Default for zwave_command_handler_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Initialize the command handlers."]
    #[doc = " @returns SL_STATUS_OK, it will always be considered as successful."]
    pub fn zwave_command_handler_init() -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Teardown of the Z-Wave command handler."]
    #[doc = " @returns 0 in case of success."]
    pub fn zwave_command_handler_teardown() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Register a command class handler."]
    #[doc = ""]
    #[doc = " This API replaces the legacy REGISTER_HANDLER() macro. Command"]
    #[doc = " handlers should perform their own initialization and register"]
    #[doc = " themselves to the command handler framework."]
    #[doc = ""]
    #[doc = " There is no sequence/order requirement, meaning that this function"]
    #[doc = " can be invoked before the Command Class handler framework is initialized."]
    #[doc = ""]
    #[doc = " @param new_command_class_handler A struct that contains the"]
    #[doc = "                                  zwave_command_handler_t info"]
    #[doc = "                                  that will be used for registering a"]
    #[doc = "                                  Command Class handler."]
    #[doc = ""]
    #[doc = " Command class handlers can be fully disabled by setting"]
    #[doc = " both support and control to false."]
    #[doc = " @returns SL_STATUS_OK    If the Command Class handler was successfully"]
    #[doc = "                          registered"]
    #[doc = " @returns SL_STATUS_FAIL  Otherwise"]
    pub fn zwave_command_handler_register_handler(
        new_command_class_handler: zwave_command_handler_t,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Get the version of Command Class that the handler handles."]
    #[doc = ""]
    #[doc = " @param command_class Command class to query with."]
    #[doc = " @returns The version number of the indicated Command Class."]
    #[doc = "          If the Command Class is neither supported not controlled, it will be 0."]
    #[doc = "          0 if no Command Class handler is registered for the Command Class identifier."]
    pub fn zwave_command_handler_get_version(command_class: zwave_command_class_t) -> u8;
}
extern "C" {
    #[doc = " @brief Dispatches a frame to its respective Command Class handler"]
    #[doc = ""]
    #[doc = " @param connection_info The connection information for the received Z-Wave"]
    #[doc = "                        Frame"]
    #[doc = " @param frame_data      The payload of the Z-Wave Frame"]
    #[doc = " @param frame_length    The length of the payload (in bytes) contained"]
    #[doc = "                        in the frame_data pointer."]
    #[doc = " @returns The handler return code"]
    pub fn zwave_command_handler_dispatch(
        connection_info: *const zwave_controller::zwave_controller_connection_info_t,
        frame_data: *const u8,
        frame_length: u16,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Check if we control a given command class"]
    #[doc = ""]
    #[doc = " @param command_class"]
    #[doc = " @return true if we control this command classs"]
    pub fn zwave_command_handler_controls(command_class: zwave_command_class_t) -> bool;
}
extern "C" {
    #[doc = " @brief Print Command Class Version info"]
    #[doc = ""]
    #[doc = " @param fd File descriptor to print to, if fd < 0 it will use sl_log_info"]
    pub fn zwave_command_handler_print_info(fd: ::std::os::raw::c_int);
}
