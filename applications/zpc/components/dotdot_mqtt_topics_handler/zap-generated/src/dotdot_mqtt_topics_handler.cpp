/******************************************************************************
 * # License
 * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>
 ******************************************************************************
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 *****************************************************************************/

// clang-format off
// This file is generated by ZCL Advanced Platform generator. Please don't edit manually.

#include "sl_log.h"
#include "sl_status.h"
#include "attribute_store.h"
#include "zpc_attribute_store_network_helper.h"
#include "attribute_store_helper.h"
#include "attribute_store_defined_attribute_types.h"
#include "attribute.hpp"
#include "zwave_unid.h"
#include "dotdot_mqtt_topics_handler.h"
#include "dotdot_attributes.h"
#include "dotdot_mqtt.h"
#include "uic_mqtt.h"
#include "ucl_definitions.h"
#include "attribute_mapper.h"
#include "attribute_timeouts.h"

#include <stdio.h>
#include <string>
#include <sstream>
#include <vector>
#include <cstring>
#include <set>

#define LOG_TAG "dotdot_mqtt_topics_handler"

// Forward declarations:
static void on_pan_node_interview_done(attribute_store_node_t updated_node,
                                       attribute_store_change_t change);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster basic
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void basic_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"basic_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_ZCL_VERSION) {
            uic_mqtt_dotdot_basic_zcl_version_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_APPLICATION_VERSION) {
            uic_mqtt_dotdot_basic_application_version_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_STACK_VERSION) {
            uic_mqtt_dotdot_basic_stack_version_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_HW_VERSION) {
            uic_mqtt_dotdot_basic_hw_version_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_NAME) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_basic_manufacturer_name_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_MODEL_IDENTIFIER) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_basic_model_identifier_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_DATE_CODE) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_basic_date_code_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_POWER_SOURCE) {
            uic_mqtt_dotdot_basic_power_source_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_CLASS) {
            uic_mqtt_dotdot_basic_generic_device_class_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_TYPE) {
            uic_mqtt_dotdot_basic_generic_device_type_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_CODE) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_basic_product_code_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCTURL) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_basic_producturl_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_VERSION_DETAILS) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_basic_manufacturer_version_details_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_SERIAL_NUMBER) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_basic_serial_number_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_LABEL) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_basic_product_label_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_LOCATION_DESCRIPTION) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_basic_location_description_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_PHYSICAL_ENVIRONMENT) {
            uic_mqtt_dotdot_basic_physical_environment_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_DEVICE_ENABLED) {
            uic_mqtt_dotdot_basic_device_enabled_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.desired_or_reported<bool>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_ALARM_MASK) {
            uic_mqtt_dotdot_basic_alarm_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_DISABLE_LOCAL_CONFIG) {
            uic_mqtt_dotdot_basic_disable_local_config_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_SW_BUILDID) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_basic_sw_buildid_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void basic_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"basic_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_ZCL_VERSION) {
            uic_mqtt_dotdot_basic_zcl_version_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_APPLICATION_VERSION) {
            uic_mqtt_dotdot_basic_application_version_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_STACK_VERSION) {
            uic_mqtt_dotdot_basic_stack_version_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_HW_VERSION) {
            uic_mqtt_dotdot_basic_hw_version_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_NAME) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_basic_manufacturer_name_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_MODEL_IDENTIFIER) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_basic_model_identifier_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_DATE_CODE) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_basic_date_code_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_POWER_SOURCE) {
            uic_mqtt_dotdot_basic_power_source_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_CLASS) {
            uic_mqtt_dotdot_basic_generic_device_class_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_TYPE) {
            uic_mqtt_dotdot_basic_generic_device_type_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_CODE) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_basic_product_code_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCTURL) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_basic_producturl_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_VERSION_DETAILS) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_basic_manufacturer_version_details_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_SERIAL_NUMBER) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_basic_serial_number_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_LABEL) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_basic_product_label_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_LOCATION_DESCRIPTION) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_basic_location_description_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_PHYSICAL_ENVIRONMENT) {
            uic_mqtt_dotdot_basic_physical_environment_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_DEVICE_ENABLED) {
            uic_mqtt_dotdot_basic_device_enabled_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.reported<bool>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_ALARM_MASK) {
            uic_mqtt_dotdot_basic_alarm_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_DISABLE_LOCAL_CONFIG) {
            uic_mqtt_dotdot_basic_disable_local_config_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BASIC_SW_BUILDID) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_basic_sw_buildid_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks basic
static sl_status_t basic_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_basic_state_t attributes,
  uic_mqtt_dotdot_basic_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_BASIC_LOCATION_DESCRIPTION == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_BASIC_PHYSICAL_ENVIRONMENT == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_BASIC_DEVICE_ENABLED == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_BASIC_ALARM_MASK == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_BASIC_DISABLE_LOCAL_CONFIG == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "basic: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.location_description) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_BASIC_LOCATION_DESCRIPTION);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_string(updated_node,attributes.location_description);
        }
      }
      if (updated_attributes.physical_environment) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_BASIC_PHYSICAL_ENVIRONMENT);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.physical_environment);
                  }
      }
      if (updated_attributes.device_enabled) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_BASIC_DEVICE_ENABLED);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.device_enabled);
                  }
      }
      if (updated_attributes.alarm_mask) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_BASIC_ALARM_MASK);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.alarm_mask);
                  }
      }
      if (updated_attributes.disable_local_config) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_BASIC_DISABLE_LOCAL_CONFIG);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.disable_local_config);
                  }
      }

  return SL_STATUS_OK;
}

static void basic_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/Basic/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_basic_publish_cluster_revision(base_topic.str().c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster power_configuration
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void power_configuration_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"power_configuration_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE) {
            uic_mqtt_dotdot_power_configuration_mains_voltage_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_FREQUENCY) {
            uic_mqtt_dotdot_power_configuration_mains_frequency_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_ALARM_MASK) {
            uic_mqtt_dotdot_power_configuration_mains_alarm_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MIN_THRESHOLD) {
            uic_mqtt_dotdot_power_configuration_mains_voltage_min_threshold_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MAX_THRESHOLD) {
            uic_mqtt_dotdot_power_configuration_mains_voltage_max_threshold_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_DWELL_TRIP_POINT) {
            uic_mqtt_dotdot_power_configuration_mains_voltage_dwell_trip_point_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE) {
            uic_mqtt_dotdot_power_configuration_battery_voltage_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_REMAINING) {
            uic_mqtt_dotdot_power_configuration_battery_percentage_remaining_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_MANUFACTURER) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_power_configuration_battery_manufacturer_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_SIZE) {
            uic_mqtt_dotdot_power_configuration_battery_size_publish(
              base_topic.str().c_str(),
              static_cast<BatterySize>(attr.desired_or_reported<BatterySize>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERYA_HR_RATING) {
            uic_mqtt_dotdot_power_configuration_batterya_hr_rating_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_QUANTITY) {
            uic_mqtt_dotdot_power_configuration_battery_quantity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_RATED_VOLTAGE) {
            uic_mqtt_dotdot_power_configuration_battery_rated_voltage_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_MASK) {
            uic_mqtt_dotdot_power_configuration_battery_alarm_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_MIN_THRESHOLD) {
            uic_mqtt_dotdot_power_configuration_battery_voltage_min_threshold_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD1) {
            uic_mqtt_dotdot_power_configuration_battery_voltage_threshold1_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD2) {
            uic_mqtt_dotdot_power_configuration_battery_voltage_threshold2_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD3) {
            uic_mqtt_dotdot_power_configuration_battery_voltage_threshold3_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_MIN_THRESHOLD) {
            uic_mqtt_dotdot_power_configuration_battery_percentage_min_threshold_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD1) {
            uic_mqtt_dotdot_power_configuration_battery_percentage_threshold1_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD2) {
            uic_mqtt_dotdot_power_configuration_battery_percentage_threshold2_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD3) {
            uic_mqtt_dotdot_power_configuration_battery_percentage_threshold3_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_STATE) {
            uic_mqtt_dotdot_power_configuration_battery_alarm_state_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE) {
            uic_mqtt_dotdot_power_configuration_battery2_voltage_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_REMAINING) {
            uic_mqtt_dotdot_power_configuration_battery2_percentage_remaining_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_MANUFACTURER) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_power_configuration_battery2_manufacturer_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_SIZE) {
            uic_mqtt_dotdot_power_configuration_battery2_size_publish(
              base_topic.str().c_str(),
              static_cast<BatterySize>(attr.desired_or_reported<BatterySize>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2A_HR_RATING) {
            uic_mqtt_dotdot_power_configuration_battery2a_hr_rating_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_QUANTITY) {
            uic_mqtt_dotdot_power_configuration_battery2_quantity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_RATED_VOLTAGE) {
            uic_mqtt_dotdot_power_configuration_battery2_rated_voltage_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_MASK) {
            uic_mqtt_dotdot_power_configuration_battery2_alarm_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_MIN_THRESHOLD) {
            uic_mqtt_dotdot_power_configuration_battery2_voltage_min_threshold_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD1) {
            uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold1_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD2) {
            uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold2_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD3) {
            uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold3_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_MIN_THRESHOLD) {
            uic_mqtt_dotdot_power_configuration_battery2_percentage_min_threshold_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD1) {
            uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold1_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD2) {
            uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold2_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD3) {
            uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold3_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_STATE) {
            uic_mqtt_dotdot_power_configuration_battery2_alarm_state_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE) {
            uic_mqtt_dotdot_power_configuration_battery3_voltage_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_REMAINING) {
            uic_mqtt_dotdot_power_configuration_battery3_percentage_remaining_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_MANUFACTURER) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_power_configuration_battery3_manufacturer_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_SIZE) {
            uic_mqtt_dotdot_power_configuration_battery3_size_publish(
              base_topic.str().c_str(),
              static_cast<BatterySize>(attr.desired_or_reported<BatterySize>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3A_HR_RATING) {
            uic_mqtt_dotdot_power_configuration_battery3a_hr_rating_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_QUANTITY) {
            uic_mqtt_dotdot_power_configuration_battery3_quantity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_RATED_VOLTAGE) {
            uic_mqtt_dotdot_power_configuration_battery3_rated_voltage_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_MASK) {
            uic_mqtt_dotdot_power_configuration_battery3_alarm_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_MIN_THRESHOLD) {
            uic_mqtt_dotdot_power_configuration_battery3_voltage_min_threshold_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD1) {
            uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold1_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD2) {
            uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold2_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD3) {
            uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold3_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_MIN_THRESHOLD) {
            uic_mqtt_dotdot_power_configuration_battery3_percentage_min_threshold_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD1) {
            uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold1_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD2) {
            uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold2_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD3) {
            uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold3_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_STATE) {
            uic_mqtt_dotdot_power_configuration_battery3_alarm_state_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void power_configuration_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"power_configuration_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE) {
            uic_mqtt_dotdot_power_configuration_mains_voltage_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_FREQUENCY) {
            uic_mqtt_dotdot_power_configuration_mains_frequency_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_ALARM_MASK) {
            uic_mqtt_dotdot_power_configuration_mains_alarm_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MIN_THRESHOLD) {
            uic_mqtt_dotdot_power_configuration_mains_voltage_min_threshold_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MAX_THRESHOLD) {
            uic_mqtt_dotdot_power_configuration_mains_voltage_max_threshold_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_DWELL_TRIP_POINT) {
            uic_mqtt_dotdot_power_configuration_mains_voltage_dwell_trip_point_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE) {
            uic_mqtt_dotdot_power_configuration_battery_voltage_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_REMAINING) {
            uic_mqtt_dotdot_power_configuration_battery_percentage_remaining_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_MANUFACTURER) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_power_configuration_battery_manufacturer_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_SIZE) {
            uic_mqtt_dotdot_power_configuration_battery_size_publish(
              base_topic.str().c_str(),
              static_cast<BatterySize>(attr.reported<BatterySize>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERYA_HR_RATING) {
            uic_mqtt_dotdot_power_configuration_batterya_hr_rating_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_QUANTITY) {
            uic_mqtt_dotdot_power_configuration_battery_quantity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_RATED_VOLTAGE) {
            uic_mqtt_dotdot_power_configuration_battery_rated_voltage_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_MASK) {
            uic_mqtt_dotdot_power_configuration_battery_alarm_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_MIN_THRESHOLD) {
            uic_mqtt_dotdot_power_configuration_battery_voltage_min_threshold_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD1) {
            uic_mqtt_dotdot_power_configuration_battery_voltage_threshold1_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD2) {
            uic_mqtt_dotdot_power_configuration_battery_voltage_threshold2_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD3) {
            uic_mqtt_dotdot_power_configuration_battery_voltage_threshold3_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_MIN_THRESHOLD) {
            uic_mqtt_dotdot_power_configuration_battery_percentage_min_threshold_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD1) {
            uic_mqtt_dotdot_power_configuration_battery_percentage_threshold1_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD2) {
            uic_mqtt_dotdot_power_configuration_battery_percentage_threshold2_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD3) {
            uic_mqtt_dotdot_power_configuration_battery_percentage_threshold3_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_STATE) {
            uic_mqtt_dotdot_power_configuration_battery_alarm_state_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE) {
            uic_mqtt_dotdot_power_configuration_battery2_voltage_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_REMAINING) {
            uic_mqtt_dotdot_power_configuration_battery2_percentage_remaining_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_MANUFACTURER) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_power_configuration_battery2_manufacturer_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_SIZE) {
            uic_mqtt_dotdot_power_configuration_battery2_size_publish(
              base_topic.str().c_str(),
              static_cast<BatterySize>(attr.reported<BatterySize>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2A_HR_RATING) {
            uic_mqtt_dotdot_power_configuration_battery2a_hr_rating_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_QUANTITY) {
            uic_mqtt_dotdot_power_configuration_battery2_quantity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_RATED_VOLTAGE) {
            uic_mqtt_dotdot_power_configuration_battery2_rated_voltage_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_MASK) {
            uic_mqtt_dotdot_power_configuration_battery2_alarm_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_MIN_THRESHOLD) {
            uic_mqtt_dotdot_power_configuration_battery2_voltage_min_threshold_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD1) {
            uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold1_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD2) {
            uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold2_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD3) {
            uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold3_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_MIN_THRESHOLD) {
            uic_mqtt_dotdot_power_configuration_battery2_percentage_min_threshold_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD1) {
            uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold1_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD2) {
            uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold2_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD3) {
            uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold3_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_STATE) {
            uic_mqtt_dotdot_power_configuration_battery2_alarm_state_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE) {
            uic_mqtt_dotdot_power_configuration_battery3_voltage_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_REMAINING) {
            uic_mqtt_dotdot_power_configuration_battery3_percentage_remaining_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_MANUFACTURER) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_power_configuration_battery3_manufacturer_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_SIZE) {
            uic_mqtt_dotdot_power_configuration_battery3_size_publish(
              base_topic.str().c_str(),
              static_cast<BatterySize>(attr.reported<BatterySize>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3A_HR_RATING) {
            uic_mqtt_dotdot_power_configuration_battery3a_hr_rating_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_QUANTITY) {
            uic_mqtt_dotdot_power_configuration_battery3_quantity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_RATED_VOLTAGE) {
            uic_mqtt_dotdot_power_configuration_battery3_rated_voltage_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_MASK) {
            uic_mqtt_dotdot_power_configuration_battery3_alarm_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_MIN_THRESHOLD) {
            uic_mqtt_dotdot_power_configuration_battery3_voltage_min_threshold_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD1) {
            uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold1_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD2) {
            uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold2_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD3) {
            uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold3_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_MIN_THRESHOLD) {
            uic_mqtt_dotdot_power_configuration_battery3_percentage_min_threshold_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD1) {
            uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold1_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD2) {
            uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold2_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD3) {
            uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold3_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_STATE) {
            uic_mqtt_dotdot_power_configuration_battery3_alarm_state_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks power_configuration
static sl_status_t power_configuration_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_power_configuration_state_t attributes,
  uic_mqtt_dotdot_power_configuration_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_ALARM_MASK == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MIN_THRESHOLD == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MAX_THRESHOLD == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_DWELL_TRIP_POINT == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_MANUFACTURER == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_SIZE == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERYA_HR_RATING == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_QUANTITY == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_RATED_VOLTAGE == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_MASK == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_MIN_THRESHOLD == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD1 == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD2 == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD3 == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_MIN_THRESHOLD == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD1 == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD2 == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD3 == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_MANUFACTURER == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_SIZE == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2A_HR_RATING == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_QUANTITY == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_RATED_VOLTAGE == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_MASK == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_MIN_THRESHOLD == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD1 == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD2 == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD3 == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_MIN_THRESHOLD == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD1 == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD2 == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD3 == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_MANUFACTURER == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_SIZE == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3A_HR_RATING == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_QUANTITY == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_RATED_VOLTAGE == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_MASK == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_MIN_THRESHOLD == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD1 == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD2 == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD3 == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_MIN_THRESHOLD == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD1 == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD2 == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD3 == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "power_configuration: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.mains_alarm_mask) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_ALARM_MASK);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.mains_alarm_mask);
                  }
      }
      if (updated_attributes.mains_voltage_min_threshold) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MIN_THRESHOLD);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.mains_voltage_min_threshold);
                  }
      }
      if (updated_attributes.mains_voltage_max_threshold) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MAX_THRESHOLD);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.mains_voltage_max_threshold);
                  }
      }
      if (updated_attributes.mains_voltage_dwell_trip_point) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_DWELL_TRIP_POINT);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.mains_voltage_dwell_trip_point);
                  }
      }
      if (updated_attributes.battery_manufacturer) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_MANUFACTURER);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_string(updated_node,attributes.battery_manufacturer);
        }
      }
      if (updated_attributes.battery_size) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_SIZE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery_size);
                  }
      }
      if (updated_attributes.batterya_hr_rating) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERYA_HR_RATING);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.batterya_hr_rating);
                  }
      }
      if (updated_attributes.battery_quantity) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_QUANTITY);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery_quantity);
                  }
      }
      if (updated_attributes.battery_rated_voltage) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_RATED_VOLTAGE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery_rated_voltage);
                  }
      }
      if (updated_attributes.battery_alarm_mask) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_MASK);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery_alarm_mask);
                  }
      }
      if (updated_attributes.battery_voltage_min_threshold) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_MIN_THRESHOLD);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery_voltage_min_threshold);
                  }
      }
      if (updated_attributes.battery_voltage_threshold1) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD1);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery_voltage_threshold1);
                  }
      }
      if (updated_attributes.battery_voltage_threshold2) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD2);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery_voltage_threshold2);
                  }
      }
      if (updated_attributes.battery_voltage_threshold3) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD3);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery_voltage_threshold3);
                  }
      }
      if (updated_attributes.battery_percentage_min_threshold) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_MIN_THRESHOLD);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery_percentage_min_threshold);
                  }
      }
      if (updated_attributes.battery_percentage_threshold1) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD1);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery_percentage_threshold1);
                  }
      }
      if (updated_attributes.battery_percentage_threshold2) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD2);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery_percentage_threshold2);
                  }
      }
      if (updated_attributes.battery_percentage_threshold3) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD3);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery_percentage_threshold3);
                  }
      }
      if (updated_attributes.battery2_manufacturer) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_MANUFACTURER);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_string(updated_node,attributes.battery2_manufacturer);
        }
      }
      if (updated_attributes.battery2_size) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_SIZE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery2_size);
                  }
      }
      if (updated_attributes.battery2a_hr_rating) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2A_HR_RATING);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery2a_hr_rating);
                  }
      }
      if (updated_attributes.battery2_quantity) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_QUANTITY);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery2_quantity);
                  }
      }
      if (updated_attributes.battery2_rated_voltage) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_RATED_VOLTAGE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery2_rated_voltage);
                  }
      }
      if (updated_attributes.battery2_alarm_mask) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_MASK);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery2_alarm_mask);
                  }
      }
      if (updated_attributes.battery2_voltage_min_threshold) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_MIN_THRESHOLD);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery2_voltage_min_threshold);
                  }
      }
      if (updated_attributes.battery2_voltage_threshold1) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD1);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery2_voltage_threshold1);
                  }
      }
      if (updated_attributes.battery2_voltage_threshold2) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD2);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery2_voltage_threshold2);
                  }
      }
      if (updated_attributes.battery2_voltage_threshold3) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD3);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery2_voltage_threshold3);
                  }
      }
      if (updated_attributes.battery2_percentage_min_threshold) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_MIN_THRESHOLD);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery2_percentage_min_threshold);
                  }
      }
      if (updated_attributes.battery2_percentage_threshold1) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD1);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery2_percentage_threshold1);
                  }
      }
      if (updated_attributes.battery2_percentage_threshold2) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD2);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery2_percentage_threshold2);
                  }
      }
      if (updated_attributes.battery2_percentage_threshold3) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD3);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery2_percentage_threshold3);
                  }
      }
      if (updated_attributes.battery3_manufacturer) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_MANUFACTURER);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_string(updated_node,attributes.battery3_manufacturer);
        }
      }
      if (updated_attributes.battery3_size) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_SIZE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery3_size);
                  }
      }
      if (updated_attributes.battery3a_hr_rating) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3A_HR_RATING);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery3a_hr_rating);
                  }
      }
      if (updated_attributes.battery3_quantity) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_QUANTITY);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery3_quantity);
                  }
      }
      if (updated_attributes.battery3_rated_voltage) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_RATED_VOLTAGE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery3_rated_voltage);
                  }
      }
      if (updated_attributes.battery3_alarm_mask) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_MASK);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery3_alarm_mask);
                  }
      }
      if (updated_attributes.battery3_voltage_min_threshold) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_MIN_THRESHOLD);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery3_voltage_min_threshold);
                  }
      }
      if (updated_attributes.battery3_voltage_threshold1) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD1);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery3_voltage_threshold1);
                  }
      }
      if (updated_attributes.battery3_voltage_threshold2) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD2);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery3_voltage_threshold2);
                  }
      }
      if (updated_attributes.battery3_voltage_threshold3) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD3);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery3_voltage_threshold3);
                  }
      }
      if (updated_attributes.battery3_percentage_min_threshold) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_MIN_THRESHOLD);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery3_percentage_min_threshold);
                  }
      }
      if (updated_attributes.battery3_percentage_threshold1) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD1);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery3_percentage_threshold1);
                  }
      }
      if (updated_attributes.battery3_percentage_threshold2) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD2);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery3_percentage_threshold2);
                  }
      }
      if (updated_attributes.battery3_percentage_threshold3) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD3);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.battery3_percentage_threshold3);
                  }
      }

  return SL_STATUS_OK;
}

static void power_configuration_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/PowerConfiguration/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_power_configuration_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster device_temperature_configuration
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void device_temperature_configuration_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"device_temperature_configuration_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_CURRENT_TEMPERATURE) {
            uic_mqtt_dotdot_device_temperature_configuration_current_temperature_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MIN_TEMP_EXPERIENCED) {
            uic_mqtt_dotdot_device_temperature_configuration_min_temp_experienced_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MAX_TEMP_EXPERIENCED) {
            uic_mqtt_dotdot_device_temperature_configuration_max_temp_experienced_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_OVER_TEMP_TOTAL_DWELL) {
            uic_mqtt_dotdot_device_temperature_configuration_over_temp_total_dwell_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_DEVICE_TEMP_ALARM_MASK) {
            uic_mqtt_dotdot_device_temperature_configuration_device_temp_alarm_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_THRESHOLD) {
            uic_mqtt_dotdot_device_temperature_configuration_low_temp_threshold_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_THRESHOLD) {
            uic_mqtt_dotdot_device_temperature_configuration_high_temp_threshold_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_DWELL_TRIP_POINT) {
            uic_mqtt_dotdot_device_temperature_configuration_low_temp_dwell_trip_point_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_DWELL_TRIP_POINT) {
            uic_mqtt_dotdot_device_temperature_configuration_high_temp_dwell_trip_point_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void device_temperature_configuration_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"device_temperature_configuration_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_CURRENT_TEMPERATURE) {
            uic_mqtt_dotdot_device_temperature_configuration_current_temperature_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MIN_TEMP_EXPERIENCED) {
            uic_mqtt_dotdot_device_temperature_configuration_min_temp_experienced_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MAX_TEMP_EXPERIENCED) {
            uic_mqtt_dotdot_device_temperature_configuration_max_temp_experienced_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_OVER_TEMP_TOTAL_DWELL) {
            uic_mqtt_dotdot_device_temperature_configuration_over_temp_total_dwell_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_DEVICE_TEMP_ALARM_MASK) {
            uic_mqtt_dotdot_device_temperature_configuration_device_temp_alarm_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_THRESHOLD) {
            uic_mqtt_dotdot_device_temperature_configuration_low_temp_threshold_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_THRESHOLD) {
            uic_mqtt_dotdot_device_temperature_configuration_high_temp_threshold_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_DWELL_TRIP_POINT) {
            uic_mqtt_dotdot_device_temperature_configuration_low_temp_dwell_trip_point_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_DWELL_TRIP_POINT) {
            uic_mqtt_dotdot_device_temperature_configuration_high_temp_dwell_trip_point_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks device_temperature_configuration
static sl_status_t device_temperature_configuration_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_device_temperature_configuration_state_t attributes,
  uic_mqtt_dotdot_device_temperature_configuration_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_DEVICE_TEMP_ALARM_MASK == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_THRESHOLD == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_THRESHOLD == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_DWELL_TRIP_POINT == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_DWELL_TRIP_POINT == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "device_temperature_configuration: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.device_temp_alarm_mask) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_DEVICE_TEMP_ALARM_MASK);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.device_temp_alarm_mask);
                  }
      }
      if (updated_attributes.low_temp_threshold) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_THRESHOLD);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.low_temp_threshold);
                  }
      }
      if (updated_attributes.high_temp_threshold) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_THRESHOLD);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.high_temp_threshold);
                  }
      }
      if (updated_attributes.low_temp_dwell_trip_point) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_DWELL_TRIP_POINT);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.low_temp_dwell_trip_point);
                  }
      }
      if (updated_attributes.high_temp_dwell_trip_point) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_DWELL_TRIP_POINT);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.high_temp_dwell_trip_point);
                  }
      }

  return SL_STATUS_OK;
}

static void device_temperature_configuration_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/DeviceTemperatureConfiguration/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_device_temperature_configuration_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster identify
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void identify_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"identify_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_IDENTIFY_IDENTIFY_TIME) {
            uic_mqtt_dotdot_identify_identify_time_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void identify_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"identify_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_IDENTIFY_IDENTIFY_TIME) {
            uic_mqtt_dotdot_identify_identify_time_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks identify
static sl_status_t identify_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_identify_state_t attributes,
  uic_mqtt_dotdot_identify_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_IDENTIFY_IDENTIFY_TIME == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "identify: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.identify_time) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_IDENTIFY_IDENTIFY_TIME);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.identify_time);
                  }
      }

  return SL_STATUS_OK;
}

static void identify_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/Identify/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_identify_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster groups
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void groups_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"groups_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_GROUPS_NAME_SUPPORT) {
            uic_mqtt_dotdot_groups_name_support_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void groups_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"groups_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_GROUPS_NAME_SUPPORT) {
            uic_mqtt_dotdot_groups_name_support_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks groups
static sl_status_t groups_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_groups_state_t attributes,
  uic_mqtt_dotdot_groups_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "groups: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;

  return SL_STATUS_OK;
}

static void groups_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/Groups/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_groups_publish_cluster_revision(base_topic.str().c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster scenes
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void scenes_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"scenes_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_COUNT) {
            uic_mqtt_dotdot_scenes_scene_count_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_SCENE) {
            uic_mqtt_dotdot_scenes_current_scene_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_GROUP) {
            uic_mqtt_dotdot_scenes_current_group_publish(
              base_topic.str().c_str(),
              static_cast<SGroupId>(attr.desired_or_reported<SGroupId>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_VALID) {
            uic_mqtt_dotdot_scenes_scene_valid_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.desired_or_reported<bool>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SCENES_NAME_SUPPORT) {
            uic_mqtt_dotdot_scenes_name_support_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SCENES_LAST_CONFIGURED_BY) {
            uic_mqtt_dotdot_scenes_last_configured_by_publish(
              base_topic.str().c_str(),
              static_cast<EUI64>(attr.desired_or_reported<EUI64>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void scenes_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"scenes_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_COUNT) {
            uic_mqtt_dotdot_scenes_scene_count_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_SCENE) {
            uic_mqtt_dotdot_scenes_current_scene_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_GROUP) {
            uic_mqtt_dotdot_scenes_current_group_publish(
              base_topic.str().c_str(),
              static_cast<SGroupId>(attr.reported<SGroupId>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_VALID) {
            uic_mqtt_dotdot_scenes_scene_valid_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.reported<bool>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SCENES_NAME_SUPPORT) {
            uic_mqtt_dotdot_scenes_name_support_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SCENES_LAST_CONFIGURED_BY) {
            uic_mqtt_dotdot_scenes_last_configured_by_publish(
              base_topic.str().c_str(),
              static_cast<EUI64>(attr.reported<EUI64>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks scenes
static sl_status_t scenes_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_scenes_state_t attributes,
  uic_mqtt_dotdot_scenes_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "scenes: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;

  return SL_STATUS_OK;
}

static void scenes_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/Scenes/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_scenes_publish_cluster_revision(base_topic.str().c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster on_off
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void on_off_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"on_off_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_OFF) {
            uic_mqtt_dotdot_on_off_on_off_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.desired_or_reported<bool>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ON_OFF_GLOBAL_SCENE_CONTROL) {
            uic_mqtt_dotdot_on_off_global_scene_control_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.desired_or_reported<bool>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_TIME) {
            uic_mqtt_dotdot_on_off_on_time_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ON_OFF_OFF_WAIT_TIME) {
            uic_mqtt_dotdot_on_off_off_wait_time_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ON_OFF_START_UP_ON_OFF) {
            uic_mqtt_dotdot_on_off_start_up_on_off_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void on_off_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"on_off_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_OFF) {
            uic_mqtt_dotdot_on_off_on_off_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.reported<bool>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ON_OFF_GLOBAL_SCENE_CONTROL) {
            uic_mqtt_dotdot_on_off_global_scene_control_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.reported<bool>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_TIME) {
            uic_mqtt_dotdot_on_off_on_time_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ON_OFF_OFF_WAIT_TIME) {
            uic_mqtt_dotdot_on_off_off_wait_time_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ON_OFF_START_UP_ON_OFF) {
            uic_mqtt_dotdot_on_off_start_up_on_off_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks on_off
static sl_status_t on_off_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_on_off_state_t attributes,
  uic_mqtt_dotdot_on_off_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_TIME == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ON_OFF_OFF_WAIT_TIME == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ON_OFF_START_UP_ON_OFF == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "on_off: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.on_time) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_TIME);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.on_time);
                  }
      }
      if (updated_attributes.off_wait_time) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ON_OFF_OFF_WAIT_TIME);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.off_wait_time);
                  }
      }
      if (updated_attributes.start_up_on_off) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ON_OFF_START_UP_ON_OFF);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.start_up_on_off);
                  }
      }

  return SL_STATUS_OK;
}

static void on_off_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/OnOff/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_on_off_publish_cluster_revision(base_topic.str().c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster level
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void level_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"level_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_LEVEL) {
            uic_mqtt_dotdot_level_current_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_REMAINING_TIME) {
            uic_mqtt_dotdot_level_remaining_time_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_LEVEL) {
            uic_mqtt_dotdot_level_min_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_LEVEL) {
            uic_mqtt_dotdot_level_max_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_FREQUENCY) {
            uic_mqtt_dotdot_level_current_frequency_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_FREQUENCY) {
            uic_mqtt_dotdot_level_min_frequency_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_FREQUENCY) {
            uic_mqtt_dotdot_level_max_frequency_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_OPTIONS) {
            uic_mqtt_dotdot_level_options_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_ON_OFF_TRANSITION_TIME) {
            uic_mqtt_dotdot_level_on_off_transition_time_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_ON_LEVEL) {
            uic_mqtt_dotdot_level_on_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_ON_TRANSITION_TIME) {
            uic_mqtt_dotdot_level_on_transition_time_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_OFF_TRANSITION_TIME) {
            uic_mqtt_dotdot_level_off_transition_time_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_DEFAULT_MOVE_RATE) {
            uic_mqtt_dotdot_level_default_move_rate_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_START_UP_CURRENT_LEVEL) {
            uic_mqtt_dotdot_level_start_up_current_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void level_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"level_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_LEVEL) {
            uic_mqtt_dotdot_level_current_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_REMAINING_TIME) {
            uic_mqtt_dotdot_level_remaining_time_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_LEVEL) {
            uic_mqtt_dotdot_level_min_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_LEVEL) {
            uic_mqtt_dotdot_level_max_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_FREQUENCY) {
            uic_mqtt_dotdot_level_current_frequency_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_FREQUENCY) {
            uic_mqtt_dotdot_level_min_frequency_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_FREQUENCY) {
            uic_mqtt_dotdot_level_max_frequency_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_OPTIONS) {
            uic_mqtt_dotdot_level_options_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_ON_OFF_TRANSITION_TIME) {
            uic_mqtt_dotdot_level_on_off_transition_time_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_ON_LEVEL) {
            uic_mqtt_dotdot_level_on_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_ON_TRANSITION_TIME) {
            uic_mqtt_dotdot_level_on_transition_time_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_OFF_TRANSITION_TIME) {
            uic_mqtt_dotdot_level_off_transition_time_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_DEFAULT_MOVE_RATE) {
            uic_mqtt_dotdot_level_default_move_rate_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_LEVEL_START_UP_CURRENT_LEVEL) {
            uic_mqtt_dotdot_level_start_up_current_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks level
static sl_status_t level_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_level_state_t attributes,
  uic_mqtt_dotdot_level_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_LEVEL_OPTIONS == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_LEVEL_ON_OFF_TRANSITION_TIME == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_LEVEL_ON_LEVEL == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_LEVEL_ON_TRANSITION_TIME == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_LEVEL_OFF_TRANSITION_TIME == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_LEVEL_DEFAULT_MOVE_RATE == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_LEVEL_START_UP_CURRENT_LEVEL == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "level: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.options) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_LEVEL_OPTIONS);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.options);
                  }
      }
      if (updated_attributes.on_off_transition_time) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_LEVEL_ON_OFF_TRANSITION_TIME);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.on_off_transition_time);
                  }
      }
      if (updated_attributes.on_level) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_LEVEL_ON_LEVEL);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.on_level);
                  }
      }
      if (updated_attributes.on_transition_time) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_LEVEL_ON_TRANSITION_TIME);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.on_transition_time);
                  }
      }
      if (updated_attributes.off_transition_time) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_LEVEL_OFF_TRANSITION_TIME);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.off_transition_time);
                  }
      }
      if (updated_attributes.default_move_rate) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_LEVEL_DEFAULT_MOVE_RATE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.default_move_rate);
                  }
      }
      if (updated_attributes.start_up_current_level) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_LEVEL_START_UP_CURRENT_LEVEL);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.start_up_current_level);
                  }
      }

  return SL_STATUS_OK;
}

static void level_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/Level/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_level_publish_cluster_revision(base_topic.str().c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster alarms
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void alarms_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"alarms_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ALARMS_ALARM_COUNT) {
            uic_mqtt_dotdot_alarms_alarm_count_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void alarms_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"alarms_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ALARMS_ALARM_COUNT) {
            uic_mqtt_dotdot_alarms_alarm_count_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks alarms
static sl_status_t alarms_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_alarms_state_t attributes,
  uic_mqtt_dotdot_alarms_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "alarms: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;

  return SL_STATUS_OK;
}

static void alarms_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/Alarms/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_alarms_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster time
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void time_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"time_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TIME_TIME) {
            uic_mqtt_dotdot_time_time_publish(
              base_topic.str().c_str(),
              static_cast<UTC>(attr.desired_or_reported<UTC>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TIME_TIME_STATUS) {
            uic_mqtt_dotdot_time_time_status_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TIME_TIME_ZONE) {
            uic_mqtt_dotdot_time_time_zone_publish(
              base_topic.str().c_str(),
              static_cast<int32_t>(attr.desired_or_reported<int32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TIME_DST_START) {
            uic_mqtt_dotdot_time_dst_start_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TIME_DST_END) {
            uic_mqtt_dotdot_time_dst_end_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TIME_DST_SHIFT) {
            uic_mqtt_dotdot_time_dst_shift_publish(
              base_topic.str().c_str(),
              static_cast<int32_t>(attr.desired_or_reported<int32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TIME_STANDARD_TIME) {
            uic_mqtt_dotdot_time_standard_time_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TIME_LOCAL_TIME) {
            uic_mqtt_dotdot_time_local_time_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TIME_LAST_SET_TIME) {
            uic_mqtt_dotdot_time_last_set_time_publish(
              base_topic.str().c_str(),
              static_cast<UTC>(attr.desired_or_reported<UTC>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TIME_VALID_UNTIL_TIME) {
            uic_mqtt_dotdot_time_valid_until_time_publish(
              base_topic.str().c_str(),
              static_cast<UTC>(attr.desired_or_reported<UTC>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void time_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"time_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TIME_TIME) {
            uic_mqtt_dotdot_time_time_publish(
              base_topic.str().c_str(),
              static_cast<UTC>(attr.reported<UTC>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TIME_TIME_STATUS) {
            uic_mqtt_dotdot_time_time_status_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TIME_TIME_ZONE) {
            uic_mqtt_dotdot_time_time_zone_publish(
              base_topic.str().c_str(),
              static_cast<int32_t>(attr.reported<int32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TIME_DST_START) {
            uic_mqtt_dotdot_time_dst_start_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TIME_DST_END) {
            uic_mqtt_dotdot_time_dst_end_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TIME_DST_SHIFT) {
            uic_mqtt_dotdot_time_dst_shift_publish(
              base_topic.str().c_str(),
              static_cast<int32_t>(attr.reported<int32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TIME_STANDARD_TIME) {
            uic_mqtt_dotdot_time_standard_time_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TIME_LOCAL_TIME) {
            uic_mqtt_dotdot_time_local_time_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TIME_LAST_SET_TIME) {
            uic_mqtt_dotdot_time_last_set_time_publish(
              base_topic.str().c_str(),
              static_cast<UTC>(attr.reported<UTC>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TIME_VALID_UNTIL_TIME) {
            uic_mqtt_dotdot_time_valid_until_time_publish(
              base_topic.str().c_str(),
              static_cast<UTC>(attr.reported<UTC>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks time
static sl_status_t time_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_time_state_t attributes,
  uic_mqtt_dotdot_time_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_TIME_TIME == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_TIME_TIME_STATUS == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_TIME_TIME_ZONE == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_TIME_DST_START == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_TIME_DST_END == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_TIME_DST_SHIFT == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_TIME_VALID_UNTIL_TIME == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "time: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.time) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_TIME_TIME);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.time);
                  }
      }
      if (updated_attributes.time_status) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_TIME_TIME_STATUS);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.time_status);
                  }
      }
      if (updated_attributes.time_zone) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_TIME_TIME_ZONE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.time_zone);
                  }
      }
      if (updated_attributes.dst_start) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_TIME_DST_START);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.dst_start);
                  }
      }
      if (updated_attributes.dst_end) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_TIME_DST_END);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.dst_end);
                  }
      }
      if (updated_attributes.dst_shift) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_TIME_DST_SHIFT);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.dst_shift);
                  }
      }
      if (updated_attributes.valid_until_time) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_TIME_VALID_UNTIL_TIME);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.valid_until_time);
                  }
      }

  return SL_STATUS_OK;
}

static void time_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/Time/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_time_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster ota_upgrade
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void ota_upgrade_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"ota_upgrade_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_UPGRADE_SERVERID) {
            uic_mqtt_dotdot_ota_upgrade_upgrade_serverid_publish(
              base_topic.str().c_str(),
              static_cast<EUI64>(attr.desired_or_reported<EUI64>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_FILE_OFFSET) {
            uic_mqtt_dotdot_ota_upgrade_file_offset_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_CURRENT_FILE_VERSION) {
            uic_mqtt_dotdot_ota_upgrade_current_file_version_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_CURRENT_ZIG_BEE_STACK_VERSION) {
            uic_mqtt_dotdot_ota_upgrade_current_zig_bee_stack_version_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_DOWNLOADED_FILE_VERSION) {
            uic_mqtt_dotdot_ota_upgrade_downloaded_file_version_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_DOWNLOADED_ZIG_BEE_STACK_VERSION) {
            uic_mqtt_dotdot_ota_upgrade_downloaded_zig_bee_stack_version_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_IMAGE_UPGRADE_STATUS) {
            uic_mqtt_dotdot_ota_upgrade_image_upgrade_status_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_MANUFACTURERID) {
            uic_mqtt_dotdot_ota_upgrade_manufacturerid_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_IMAGE_TYPEID) {
            uic_mqtt_dotdot_ota_upgrade_image_typeid_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_MINIMUM_BLOCK_PERIOD) {
            uic_mqtt_dotdot_ota_upgrade_minimum_block_period_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_IMAGE_STAMP) {
            uic_mqtt_dotdot_ota_upgrade_image_stamp_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_UPGRADE_ACTIVATION_POLICY) {
            uic_mqtt_dotdot_ota_upgrade_upgrade_activation_policy_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_UPGRADE_TIMEOUT_POLICY) {
            uic_mqtt_dotdot_ota_upgrade_upgrade_timeout_policy_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void ota_upgrade_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"ota_upgrade_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_UPGRADE_SERVERID) {
            uic_mqtt_dotdot_ota_upgrade_upgrade_serverid_publish(
              base_topic.str().c_str(),
              static_cast<EUI64>(attr.reported<EUI64>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_FILE_OFFSET) {
            uic_mqtt_dotdot_ota_upgrade_file_offset_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_CURRENT_FILE_VERSION) {
            uic_mqtt_dotdot_ota_upgrade_current_file_version_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_CURRENT_ZIG_BEE_STACK_VERSION) {
            uic_mqtt_dotdot_ota_upgrade_current_zig_bee_stack_version_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_DOWNLOADED_FILE_VERSION) {
            uic_mqtt_dotdot_ota_upgrade_downloaded_file_version_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_DOWNLOADED_ZIG_BEE_STACK_VERSION) {
            uic_mqtt_dotdot_ota_upgrade_downloaded_zig_bee_stack_version_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_IMAGE_UPGRADE_STATUS) {
            uic_mqtt_dotdot_ota_upgrade_image_upgrade_status_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_MANUFACTURERID) {
            uic_mqtt_dotdot_ota_upgrade_manufacturerid_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_IMAGE_TYPEID) {
            uic_mqtt_dotdot_ota_upgrade_image_typeid_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_MINIMUM_BLOCK_PERIOD) {
            uic_mqtt_dotdot_ota_upgrade_minimum_block_period_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_IMAGE_STAMP) {
            uic_mqtt_dotdot_ota_upgrade_image_stamp_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_UPGRADE_ACTIVATION_POLICY) {
            uic_mqtt_dotdot_ota_upgrade_upgrade_activation_policy_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_UPGRADE_TIMEOUT_POLICY) {
            uic_mqtt_dotdot_ota_upgrade_upgrade_timeout_policy_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks ota_upgrade
static sl_status_t ota_upgrade_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_ota_upgrade_state_t attributes,
  uic_mqtt_dotdot_ota_upgrade_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "ota_upgrade: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;

  return SL_STATUS_OK;
}

static void ota_upgrade_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/OTAUpgrade/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_ota_upgrade_publish_cluster_revision(base_topic.str().c_str(), 3);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster poll_control
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void poll_control_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"poll_control_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL) {
            uic_mqtt_dotdot_poll_control_check_in_interval_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL) {
            uic_mqtt_dotdot_poll_control_long_poll_interval_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_SHORT_POLL_INTERVAL) {
            uic_mqtt_dotdot_poll_control_short_poll_interval_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT) {
            uic_mqtt_dotdot_poll_control_fast_poll_timeout_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL_MIN) {
            uic_mqtt_dotdot_poll_control_check_in_interval_min_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL_MIN) {
            uic_mqtt_dotdot_poll_control_long_poll_interval_min_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT_MAX) {
            uic_mqtt_dotdot_poll_control_fast_poll_timeout_max_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void poll_control_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"poll_control_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL) {
            uic_mqtt_dotdot_poll_control_check_in_interval_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL) {
            uic_mqtt_dotdot_poll_control_long_poll_interval_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_SHORT_POLL_INTERVAL) {
            uic_mqtt_dotdot_poll_control_short_poll_interval_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT) {
            uic_mqtt_dotdot_poll_control_fast_poll_timeout_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL_MIN) {
            uic_mqtt_dotdot_poll_control_check_in_interval_min_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL_MIN) {
            uic_mqtt_dotdot_poll_control_long_poll_interval_min_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT_MAX) {
            uic_mqtt_dotdot_poll_control_fast_poll_timeout_max_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks poll_control
static sl_status_t poll_control_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_poll_control_state_t attributes,
  uic_mqtt_dotdot_poll_control_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "poll_control: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.check_in_interval) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.check_in_interval);
                  }
      }
      if (updated_attributes.fast_poll_timeout) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.fast_poll_timeout);
                  }
      }

  return SL_STATUS_OK;
}

static void poll_control_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/PollControl/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_poll_control_publish_cluster_revision(base_topic.str().c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster shade_configuration
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void shade_configuration_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"shade_configuration_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_PHYSICAL_CLOSED_LIMIT) {
            uic_mqtt_dotdot_shade_configuration_physical_closed_limit_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MOTOR_STEP_SIZE) {
            uic_mqtt_dotdot_shade_configuration_motor_step_size_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_STATUS) {
            uic_mqtt_dotdot_shade_configuration_status_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_CLOSED_LIMIT) {
            uic_mqtt_dotdot_shade_configuration_closed_limit_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MODE) {
            uic_mqtt_dotdot_shade_configuration_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void shade_configuration_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"shade_configuration_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_PHYSICAL_CLOSED_LIMIT) {
            uic_mqtt_dotdot_shade_configuration_physical_closed_limit_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MOTOR_STEP_SIZE) {
            uic_mqtt_dotdot_shade_configuration_motor_step_size_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_STATUS) {
            uic_mqtt_dotdot_shade_configuration_status_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_CLOSED_LIMIT) {
            uic_mqtt_dotdot_shade_configuration_closed_limit_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MODE) {
            uic_mqtt_dotdot_shade_configuration_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks shade_configuration
static sl_status_t shade_configuration_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_shade_configuration_state_t attributes,
  uic_mqtt_dotdot_shade_configuration_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_STATUS == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_CLOSED_LIMIT == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MODE == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "shade_configuration: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.status) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_STATUS);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.status);
                  }
      }
      if (updated_attributes.closed_limit) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_CLOSED_LIMIT);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.closed_limit);
                  }
      }
      if (updated_attributes.mode) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MODE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.mode);
                  }
      }

  return SL_STATUS_OK;
}

static void shade_configuration_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/ShadeConfiguration/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_shade_configuration_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster door_lock
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void door_lock_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"door_lock_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_STATE) {
            uic_mqtt_dotdot_door_lock_lock_state_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_TYPE) {
            uic_mqtt_dotdot_door_lock_lock_type_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ACTUATOR_ENABLED) {
            uic_mqtt_dotdot_door_lock_actuator_enabled_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.desired_or_reported<bool>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_STATE) {
            uic_mqtt_dotdot_door_lock_door_state_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_OPEN_EVENTS) {
            uic_mqtt_dotdot_door_lock_door_open_events_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_CLOSED_EVENTS) {
            uic_mqtt_dotdot_door_lock_door_closed_events_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPEN_PERIOD) {
            uic_mqtt_dotdot_door_lock_open_period_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_LOG_RECORDS_SUPPORTED) {
            uic_mqtt_dotdot_door_lock_number_of_log_records_supported_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_TOTAL_USERS_SUPPORTED) {
            uic_mqtt_dotdot_door_lock_number_of_total_users_supported_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OFPIN_USERS_SUPPORTED) {
            uic_mqtt_dotdot_door_lock_number_ofpin_users_supported_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OFRFID_USERS_SUPPORTED) {
            uic_mqtt_dotdot_door_lock_number_ofrfid_users_supported_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_WEEK_DAY_SCHEDULES_SUPPORTED_PER_USER) {
            uic_mqtt_dotdot_door_lock_number_of_week_day_schedules_supported_per_user_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_YEAR_DAY_SCHEDULES_SUPPORTED_PER_USER) {
            uic_mqtt_dotdot_door_lock_number_of_year_day_schedules_supported_per_user_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_HOLIDAY_SCHEDULES_SUPPORTED) {
            uic_mqtt_dotdot_door_lock_number_of_holiday_schedules_supported_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAXPIN_CODE_LENGTH) {
            uic_mqtt_dotdot_door_lock_maxpin_code_length_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MINPIN_CODE_LENGTH) {
            uic_mqtt_dotdot_door_lock_minpin_code_length_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAXRFID_CODE_LENGTH) {
            uic_mqtt_dotdot_door_lock_maxrfid_code_length_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MINRFID_CODE_LENGTH) {
            uic_mqtt_dotdot_door_lock_minrfid_code_length_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOGGING) {
            uic_mqtt_dotdot_door_lock_enable_logging_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.desired_or_reported<bool>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LANGUAGE) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_door_lock_language_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LED_SETTINGS) {
            uic_mqtt_dotdot_door_lock_led_settings_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_AUTO_RELOCK_TIME) {
            uic_mqtt_dotdot_door_lock_auto_relock_time_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SOUND_VOLUME) {
            uic_mqtt_dotdot_door_lock_sound_volume_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPERATING_MODE) {
            uic_mqtt_dotdot_door_lock_operating_mode_publish(
              base_topic.str().c_str(),
              static_cast<DrlkOperMode>(attr.desired_or_reported<DrlkOperMode>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SUPPORTED_OPERATING_MODES) {
            uic_mqtt_dotdot_door_lock_supported_operating_modes_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DEFAULT_CONFIGURATION_REGISTER) {
            uic_mqtt_dotdot_door_lock_default_configuration_register_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOCAL_PROGRAMMING) {
            uic_mqtt_dotdot_door_lock_enable_local_programming_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.desired_or_reported<bool>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_ONE_TOUCH_LOCKING) {
            uic_mqtt_dotdot_door_lock_enable_one_touch_locking_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.desired_or_reported<bool>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_INSIDE_STATUSLED) {
            uic_mqtt_dotdot_door_lock_enable_inside_statusled_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.desired_or_reported<bool>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_PRIVACY_MODE_BUTTON) {
            uic_mqtt_dotdot_door_lock_enable_privacy_mode_button_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.desired_or_reported<bool>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_WRONG_CODE_ENTRY_LIMIT) {
            uic_mqtt_dotdot_door_lock_wrong_code_entry_limit_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_USER_CODE_TEMPORARY_DISABLE_TIME) {
            uic_mqtt_dotdot_door_lock_user_code_temporary_disable_time_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SENDPIN_OVER_THE_AIR) {
            uic_mqtt_dotdot_door_lock_sendpin_over_the_air_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.desired_or_reported<bool>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_REQUIREPI_NFORRF_OPERATION) {
            uic_mqtt_dotdot_door_lock_requirepi_nforrf_operation_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.desired_or_reported<bool>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SECURITY_LEVEL) {
            uic_mqtt_dotdot_door_lock_security_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ALARM_MASK) {
            uic_mqtt_dotdot_door_lock_alarm_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_OPERATION_EVENT_MASK) {
            uic_mqtt_dotdot_door_lock_keypad_operation_event_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_OPERATION_EVENT_MASK) {
            uic_mqtt_dotdot_door_lock_rf_operation_event_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MANUAL_OPERATION_EVENT_MASK) {
            uic_mqtt_dotdot_door_lock_manual_operation_event_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_OPERATION_EVENT_MASK) {
            uic_mqtt_dotdot_door_lock_rfid_operation_event_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_PROGRAMMING_EVENT_MASK) {
            uic_mqtt_dotdot_door_lock_keypad_programming_event_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_PROGRAMMING_EVENT_MASK) {
            uic_mqtt_dotdot_door_lock_rf_programming_event_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_PROGRAMMING_EVENT_MASK) {
            uic_mqtt_dotdot_door_lock_rfid_programming_event_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void door_lock_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"door_lock_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_STATE) {
            uic_mqtt_dotdot_door_lock_lock_state_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_TYPE) {
            uic_mqtt_dotdot_door_lock_lock_type_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ACTUATOR_ENABLED) {
            uic_mqtt_dotdot_door_lock_actuator_enabled_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.reported<bool>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_STATE) {
            uic_mqtt_dotdot_door_lock_door_state_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_OPEN_EVENTS) {
            uic_mqtt_dotdot_door_lock_door_open_events_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_CLOSED_EVENTS) {
            uic_mqtt_dotdot_door_lock_door_closed_events_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPEN_PERIOD) {
            uic_mqtt_dotdot_door_lock_open_period_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_LOG_RECORDS_SUPPORTED) {
            uic_mqtt_dotdot_door_lock_number_of_log_records_supported_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_TOTAL_USERS_SUPPORTED) {
            uic_mqtt_dotdot_door_lock_number_of_total_users_supported_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OFPIN_USERS_SUPPORTED) {
            uic_mqtt_dotdot_door_lock_number_ofpin_users_supported_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OFRFID_USERS_SUPPORTED) {
            uic_mqtt_dotdot_door_lock_number_ofrfid_users_supported_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_WEEK_DAY_SCHEDULES_SUPPORTED_PER_USER) {
            uic_mqtt_dotdot_door_lock_number_of_week_day_schedules_supported_per_user_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_YEAR_DAY_SCHEDULES_SUPPORTED_PER_USER) {
            uic_mqtt_dotdot_door_lock_number_of_year_day_schedules_supported_per_user_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_HOLIDAY_SCHEDULES_SUPPORTED) {
            uic_mqtt_dotdot_door_lock_number_of_holiday_schedules_supported_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAXPIN_CODE_LENGTH) {
            uic_mqtt_dotdot_door_lock_maxpin_code_length_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MINPIN_CODE_LENGTH) {
            uic_mqtt_dotdot_door_lock_minpin_code_length_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAXRFID_CODE_LENGTH) {
            uic_mqtt_dotdot_door_lock_maxrfid_code_length_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MINRFID_CODE_LENGTH) {
            uic_mqtt_dotdot_door_lock_minrfid_code_length_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOGGING) {
            uic_mqtt_dotdot_door_lock_enable_logging_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.reported<bool>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LANGUAGE) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_door_lock_language_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LED_SETTINGS) {
            uic_mqtt_dotdot_door_lock_led_settings_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_AUTO_RELOCK_TIME) {
            uic_mqtt_dotdot_door_lock_auto_relock_time_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SOUND_VOLUME) {
            uic_mqtt_dotdot_door_lock_sound_volume_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPERATING_MODE) {
            uic_mqtt_dotdot_door_lock_operating_mode_publish(
              base_topic.str().c_str(),
              static_cast<DrlkOperMode>(attr.reported<DrlkOperMode>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SUPPORTED_OPERATING_MODES) {
            uic_mqtt_dotdot_door_lock_supported_operating_modes_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DEFAULT_CONFIGURATION_REGISTER) {
            uic_mqtt_dotdot_door_lock_default_configuration_register_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOCAL_PROGRAMMING) {
            uic_mqtt_dotdot_door_lock_enable_local_programming_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.reported<bool>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_ONE_TOUCH_LOCKING) {
            uic_mqtt_dotdot_door_lock_enable_one_touch_locking_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.reported<bool>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_INSIDE_STATUSLED) {
            uic_mqtt_dotdot_door_lock_enable_inside_statusled_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.reported<bool>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_PRIVACY_MODE_BUTTON) {
            uic_mqtt_dotdot_door_lock_enable_privacy_mode_button_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.reported<bool>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_WRONG_CODE_ENTRY_LIMIT) {
            uic_mqtt_dotdot_door_lock_wrong_code_entry_limit_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_USER_CODE_TEMPORARY_DISABLE_TIME) {
            uic_mqtt_dotdot_door_lock_user_code_temporary_disable_time_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SENDPIN_OVER_THE_AIR) {
            uic_mqtt_dotdot_door_lock_sendpin_over_the_air_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.reported<bool>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_REQUIREPI_NFORRF_OPERATION) {
            uic_mqtt_dotdot_door_lock_requirepi_nforrf_operation_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.reported<bool>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SECURITY_LEVEL) {
            uic_mqtt_dotdot_door_lock_security_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ALARM_MASK) {
            uic_mqtt_dotdot_door_lock_alarm_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_OPERATION_EVENT_MASK) {
            uic_mqtt_dotdot_door_lock_keypad_operation_event_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_OPERATION_EVENT_MASK) {
            uic_mqtt_dotdot_door_lock_rf_operation_event_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MANUAL_OPERATION_EVENT_MASK) {
            uic_mqtt_dotdot_door_lock_manual_operation_event_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_OPERATION_EVENT_MASK) {
            uic_mqtt_dotdot_door_lock_rfid_operation_event_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_PROGRAMMING_EVENT_MASK) {
            uic_mqtt_dotdot_door_lock_keypad_programming_event_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_PROGRAMMING_EVENT_MASK) {
            uic_mqtt_dotdot_door_lock_rf_programming_event_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_PROGRAMMING_EVENT_MASK) {
            uic_mqtt_dotdot_door_lock_rfid_programming_event_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks door_lock
static sl_status_t door_lock_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_door_lock_state_t attributes,
  uic_mqtt_dotdot_door_lock_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_OPEN_EVENTS == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_CLOSED_EVENTS == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPEN_PERIOD == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOGGING == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LANGUAGE == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LED_SETTINGS == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_AUTO_RELOCK_TIME == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SOUND_VOLUME == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPERATING_MODE == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOCAL_PROGRAMMING == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_ONE_TOUCH_LOCKING == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_INSIDE_STATUSLED == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_PRIVACY_MODE_BUTTON == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_WRONG_CODE_ENTRY_LIMIT == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_USER_CODE_TEMPORARY_DISABLE_TIME == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SENDPIN_OVER_THE_AIR == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_REQUIREPI_NFORRF_OPERATION == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ALARM_MASK == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_OPERATION_EVENT_MASK == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_OPERATION_EVENT_MASK == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MANUAL_OPERATION_EVENT_MASK == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_OPERATION_EVENT_MASK == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_PROGRAMMING_EVENT_MASK == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_PROGRAMMING_EVENT_MASK == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_PROGRAMMING_EVENT_MASK == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "door_lock: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.door_open_events) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_OPEN_EVENTS);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.door_open_events);
                  }
      }
      if (updated_attributes.door_closed_events) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_CLOSED_EVENTS);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.door_closed_events);
                  }
      }
      if (updated_attributes.open_period) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPEN_PERIOD);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.open_period);
                  }
      }
      if (updated_attributes.enable_logging) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOGGING);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.enable_logging);
                  }
      }
      if (updated_attributes.language) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LANGUAGE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_string(updated_node,attributes.language);
        }
      }
      if (updated_attributes.led_settings) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LED_SETTINGS);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.led_settings);
                  }
      }
      if (updated_attributes.auto_relock_time) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_AUTO_RELOCK_TIME);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.auto_relock_time);
                  }
      }
      if (updated_attributes.sound_volume) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SOUND_VOLUME);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.sound_volume);
                  }
      }
      if (updated_attributes.operating_mode) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPERATING_MODE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.operating_mode);
                  }
      }
      if (updated_attributes.enable_local_programming) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOCAL_PROGRAMMING);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.enable_local_programming);
                  }
      }
      if (updated_attributes.enable_one_touch_locking) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_ONE_TOUCH_LOCKING);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.enable_one_touch_locking);
                  }
      }
      if (updated_attributes.enable_inside_statusled) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_INSIDE_STATUSLED);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.enable_inside_statusled);
                  }
      }
      if (updated_attributes.enable_privacy_mode_button) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_PRIVACY_MODE_BUTTON);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.enable_privacy_mode_button);
                  }
      }
      if (updated_attributes.wrong_code_entry_limit) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_WRONG_CODE_ENTRY_LIMIT);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.wrong_code_entry_limit);
                  }
      }
      if (updated_attributes.user_code_temporary_disable_time) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_USER_CODE_TEMPORARY_DISABLE_TIME);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.user_code_temporary_disable_time);
                  }
      }
      if (updated_attributes.sendpin_over_the_air) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SENDPIN_OVER_THE_AIR);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.sendpin_over_the_air);
                  }
      }
      if (updated_attributes.requirepi_nforrf_operation) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_REQUIREPI_NFORRF_OPERATION);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.requirepi_nforrf_operation);
                  }
      }
      if (updated_attributes.alarm_mask) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ALARM_MASK);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.alarm_mask);
                  }
      }
      if (updated_attributes.keypad_operation_event_mask) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_OPERATION_EVENT_MASK);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.keypad_operation_event_mask);
                  }
      }
      if (updated_attributes.rf_operation_event_mask) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_OPERATION_EVENT_MASK);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.rf_operation_event_mask);
                  }
      }
      if (updated_attributes.manual_operation_event_mask) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MANUAL_OPERATION_EVENT_MASK);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.manual_operation_event_mask);
                  }
      }
      if (updated_attributes.rfid_operation_event_mask) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_OPERATION_EVENT_MASK);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.rfid_operation_event_mask);
                  }
      }
      if (updated_attributes.keypad_programming_event_mask) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_PROGRAMMING_EVENT_MASK);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.keypad_programming_event_mask);
                  }
      }
      if (updated_attributes.rf_programming_event_mask) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_PROGRAMMING_EVENT_MASK);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.rf_programming_event_mask);
                  }
      }
      if (updated_attributes.rfid_programming_event_mask) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_PROGRAMMING_EVENT_MASK);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.rfid_programming_event_mask);
                  }
      }

  return SL_STATUS_OK;
}

static void door_lock_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/DoorLock/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_door_lock_publish_cluster_revision(base_topic.str().c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster window_covering
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void window_covering_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"window_covering_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_WINDOW_COVERING_TYPE) {
            uic_mqtt_dotdot_window_covering_window_covering_type_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_LIFT) {
            uic_mqtt_dotdot_window_covering_physical_closed_limit_lift_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_TILT) {
            uic_mqtt_dotdot_window_covering_physical_closed_limit_tilt_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT) {
            uic_mqtt_dotdot_window_covering_current_position_lift_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT) {
            uic_mqtt_dotdot_window_covering_current_position_tilt_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_LIFT) {
            uic_mqtt_dotdot_window_covering_number_of_actuations_lift_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_TILT) {
            uic_mqtt_dotdot_window_covering_number_of_actuations_tilt_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CONFIG_OR_STATUS) {
            uic_mqtt_dotdot_window_covering_config_or_status_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT_PERCENTAGE) {
            uic_mqtt_dotdot_window_covering_current_position_lift_percentage_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT_PERCENTAGE) {
            uic_mqtt_dotdot_window_covering_current_position_tilt_percentage_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_LIFT) {
            uic_mqtt_dotdot_window_covering_installed_open_limit_lift_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_LIFT) {
            uic_mqtt_dotdot_window_covering_installed_closed_limit_lift_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_TILT) {
            uic_mqtt_dotdot_window_covering_installed_open_limit_tilt_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_TILT) {
            uic_mqtt_dotdot_window_covering_installed_closed_limit_tilt_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_VELOCITY_LIFT) {
            uic_mqtt_dotdot_window_covering_velocity_lift_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_ACCELERATION_TIME_LIFT) {
            uic_mqtt_dotdot_window_covering_acceleration_time_lift_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_DECELERATION_TIME_LIFT) {
            uic_mqtt_dotdot_window_covering_deceleration_time_lift_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_MODE) {
            uic_mqtt_dotdot_window_covering_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_LIFT) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_window_covering_intermediate_setpoints_lift_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_TILT) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_window_covering_intermediate_setpoints_tilt_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void window_covering_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"window_covering_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_WINDOW_COVERING_TYPE) {
            uic_mqtt_dotdot_window_covering_window_covering_type_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_LIFT) {
            uic_mqtt_dotdot_window_covering_physical_closed_limit_lift_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_TILT) {
            uic_mqtt_dotdot_window_covering_physical_closed_limit_tilt_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT) {
            uic_mqtt_dotdot_window_covering_current_position_lift_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT) {
            uic_mqtt_dotdot_window_covering_current_position_tilt_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_LIFT) {
            uic_mqtt_dotdot_window_covering_number_of_actuations_lift_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_TILT) {
            uic_mqtt_dotdot_window_covering_number_of_actuations_tilt_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CONFIG_OR_STATUS) {
            uic_mqtt_dotdot_window_covering_config_or_status_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT_PERCENTAGE) {
            uic_mqtt_dotdot_window_covering_current_position_lift_percentage_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT_PERCENTAGE) {
            uic_mqtt_dotdot_window_covering_current_position_tilt_percentage_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_LIFT) {
            uic_mqtt_dotdot_window_covering_installed_open_limit_lift_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_LIFT) {
            uic_mqtt_dotdot_window_covering_installed_closed_limit_lift_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_TILT) {
            uic_mqtt_dotdot_window_covering_installed_open_limit_tilt_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_TILT) {
            uic_mqtt_dotdot_window_covering_installed_closed_limit_tilt_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_VELOCITY_LIFT) {
            uic_mqtt_dotdot_window_covering_velocity_lift_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_ACCELERATION_TIME_LIFT) {
            uic_mqtt_dotdot_window_covering_acceleration_time_lift_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_DECELERATION_TIME_LIFT) {
            uic_mqtt_dotdot_window_covering_deceleration_time_lift_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_MODE) {
            uic_mqtt_dotdot_window_covering_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_LIFT) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_window_covering_intermediate_setpoints_lift_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_TILT) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_window_covering_intermediate_setpoints_tilt_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks window_covering
static sl_status_t window_covering_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_window_covering_state_t attributes,
  uic_mqtt_dotdot_window_covering_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_VELOCITY_LIFT == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_ACCELERATION_TIME_LIFT == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_DECELERATION_TIME_LIFT == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "window_covering: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.velocity_lift) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_VELOCITY_LIFT);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.velocity_lift);
                  }
      }
      if (updated_attributes.acceleration_time_lift) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_ACCELERATION_TIME_LIFT);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.acceleration_time_lift);
                  }
      }
      if (updated_attributes.deceleration_time_lift) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_DECELERATION_TIME_LIFT);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.deceleration_time_lift);
                  }
      }

  return SL_STATUS_OK;
}

static void window_covering_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/WindowCovering/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_window_covering_publish_cluster_revision(base_topic.str().c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster barrier_control
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void barrier_control_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"barrier_control_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_MOVING_STATE) {
            uic_mqtt_dotdot_barrier_control_moving_state_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_SAFETY_STATUS) {
            uic_mqtt_dotdot_barrier_control_safety_status_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CAPABILITIES) {
            uic_mqtt_dotdot_barrier_control_capabilities_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_EVENTS) {
            uic_mqtt_dotdot_barrier_control_open_events_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_EVENTS) {
            uic_mqtt_dotdot_barrier_control_close_events_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_OPEN_EVENTS) {
            uic_mqtt_dotdot_barrier_control_command_open_events_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_CLOSE_EVENTS) {
            uic_mqtt_dotdot_barrier_control_command_close_events_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_PERIOD) {
            uic_mqtt_dotdot_barrier_control_open_period_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_PERIOD) {
            uic_mqtt_dotdot_barrier_control_close_period_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_BARRIER_POSITION) {
            uic_mqtt_dotdot_barrier_control_barrier_position_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void barrier_control_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"barrier_control_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_MOVING_STATE) {
            uic_mqtt_dotdot_barrier_control_moving_state_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_SAFETY_STATUS) {
            uic_mqtt_dotdot_barrier_control_safety_status_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CAPABILITIES) {
            uic_mqtt_dotdot_barrier_control_capabilities_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_EVENTS) {
            uic_mqtt_dotdot_barrier_control_open_events_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_EVENTS) {
            uic_mqtt_dotdot_barrier_control_close_events_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_OPEN_EVENTS) {
            uic_mqtt_dotdot_barrier_control_command_open_events_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_CLOSE_EVENTS) {
            uic_mqtt_dotdot_barrier_control_command_close_events_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_PERIOD) {
            uic_mqtt_dotdot_barrier_control_open_period_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_PERIOD) {
            uic_mqtt_dotdot_barrier_control_close_period_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_BARRIER_POSITION) {
            uic_mqtt_dotdot_barrier_control_barrier_position_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks barrier_control
static sl_status_t barrier_control_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_barrier_control_state_t attributes,
  uic_mqtt_dotdot_barrier_control_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_EVENTS == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_EVENTS == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_OPEN_EVENTS == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_CLOSE_EVENTS == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_PERIOD == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_PERIOD == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "barrier_control: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.open_events) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_EVENTS);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.open_events);
                  }
      }
      if (updated_attributes.close_events) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_EVENTS);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.close_events);
                  }
      }
      if (updated_attributes.command_open_events) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_OPEN_EVENTS);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.command_open_events);
                  }
      }
      if (updated_attributes.command_close_events) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_CLOSE_EVENTS);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.command_close_events);
                  }
      }
      if (updated_attributes.open_period) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_PERIOD);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.open_period);
                  }
      }
      if (updated_attributes.close_period) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_PERIOD);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.close_period);
                  }
      }

  return SL_STATUS_OK;
}

static void barrier_control_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/BarrierControl/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_barrier_control_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster pump_configuration_and_control
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_PRESSURE) {
            uic_mqtt_dotdot_pump_configuration_and_control_max_pressure_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_SPEED) {
            uic_mqtt_dotdot_pump_configuration_and_control_max_speed_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_FLOW) {
            uic_mqtt_dotdot_pump_configuration_and_control_max_flow_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_PRESSURE) {
            uic_mqtt_dotdot_pump_configuration_and_control_min_const_pressure_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_PRESSURE) {
            uic_mqtt_dotdot_pump_configuration_and_control_max_const_pressure_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_COMP_PRESSURE) {
            uic_mqtt_dotdot_pump_configuration_and_control_min_comp_pressure_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_COMP_PRESSURE) {
            uic_mqtt_dotdot_pump_configuration_and_control_max_comp_pressure_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_SPEED) {
            uic_mqtt_dotdot_pump_configuration_and_control_min_const_speed_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_SPEED) {
            uic_mqtt_dotdot_pump_configuration_and_control_max_const_speed_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_FLOW) {
            uic_mqtt_dotdot_pump_configuration_and_control_min_const_flow_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_FLOW) {
            uic_mqtt_dotdot_pump_configuration_and_control_max_const_flow_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_TEMP) {
            uic_mqtt_dotdot_pump_configuration_and_control_min_const_temp_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_TEMP) {
            uic_mqtt_dotdot_pump_configuration_and_control_max_const_temp_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_PUMP_STATUS) {
            uic_mqtt_dotdot_pump_configuration_and_control_pump_status_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_OPERATION_MODE) {
            uic_mqtt_dotdot_pump_configuration_and_control_effective_operation_mode_publish(
              base_topic.str().c_str(),
              static_cast<PumpOperationMode>(attr.desired_or_reported<PumpOperationMode>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_CONTROL_MODE) {
            uic_mqtt_dotdot_pump_configuration_and_control_effective_control_mode_publish(
              base_topic.str().c_str(),
              static_cast<PumpControlMode>(attr.desired_or_reported<PumpControlMode>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CAPACITY) {
            uic_mqtt_dotdot_pump_configuration_and_control_capacity_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_SPEED) {
            uic_mqtt_dotdot_pump_configuration_and_control_speed_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_RUNNING_HOURS) {
            uic_mqtt_dotdot_pump_configuration_and_control_lifetime_running_hours_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_POWER) {
            uic_mqtt_dotdot_pump_configuration_and_control_power_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_ENERGY_CONSUMED) {
            uic_mqtt_dotdot_pump_configuration_and_control_lifetime_energy_consumed_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_OPERATION_MODE) {
            uic_mqtt_dotdot_pump_configuration_and_control_operation_mode_publish(
              base_topic.str().c_str(),
              static_cast<PumpOperationMode>(attr.desired_or_reported<PumpOperationMode>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CONTROL_MODE) {
            uic_mqtt_dotdot_pump_configuration_and_control_control_mode_publish(
              base_topic.str().c_str(),
              static_cast<PumpControlMode>(attr.desired_or_reported<PumpControlMode>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_ALARM_MASK) {
            uic_mqtt_dotdot_pump_configuration_and_control_alarm_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_PRESSURE) {
            uic_mqtt_dotdot_pump_configuration_and_control_max_pressure_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_SPEED) {
            uic_mqtt_dotdot_pump_configuration_and_control_max_speed_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_FLOW) {
            uic_mqtt_dotdot_pump_configuration_and_control_max_flow_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_PRESSURE) {
            uic_mqtt_dotdot_pump_configuration_and_control_min_const_pressure_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_PRESSURE) {
            uic_mqtt_dotdot_pump_configuration_and_control_max_const_pressure_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_COMP_PRESSURE) {
            uic_mqtt_dotdot_pump_configuration_and_control_min_comp_pressure_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_COMP_PRESSURE) {
            uic_mqtt_dotdot_pump_configuration_and_control_max_comp_pressure_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_SPEED) {
            uic_mqtt_dotdot_pump_configuration_and_control_min_const_speed_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_SPEED) {
            uic_mqtt_dotdot_pump_configuration_and_control_max_const_speed_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_FLOW) {
            uic_mqtt_dotdot_pump_configuration_and_control_min_const_flow_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_FLOW) {
            uic_mqtt_dotdot_pump_configuration_and_control_max_const_flow_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_TEMP) {
            uic_mqtt_dotdot_pump_configuration_and_control_min_const_temp_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_TEMP) {
            uic_mqtt_dotdot_pump_configuration_and_control_max_const_temp_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_PUMP_STATUS) {
            uic_mqtt_dotdot_pump_configuration_and_control_pump_status_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_OPERATION_MODE) {
            uic_mqtt_dotdot_pump_configuration_and_control_effective_operation_mode_publish(
              base_topic.str().c_str(),
              static_cast<PumpOperationMode>(attr.reported<PumpOperationMode>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_CONTROL_MODE) {
            uic_mqtt_dotdot_pump_configuration_and_control_effective_control_mode_publish(
              base_topic.str().c_str(),
              static_cast<PumpControlMode>(attr.reported<PumpControlMode>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CAPACITY) {
            uic_mqtt_dotdot_pump_configuration_and_control_capacity_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_SPEED) {
            uic_mqtt_dotdot_pump_configuration_and_control_speed_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_RUNNING_HOURS) {
            uic_mqtt_dotdot_pump_configuration_and_control_lifetime_running_hours_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_POWER) {
            uic_mqtt_dotdot_pump_configuration_and_control_power_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_ENERGY_CONSUMED) {
            uic_mqtt_dotdot_pump_configuration_and_control_lifetime_energy_consumed_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_OPERATION_MODE) {
            uic_mqtt_dotdot_pump_configuration_and_control_operation_mode_publish(
              base_topic.str().c_str(),
              static_cast<PumpOperationMode>(attr.reported<PumpOperationMode>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CONTROL_MODE) {
            uic_mqtt_dotdot_pump_configuration_and_control_control_mode_publish(
              base_topic.str().c_str(),
              static_cast<PumpControlMode>(attr.reported<PumpControlMode>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_ALARM_MASK) {
            uic_mqtt_dotdot_pump_configuration_and_control_alarm_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks pump_configuration_and_control
static sl_status_t pump_configuration_and_control_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_pump_configuration_and_control_state_t attributes,
  uic_mqtt_dotdot_pump_configuration_and_control_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_RUNNING_HOURS == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_POWER == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_OPERATION_MODE == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CONTROL_MODE == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "pump_configuration_and_control: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.lifetime_running_hours) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_RUNNING_HOURS);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.lifetime_running_hours);
                  }
      }
      if (updated_attributes.power) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_POWER);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.power);
                  }
      }
      if (updated_attributes.operation_mode) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_OPERATION_MODE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.operation_mode);
                  }
      }
      if (updated_attributes.control_mode) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CONTROL_MODE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.control_mode);
                  }
      }

  return SL_STATUS_OK;
}

static void pump_configuration_and_control_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/PumpConfigurationAndControl/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_pump_configuration_and_control_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster thermostat
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void thermostat_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"thermostat_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE) {
            uic_mqtt_dotdot_thermostat_local_temperature_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OUTDOOR_TEMPERATURE) {
            uic_mqtt_dotdot_thermostat_outdoor_temperature_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPANCY) {
            uic_mqtt_dotdot_thermostat_occupancy_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_HEAT_SETPOINT_LIMIT) {
            uic_mqtt_dotdot_thermostat_abs_min_heat_setpoint_limit_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_HEAT_SETPOINT_LIMIT) {
            uic_mqtt_dotdot_thermostat_abs_max_heat_setpoint_limit_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_COOL_SETPOINT_LIMIT) {
            uic_mqtt_dotdot_thermostat_abs_min_cool_setpoint_limit_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_COOL_SETPOINT_LIMIT) {
            uic_mqtt_dotdot_thermostat_abs_max_cool_setpoint_limit_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_COOLING_DEMAND) {
            uic_mqtt_dotdot_thermostat_pi_cooling_demand_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_HEATING_DEMAND) {
            uic_mqtt_dotdot_thermostat_pi_heating_demand_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_HVAC_SYSTEM_TYPE_CONFIGURATION) {
            uic_mqtt_dotdot_thermostat_hvac_system_type_configuration_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE_CALIBRATION) {
            uic_mqtt_dotdot_thermostat_local_temperature_calibration_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_COOLING_SETPOINT) {
            uic_mqtt_dotdot_thermostat_occupied_cooling_setpoint_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_HEATING_SETPOINT) {
            uic_mqtt_dotdot_thermostat_occupied_heating_setpoint_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_COOLING_SETPOINT) {
            uic_mqtt_dotdot_thermostat_unoccupied_cooling_setpoint_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_HEATING_SETPOINT) {
            uic_mqtt_dotdot_thermostat_unoccupied_heating_setpoint_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_HEAT_SETPOINT_LIMIT) {
            uic_mqtt_dotdot_thermostat_min_heat_setpoint_limit_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_HEAT_SETPOINT_LIMIT) {
            uic_mqtt_dotdot_thermostat_max_heat_setpoint_limit_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_COOL_SETPOINT_LIMIT) {
            uic_mqtt_dotdot_thermostat_min_cool_setpoint_limit_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_COOL_SETPOINT_LIMIT) {
            uic_mqtt_dotdot_thermostat_max_cool_setpoint_limit_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_SETPOINT_DEAD_BAND) {
            uic_mqtt_dotdot_thermostat_min_setpoint_dead_band_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_REMOTE_SENSING) {
            uic_mqtt_dotdot_thermostat_remote_sensing_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_CONTROL_SEQUENCE_OF_OPERATION) {
            uic_mqtt_dotdot_thermostat_control_sequence_of_operation_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SYSTEM_MODE) {
            uic_mqtt_dotdot_thermostat_system_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ALARM_MASK) {
            uic_mqtt_dotdot_thermostat_alarm_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_MODE) {
            uic_mqtt_dotdot_thermostat_thermostat_running_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_START_OF_WEEK) {
            uic_mqtt_dotdot_thermostat_start_of_week_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_WEEKLY_TRANSITIONS) {
            uic_mqtt_dotdot_thermostat_number_of_weekly_transitions_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_DAILY_TRANSITIONS) {
            uic_mqtt_dotdot_thermostat_number_of_daily_transitions_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD) {
            uic_mqtt_dotdot_thermostat_temperature_setpoint_hold_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD_DURATION) {
            uic_mqtt_dotdot_thermostat_temperature_setpoint_hold_duration_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_PROGRAMMING_OPERATION_MODE) {
            uic_mqtt_dotdot_thermostat_thermostat_programming_operation_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_STATE) {
            uic_mqtt_dotdot_thermostat_thermostat_running_state_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE) {
            uic_mqtt_dotdot_thermostat_setpoint_change_source_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_AMOUNT) {
            uic_mqtt_dotdot_thermostat_setpoint_change_amount_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE_TIMESTAMP) {
            uic_mqtt_dotdot_thermostat_setpoint_change_source_timestamp_publish(
              base_topic.str().c_str(),
              static_cast<UTC>(attr.desired_or_reported<UTC>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK) {
            uic_mqtt_dotdot_thermostat_occupied_setback_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MIN) {
            uic_mqtt_dotdot_thermostat_occupied_setback_min_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MAX) {
            uic_mqtt_dotdot_thermostat_occupied_setback_max_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK) {
            uic_mqtt_dotdot_thermostat_unoccupied_setback_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MIN) {
            uic_mqtt_dotdot_thermostat_unoccupied_setback_min_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MAX) {
            uic_mqtt_dotdot_thermostat_unoccupied_setback_max_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_EMERGENCY_HEAT_DELTA) {
            uic_mqtt_dotdot_thermostat_emergency_heat_delta_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_TYPE) {
            uic_mqtt_dotdot_thermostat_ac_type_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY) {
            uic_mqtt_dotdot_thermostat_ac_capacity_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_REFRIGERANT_TYPE) {
            uic_mqtt_dotdot_thermostat_ac_refrigerant_type_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COMPRESSOR_TYPE) {
            uic_mqtt_dotdot_thermostat_ac_compressor_type_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_ERROR_CODE) {
            uic_mqtt_dotdot_thermostat_ac_error_code_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_LOUVER_POSITION) {
            uic_mqtt_dotdot_thermostat_ac_louver_position_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COIL_TEMPERATURE) {
            uic_mqtt_dotdot_thermostat_ac_coil_temperature_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY_FORMAT) {
            uic_mqtt_dotdot_thermostat_ac_capacity_format_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void thermostat_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"thermostat_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE) {
            uic_mqtt_dotdot_thermostat_local_temperature_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OUTDOOR_TEMPERATURE) {
            uic_mqtt_dotdot_thermostat_outdoor_temperature_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPANCY) {
            uic_mqtt_dotdot_thermostat_occupancy_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_HEAT_SETPOINT_LIMIT) {
            uic_mqtt_dotdot_thermostat_abs_min_heat_setpoint_limit_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_HEAT_SETPOINT_LIMIT) {
            uic_mqtt_dotdot_thermostat_abs_max_heat_setpoint_limit_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_COOL_SETPOINT_LIMIT) {
            uic_mqtt_dotdot_thermostat_abs_min_cool_setpoint_limit_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_COOL_SETPOINT_LIMIT) {
            uic_mqtt_dotdot_thermostat_abs_max_cool_setpoint_limit_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_COOLING_DEMAND) {
            uic_mqtt_dotdot_thermostat_pi_cooling_demand_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_HEATING_DEMAND) {
            uic_mqtt_dotdot_thermostat_pi_heating_demand_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_HVAC_SYSTEM_TYPE_CONFIGURATION) {
            uic_mqtt_dotdot_thermostat_hvac_system_type_configuration_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE_CALIBRATION) {
            uic_mqtt_dotdot_thermostat_local_temperature_calibration_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.reported<int8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_COOLING_SETPOINT) {
            uic_mqtt_dotdot_thermostat_occupied_cooling_setpoint_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_HEATING_SETPOINT) {
            uic_mqtt_dotdot_thermostat_occupied_heating_setpoint_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_COOLING_SETPOINT) {
            uic_mqtt_dotdot_thermostat_unoccupied_cooling_setpoint_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_HEATING_SETPOINT) {
            uic_mqtt_dotdot_thermostat_unoccupied_heating_setpoint_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_HEAT_SETPOINT_LIMIT) {
            uic_mqtt_dotdot_thermostat_min_heat_setpoint_limit_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_HEAT_SETPOINT_LIMIT) {
            uic_mqtt_dotdot_thermostat_max_heat_setpoint_limit_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_COOL_SETPOINT_LIMIT) {
            uic_mqtt_dotdot_thermostat_min_cool_setpoint_limit_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_COOL_SETPOINT_LIMIT) {
            uic_mqtt_dotdot_thermostat_max_cool_setpoint_limit_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_SETPOINT_DEAD_BAND) {
            uic_mqtt_dotdot_thermostat_min_setpoint_dead_band_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.reported<int8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_REMOTE_SENSING) {
            uic_mqtt_dotdot_thermostat_remote_sensing_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_CONTROL_SEQUENCE_OF_OPERATION) {
            uic_mqtt_dotdot_thermostat_control_sequence_of_operation_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SYSTEM_MODE) {
            uic_mqtt_dotdot_thermostat_system_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ALARM_MASK) {
            uic_mqtt_dotdot_thermostat_alarm_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_MODE) {
            uic_mqtt_dotdot_thermostat_thermostat_running_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_START_OF_WEEK) {
            uic_mqtt_dotdot_thermostat_start_of_week_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_WEEKLY_TRANSITIONS) {
            uic_mqtt_dotdot_thermostat_number_of_weekly_transitions_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_DAILY_TRANSITIONS) {
            uic_mqtt_dotdot_thermostat_number_of_daily_transitions_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD) {
            uic_mqtt_dotdot_thermostat_temperature_setpoint_hold_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD_DURATION) {
            uic_mqtt_dotdot_thermostat_temperature_setpoint_hold_duration_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_PROGRAMMING_OPERATION_MODE) {
            uic_mqtt_dotdot_thermostat_thermostat_programming_operation_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_STATE) {
            uic_mqtt_dotdot_thermostat_thermostat_running_state_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE) {
            uic_mqtt_dotdot_thermostat_setpoint_change_source_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_AMOUNT) {
            uic_mqtt_dotdot_thermostat_setpoint_change_amount_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE_TIMESTAMP) {
            uic_mqtt_dotdot_thermostat_setpoint_change_source_timestamp_publish(
              base_topic.str().c_str(),
              static_cast<UTC>(attr.reported<UTC>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK) {
            uic_mqtt_dotdot_thermostat_occupied_setback_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MIN) {
            uic_mqtt_dotdot_thermostat_occupied_setback_min_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MAX) {
            uic_mqtt_dotdot_thermostat_occupied_setback_max_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK) {
            uic_mqtt_dotdot_thermostat_unoccupied_setback_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MIN) {
            uic_mqtt_dotdot_thermostat_unoccupied_setback_min_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MAX) {
            uic_mqtt_dotdot_thermostat_unoccupied_setback_max_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_EMERGENCY_HEAT_DELTA) {
            uic_mqtt_dotdot_thermostat_emergency_heat_delta_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_TYPE) {
            uic_mqtt_dotdot_thermostat_ac_type_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY) {
            uic_mqtt_dotdot_thermostat_ac_capacity_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_REFRIGERANT_TYPE) {
            uic_mqtt_dotdot_thermostat_ac_refrigerant_type_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COMPRESSOR_TYPE) {
            uic_mqtt_dotdot_thermostat_ac_compressor_type_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_ERROR_CODE) {
            uic_mqtt_dotdot_thermostat_ac_error_code_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_LOUVER_POSITION) {
            uic_mqtt_dotdot_thermostat_ac_louver_position_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COIL_TEMPERATURE) {
            uic_mqtt_dotdot_thermostat_ac_coil_temperature_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY_FORMAT) {
            uic_mqtt_dotdot_thermostat_ac_capacity_format_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks thermostat
static sl_status_t thermostat_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_thermostat_state_t attributes,
  uic_mqtt_dotdot_thermostat_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_COOLING_SETPOINT == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_HEATING_SETPOINT == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_HEAT_SETPOINT_LIMIT == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SYSTEM_MODE == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "thermostat: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.occupied_cooling_setpoint) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_COOLING_SETPOINT);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.occupied_cooling_setpoint);
                  }
      }
      if (updated_attributes.occupied_heating_setpoint) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_HEATING_SETPOINT);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.occupied_heating_setpoint);
                  }
      }
      if (updated_attributes.min_heat_setpoint_limit) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_HEAT_SETPOINT_LIMIT);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.min_heat_setpoint_limit);
                  }
      }
      if (updated_attributes.system_mode) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SYSTEM_MODE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.system_mode);
                  }
      }

  return SL_STATUS_OK;
}

static void thermostat_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/Thermostat/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_thermostat_publish_cluster_revision(base_topic.str().c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster fan_control
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void fan_control_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"fan_control_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE) {
            uic_mqtt_dotdot_fan_control_fan_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE_SEQUENCE) {
            uic_mqtt_dotdot_fan_control_fan_mode_sequence_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void fan_control_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"fan_control_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE) {
            uic_mqtt_dotdot_fan_control_fan_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE_SEQUENCE) {
            uic_mqtt_dotdot_fan_control_fan_mode_sequence_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks fan_control
static sl_status_t fan_control_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_fan_control_state_t attributes,
  uic_mqtt_dotdot_fan_control_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE_SEQUENCE == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "fan_control: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.fan_mode) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.fan_mode);
                  }
      }
      if (updated_attributes.fan_mode_sequence) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE_SEQUENCE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.fan_mode_sequence);
                  }
      }

  return SL_STATUS_OK;
}

static void fan_control_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/FanControl/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_fan_control_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster dehumidification_control
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void dehumidification_control_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"dehumidification_control_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY) {
            uic_mqtt_dotdot_dehumidification_control_relative_humidity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_COOLING) {
            uic_mqtt_dotdot_dehumidification_control_dehumidification_cooling_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RH_DEHUMIDIFICATION_SETPOINT) {
            uic_mqtt_dotdot_dehumidification_control_rh_dehumidification_setpoint_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_MODE) {
            uic_mqtt_dotdot_dehumidification_control_relative_humidity_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_LOCKOUT) {
            uic_mqtt_dotdot_dehumidification_control_dehumidification_lockout_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_HYSTERESIS) {
            uic_mqtt_dotdot_dehumidification_control_dehumidification_hysteresis_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_MAX_COOL) {
            uic_mqtt_dotdot_dehumidification_control_dehumidification_max_cool_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_DISPLAY) {
            uic_mqtt_dotdot_dehumidification_control_relative_humidity_display_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void dehumidification_control_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"dehumidification_control_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY) {
            uic_mqtt_dotdot_dehumidification_control_relative_humidity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_COOLING) {
            uic_mqtt_dotdot_dehumidification_control_dehumidification_cooling_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RH_DEHUMIDIFICATION_SETPOINT) {
            uic_mqtt_dotdot_dehumidification_control_rh_dehumidification_setpoint_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_MODE) {
            uic_mqtt_dotdot_dehumidification_control_relative_humidity_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_LOCKOUT) {
            uic_mqtt_dotdot_dehumidification_control_dehumidification_lockout_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_HYSTERESIS) {
            uic_mqtt_dotdot_dehumidification_control_dehumidification_hysteresis_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_MAX_COOL) {
            uic_mqtt_dotdot_dehumidification_control_dehumidification_max_cool_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_DISPLAY) {
            uic_mqtt_dotdot_dehumidification_control_relative_humidity_display_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks dehumidification_control
static sl_status_t dehumidification_control_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_dehumidification_control_state_t attributes,
  uic_mqtt_dotdot_dehumidification_control_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RH_DEHUMIDIFICATION_SETPOINT == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_MODE == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_LOCKOUT == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_HYSTERESIS == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_MAX_COOL == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_DISPLAY == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "dehumidification_control: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.rh_dehumidification_setpoint) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RH_DEHUMIDIFICATION_SETPOINT);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.rh_dehumidification_setpoint);
                  }
      }
      if (updated_attributes.relative_humidity_mode) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_MODE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.relative_humidity_mode);
                  }
      }
      if (updated_attributes.dehumidification_lockout) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_LOCKOUT);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.dehumidification_lockout);
                  }
      }
      if (updated_attributes.dehumidification_hysteresis) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_HYSTERESIS);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.dehumidification_hysteresis);
                  }
      }
      if (updated_attributes.dehumidification_max_cool) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_MAX_COOL);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.dehumidification_max_cool);
                  }
      }
      if (updated_attributes.relative_humidity_display) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_DISPLAY);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.relative_humidity_display);
                  }
      }

  return SL_STATUS_OK;
}

static void dehumidification_control_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/DehumidificationControl/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_dehumidification_control_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster thermostat_user_interface_configuration
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void thermostat_user_interface_configuration_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"thermostat_user_interface_configuration_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_TEMPERATURE_DISPLAY_MODE) {
            uic_mqtt_dotdot_thermostat_user_interface_configuration_temperature_display_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_KEYPAD_LOCKOUT) {
            uic_mqtt_dotdot_thermostat_user_interface_configuration_keypad_lockout_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_SCHEDULE_PROGRAMMING_VISIBILITY) {
            uic_mqtt_dotdot_thermostat_user_interface_configuration_schedule_programming_visibility_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void thermostat_user_interface_configuration_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"thermostat_user_interface_configuration_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_TEMPERATURE_DISPLAY_MODE) {
            uic_mqtt_dotdot_thermostat_user_interface_configuration_temperature_display_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_KEYPAD_LOCKOUT) {
            uic_mqtt_dotdot_thermostat_user_interface_configuration_keypad_lockout_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_SCHEDULE_PROGRAMMING_VISIBILITY) {
            uic_mqtt_dotdot_thermostat_user_interface_configuration_schedule_programming_visibility_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks thermostat_user_interface_configuration
static sl_status_t thermostat_user_interface_configuration_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_thermostat_user_interface_configuration_state_t attributes,
  uic_mqtt_dotdot_thermostat_user_interface_configuration_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_TEMPERATURE_DISPLAY_MODE == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_KEYPAD_LOCKOUT == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_SCHEDULE_PROGRAMMING_VISIBILITY == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "thermostat_user_interface_configuration: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.temperature_display_mode) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_TEMPERATURE_DISPLAY_MODE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.temperature_display_mode);
                  }
      }
      if (updated_attributes.keypad_lockout) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_KEYPAD_LOCKOUT);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.keypad_lockout);
                  }
      }
      if (updated_attributes.schedule_programming_visibility) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_SCHEDULE_PROGRAMMING_VISIBILITY);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.schedule_programming_visibility);
                  }
      }

  return SL_STATUS_OK;
}

static void thermostat_user_interface_configuration_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/ThermostatUserInterfaceConfiguration/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_thermostat_user_interface_configuration_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster color_control
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void color_control_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"color_control_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_HUE) {
            uic_mqtt_dotdot_color_control_current_hue_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_SATURATION) {
            uic_mqtt_dotdot_color_control_current_saturation_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_REMAINING_TIME) {
            uic_mqtt_dotdot_color_control_remaining_time_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTX) {
            uic_mqtt_dotdot_color_control_currentx_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTY) {
            uic_mqtt_dotdot_color_control_currenty_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_DRIFT_COMPENSATION) {
            uic_mqtt_dotdot_color_control_drift_compensation_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COMPENSATION_TEXT) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_color_control_compensation_text_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMPERATURE_MIREDS) {
            uic_mqtt_dotdot_color_control_color_temperature_mireds_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_MODE) {
            uic_mqtt_dotdot_color_control_color_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_OPTIONS) {
            uic_mqtt_dotdot_color_control_options_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_NUMBER_OF_PRIMARIES) {
            uic_mqtt_dotdot_color_control_number_of_primaries_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1X) {
            uic_mqtt_dotdot_color_control_primary1x_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1Y) {
            uic_mqtt_dotdot_color_control_primary1y_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1_INTENSITY) {
            uic_mqtt_dotdot_color_control_primary1_intensity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2X) {
            uic_mqtt_dotdot_color_control_primary2x_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2Y) {
            uic_mqtt_dotdot_color_control_primary2y_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2_INTENSITY) {
            uic_mqtt_dotdot_color_control_primary2_intensity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3X) {
            uic_mqtt_dotdot_color_control_primary3x_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3Y) {
            uic_mqtt_dotdot_color_control_primary3y_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3_INTENSITY) {
            uic_mqtt_dotdot_color_control_primary3_intensity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4X) {
            uic_mqtt_dotdot_color_control_primary4x_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4Y) {
            uic_mqtt_dotdot_color_control_primary4y_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4_INTENSITY) {
            uic_mqtt_dotdot_color_control_primary4_intensity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5X) {
            uic_mqtt_dotdot_color_control_primary5x_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5Y) {
            uic_mqtt_dotdot_color_control_primary5y_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5_INTENSITY) {
            uic_mqtt_dotdot_color_control_primary5_intensity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6X) {
            uic_mqtt_dotdot_color_control_primary6x_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6Y) {
            uic_mqtt_dotdot_color_control_primary6y_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6_INTENSITY) {
            uic_mqtt_dotdot_color_control_primary6_intensity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTX) {
            uic_mqtt_dotdot_color_control_white_pointx_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTY) {
            uic_mqtt_dotdot_color_control_white_pointy_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRX) {
            uic_mqtt_dotdot_color_control_color_pointrx_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRY) {
            uic_mqtt_dotdot_color_control_color_pointry_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTR_INTENSITY) {
            uic_mqtt_dotdot_color_control_color_pointr_intensity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGX) {
            uic_mqtt_dotdot_color_control_color_pointgx_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGY) {
            uic_mqtt_dotdot_color_control_color_pointgy_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTG_INTENSITY) {
            uic_mqtt_dotdot_color_control_color_pointg_intensity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBX) {
            uic_mqtt_dotdot_color_control_color_pointbx_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBY) {
            uic_mqtt_dotdot_color_control_color_pointby_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTB_INTENSITY) {
            uic_mqtt_dotdot_color_control_color_pointb_intensity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_CURRENT_HUE) {
            uic_mqtt_dotdot_color_control_enhanced_current_hue_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_COLOR_MODE) {
            uic_mqtt_dotdot_color_control_enhanced_color_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_ACTIVE) {
            uic_mqtt_dotdot_color_control_color_loop_active_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_DIRECTION) {
            uic_mqtt_dotdot_color_control_color_loop_direction_publish(
              base_topic.str().c_str(),
              static_cast<CCColorLoopDirection>(attr.desired_or_reported<CCColorLoopDirection>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_TIME) {
            uic_mqtt_dotdot_color_control_color_loop_time_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_START_ENHANCED_HUE) {
            uic_mqtt_dotdot_color_control_color_loop_start_enhanced_hue_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_STORED_ENHANCED_HUE) {
            uic_mqtt_dotdot_color_control_color_loop_stored_enhanced_hue_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_CAPABILITIES) {
            uic_mqtt_dotdot_color_control_color_capabilities_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MIN_MIREDS) {
            uic_mqtt_dotdot_color_control_color_temp_physical_min_mireds_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MAX_MIREDS) {
            uic_mqtt_dotdot_color_control_color_temp_physical_max_mireds_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COUPLE_COLOR_TEMP_TO_LEVEL_MIN_MIREDS) {
            uic_mqtt_dotdot_color_control_couple_color_temp_to_level_min_mireds_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_START_UP_COLOR_TEMPERATURE_MIREDS) {
            uic_mqtt_dotdot_color_control_start_up_color_temperature_mireds_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void color_control_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"color_control_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_HUE) {
            uic_mqtt_dotdot_color_control_current_hue_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_SATURATION) {
            uic_mqtt_dotdot_color_control_current_saturation_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_REMAINING_TIME) {
            uic_mqtt_dotdot_color_control_remaining_time_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTX) {
            uic_mqtt_dotdot_color_control_currentx_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTY) {
            uic_mqtt_dotdot_color_control_currenty_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_DRIFT_COMPENSATION) {
            uic_mqtt_dotdot_color_control_drift_compensation_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COMPENSATION_TEXT) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_color_control_compensation_text_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMPERATURE_MIREDS) {
            uic_mqtt_dotdot_color_control_color_temperature_mireds_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_MODE) {
            uic_mqtt_dotdot_color_control_color_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_OPTIONS) {
            uic_mqtt_dotdot_color_control_options_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_NUMBER_OF_PRIMARIES) {
            uic_mqtt_dotdot_color_control_number_of_primaries_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1X) {
            uic_mqtt_dotdot_color_control_primary1x_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1Y) {
            uic_mqtt_dotdot_color_control_primary1y_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1_INTENSITY) {
            uic_mqtt_dotdot_color_control_primary1_intensity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2X) {
            uic_mqtt_dotdot_color_control_primary2x_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2Y) {
            uic_mqtt_dotdot_color_control_primary2y_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2_INTENSITY) {
            uic_mqtt_dotdot_color_control_primary2_intensity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3X) {
            uic_mqtt_dotdot_color_control_primary3x_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3Y) {
            uic_mqtt_dotdot_color_control_primary3y_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3_INTENSITY) {
            uic_mqtt_dotdot_color_control_primary3_intensity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4X) {
            uic_mqtt_dotdot_color_control_primary4x_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4Y) {
            uic_mqtt_dotdot_color_control_primary4y_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4_INTENSITY) {
            uic_mqtt_dotdot_color_control_primary4_intensity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5X) {
            uic_mqtt_dotdot_color_control_primary5x_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5Y) {
            uic_mqtt_dotdot_color_control_primary5y_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5_INTENSITY) {
            uic_mqtt_dotdot_color_control_primary5_intensity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6X) {
            uic_mqtt_dotdot_color_control_primary6x_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6Y) {
            uic_mqtt_dotdot_color_control_primary6y_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6_INTENSITY) {
            uic_mqtt_dotdot_color_control_primary6_intensity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTX) {
            uic_mqtt_dotdot_color_control_white_pointx_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTY) {
            uic_mqtt_dotdot_color_control_white_pointy_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRX) {
            uic_mqtt_dotdot_color_control_color_pointrx_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRY) {
            uic_mqtt_dotdot_color_control_color_pointry_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTR_INTENSITY) {
            uic_mqtt_dotdot_color_control_color_pointr_intensity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGX) {
            uic_mqtt_dotdot_color_control_color_pointgx_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGY) {
            uic_mqtt_dotdot_color_control_color_pointgy_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTG_INTENSITY) {
            uic_mqtt_dotdot_color_control_color_pointg_intensity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBX) {
            uic_mqtt_dotdot_color_control_color_pointbx_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBY) {
            uic_mqtt_dotdot_color_control_color_pointby_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTB_INTENSITY) {
            uic_mqtt_dotdot_color_control_color_pointb_intensity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_CURRENT_HUE) {
            uic_mqtt_dotdot_color_control_enhanced_current_hue_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_COLOR_MODE) {
            uic_mqtt_dotdot_color_control_enhanced_color_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_ACTIVE) {
            uic_mqtt_dotdot_color_control_color_loop_active_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_DIRECTION) {
            uic_mqtt_dotdot_color_control_color_loop_direction_publish(
              base_topic.str().c_str(),
              static_cast<CCColorLoopDirection>(attr.reported<CCColorLoopDirection>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_TIME) {
            uic_mqtt_dotdot_color_control_color_loop_time_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_START_ENHANCED_HUE) {
            uic_mqtt_dotdot_color_control_color_loop_start_enhanced_hue_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_STORED_ENHANCED_HUE) {
            uic_mqtt_dotdot_color_control_color_loop_stored_enhanced_hue_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_CAPABILITIES) {
            uic_mqtt_dotdot_color_control_color_capabilities_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MIN_MIREDS) {
            uic_mqtt_dotdot_color_control_color_temp_physical_min_mireds_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MAX_MIREDS) {
            uic_mqtt_dotdot_color_control_color_temp_physical_max_mireds_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COUPLE_COLOR_TEMP_TO_LEVEL_MIN_MIREDS) {
            uic_mqtt_dotdot_color_control_couple_color_temp_to_level_min_mireds_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_START_UP_COLOR_TEMPERATURE_MIREDS) {
            uic_mqtt_dotdot_color_control_start_up_color_temperature_mireds_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks color_control
static sl_status_t color_control_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_color_control_state_t attributes,
  uic_mqtt_dotdot_color_control_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_OPTIONS == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTX == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTY == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRX == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRY == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTR_INTENSITY == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGX == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGY == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTG_INTENSITY == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBX == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBY == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTB_INTENSITY == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_START_UP_COLOR_TEMPERATURE_MIREDS == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "color_control: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.options) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_OPTIONS);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.options);
                  }
      }
      if (updated_attributes.white_pointx) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTX);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.white_pointx);
                  }
      }
      if (updated_attributes.white_pointy) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTY);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.white_pointy);
                  }
      }
      if (updated_attributes.color_pointrx) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRX);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.color_pointrx);
                  }
      }
      if (updated_attributes.color_pointry) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRY);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.color_pointry);
                  }
      }
      if (updated_attributes.color_pointr_intensity) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTR_INTENSITY);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.color_pointr_intensity);
                  }
      }
      if (updated_attributes.color_pointgx) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGX);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.color_pointgx);
                  }
      }
      if (updated_attributes.color_pointgy) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGY);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.color_pointgy);
                  }
      }
      if (updated_attributes.color_pointg_intensity) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTG_INTENSITY);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.color_pointg_intensity);
                  }
      }
      if (updated_attributes.color_pointbx) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBX);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.color_pointbx);
                  }
      }
      if (updated_attributes.color_pointby) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBY);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.color_pointby);
                  }
      }
      if (updated_attributes.color_pointb_intensity) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTB_INTENSITY);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.color_pointb_intensity);
                  }
      }
      if (updated_attributes.start_up_color_temperature_mireds) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_START_UP_COLOR_TEMPERATURE_MIREDS);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.start_up_color_temperature_mireds);
                  }
      }

  return SL_STATUS_OK;
}

static void color_control_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/ColorControl/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_color_control_publish_cluster_revision(base_topic.str().c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster ballast_configuration
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void ballast_configuration_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"ballast_configuration_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MIN_LEVEL) {
            uic_mqtt_dotdot_ballast_configuration_physical_min_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MAX_LEVEL) {
            uic_mqtt_dotdot_ballast_configuration_physical_max_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_STATUS) {
            uic_mqtt_dotdot_ballast_configuration_ballast_status_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MIN_LEVEL) {
            uic_mqtt_dotdot_ballast_configuration_min_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MAX_LEVEL) {
            uic_mqtt_dotdot_ballast_configuration_max_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_LEVEL) {
            uic_mqtt_dotdot_ballast_configuration_power_on_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_FADE_TIME) {
            uic_mqtt_dotdot_ballast_configuration_power_on_fade_time_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_INTRINSIC_BALLAST_FACTOR) {
            uic_mqtt_dotdot_ballast_configuration_intrinsic_ballast_factor_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_FACTOR_ADJUSTMENT) {
            uic_mqtt_dotdot_ballast_configuration_ballast_factor_adjustment_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_QUANTITY) {
            uic_mqtt_dotdot_ballast_configuration_lamp_quantity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_TYPE) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_ballast_configuration_lamp_type_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_MANUFACTURER) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_ballast_configuration_lamp_manufacturer_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_RATED_HOURS) {
            uic_mqtt_dotdot_ballast_configuration_lamp_rated_hours_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS) {
            uic_mqtt_dotdot_ballast_configuration_lamp_burn_hours_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_ALARM_MODE) {
            uic_mqtt_dotdot_ballast_configuration_lamp_alarm_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS_TRIP_POINT) {
            uic_mqtt_dotdot_ballast_configuration_lamp_burn_hours_trip_point_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void ballast_configuration_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"ballast_configuration_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MIN_LEVEL) {
            uic_mqtt_dotdot_ballast_configuration_physical_min_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MAX_LEVEL) {
            uic_mqtt_dotdot_ballast_configuration_physical_max_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_STATUS) {
            uic_mqtt_dotdot_ballast_configuration_ballast_status_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MIN_LEVEL) {
            uic_mqtt_dotdot_ballast_configuration_min_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MAX_LEVEL) {
            uic_mqtt_dotdot_ballast_configuration_max_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_LEVEL) {
            uic_mqtt_dotdot_ballast_configuration_power_on_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_FADE_TIME) {
            uic_mqtt_dotdot_ballast_configuration_power_on_fade_time_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_INTRINSIC_BALLAST_FACTOR) {
            uic_mqtt_dotdot_ballast_configuration_intrinsic_ballast_factor_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_FACTOR_ADJUSTMENT) {
            uic_mqtt_dotdot_ballast_configuration_ballast_factor_adjustment_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_QUANTITY) {
            uic_mqtt_dotdot_ballast_configuration_lamp_quantity_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_TYPE) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_ballast_configuration_lamp_type_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_MANUFACTURER) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_ballast_configuration_lamp_manufacturer_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_RATED_HOURS) {
            uic_mqtt_dotdot_ballast_configuration_lamp_rated_hours_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS) {
            uic_mqtt_dotdot_ballast_configuration_lamp_burn_hours_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_ALARM_MODE) {
            uic_mqtt_dotdot_ballast_configuration_lamp_alarm_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS_TRIP_POINT) {
            uic_mqtt_dotdot_ballast_configuration_lamp_burn_hours_trip_point_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks ballast_configuration
static sl_status_t ballast_configuration_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_ballast_configuration_state_t attributes,
  uic_mqtt_dotdot_ballast_configuration_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MIN_LEVEL == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MAX_LEVEL == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_LEVEL == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_FADE_TIME == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_INTRINSIC_BALLAST_FACTOR == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_FACTOR_ADJUSTMENT == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_TYPE == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_MANUFACTURER == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_RATED_HOURS == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_ALARM_MODE == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS_TRIP_POINT == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "ballast_configuration: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.min_level) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MIN_LEVEL);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.min_level);
                  }
      }
      if (updated_attributes.max_level) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MAX_LEVEL);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.max_level);
                  }
      }
      if (updated_attributes.power_on_level) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_LEVEL);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.power_on_level);
                  }
      }
      if (updated_attributes.power_on_fade_time) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_FADE_TIME);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.power_on_fade_time);
                  }
      }
      if (updated_attributes.intrinsic_ballast_factor) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_INTRINSIC_BALLAST_FACTOR);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.intrinsic_ballast_factor);
                  }
      }
      if (updated_attributes.ballast_factor_adjustment) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_FACTOR_ADJUSTMENT);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.ballast_factor_adjustment);
                  }
      }
      if (updated_attributes.lamp_type) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_TYPE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_string(updated_node,attributes.lamp_type);
        }
      }
      if (updated_attributes.lamp_manufacturer) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_MANUFACTURER);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_string(updated_node,attributes.lamp_manufacturer);
        }
      }
      if (updated_attributes.lamp_rated_hours) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_RATED_HOURS);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.lamp_rated_hours);
                  }
      }
      if (updated_attributes.lamp_burn_hours) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.lamp_burn_hours);
                  }
      }
      if (updated_attributes.lamp_alarm_mode) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_ALARM_MODE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.lamp_alarm_mode);
                  }
      }
      if (updated_attributes.lamp_burn_hours_trip_point) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS_TRIP_POINT);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.lamp_burn_hours_trip_point);
                  }
      }

  return SL_STATUS_OK;
}

static void ballast_configuration_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/BallastConfiguration/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_ballast_configuration_publish_cluster_revision(base_topic.str().c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster illuminance_measurement
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void illuminance_measurement_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"illuminance_measurement_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MEASURED_VALUE) {
            uic_mqtt_dotdot_illuminance_measurement_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MIN_MEASURED_VALUE) {
            uic_mqtt_dotdot_illuminance_measurement_min_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MAX_MEASURED_VALUE) {
            uic_mqtt_dotdot_illuminance_measurement_max_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_TOLERANCE) {
            uic_mqtt_dotdot_illuminance_measurement_tolerance_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_LIGHT_SENSOR_TYPE) {
            uic_mqtt_dotdot_illuminance_measurement_light_sensor_type_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void illuminance_measurement_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"illuminance_measurement_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MEASURED_VALUE) {
            uic_mqtt_dotdot_illuminance_measurement_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MIN_MEASURED_VALUE) {
            uic_mqtt_dotdot_illuminance_measurement_min_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MAX_MEASURED_VALUE) {
            uic_mqtt_dotdot_illuminance_measurement_max_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_TOLERANCE) {
            uic_mqtt_dotdot_illuminance_measurement_tolerance_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_LIGHT_SENSOR_TYPE) {
            uic_mqtt_dotdot_illuminance_measurement_light_sensor_type_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks illuminance_measurement
static sl_status_t illuminance_measurement_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_illuminance_measurement_state_t attributes,
  uic_mqtt_dotdot_illuminance_measurement_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "illuminance_measurement: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;

  return SL_STATUS_OK;
}

static void illuminance_measurement_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/IlluminanceMeasurement/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_illuminance_measurement_publish_cluster_revision(base_topic.str().c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster illuminance_level_sensing
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void illuminance_level_sensing_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"illuminance_level_sensing_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LEVEL_STATUS) {
            uic_mqtt_dotdot_illuminance_level_sensing_level_status_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LIGHT_SENSOR_TYPE) {
            uic_mqtt_dotdot_illuminance_level_sensing_light_sensor_type_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_ILLUMINANCE_TARGET_LEVEL) {
            uic_mqtt_dotdot_illuminance_level_sensing_illuminance_target_level_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void illuminance_level_sensing_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"illuminance_level_sensing_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LEVEL_STATUS) {
            uic_mqtt_dotdot_illuminance_level_sensing_level_status_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LIGHT_SENSOR_TYPE) {
            uic_mqtt_dotdot_illuminance_level_sensing_light_sensor_type_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_ILLUMINANCE_TARGET_LEVEL) {
            uic_mqtt_dotdot_illuminance_level_sensing_illuminance_target_level_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks illuminance_level_sensing
static sl_status_t illuminance_level_sensing_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_illuminance_level_sensing_state_t attributes,
  uic_mqtt_dotdot_illuminance_level_sensing_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_ILLUMINANCE_TARGET_LEVEL == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "illuminance_level_sensing: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.illuminance_target_level) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_ILLUMINANCE_TARGET_LEVEL);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.illuminance_target_level);
                  }
      }

  return SL_STATUS_OK;
}

static void illuminance_level_sensing_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/IlluminanceLevelSensing/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_illuminance_level_sensing_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster temperature_measurement
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void temperature_measurement_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"temperature_measurement_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MEASURED_VALUE) {
            uic_mqtt_dotdot_temperature_measurement_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MIN_MEASURED_VALUE) {
            uic_mqtt_dotdot_temperature_measurement_min_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MAX_MEASURED_VALUE) {
            uic_mqtt_dotdot_temperature_measurement_max_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_TOLERANCE) {
            uic_mqtt_dotdot_temperature_measurement_tolerance_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void temperature_measurement_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"temperature_measurement_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MEASURED_VALUE) {
            uic_mqtt_dotdot_temperature_measurement_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MIN_MEASURED_VALUE) {
            uic_mqtt_dotdot_temperature_measurement_min_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MAX_MEASURED_VALUE) {
            uic_mqtt_dotdot_temperature_measurement_max_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_TOLERANCE) {
            uic_mqtt_dotdot_temperature_measurement_tolerance_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks temperature_measurement
static sl_status_t temperature_measurement_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_temperature_measurement_state_t attributes,
  uic_mqtt_dotdot_temperature_measurement_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "temperature_measurement: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;

  return SL_STATUS_OK;
}

static void temperature_measurement_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/TemperatureMeasurement/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_temperature_measurement_publish_cluster_revision(base_topic.str().c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster pressure_measurement
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void pressure_measurement_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"pressure_measurement_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MEASURED_VALUE) {
            uic_mqtt_dotdot_pressure_measurement_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_MEASURED_VALUE) {
            uic_mqtt_dotdot_pressure_measurement_min_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_MEASURED_VALUE) {
            uic_mqtt_dotdot_pressure_measurement_max_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_TOLERANCE) {
            uic_mqtt_dotdot_pressure_measurement_tolerance_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_VALUE) {
            uic_mqtt_dotdot_pressure_measurement_scaled_value_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_SCALED_VALUE) {
            uic_mqtt_dotdot_pressure_measurement_min_scaled_value_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_SCALED_VALUE) {
            uic_mqtt_dotdot_pressure_measurement_max_scaled_value_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_TOLERANCE) {
            uic_mqtt_dotdot_pressure_measurement_scaled_tolerance_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALE) {
            uic_mqtt_dotdot_pressure_measurement_scale_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void pressure_measurement_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"pressure_measurement_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MEASURED_VALUE) {
            uic_mqtt_dotdot_pressure_measurement_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_MEASURED_VALUE) {
            uic_mqtt_dotdot_pressure_measurement_min_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_MEASURED_VALUE) {
            uic_mqtt_dotdot_pressure_measurement_max_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_TOLERANCE) {
            uic_mqtt_dotdot_pressure_measurement_tolerance_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_VALUE) {
            uic_mqtt_dotdot_pressure_measurement_scaled_value_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_SCALED_VALUE) {
            uic_mqtt_dotdot_pressure_measurement_min_scaled_value_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_SCALED_VALUE) {
            uic_mqtt_dotdot_pressure_measurement_max_scaled_value_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_TOLERANCE) {
            uic_mqtt_dotdot_pressure_measurement_scaled_tolerance_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALE) {
            uic_mqtt_dotdot_pressure_measurement_scale_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.reported<int8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks pressure_measurement
static sl_status_t pressure_measurement_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_pressure_measurement_state_t attributes,
  uic_mqtt_dotdot_pressure_measurement_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "pressure_measurement: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;

  return SL_STATUS_OK;
}

static void pressure_measurement_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/PressureMeasurement/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_pressure_measurement_publish_cluster_revision(base_topic.str().c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster flow_measurement
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void flow_measurement_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"flow_measurement_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MEASURED_VALUE) {
            uic_mqtt_dotdot_flow_measurement_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MIN_MEASURED_VALUE) {
            uic_mqtt_dotdot_flow_measurement_min_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MAX_MEASURED_VALUE) {
            uic_mqtt_dotdot_flow_measurement_max_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_TOLERANCE) {
            uic_mqtt_dotdot_flow_measurement_tolerance_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void flow_measurement_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"flow_measurement_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MEASURED_VALUE) {
            uic_mqtt_dotdot_flow_measurement_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MIN_MEASURED_VALUE) {
            uic_mqtt_dotdot_flow_measurement_min_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MAX_MEASURED_VALUE) {
            uic_mqtt_dotdot_flow_measurement_max_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_TOLERANCE) {
            uic_mqtt_dotdot_flow_measurement_tolerance_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks flow_measurement
static sl_status_t flow_measurement_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_flow_measurement_state_t attributes,
  uic_mqtt_dotdot_flow_measurement_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "flow_measurement: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;

  return SL_STATUS_OK;
}

static void flow_measurement_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/FlowMeasurement/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_flow_measurement_publish_cluster_revision(base_topic.str().c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster relativity_humidity
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void relativity_humidity_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"relativity_humidity_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MEASURED_VALUE) {
            uic_mqtt_dotdot_relativity_humidity_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MIN_MEASURED_VALUE) {
            uic_mqtt_dotdot_relativity_humidity_min_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MAX_MEASURED_VALUE) {
            uic_mqtt_dotdot_relativity_humidity_max_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_TOLERANCE) {
            uic_mqtt_dotdot_relativity_humidity_tolerance_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void relativity_humidity_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"relativity_humidity_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MEASURED_VALUE) {
            uic_mqtt_dotdot_relativity_humidity_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MIN_MEASURED_VALUE) {
            uic_mqtt_dotdot_relativity_humidity_min_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MAX_MEASURED_VALUE) {
            uic_mqtt_dotdot_relativity_humidity_max_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_TOLERANCE) {
            uic_mqtt_dotdot_relativity_humidity_tolerance_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks relativity_humidity
static sl_status_t relativity_humidity_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_relativity_humidity_state_t attributes,
  uic_mqtt_dotdot_relativity_humidity_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "relativity_humidity: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;

  return SL_STATUS_OK;
}

static void relativity_humidity_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/RelativityHumidity/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_relativity_humidity_publish_cluster_revision(base_topic.str().c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster occupancy_sensing
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void occupancy_sensing_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"occupancy_sensing_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY) {
            uic_mqtt_dotdot_occupancy_sensing_occupancy_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE) {
            uic_mqtt_dotdot_occupancy_sensing_occupancy_sensor_type_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE_BITMAP) {
            uic_mqtt_dotdot_occupancy_sensing_occupancy_sensor_type_bitmap_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_OCCUPIED_TO_UNOCCUPIED_DELAY) {
            uic_mqtt_dotdot_occupancy_sensing_pir_occupied_to_unoccupied_delay_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_DELAY) {
            uic_mqtt_dotdot_occupancy_sensing_pir_unoccupied_to_occupied_delay_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_THRESHOLD) {
            uic_mqtt_dotdot_occupancy_sensing_pir_unoccupied_to_occupied_threshold_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_OCCUPIED_TO_UNOCCUPIED_DELAY) {
            uic_mqtt_dotdot_occupancy_sensing_ultrasonic_occupied_to_unoccupied_delay_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_DELAY) {
            uic_mqtt_dotdot_occupancy_sensing_ultrasonic_unoccupied_to_occupied_delay_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_THRESHOLD) {
            uic_mqtt_dotdot_occupancy_sensing_ultrasonic_unoccupied_to_occupied_threshold_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_OCCUPIED_TO_UNOCCUPIED_DELAY) {
            uic_mqtt_dotdot_occupancy_sensing_physical_contact_occupied_to_unoccupied_delay_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_DELAY) {
            uic_mqtt_dotdot_occupancy_sensing_physical_contact_unoccupied_to_occupied_delay_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_THRESHOLD) {
            uic_mqtt_dotdot_occupancy_sensing_physical_contact_unoccupied_to_occupied_threshold_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void occupancy_sensing_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"occupancy_sensing_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY) {
            uic_mqtt_dotdot_occupancy_sensing_occupancy_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE) {
            uic_mqtt_dotdot_occupancy_sensing_occupancy_sensor_type_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE_BITMAP) {
            uic_mqtt_dotdot_occupancy_sensing_occupancy_sensor_type_bitmap_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_OCCUPIED_TO_UNOCCUPIED_DELAY) {
            uic_mqtt_dotdot_occupancy_sensing_pir_occupied_to_unoccupied_delay_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_DELAY) {
            uic_mqtt_dotdot_occupancy_sensing_pir_unoccupied_to_occupied_delay_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_THRESHOLD) {
            uic_mqtt_dotdot_occupancy_sensing_pir_unoccupied_to_occupied_threshold_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_OCCUPIED_TO_UNOCCUPIED_DELAY) {
            uic_mqtt_dotdot_occupancy_sensing_ultrasonic_occupied_to_unoccupied_delay_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_DELAY) {
            uic_mqtt_dotdot_occupancy_sensing_ultrasonic_unoccupied_to_occupied_delay_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_THRESHOLD) {
            uic_mqtt_dotdot_occupancy_sensing_ultrasonic_unoccupied_to_occupied_threshold_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_OCCUPIED_TO_UNOCCUPIED_DELAY) {
            uic_mqtt_dotdot_occupancy_sensing_physical_contact_occupied_to_unoccupied_delay_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_DELAY) {
            uic_mqtt_dotdot_occupancy_sensing_physical_contact_unoccupied_to_occupied_delay_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_THRESHOLD) {
            uic_mqtt_dotdot_occupancy_sensing_physical_contact_unoccupied_to_occupied_threshold_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks occupancy_sensing
static sl_status_t occupancy_sensing_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_occupancy_sensing_state_t attributes,
  uic_mqtt_dotdot_occupancy_sensing_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_OCCUPIED_TO_UNOCCUPIED_DELAY == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_DELAY == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_THRESHOLD == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_OCCUPIED_TO_UNOCCUPIED_DELAY == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_DELAY == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_THRESHOLD == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_OCCUPIED_TO_UNOCCUPIED_DELAY == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_DELAY == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_THRESHOLD == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "occupancy_sensing: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.pir_occupied_to_unoccupied_delay) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_OCCUPIED_TO_UNOCCUPIED_DELAY);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.pir_occupied_to_unoccupied_delay);
                  }
      }
      if (updated_attributes.pir_unoccupied_to_occupied_delay) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_DELAY);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.pir_unoccupied_to_occupied_delay);
                  }
      }
      if (updated_attributes.pir_unoccupied_to_occupied_threshold) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_THRESHOLD);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.pir_unoccupied_to_occupied_threshold);
                  }
      }
      if (updated_attributes.ultrasonic_occupied_to_unoccupied_delay) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_OCCUPIED_TO_UNOCCUPIED_DELAY);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.ultrasonic_occupied_to_unoccupied_delay);
                  }
      }
      if (updated_attributes.ultrasonic_unoccupied_to_occupied_delay) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_DELAY);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.ultrasonic_unoccupied_to_occupied_delay);
                  }
      }
      if (updated_attributes.ultrasonic_unoccupied_to_occupied_threshold) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_THRESHOLD);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.ultrasonic_unoccupied_to_occupied_threshold);
                  }
      }
      if (updated_attributes.physical_contact_occupied_to_unoccupied_delay) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_OCCUPIED_TO_UNOCCUPIED_DELAY);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.physical_contact_occupied_to_unoccupied_delay);
                  }
      }
      if (updated_attributes.physical_contact_unoccupied_to_occupied_delay) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_DELAY);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.physical_contact_unoccupied_to_occupied_delay);
                  }
      }
      if (updated_attributes.physical_contact_unoccupied_to_occupied_threshold) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_THRESHOLD);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.physical_contact_unoccupied_to_occupied_threshold);
                  }
      }

  return SL_STATUS_OK;
}

static void occupancy_sensing_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/OccupancySensing/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_occupancy_sensing_publish_cluster_revision(base_topic.str().c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster ph_measurement
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void ph_measurement_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"ph_measurement_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MEASURED_VALUE) {
            uic_mqtt_dotdot_ph_measurement_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MIN_MEASURED_VALUE) {
            uic_mqtt_dotdot_ph_measurement_min_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MAX_MEASURED_VALUE) {
            uic_mqtt_dotdot_ph_measurement_max_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_TOLERANCE) {
            uic_mqtt_dotdot_ph_measurement_tolerance_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void ph_measurement_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"ph_measurement_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MEASURED_VALUE) {
            uic_mqtt_dotdot_ph_measurement_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MIN_MEASURED_VALUE) {
            uic_mqtt_dotdot_ph_measurement_min_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MAX_MEASURED_VALUE) {
            uic_mqtt_dotdot_ph_measurement_max_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_TOLERANCE) {
            uic_mqtt_dotdot_ph_measurement_tolerance_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks ph_measurement
static sl_status_t ph_measurement_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_ph_measurement_state_t attributes,
  uic_mqtt_dotdot_ph_measurement_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "ph_measurement: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;

  return SL_STATUS_OK;
}

static void ph_measurement_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/PhMeasurement/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_ph_measurement_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster electrical_conductivity_measurement
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void electrical_conductivity_measurement_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"electrical_conductivity_measurement_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MEASURED_VALUE) {
            uic_mqtt_dotdot_electrical_conductivity_measurement_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MIN_MEASURED_VALUE) {
            uic_mqtt_dotdot_electrical_conductivity_measurement_min_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MAX_MEASURED_VALUE) {
            uic_mqtt_dotdot_electrical_conductivity_measurement_max_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_TOLERANCE) {
            uic_mqtt_dotdot_electrical_conductivity_measurement_tolerance_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void electrical_conductivity_measurement_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"electrical_conductivity_measurement_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MEASURED_VALUE) {
            uic_mqtt_dotdot_electrical_conductivity_measurement_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MIN_MEASURED_VALUE) {
            uic_mqtt_dotdot_electrical_conductivity_measurement_min_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MAX_MEASURED_VALUE) {
            uic_mqtt_dotdot_electrical_conductivity_measurement_max_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_TOLERANCE) {
            uic_mqtt_dotdot_electrical_conductivity_measurement_tolerance_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks electrical_conductivity_measurement
static sl_status_t electrical_conductivity_measurement_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_electrical_conductivity_measurement_state_t attributes,
  uic_mqtt_dotdot_electrical_conductivity_measurement_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "electrical_conductivity_measurement: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;

  return SL_STATUS_OK;
}

static void electrical_conductivity_measurement_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/ElectricalConductivityMeasurement/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_electrical_conductivity_measurement_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster wind_speed_measurement
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void wind_speed_measurement_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"wind_speed_measurement_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MEASURED_VALUE) {
            uic_mqtt_dotdot_wind_speed_measurement_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MIN_MEASURED_VALUE) {
            uic_mqtt_dotdot_wind_speed_measurement_min_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MAX_MEASURED_VALUE) {
            uic_mqtt_dotdot_wind_speed_measurement_max_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_TOLERANCE) {
            uic_mqtt_dotdot_wind_speed_measurement_tolerance_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void wind_speed_measurement_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"wind_speed_measurement_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MEASURED_VALUE) {
            uic_mqtt_dotdot_wind_speed_measurement_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MIN_MEASURED_VALUE) {
            uic_mqtt_dotdot_wind_speed_measurement_min_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MAX_MEASURED_VALUE) {
            uic_mqtt_dotdot_wind_speed_measurement_max_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_TOLERANCE) {
            uic_mqtt_dotdot_wind_speed_measurement_tolerance_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks wind_speed_measurement
static sl_status_t wind_speed_measurement_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_wind_speed_measurement_state_t attributes,
  uic_mqtt_dotdot_wind_speed_measurement_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "wind_speed_measurement: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;

  return SL_STATUS_OK;
}

static void wind_speed_measurement_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/WindSpeedMeasurement/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_wind_speed_measurement_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster carbon_monoxide
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void carbon_monoxide_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"carbon_monoxide_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MEASURED_VALUE) {
            uic_mqtt_dotdot_carbon_monoxide_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<float>(attr.desired_or_reported<float>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MIN_MEASURED_VALUE) {
            uic_mqtt_dotdot_carbon_monoxide_min_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<float>(attr.desired_or_reported<float>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MAX_MEASURED_VALUE) {
            uic_mqtt_dotdot_carbon_monoxide_max_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<float>(attr.desired_or_reported<float>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_TOLERANCE) {
            uic_mqtt_dotdot_carbon_monoxide_tolerance_publish(
              base_topic.str().c_str(),
              static_cast<float>(attr.desired_or_reported<float>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void carbon_monoxide_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"carbon_monoxide_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MEASURED_VALUE) {
            uic_mqtt_dotdot_carbon_monoxide_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<float>(attr.reported<float>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MIN_MEASURED_VALUE) {
            uic_mqtt_dotdot_carbon_monoxide_min_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<float>(attr.reported<float>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MAX_MEASURED_VALUE) {
            uic_mqtt_dotdot_carbon_monoxide_max_measured_value_publish(
              base_topic.str().c_str(),
              static_cast<float>(attr.reported<float>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_TOLERANCE) {
            uic_mqtt_dotdot_carbon_monoxide_tolerance_publish(
              base_topic.str().c_str(),
              static_cast<float>(attr.reported<float>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks carbon_monoxide
static sl_status_t carbon_monoxide_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_carbon_monoxide_state_t attributes,
  uic_mqtt_dotdot_carbon_monoxide_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "carbon_monoxide: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;

  return SL_STATUS_OK;
}

static void carbon_monoxide_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/CarbonMonoxide/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_carbon_monoxide_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster ias_zone
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void ias_zone_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"ias_zone_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATE) {
            uic_mqtt_dotdot_ias_zone_zone_state_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_TYPE) {
            uic_mqtt_dotdot_ias_zone_zone_type_publish(
              base_topic.str().c_str(),
              static_cast<IasZoneType>(attr.desired_or_reported<IasZoneType>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATUS) {
            uic_mqtt_dotdot_ias_zone_zone_status_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_IASCIE_ADDRESS) {
            uic_mqtt_dotdot_ias_zone_iascie_address_publish(
              base_topic.str().c_str(),
              static_cast<EUI64>(attr.desired_or_reported<EUI64>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONEID) {
            uic_mqtt_dotdot_ias_zone_zoneid_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_NUMBER_OF_ZONE_SENSITIVITY_LEVELS_SUPPORTED) {
            uic_mqtt_dotdot_ias_zone_number_of_zone_sensitivity_levels_supported_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_CURRENT_ZONE_SENSITIVITY_LEVEL) {
            uic_mqtt_dotdot_ias_zone_current_zone_sensitivity_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void ias_zone_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"ias_zone_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATE) {
            uic_mqtt_dotdot_ias_zone_zone_state_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_TYPE) {
            uic_mqtt_dotdot_ias_zone_zone_type_publish(
              base_topic.str().c_str(),
              static_cast<IasZoneType>(attr.reported<IasZoneType>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATUS) {
            uic_mqtt_dotdot_ias_zone_zone_status_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_IASCIE_ADDRESS) {
            uic_mqtt_dotdot_ias_zone_iascie_address_publish(
              base_topic.str().c_str(),
              static_cast<EUI64>(attr.reported<EUI64>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONEID) {
            uic_mqtt_dotdot_ias_zone_zoneid_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_NUMBER_OF_ZONE_SENSITIVITY_LEVELS_SUPPORTED) {
            uic_mqtt_dotdot_ias_zone_number_of_zone_sensitivity_levels_supported_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_IAS_ZONE_CURRENT_ZONE_SENSITIVITY_LEVEL) {
            uic_mqtt_dotdot_ias_zone_current_zone_sensitivity_level_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks ias_zone
static sl_status_t ias_zone_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_ias_zone_state_t attributes,
  uic_mqtt_dotdot_ias_zone_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_IAS_ZONE_IASCIE_ADDRESS == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_IAS_ZONE_CURRENT_ZONE_SENSITIVITY_LEVEL == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "ias_zone: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.iascie_address) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_IAS_ZONE_IASCIE_ADDRESS);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.iascie_address);
                  }
      }
      if (updated_attributes.current_zone_sensitivity_level) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_IAS_ZONE_CURRENT_ZONE_SENSITIVITY_LEVEL);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.current_zone_sensitivity_level);
                  }
      }

  return SL_STATUS_OK;
}

static void ias_zone_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/IASZone/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_ias_zone_publish_cluster_revision(base_topic.str().c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster iaswd
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void iaswd_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"iaswd_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_IASWD_MAX_DURATION) {
            uic_mqtt_dotdot_iaswd_max_duration_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void iaswd_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"iaswd_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_IASWD_MAX_DURATION) {
            uic_mqtt_dotdot_iaswd_max_duration_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks iaswd
static sl_status_t iaswd_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_iaswd_state_t attributes,
  uic_mqtt_dotdot_iaswd_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_IASWD_MAX_DURATION == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "iaswd: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.max_duration) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_IASWD_MAX_DURATION);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.max_duration);
                  }
      }

  return SL_STATUS_OK;
}

static void iaswd_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/IASWD/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_iaswd_publish_cluster_revision(base_topic.str().c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster metering
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void metering_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"metering_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_DELIVERED) {
            uic_mqtt_dotdot_metering_current_summation_delivered_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_RECEIVED) {
            uic_mqtt_dotdot_metering_current_summation_received_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED) {
            uic_mqtt_dotdot_metering_current_max_demand_delivered_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED) {
            uic_mqtt_dotdot_metering_current_max_demand_received_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_POWER_FACTOR) {
            uic_mqtt_dotdot_metering_power_factor_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_READING_SNAP_SHOT_TIME) {
            uic_mqtt_dotdot_metering_reading_snap_shot_time_publish(
              base_topic.str().c_str(),
              static_cast<UTC>(attr.desired_or_reported<UTC>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED_TIME) {
            uic_mqtt_dotdot_metering_current_max_demand_delivered_time_publish(
              base_topic.str().c_str(),
              static_cast<UTC>(attr.desired_or_reported<UTC>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED_TIME) {
            uic_mqtt_dotdot_metering_current_max_demand_received_time_publish(
              base_topic.str().c_str(),
              static_cast<UTC>(attr.desired_or_reported<UTC>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_DEFAULT_UPDATE_PERIOD) {
            uic_mqtt_dotdot_metering_default_update_period_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_SUPPLY_STATUS) {
            uic_mqtt_dotdot_metering_supply_status_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_INLET_ENERGY_CARRIER_SUMMATION) {
            uic_mqtt_dotdot_metering_current_inlet_energy_carrier_summation_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_OUTLET_ENERGY_CARRIER_SUMMATION) {
            uic_mqtt_dotdot_metering_current_outlet_energy_carrier_summation_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_INLET_TEMPERATURE) {
            uic_mqtt_dotdot_metering_inlet_temperature_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_OUTLET_TEMPERATURE) {
            uic_mqtt_dotdot_metering_outlet_temperature_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_UNITOF_MEASURE) {
            uic_mqtt_dotdot_metering_unitof_measure_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_MULTIPLIER) {
            uic_mqtt_dotdot_metering_multiplier_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_DIVISOR) {
            uic_mqtt_dotdot_metering_divisor_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_SUMMATION_FORMATTING) {
            uic_mqtt_dotdot_metering_summation_formatting_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_DEMAND_FORMATTING) {
            uic_mqtt_dotdot_metering_demand_formatting_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_HISTORICAL_CONSUMPTION_FORMATTING) {
            uic_mqtt_dotdot_metering_historical_consumption_formatting_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_METERING_DEVICE_TYPE) {
            uic_mqtt_dotdot_metering_metering_device_type_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_UNIT_OF_MEASURE) {
            uic_mqtt_dotdot_metering_energy_carrier_unit_of_measure_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_SUMMATION_FORMATTING) {
            uic_mqtt_dotdot_metering_energy_carrier_summation_formatting_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_DEMAND_FORMATTING) {
            uic_mqtt_dotdot_metering_energy_carrier_demand_formatting_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_UNIT_OF_MEASURE) {
            uic_mqtt_dotdot_metering_temperature_unit_of_measure_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_FORMATTING) {
            uic_mqtt_dotdot_metering_temperature_formatting_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void metering_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"metering_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_DELIVERED) {
            uic_mqtt_dotdot_metering_current_summation_delivered_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.reported<uint64_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_RECEIVED) {
            uic_mqtt_dotdot_metering_current_summation_received_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.reported<uint64_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED) {
            uic_mqtt_dotdot_metering_current_max_demand_delivered_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.reported<uint64_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED) {
            uic_mqtt_dotdot_metering_current_max_demand_received_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.reported<int8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_POWER_FACTOR) {
            uic_mqtt_dotdot_metering_power_factor_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.reported<int8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_READING_SNAP_SHOT_TIME) {
            uic_mqtt_dotdot_metering_reading_snap_shot_time_publish(
              base_topic.str().c_str(),
              static_cast<UTC>(attr.reported<UTC>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED_TIME) {
            uic_mqtt_dotdot_metering_current_max_demand_delivered_time_publish(
              base_topic.str().c_str(),
              static_cast<UTC>(attr.reported<UTC>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED_TIME) {
            uic_mqtt_dotdot_metering_current_max_demand_received_time_publish(
              base_topic.str().c_str(),
              static_cast<UTC>(attr.reported<UTC>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_DEFAULT_UPDATE_PERIOD) {
            uic_mqtt_dotdot_metering_default_update_period_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_SUPPLY_STATUS) {
            uic_mqtt_dotdot_metering_supply_status_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_INLET_ENERGY_CARRIER_SUMMATION) {
            uic_mqtt_dotdot_metering_current_inlet_energy_carrier_summation_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.reported<uint64_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_OUTLET_ENERGY_CARRIER_SUMMATION) {
            uic_mqtt_dotdot_metering_current_outlet_energy_carrier_summation_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.reported<uint64_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_INLET_TEMPERATURE) {
            uic_mqtt_dotdot_metering_inlet_temperature_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_OUTLET_TEMPERATURE) {
            uic_mqtt_dotdot_metering_outlet_temperature_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_UNITOF_MEASURE) {
            uic_mqtt_dotdot_metering_unitof_measure_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_MULTIPLIER) {
            uic_mqtt_dotdot_metering_multiplier_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_DIVISOR) {
            uic_mqtt_dotdot_metering_divisor_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_SUMMATION_FORMATTING) {
            uic_mqtt_dotdot_metering_summation_formatting_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_DEMAND_FORMATTING) {
            uic_mqtt_dotdot_metering_demand_formatting_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_HISTORICAL_CONSUMPTION_FORMATTING) {
            uic_mqtt_dotdot_metering_historical_consumption_formatting_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_METERING_DEVICE_TYPE) {
            uic_mqtt_dotdot_metering_metering_device_type_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_UNIT_OF_MEASURE) {
            uic_mqtt_dotdot_metering_energy_carrier_unit_of_measure_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_SUMMATION_FORMATTING) {
            uic_mqtt_dotdot_metering_energy_carrier_summation_formatting_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_DEMAND_FORMATTING) {
            uic_mqtt_dotdot_metering_energy_carrier_demand_formatting_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_UNIT_OF_MEASURE) {
            uic_mqtt_dotdot_metering_temperature_unit_of_measure_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_FORMATTING) {
            uic_mqtt_dotdot_metering_temperature_formatting_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks metering
static sl_status_t metering_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_metering_state_t attributes,
  uic_mqtt_dotdot_metering_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "metering: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;

  return SL_STATUS_OK;
}

static void metering_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/Metering/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_metering_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster electrical_measurement
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void electrical_measurement_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"electrical_measurement_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASUREMENT_TYPE) {
            uic_mqtt_dotdot_electrical_measurement_measurement_type_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE) {
            uic_mqtt_dotdot_electrical_measurement_dc_voltage_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MIN) {
            uic_mqtt_dotdot_electrical_measurement_dc_voltage_min_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MAX) {
            uic_mqtt_dotdot_electrical_measurement_dc_voltage_max_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_dc_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MIN) {
            uic_mqtt_dotdot_electrical_measurement_dc_current_min_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MAX) {
            uic_mqtt_dotdot_electrical_measurement_dc_current_max_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER) {
            uic_mqtt_dotdot_electrical_measurement_dc_power_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MIN) {
            uic_mqtt_dotdot_electrical_measurement_dc_power_min_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MAX) {
            uic_mqtt_dotdot_electrical_measurement_dc_power_max_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MULTIPLIER) {
            uic_mqtt_dotdot_electrical_measurement_dc_voltage_multiplier_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_DIVISOR) {
            uic_mqtt_dotdot_electrical_measurement_dc_voltage_divisor_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MULTIPLIER) {
            uic_mqtt_dotdot_electrical_measurement_dc_current_multiplier_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_DIVISOR) {
            uic_mqtt_dotdot_electrical_measurement_dc_current_divisor_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MULTIPLIER) {
            uic_mqtt_dotdot_electrical_measurement_dc_power_multiplier_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_DIVISOR) {
            uic_mqtt_dotdot_electrical_measurement_dc_power_divisor_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY) {
            uic_mqtt_dotdot_electrical_measurement_ac_frequency_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MIN) {
            uic_mqtt_dotdot_electrical_measurement_ac_frequency_min_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MAX) {
            uic_mqtt_dotdot_electrical_measurement_ac_frequency_max_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_NEUTRAL_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_neutral_current_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_ACTIVE_POWER) {
            uic_mqtt_dotdot_electrical_measurement_total_active_power_publish(
              base_topic.str().c_str(),
              static_cast<int32_t>(attr.desired_or_reported<int32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_REACTIVE_POWER) {
            uic_mqtt_dotdot_electrical_measurement_total_reactive_power_publish(
              base_topic.str().c_str(),
              static_cast<int32_t>(attr.desired_or_reported<int32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_APPARENT_POWER) {
            uic_mqtt_dotdot_electrical_measurement_total_apparent_power_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED1ST_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured1st_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED3RD_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured3rd_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED5TH_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured5th_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED7TH_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured7th_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED9TH_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured9th_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED11TH_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured11th_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE1ST_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured_phase1st_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE3RD_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured_phase3rd_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE5TH_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured_phase5th_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE7TH_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured_phase7th_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE9TH_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured_phase9th_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE11TH_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured_phase11th_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MULTIPLIER) {
            uic_mqtt_dotdot_electrical_measurement_ac_frequency_multiplier_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_DIVISOR) {
            uic_mqtt_dotdot_electrical_measurement_ac_frequency_divisor_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_MULTIPLIER) {
            uic_mqtt_dotdot_electrical_measurement_power_multiplier_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_DIVISOR) {
            uic_mqtt_dotdot_electrical_measurement_power_divisor_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_HARMONIC_CURRENT_MULTIPLIER) {
            uic_mqtt_dotdot_electrical_measurement_harmonic_current_multiplier_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_PHASE_HARMONIC_CURRENT_MULTIPLIER) {
            uic_mqtt_dotdot_electrical_measurement_phase_harmonic_current_multiplier_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_line_current_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_active_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_reactive_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_rms_current_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN) {
            uic_mqtt_dotdot_electrical_measurement_rms_current_min_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX) {
            uic_mqtt_dotdot_electrical_measurement_rms_current_max_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER) {
            uic_mqtt_dotdot_electrical_measurement_active_power_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN) {
            uic_mqtt_dotdot_electrical_measurement_active_power_min_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX) {
            uic_mqtt_dotdot_electrical_measurement_active_power_max_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER) {
            uic_mqtt_dotdot_electrical_measurement_reactive_power_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER) {
            uic_mqtt_dotdot_electrical_measurement_apparent_power_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR) {
            uic_mqtt_dotdot_electrical_measurement_power_factor_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD) {
            uic_mqtt_dotdot_electrical_measurement_averagerms_voltage_measurement_period_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER) {
            uic_mqtt_dotdot_electrical_measurement_averagerms_over_voltage_counter_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER) {
            uic_mqtt_dotdot_electrical_measurement_averagerms_under_voltage_counter_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD) {
            uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD) {
            uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_MULTIPLIER) {
            uic_mqtt_dotdot_electrical_measurement_ac_voltage_multiplier_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_DIVISOR) {
            uic_mqtt_dotdot_electrical_measurement_ac_voltage_divisor_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_MULTIPLIER) {
            uic_mqtt_dotdot_electrical_measurement_ac_current_multiplier_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_DIVISOR) {
            uic_mqtt_dotdot_electrical_measurement_ac_current_divisor_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_MULTIPLIER) {
            uic_mqtt_dotdot_electrical_measurement_ac_power_multiplier_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_DIVISOR) {
            uic_mqtt_dotdot_electrical_measurement_ac_power_divisor_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_OVERLOAD_ALARMS_MASK) {
            uic_mqtt_dotdot_electrical_measurement_dc_overload_alarms_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_OVERLOAD) {
            uic_mqtt_dotdot_electrical_measurement_dc_voltage_overload_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_OVERLOAD) {
            uic_mqtt_dotdot_electrical_measurement_dc_current_overload_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ALARMS_MASK) {
            uic_mqtt_dotdot_electrical_measurement_ac_alarms_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_OVERLOAD) {
            uic_mqtt_dotdot_electrical_measurement_ac_voltage_overload_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_OVERLOAD) {
            uic_mqtt_dotdot_electrical_measurement_ac_current_overload_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ACTIVE_POWER_OVERLOAD) {
            uic_mqtt_dotdot_electrical_measurement_ac_active_power_overload_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_REACTIVE_POWER_OVERLOAD) {
            uic_mqtt_dotdot_electrical_measurement_ac_reactive_power_overload_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE) {
            uic_mqtt_dotdot_electrical_measurement_averagerms_over_voltage_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE) {
            uic_mqtt_dotdot_electrical_measurement_averagerms_under_voltage_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE) {
            uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE) {
            uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHB) {
            uic_mqtt_dotdot_electrical_measurement_line_current_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHB) {
            uic_mqtt_dotdot_electrical_measurement_active_current_phb_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHB) {
            uic_mqtt_dotdot_electrical_measurement_reactive_current_phb_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHB) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHB) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHB) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHB) {
            uic_mqtt_dotdot_electrical_measurement_rms_current_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHB) {
            uic_mqtt_dotdot_electrical_measurement_rms_current_min_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHB) {
            uic_mqtt_dotdot_electrical_measurement_rms_current_max_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHB) {
            uic_mqtt_dotdot_electrical_measurement_active_power_phb_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHB) {
            uic_mqtt_dotdot_electrical_measurement_active_power_min_phb_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHB) {
            uic_mqtt_dotdot_electrical_measurement_active_power_max_phb_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHB) {
            uic_mqtt_dotdot_electrical_measurement_reactive_power_phb_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHB) {
            uic_mqtt_dotdot_electrical_measurement_apparent_power_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHB) {
            uic_mqtt_dotdot_electrical_measurement_power_factor_phb_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD_PHB) {
            uic_mqtt_dotdot_electrical_measurement_averagerms_voltage_measurement_period_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER_PHB) {
            uic_mqtt_dotdot_electrical_measurement_averagerms_over_voltage_counter_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER_PHB) {
            uic_mqtt_dotdot_electrical_measurement_averagerms_under_voltage_counter_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHB) {
            uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHB) {
            uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHB) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHB) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHC) {
            uic_mqtt_dotdot_electrical_measurement_line_current_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHC) {
            uic_mqtt_dotdot_electrical_measurement_active_current_phc_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHC) {
            uic_mqtt_dotdot_electrical_measurement_reactive_current_phc_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHC) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHC) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHC) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHC) {
            uic_mqtt_dotdot_electrical_measurement_rms_current_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHC) {
            uic_mqtt_dotdot_electrical_measurement_rms_current_min_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHC) {
            uic_mqtt_dotdot_electrical_measurement_rms_current_max_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHC) {
            uic_mqtt_dotdot_electrical_measurement_active_power_phc_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHC) {
            uic_mqtt_dotdot_electrical_measurement_active_power_min_phc_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHC) {
            uic_mqtt_dotdot_electrical_measurement_active_power_max_phc_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHC) {
            uic_mqtt_dotdot_electrical_measurement_reactive_power_phc_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.desired_or_reported<int16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHC) {
            uic_mqtt_dotdot_electrical_measurement_apparent_power_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHC) {
            uic_mqtt_dotdot_electrical_measurement_power_factor_phc_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD_PHC) {
            uic_mqtt_dotdot_electrical_measurement_averagerms_voltage_measurement_period_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER_PHC) {
            uic_mqtt_dotdot_electrical_measurement_averagerms_over_voltage_counter_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER_PHC) {
            uic_mqtt_dotdot_electrical_measurement_averagerms_under_voltage_counter_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHC) {
            uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHC) {
            uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHC) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHC) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void electrical_measurement_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"electrical_measurement_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASUREMENT_TYPE) {
            uic_mqtt_dotdot_electrical_measurement_measurement_type_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE) {
            uic_mqtt_dotdot_electrical_measurement_dc_voltage_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MIN) {
            uic_mqtt_dotdot_electrical_measurement_dc_voltage_min_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MAX) {
            uic_mqtt_dotdot_electrical_measurement_dc_voltage_max_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_dc_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MIN) {
            uic_mqtt_dotdot_electrical_measurement_dc_current_min_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MAX) {
            uic_mqtt_dotdot_electrical_measurement_dc_current_max_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER) {
            uic_mqtt_dotdot_electrical_measurement_dc_power_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MIN) {
            uic_mqtt_dotdot_electrical_measurement_dc_power_min_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MAX) {
            uic_mqtt_dotdot_electrical_measurement_dc_power_max_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MULTIPLIER) {
            uic_mqtt_dotdot_electrical_measurement_dc_voltage_multiplier_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_DIVISOR) {
            uic_mqtt_dotdot_electrical_measurement_dc_voltage_divisor_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MULTIPLIER) {
            uic_mqtt_dotdot_electrical_measurement_dc_current_multiplier_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_DIVISOR) {
            uic_mqtt_dotdot_electrical_measurement_dc_current_divisor_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MULTIPLIER) {
            uic_mqtt_dotdot_electrical_measurement_dc_power_multiplier_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_DIVISOR) {
            uic_mqtt_dotdot_electrical_measurement_dc_power_divisor_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY) {
            uic_mqtt_dotdot_electrical_measurement_ac_frequency_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MIN) {
            uic_mqtt_dotdot_electrical_measurement_ac_frequency_min_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MAX) {
            uic_mqtt_dotdot_electrical_measurement_ac_frequency_max_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_NEUTRAL_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_neutral_current_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_ACTIVE_POWER) {
            uic_mqtt_dotdot_electrical_measurement_total_active_power_publish(
              base_topic.str().c_str(),
              static_cast<int32_t>(attr.reported<int32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_REACTIVE_POWER) {
            uic_mqtt_dotdot_electrical_measurement_total_reactive_power_publish(
              base_topic.str().c_str(),
              static_cast<int32_t>(attr.reported<int32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_APPARENT_POWER) {
            uic_mqtt_dotdot_electrical_measurement_total_apparent_power_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED1ST_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured1st_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED3RD_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured3rd_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED5TH_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured5th_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED7TH_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured7th_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED9TH_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured9th_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED11TH_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured11th_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE1ST_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured_phase1st_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE3RD_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured_phase3rd_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE5TH_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured_phase5th_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE7TH_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured_phase7th_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE9TH_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured_phase9th_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE11TH_HARMONIC_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_measured_phase11th_harmonic_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MULTIPLIER) {
            uic_mqtt_dotdot_electrical_measurement_ac_frequency_multiplier_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_DIVISOR) {
            uic_mqtt_dotdot_electrical_measurement_ac_frequency_divisor_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_MULTIPLIER) {
            uic_mqtt_dotdot_electrical_measurement_power_multiplier_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_DIVISOR) {
            uic_mqtt_dotdot_electrical_measurement_power_divisor_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_HARMONIC_CURRENT_MULTIPLIER) {
            uic_mqtt_dotdot_electrical_measurement_harmonic_current_multiplier_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.reported<int8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_PHASE_HARMONIC_CURRENT_MULTIPLIER) {
            uic_mqtt_dotdot_electrical_measurement_phase_harmonic_current_multiplier_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.reported<int8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_line_current_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_active_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_reactive_current_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT) {
            uic_mqtt_dotdot_electrical_measurement_rms_current_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN) {
            uic_mqtt_dotdot_electrical_measurement_rms_current_min_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX) {
            uic_mqtt_dotdot_electrical_measurement_rms_current_max_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER) {
            uic_mqtt_dotdot_electrical_measurement_active_power_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN) {
            uic_mqtt_dotdot_electrical_measurement_active_power_min_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX) {
            uic_mqtt_dotdot_electrical_measurement_active_power_max_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER) {
            uic_mqtt_dotdot_electrical_measurement_reactive_power_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER) {
            uic_mqtt_dotdot_electrical_measurement_apparent_power_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR) {
            uic_mqtt_dotdot_electrical_measurement_power_factor_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.reported<int8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD) {
            uic_mqtt_dotdot_electrical_measurement_averagerms_voltage_measurement_period_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER) {
            uic_mqtt_dotdot_electrical_measurement_averagerms_over_voltage_counter_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER) {
            uic_mqtt_dotdot_electrical_measurement_averagerms_under_voltage_counter_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD) {
            uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD) {
            uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_MULTIPLIER) {
            uic_mqtt_dotdot_electrical_measurement_ac_voltage_multiplier_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_DIVISOR) {
            uic_mqtt_dotdot_electrical_measurement_ac_voltage_divisor_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_MULTIPLIER) {
            uic_mqtt_dotdot_electrical_measurement_ac_current_multiplier_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_DIVISOR) {
            uic_mqtt_dotdot_electrical_measurement_ac_current_divisor_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_MULTIPLIER) {
            uic_mqtt_dotdot_electrical_measurement_ac_power_multiplier_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_DIVISOR) {
            uic_mqtt_dotdot_electrical_measurement_ac_power_divisor_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_OVERLOAD_ALARMS_MASK) {
            uic_mqtt_dotdot_electrical_measurement_dc_overload_alarms_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_OVERLOAD) {
            uic_mqtt_dotdot_electrical_measurement_dc_voltage_overload_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_OVERLOAD) {
            uic_mqtt_dotdot_electrical_measurement_dc_current_overload_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ALARMS_MASK) {
            uic_mqtt_dotdot_electrical_measurement_ac_alarms_mask_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_OVERLOAD) {
            uic_mqtt_dotdot_electrical_measurement_ac_voltage_overload_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_OVERLOAD) {
            uic_mqtt_dotdot_electrical_measurement_ac_current_overload_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ACTIVE_POWER_OVERLOAD) {
            uic_mqtt_dotdot_electrical_measurement_ac_active_power_overload_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_REACTIVE_POWER_OVERLOAD) {
            uic_mqtt_dotdot_electrical_measurement_ac_reactive_power_overload_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE) {
            uic_mqtt_dotdot_electrical_measurement_averagerms_over_voltage_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE) {
            uic_mqtt_dotdot_electrical_measurement_averagerms_under_voltage_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE) {
            uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE) {
            uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHB) {
            uic_mqtt_dotdot_electrical_measurement_line_current_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHB) {
            uic_mqtt_dotdot_electrical_measurement_active_current_phb_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHB) {
            uic_mqtt_dotdot_electrical_measurement_reactive_current_phb_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHB) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHB) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHB) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHB) {
            uic_mqtt_dotdot_electrical_measurement_rms_current_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHB) {
            uic_mqtt_dotdot_electrical_measurement_rms_current_min_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHB) {
            uic_mqtt_dotdot_electrical_measurement_rms_current_max_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHB) {
            uic_mqtt_dotdot_electrical_measurement_active_power_phb_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHB) {
            uic_mqtt_dotdot_electrical_measurement_active_power_min_phb_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHB) {
            uic_mqtt_dotdot_electrical_measurement_active_power_max_phb_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHB) {
            uic_mqtt_dotdot_electrical_measurement_reactive_power_phb_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHB) {
            uic_mqtt_dotdot_electrical_measurement_apparent_power_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHB) {
            uic_mqtt_dotdot_electrical_measurement_power_factor_phb_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.reported<int8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD_PHB) {
            uic_mqtt_dotdot_electrical_measurement_averagerms_voltage_measurement_period_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER_PHB) {
            uic_mqtt_dotdot_electrical_measurement_averagerms_over_voltage_counter_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER_PHB) {
            uic_mqtt_dotdot_electrical_measurement_averagerms_under_voltage_counter_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHB) {
            uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHB) {
            uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHB) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHB) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_phb_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHC) {
            uic_mqtt_dotdot_electrical_measurement_line_current_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHC) {
            uic_mqtt_dotdot_electrical_measurement_active_current_phc_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHC) {
            uic_mqtt_dotdot_electrical_measurement_reactive_current_phc_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHC) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHC) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHC) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHC) {
            uic_mqtt_dotdot_electrical_measurement_rms_current_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHC) {
            uic_mqtt_dotdot_electrical_measurement_rms_current_min_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHC) {
            uic_mqtt_dotdot_electrical_measurement_rms_current_max_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHC) {
            uic_mqtt_dotdot_electrical_measurement_active_power_phc_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHC) {
            uic_mqtt_dotdot_electrical_measurement_active_power_min_phc_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHC) {
            uic_mqtt_dotdot_electrical_measurement_active_power_max_phc_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHC) {
            uic_mqtt_dotdot_electrical_measurement_reactive_power_phc_publish(
              base_topic.str().c_str(),
              static_cast<int16_t>(attr.reported<int16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHC) {
            uic_mqtt_dotdot_electrical_measurement_apparent_power_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHC) {
            uic_mqtt_dotdot_electrical_measurement_power_factor_phc_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.reported<int8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD_PHC) {
            uic_mqtt_dotdot_electrical_measurement_averagerms_voltage_measurement_period_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER_PHC) {
            uic_mqtt_dotdot_electrical_measurement_averagerms_over_voltage_counter_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER_PHC) {
            uic_mqtt_dotdot_electrical_measurement_averagerms_under_voltage_counter_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHC) {
            uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHC) {
            uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHC) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHC) {
            uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_phc_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks electrical_measurement
static sl_status_t electrical_measurement_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_electrical_measurement_state_t attributes,
  uic_mqtt_dotdot_electrical_measurement_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_OVERLOAD_ALARMS_MASK == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ALARMS_MASK == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD_PHB == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER_PHB == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER_PHB == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHB == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHB == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHB == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHB == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD_PHC == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER_PHC == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER_PHC == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHC == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHC == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHC == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHC == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "electrical_measurement: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.averagerms_voltage_measurement_period) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.averagerms_voltage_measurement_period);
                  }
      }
      if (updated_attributes.averagerms_over_voltage_counter) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.averagerms_over_voltage_counter);
                  }
      }
      if (updated_attributes.averagerms_under_voltage_counter) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.averagerms_under_voltage_counter);
                  }
      }
      if (updated_attributes.rms_extreme_over_voltage_period) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.rms_extreme_over_voltage_period);
                  }
      }
      if (updated_attributes.rms_extreme_under_voltage_period) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.rms_extreme_under_voltage_period);
                  }
      }
      if (updated_attributes.rms_voltage_sag_period) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.rms_voltage_sag_period);
                  }
      }
      if (updated_attributes.rms_voltage_swell_period) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.rms_voltage_swell_period);
                  }
      }
      if (updated_attributes.dc_overload_alarms_mask) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_OVERLOAD_ALARMS_MASK);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.dc_overload_alarms_mask);
                  }
      }
      if (updated_attributes.ac_alarms_mask) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ALARMS_MASK);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.ac_alarms_mask);
                  }
      }
      if (updated_attributes.rms_extreme_over_voltage) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.rms_extreme_over_voltage);
                  }
      }
      if (updated_attributes.rms_extreme_under_voltage) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.rms_extreme_under_voltage);
                  }
      }
      if (updated_attributes.rms_voltage_sag) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.rms_voltage_sag);
                  }
      }
      if (updated_attributes.rms_voltage_swell) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.rms_voltage_swell);
                  }
      }
      if (updated_attributes.averagerms_voltage_measurement_period_phb) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD_PHB);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.averagerms_voltage_measurement_period_phb);
                  }
      }
      if (updated_attributes.averagerms_over_voltage_counter_phb) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER_PHB);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.averagerms_over_voltage_counter_phb);
                  }
      }
      if (updated_attributes.averagerms_under_voltage_counter_phb) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER_PHB);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.averagerms_under_voltage_counter_phb);
                  }
      }
      if (updated_attributes.rms_extreme_over_voltage_period_phb) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHB);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.rms_extreme_over_voltage_period_phb);
                  }
      }
      if (updated_attributes.rms_extreme_under_voltage_period_phb) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHB);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.rms_extreme_under_voltage_period_phb);
                  }
      }
      if (updated_attributes.rms_voltage_sag_period_phb) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHB);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.rms_voltage_sag_period_phb);
                  }
      }
      if (updated_attributes.rms_voltage_swell_period_phb) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHB);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.rms_voltage_swell_period_phb);
                  }
      }
      if (updated_attributes.averagerms_voltage_measurement_period_phc) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD_PHC);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.averagerms_voltage_measurement_period_phc);
                  }
      }
      if (updated_attributes.averagerms_over_voltage_counter_phc) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER_PHC);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.averagerms_over_voltage_counter_phc);
                  }
      }
      if (updated_attributes.averagerms_under_voltage_counter_phc) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER_PHC);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.averagerms_under_voltage_counter_phc);
                  }
      }
      if (updated_attributes.rms_extreme_over_voltage_period_phc) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHC);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.rms_extreme_over_voltage_period_phc);
                  }
      }
      if (updated_attributes.rms_extreme_under_voltage_period_phc) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHC);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.rms_extreme_under_voltage_period_phc);
                  }
      }
      if (updated_attributes.rms_voltage_sag_period_phc) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHC);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.rms_voltage_sag_period_phc);
                  }
      }
      if (updated_attributes.rms_voltage_swell_period_phc) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHC);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.rms_voltage_swell_period_phc);
                  }
      }

  return SL_STATUS_OK;
}

static void electrical_measurement_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/ElectricalMeasurement/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_electrical_measurement_publish_cluster_revision(base_topic.str().c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster diagnostics
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void diagnostics_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"diagnostics_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NUMBER_OF_RESETS) {
            uic_mqtt_dotdot_diagnostics_number_of_resets_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PERSISTENT_MEMORY_WRITES) {
            uic_mqtt_dotdot_diagnostics_persistent_memory_writes_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_BCAST) {
            uic_mqtt_dotdot_diagnostics_mac_rx_bcast_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_BCAST) {
            uic_mqtt_dotdot_diagnostics_mac_tx_bcast_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_UCAST) {
            uic_mqtt_dotdot_diagnostics_mac_rx_ucast_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST) {
            uic_mqtt_dotdot_diagnostics_mac_tx_ucast_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_RETRY) {
            uic_mqtt_dotdot_diagnostics_mac_tx_ucast_retry_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_FAIL) {
            uic_mqtt_dotdot_diagnostics_mac_tx_ucast_fail_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_BCAST) {
            uic_mqtt_dotdot_diagnostics_aps_rx_bcast_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_BCAST) {
            uic_mqtt_dotdot_diagnostics_aps_tx_bcast_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_UCAST) {
            uic_mqtt_dotdot_diagnostics_aps_rx_ucast_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_SUCCESS) {
            uic_mqtt_dotdot_diagnostics_aps_tx_ucast_success_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_RETRY) {
            uic_mqtt_dotdot_diagnostics_aps_tx_ucast_retry_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_FAIL) {
            uic_mqtt_dotdot_diagnostics_aps_tx_ucast_fail_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_ROUTE_DISC_INITIATED) {
            uic_mqtt_dotdot_diagnostics_route_disc_initiated_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_ADDED) {
            uic_mqtt_dotdot_diagnostics_neighbor_added_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_REMOVED) {
            uic_mqtt_dotdot_diagnostics_neighbor_removed_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_STALE) {
            uic_mqtt_dotdot_diagnostics_neighbor_stale_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_JOIN_INDICATION) {
            uic_mqtt_dotdot_diagnostics_join_indication_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_CHILD_MOVED) {
            uic_mqtt_dotdot_diagnostics_child_moved_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWKFC_FAILURE) {
            uic_mqtt_dotdot_diagnostics_nwkfc_failure_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APSFC_FAILURE) {
            uic_mqtt_dotdot_diagnostics_apsfc_failure_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_UNAUTHORIZED_KEY) {
            uic_mqtt_dotdot_diagnostics_aps_unauthorized_key_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWK_DECRYPT_FAILURES) {
            uic_mqtt_dotdot_diagnostics_nwk_decrypt_failures_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_DECRYPT_FAILURES) {
            uic_mqtt_dotdot_diagnostics_aps_decrypt_failures_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_BUFFER_ALLOCATE_FAILURES) {
            uic_mqtt_dotdot_diagnostics_packet_buffer_allocate_failures_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_RELAYED_UCAST) {
            uic_mqtt_dotdot_diagnostics_relayed_ucast_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PHY_TOMAC_QUEUE_LIMIT_REACHED) {
            uic_mqtt_dotdot_diagnostics_phy_tomac_queue_limit_reached_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_VALIDATE_DROP_COUNT) {
            uic_mqtt_dotdot_diagnostics_packet_validate_drop_count_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_AVERAGEMAC_RETRY_PERAPS_MESSAGE_SENT) {
            uic_mqtt_dotdot_diagnostics_averagemac_retry_peraps_message_sent_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.desired_or_reported<uint16_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGELQI) {
            uic_mqtt_dotdot_diagnostics_last_messagelqi_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGERSSI) {
            uic_mqtt_dotdot_diagnostics_last_messagerssi_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void diagnostics_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"diagnostics_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NUMBER_OF_RESETS) {
            uic_mqtt_dotdot_diagnostics_number_of_resets_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PERSISTENT_MEMORY_WRITES) {
            uic_mqtt_dotdot_diagnostics_persistent_memory_writes_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_BCAST) {
            uic_mqtt_dotdot_diagnostics_mac_rx_bcast_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_BCAST) {
            uic_mqtt_dotdot_diagnostics_mac_tx_bcast_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_UCAST) {
            uic_mqtt_dotdot_diagnostics_mac_rx_ucast_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST) {
            uic_mqtt_dotdot_diagnostics_mac_tx_ucast_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_RETRY) {
            uic_mqtt_dotdot_diagnostics_mac_tx_ucast_retry_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_FAIL) {
            uic_mqtt_dotdot_diagnostics_mac_tx_ucast_fail_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_BCAST) {
            uic_mqtt_dotdot_diagnostics_aps_rx_bcast_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_BCAST) {
            uic_mqtt_dotdot_diagnostics_aps_tx_bcast_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_UCAST) {
            uic_mqtt_dotdot_diagnostics_aps_rx_ucast_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_SUCCESS) {
            uic_mqtt_dotdot_diagnostics_aps_tx_ucast_success_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_RETRY) {
            uic_mqtt_dotdot_diagnostics_aps_tx_ucast_retry_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_FAIL) {
            uic_mqtt_dotdot_diagnostics_aps_tx_ucast_fail_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_ROUTE_DISC_INITIATED) {
            uic_mqtt_dotdot_diagnostics_route_disc_initiated_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_ADDED) {
            uic_mqtt_dotdot_diagnostics_neighbor_added_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_REMOVED) {
            uic_mqtt_dotdot_diagnostics_neighbor_removed_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_STALE) {
            uic_mqtt_dotdot_diagnostics_neighbor_stale_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_JOIN_INDICATION) {
            uic_mqtt_dotdot_diagnostics_join_indication_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_CHILD_MOVED) {
            uic_mqtt_dotdot_diagnostics_child_moved_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWKFC_FAILURE) {
            uic_mqtt_dotdot_diagnostics_nwkfc_failure_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APSFC_FAILURE) {
            uic_mqtt_dotdot_diagnostics_apsfc_failure_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_UNAUTHORIZED_KEY) {
            uic_mqtt_dotdot_diagnostics_aps_unauthorized_key_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWK_DECRYPT_FAILURES) {
            uic_mqtt_dotdot_diagnostics_nwk_decrypt_failures_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_DECRYPT_FAILURES) {
            uic_mqtt_dotdot_diagnostics_aps_decrypt_failures_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_BUFFER_ALLOCATE_FAILURES) {
            uic_mqtt_dotdot_diagnostics_packet_buffer_allocate_failures_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_RELAYED_UCAST) {
            uic_mqtt_dotdot_diagnostics_relayed_ucast_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PHY_TOMAC_QUEUE_LIMIT_REACHED) {
            uic_mqtt_dotdot_diagnostics_phy_tomac_queue_limit_reached_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_VALIDATE_DROP_COUNT) {
            uic_mqtt_dotdot_diagnostics_packet_validate_drop_count_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_AVERAGEMAC_RETRY_PERAPS_MESSAGE_SENT) {
            uic_mqtt_dotdot_diagnostics_averagemac_retry_peraps_message_sent_publish(
              base_topic.str().c_str(),
              static_cast<uint16_t>(attr.reported<uint16_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGELQI) {
            uic_mqtt_dotdot_diagnostics_last_messagelqi_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGERSSI) {
            uic_mqtt_dotdot_diagnostics_last_messagerssi_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.reported<int8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks diagnostics
static sl_status_t diagnostics_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_diagnostics_state_t attributes,
  uic_mqtt_dotdot_diagnostics_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "diagnostics: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;

  return SL_STATUS_OK;
}

static void diagnostics_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/Diagnostics/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_diagnostics_publish_cluster_revision(base_topic.str().c_str(), 2);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster protocol_controller_rf_telemetry
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void protocol_controller_rf_telemetry_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"protocol_controller_rf_telemetry_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_TX_REPORT_ENABLED) {
            uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_enabled_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.desired_or_reported<bool>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_PTI_ENABLED) {
            uic_mqtt_dotdot_protocol_controller_rf_telemetry_pti_enabled_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.desired_or_reported<bool>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void protocol_controller_rf_telemetry_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"protocol_controller_rf_telemetry_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_TX_REPORT_ENABLED) {
            uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_enabled_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.reported<bool>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_PTI_ENABLED) {
            uic_mqtt_dotdot_protocol_controller_rf_telemetry_pti_enabled_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.reported<bool>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks protocol_controller_rf_telemetry
static sl_status_t protocol_controller_rf_telemetry_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_state_t attributes,
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_TX_REPORT_ENABLED == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_PTI_ENABLED == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "protocol_controller_rf_telemetry: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.tx_report_enabled) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_TX_REPORT_ENABLED);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.tx_report_enabled);
                  }
      }
      if (updated_attributes.pti_enabled) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_PTI_ENABLED);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.pti_enabled);
                  }
      }

  return SL_STATUS_OK;
}

static void protocol_controller_rf_telemetry_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/ProtocolController/RFTelemetry/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_protocol_controller_rf_telemetry_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster state
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void state_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"state_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
      // Skip attribute EndpointIdList because it is an array,
      // we typically don't save them as array in the attribute store.
    } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void state_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"state_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
      // Skip attribute EndpointIdList because it is an array,
      // we typically don't save them as array in the attribute store.
    } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks state
static sl_status_t state_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_state_state_t attributes,
  uic_mqtt_dotdot_state_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "state: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;

  return SL_STATUS_OK;
}

static void state_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/State/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_state_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster binding
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void binding_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"binding_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BINDING_BINDING_TABLE_FULL) {
            uic_mqtt_dotdot_binding_binding_table_full_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.desired_or_reported<bool>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
            // Skip attribute BindableClusterList because it is an array,
      // we typically don't save them as array in the attribute store.
      // Skip attribute BindingTable because it is an array,
      // we typically don't save them as array in the attribute store.
    } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void binding_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"binding_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_BINDING_BINDING_TABLE_FULL) {
            uic_mqtt_dotdot_binding_binding_table_full_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.reported<bool>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
            // Skip attribute BindableClusterList because it is an array,
      // we typically don't save them as array in the attribute store.
      // Skip attribute BindingTable because it is an array,
      // we typically don't save them as array in the attribute store.
    } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks binding
static sl_status_t binding_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_binding_state_t attributes,
  uic_mqtt_dotdot_binding_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "binding: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;

  return SL_STATUS_OK;
}

static void binding_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/Binding/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_binding_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster system_metrics
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void system_metrics_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"system_metrics_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_REPORTING_INTERVAL_SECONDS) {
            uic_mqtt_dotdot_system_metrics_reporting_interval_seconds_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
            // Skip attribute CPUUsagePercent because it is an array,
      // we typically don't save them as array in the attribute store.
      // Skip attribute CPUFrequencyMHz because it is an array,
      // we typically don't save them as array in the attribute store.
      // Skip attribute CPUAverageUsagePercent because it is an array,
      // we typically don't save them as array in the attribute store.
      // Skip attribute CPUMinUsagePercent because it is an array,
      // we typically don't save them as array in the attribute store.
      // Skip attribute CPUMaxUsagePercent because it is an array,
      // we typically don't save them as array in the attribute store.
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_TOTALMB) {
            uic_mqtt_dotdot_system_metrics_ram_totalmb_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.desired_or_reported<double>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_FREEMB) {
            uic_mqtt_dotdot_system_metrics_ram_freemb_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.desired_or_reported<double>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_AVAILABLEMB) {
            uic_mqtt_dotdot_system_metrics_ram_availablemb_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.desired_or_reported<double>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_TOTALMB) {
            uic_mqtt_dotdot_system_metrics_swap_memory_totalmb_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.desired_or_reported<double>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_USEDMB) {
            uic_mqtt_dotdot_system_metrics_swap_memory_usedmb_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.desired_or_reported<double>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_TOTALMB) {
            uic_mqtt_dotdot_system_metrics_virtual_memory_totalmb_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.desired_or_reported<double>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_USEDMB) {
            uic_mqtt_dotdot_system_metrics_virtual_memory_usedmb_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.desired_or_reported<double>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
            // Skip attribute DisksUsage because it is an array,
      // we typically don't save them as array in the attribute store.
      // Skip attribute DisksCounters because it is an array,
      // we typically don't save them as array in the attribute store.
      // Skip attribute NetworkInterfacesData because it is an array,
      // we typically don't save them as array in the attribute store.
      // Skip attribute WirelessNetworkInterfacesData because it is an array,
      // we typically don't save them as array in the attribute store.
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_HOSTNAME) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_system_metrics_hostname_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_FQDN) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_system_metrics_fqdn_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_UPTIME_MINUTES) {
            uic_mqtt_dotdot_system_metrics_uptime_minutes_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CURRENT_TEMPERATURE_CELCIUS) {
            uic_mqtt_dotdot_system_metrics_current_temperature_celcius_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.desired_or_reported<double>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_AVERAGE_TEMPERATURE_CELCIUS) {
            uic_mqtt_dotdot_system_metrics_average_temperature_celcius_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.desired_or_reported<double>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MIN_TEMPERATURE_CELCIUS) {
            uic_mqtt_dotdot_system_metrics_min_temperature_celcius_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.desired_or_reported<double>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MAX_TEMPERATURE_CELCIUS) {
            uic_mqtt_dotdot_system_metrics_max_temperature_celcius_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.desired_or_reported<double>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_POWER_PLUGGED) {
            uic_mqtt_dotdot_system_metrics_power_plugged_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.desired_or_reported<bool>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_BATTERY_PERCENTAGE) {
            uic_mqtt_dotdot_system_metrics_battery_percentage_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.desired_or_reported<double>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SYSTEM_INTERRUPTS) {
            uic_mqtt_dotdot_system_metrics_system_interrupts_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void system_metrics_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"system_metrics_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_REPORTING_INTERVAL_SECONDS) {
            uic_mqtt_dotdot_system_metrics_reporting_interval_seconds_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
            // Skip attribute CPUUsagePercent because it is an array,
      // we typically don't save them as array in the attribute store.
      // Skip attribute CPUFrequencyMHz because it is an array,
      // we typically don't save them as array in the attribute store.
      // Skip attribute CPUAverageUsagePercent because it is an array,
      // we typically don't save them as array in the attribute store.
      // Skip attribute CPUMinUsagePercent because it is an array,
      // we typically don't save them as array in the attribute store.
      // Skip attribute CPUMaxUsagePercent because it is an array,
      // we typically don't save them as array in the attribute store.
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_TOTALMB) {
            uic_mqtt_dotdot_system_metrics_ram_totalmb_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.reported<double>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_FREEMB) {
            uic_mqtt_dotdot_system_metrics_ram_freemb_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.reported<double>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_AVAILABLEMB) {
            uic_mqtt_dotdot_system_metrics_ram_availablemb_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.reported<double>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_TOTALMB) {
            uic_mqtt_dotdot_system_metrics_swap_memory_totalmb_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.reported<double>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_USEDMB) {
            uic_mqtt_dotdot_system_metrics_swap_memory_usedmb_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.reported<double>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_TOTALMB) {
            uic_mqtt_dotdot_system_metrics_virtual_memory_totalmb_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.reported<double>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_USEDMB) {
            uic_mqtt_dotdot_system_metrics_virtual_memory_usedmb_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.reported<double>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
            // Skip attribute DisksUsage because it is an array,
      // we typically don't save them as array in the attribute store.
      // Skip attribute DisksCounters because it is an array,
      // we typically don't save them as array in the attribute store.
      // Skip attribute NetworkInterfacesData because it is an array,
      // we typically don't save them as array in the attribute store.
      // Skip attribute WirelessNetworkInterfacesData because it is an array,
      // we typically don't save them as array in the attribute store.
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_HOSTNAME) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_system_metrics_hostname_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_FQDN) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_system_metrics_fqdn_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_UPTIME_MINUTES) {
            uic_mqtt_dotdot_system_metrics_uptime_minutes_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.reported<uint64_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CURRENT_TEMPERATURE_CELCIUS) {
            uic_mqtt_dotdot_system_metrics_current_temperature_celcius_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.reported<double>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_AVERAGE_TEMPERATURE_CELCIUS) {
            uic_mqtt_dotdot_system_metrics_average_temperature_celcius_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.reported<double>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MIN_TEMPERATURE_CELCIUS) {
            uic_mqtt_dotdot_system_metrics_min_temperature_celcius_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.reported<double>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MAX_TEMPERATURE_CELCIUS) {
            uic_mqtt_dotdot_system_metrics_max_temperature_celcius_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.reported<double>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_POWER_PLUGGED) {
            uic_mqtt_dotdot_system_metrics_power_plugged_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.reported<bool>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_BATTERY_PERCENTAGE) {
            uic_mqtt_dotdot_system_metrics_battery_percentage_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.reported<double>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SYSTEM_INTERRUPTS) {
            uic_mqtt_dotdot_system_metrics_system_interrupts_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.reported<uint64_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks system_metrics
static sl_status_t system_metrics_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_system_metrics_state_t attributes,
  uic_mqtt_dotdot_system_metrics_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_REPORTING_INTERVAL_SECONDS == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "system_metrics: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.reporting_interval_seconds) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_REPORTING_INTERVAL_SECONDS);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.reporting_interval_seconds);
                  }
      }

  return SL_STATUS_OK;
}

static void system_metrics_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/SystemMetrics/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_system_metrics_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster application_monitoring
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void application_monitoring_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"application_monitoring_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_NAME) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_application_monitoring_application_name_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_VERSION) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_application_monitoring_application_version_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CONNECTED) {
            uic_mqtt_dotdot_application_monitoring_application_connected_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.desired_or_reported<bool>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
            // Skip attribute ApplicationMQTTTopics because it is an array,
      // we typically don't save them as array in the attribute store.
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_UPTIME_MINUTES) {
            uic_mqtt_dotdot_application_monitoring_uptime_minutes_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_PROCESS_ID) {
            uic_mqtt_dotdot_application_monitoring_process_id_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_HOSTNAME) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_application_monitoring_hostname_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_FQDN) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_application_monitoring_fqdn_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_ENABLED) {
            uic_mqtt_dotdot_application_monitoring_mqtt_logging_enabled_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.desired_or_reported<bool>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_LEVEL) {
            uic_mqtt_dotdot_application_monitoring_mqtt_logging_level_publish(
              base_topic.str().c_str(),
              static_cast<LoggingLevelEnum>(attr.desired_or_reported<LoggingLevelEnum>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_STATISTICS_REPORTING_INTERVAL_SECONDS) {
            uic_mqtt_dotdot_application_monitoring_mqtt_statistics_reporting_interval_seconds_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_SENT) {
            uic_mqtt_dotdot_application_monitoring_mqtt_messages_sent_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_RECEIVED) {
            uic_mqtt_dotdot_application_monitoring_mqtt_messages_received_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_SUBSCRIPTION_COUNT) {
            uic_mqtt_dotdot_application_monitoring_mqtt_subscription_count_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.desired_or_reported<uint64_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_AVERAGE_DELIVERY_TIME_SECONDS) {
            uic_mqtt_dotdot_application_monitoring_mqtt_average_delivery_time_seconds_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.desired_or_reported<double>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MIN_DELIVERY_TIME_SECONDS) {
            uic_mqtt_dotdot_application_monitoring_mqtt_min_delivery_time_seconds_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.desired_or_reported<double>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MAX_DELIVERY_TIME_SECONDS) {
            uic_mqtt_dotdot_application_monitoring_mqtt_max_delivery_time_seconds_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.desired_or_reported<double>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_STATISTICS_REPORTING_INTERVAL_SECONDS) {
            uic_mqtt_dotdot_application_monitoring_application_statistics_reporting_interval_seconds_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.desired_or_reported<uint32_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_USAGE_PERCENT) {
            uic_mqtt_dotdot_application_monitoring_applicationcpu_usage_percent_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.desired_or_reported<double>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_AVERAGE_USAGE_PERCENT) {
            uic_mqtt_dotdot_application_monitoring_applicationcpu_average_usage_percent_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.desired_or_reported<double>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_MIN_USAGE_PERCENT) {
            uic_mqtt_dotdot_application_monitoring_applicationcpu_min_usage_percent_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.desired_or_reported<double>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_MAX_USAGE_PERCENT) {
            uic_mqtt_dotdot_application_monitoring_applicationcpu_max_usage_percent_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.desired_or_reported<double>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONRAM_USAGEMB) {
            uic_mqtt_dotdot_application_monitoring_applicationram_usagemb_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.desired_or_reported<double>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void application_monitoring_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"application_monitoring_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_NAME) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_application_monitoring_application_name_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_VERSION) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_application_monitoring_application_version_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CONNECTED) {
            uic_mqtt_dotdot_application_monitoring_application_connected_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.reported<bool>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
            // Skip attribute ApplicationMQTTTopics because it is an array,
      // we typically don't save them as array in the attribute store.
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_UPTIME_MINUTES) {
            uic_mqtt_dotdot_application_monitoring_uptime_minutes_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.reported<uint64_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_PROCESS_ID) {
            uic_mqtt_dotdot_application_monitoring_process_id_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.reported<uint64_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_HOSTNAME) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_application_monitoring_hostname_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_FQDN) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_application_monitoring_fqdn_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_ENABLED) {
            uic_mqtt_dotdot_application_monitoring_mqtt_logging_enabled_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.reported<bool>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_LEVEL) {
            uic_mqtt_dotdot_application_monitoring_mqtt_logging_level_publish(
              base_topic.str().c_str(),
              static_cast<LoggingLevelEnum>(attr.reported<LoggingLevelEnum>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_STATISTICS_REPORTING_INTERVAL_SECONDS) {
            uic_mqtt_dotdot_application_monitoring_mqtt_statistics_reporting_interval_seconds_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_SENT) {
            uic_mqtt_dotdot_application_monitoring_mqtt_messages_sent_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.reported<uint64_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_RECEIVED) {
            uic_mqtt_dotdot_application_monitoring_mqtt_messages_received_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.reported<uint64_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_SUBSCRIPTION_COUNT) {
            uic_mqtt_dotdot_application_monitoring_mqtt_subscription_count_publish(
              base_topic.str().c_str(),
              static_cast<uint64_t>(attr.reported<uint64_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_AVERAGE_DELIVERY_TIME_SECONDS) {
            uic_mqtt_dotdot_application_monitoring_mqtt_average_delivery_time_seconds_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.reported<double>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MIN_DELIVERY_TIME_SECONDS) {
            uic_mqtt_dotdot_application_monitoring_mqtt_min_delivery_time_seconds_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.reported<double>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MAX_DELIVERY_TIME_SECONDS) {
            uic_mqtt_dotdot_application_monitoring_mqtt_max_delivery_time_seconds_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.reported<double>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_STATISTICS_REPORTING_INTERVAL_SECONDS) {
            uic_mqtt_dotdot_application_monitoring_application_statistics_reporting_interval_seconds_publish(
              base_topic.str().c_str(),
              static_cast<uint32_t>(attr.reported<uint32_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_USAGE_PERCENT) {
            uic_mqtt_dotdot_application_monitoring_applicationcpu_usage_percent_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.reported<double>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_AVERAGE_USAGE_PERCENT) {
            uic_mqtt_dotdot_application_monitoring_applicationcpu_average_usage_percent_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.reported<double>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_MIN_USAGE_PERCENT) {
            uic_mqtt_dotdot_application_monitoring_applicationcpu_min_usage_percent_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.reported<double>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_MAX_USAGE_PERCENT) {
            uic_mqtt_dotdot_application_monitoring_applicationcpu_max_usage_percent_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.reported<double>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONRAM_USAGEMB) {
            uic_mqtt_dotdot_application_monitoring_applicationram_usagemb_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.reported<double>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks application_monitoring
static sl_status_t application_monitoring_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_application_monitoring_state_t attributes,
  uic_mqtt_dotdot_application_monitoring_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_ENABLED == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_LEVEL == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_STATISTICS_REPORTING_INTERVAL_SECONDS == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_STATISTICS_REPORTING_INTERVAL_SECONDS == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "application_monitoring: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.mqtt_logging_enabled) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_ENABLED);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.mqtt_logging_enabled);
                  }
      }
      if (updated_attributes.mqtt_logging_level) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_LEVEL);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.mqtt_logging_level);
                  }
      }
      if (updated_attributes.mqtt_statistics_reporting_interval_seconds) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_STATISTICS_REPORTING_INTERVAL_SECONDS);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.mqtt_statistics_reporting_interval_seconds);
                  }
      }
      if (updated_attributes.application_statistics_reporting_interval_seconds) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_STATISTICS_REPORTING_INTERVAL_SECONDS);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.application_statistics_reporting_interval_seconds);
                  }
      }

  return SL_STATUS_OK;
}

static void application_monitoring_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/ApplicationMonitoring/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_application_monitoring_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster name_and_location
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void name_and_location_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"name_and_location_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_NAME) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_name_and_location_name_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_LOCATION) {
            std::vector<char> str_desired = attr.desired_or_reported<std::vector<char>>();
            uic_mqtt_dotdot_name_and_location_location_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_desired.data() ),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void name_and_location_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"name_and_location_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_NAME) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_name_and_location_name_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_LOCATION) {
            auto str_reported = attr.reported<std::string>();
            uic_mqtt_dotdot_name_and_location_location_publish(
              base_topic.str().c_str(),
              static_cast<const char*>( str_reported.c_str() ),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks name_and_location
static sl_status_t name_and_location_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_name_and_location_state_t attributes,
  uic_mqtt_dotdot_name_and_location_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_NAME == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_LOCATION == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "name_and_location: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.name) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_NAME);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_string(updated_node,attributes.name);
        }
      }
      if (updated_attributes.location) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_LOCATION);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_string(updated_node,attributes.location);
        }
      }

  return SL_STATUS_OK;
}

static void name_and_location_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/NameAndLocation/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_name_and_location_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster configuration_parameters
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void configuration_parameters_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"configuration_parameters_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
      // Skip attribute ConfigurationParameters because it is an array,
      // we typically don't save them as array in the attribute store.
    } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void configuration_parameters_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"configuration_parameters_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
      // Skip attribute ConfigurationParameters because it is an array,
      // we typically don't save them as array in the attribute store.
    } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks configuration_parameters
static sl_status_t configuration_parameters_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_configuration_parameters_state_t attributes,
  uic_mqtt_dotdot_configuration_parameters_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "configuration_parameters: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;

  return SL_STATUS_OK;
}

static void configuration_parameters_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/ConfigurationParameters/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_configuration_parameters_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster aox_locator
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void aox_locator_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"aox_locator_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_REPORTING_MODE) {
            uic_mqtt_dotdot_aox_locator_reporting_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION_VALID) {
            uic_mqtt_dotdot_aox_locator_position_and_orientation_valid_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.desired_or_reported<bool>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
            // Skip attribute PositionAndOrientation because it is a struct,
      // we typically don't save them as structs in the attribute store.
      // Skip attribute AzimuthMask because it is an array,
      // we typically don't save them as array in the attribute store.
      // Skip attribute ElevationMask because it is an array,
      // we typically don't save them as array in the attribute store.
      // Skip attribute AllowList because it is an array,
      // we typically don't save them as array in the attribute store.
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AOX_MODE) {
            uic_mqtt_dotdot_aox_locator_aox_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_MODE) {
            uic_mqtt_dotdot_aox_locator_antenna_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
            // Skip attribute AntennaArray because it is an array,
      // we typically don't save them as array in the attribute store.
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_PERIOD_SAMPLES) {
            uic_mqtt_dotdot_aox_locator_period_samples_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING) {
            uic_mqtt_dotdot_aox_locator_angle_filtering_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.desired_or_reported<bool>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING_WEIGHT) {
            uic_mqtt_dotdot_aox_locator_angle_filtering_weight_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.desired_or_reported<double>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_TIMEOUT) {
            uic_mqtt_dotdot_aox_locator_angle_correction_timeout_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_DELAY) {
            uic_mqtt_dotdot_aox_locator_angle_correction_delay_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_MODE) {
            uic_mqtt_dotdot_aox_locator_cte_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_SAMPLING_INTERVAL) {
            uic_mqtt_dotdot_aox_locator_cte_sampling_interval_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_LENGTH) {
            uic_mqtt_dotdot_aox_locator_cte_length_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_SLOT_DURATION) {
            uic_mqtt_dotdot_aox_locator_slot_duration_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.desired_or_reported<int8_t>()),
              UCL_MQTT_PUBLISH_TYPE_DESIRED);
          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void aox_locator_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"aox_locator_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_REPORTING_MODE) {
            uic_mqtt_dotdot_aox_locator_reporting_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION_VALID) {
            uic_mqtt_dotdot_aox_locator_position_and_orientation_valid_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.reported<bool>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
            // Skip attribute PositionAndOrientation because it is a struct,
      // we typically don't save them as structs in the attribute store.
      // Skip attribute AzimuthMask because it is an array,
      // we typically don't save them as array in the attribute store.
      // Skip attribute ElevationMask because it is an array,
      // we typically don't save them as array in the attribute store.
      // Skip attribute AllowList because it is an array,
      // we typically don't save them as array in the attribute store.
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AOX_MODE) {
            uic_mqtt_dotdot_aox_locator_aox_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_MODE) {
            uic_mqtt_dotdot_aox_locator_antenna_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
            // Skip attribute AntennaArray because it is an array,
      // we typically don't save them as array in the attribute store.
        if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_PERIOD_SAMPLES) {
            uic_mqtt_dotdot_aox_locator_period_samples_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.reported<int8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING) {
            uic_mqtt_dotdot_aox_locator_angle_filtering_publish(
              base_topic.str().c_str(),
              static_cast<bool>(attr.reported<bool>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING_WEIGHT) {
            uic_mqtt_dotdot_aox_locator_angle_filtering_weight_publish(
              base_topic.str().c_str(),
              static_cast<double>(attr.reported<double>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_TIMEOUT) {
            uic_mqtt_dotdot_aox_locator_angle_correction_timeout_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.reported<int8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_DELAY) {
            uic_mqtt_dotdot_aox_locator_angle_correction_delay_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.reported<int8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_MODE) {
            uic_mqtt_dotdot_aox_locator_cte_mode_publish(
              base_topic.str().c_str(),
              static_cast<uint8_t>(attr.reported<uint8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_SAMPLING_INTERVAL) {
            uic_mqtt_dotdot_aox_locator_cte_sampling_interval_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.reported<int8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_LENGTH) {
            uic_mqtt_dotdot_aox_locator_cte_length_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.reported<int8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
              if (attr_node_type == DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_SLOT_DURATION) {
            uic_mqtt_dotdot_aox_locator_slot_duration_publish(
              base_topic.str().c_str(),
              static_cast<int8_t>(attr.reported<int8_t>()),
              attr.desired_exists() ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);

          return;
        }
          } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks aox_locator
static sl_status_t aox_locator_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_aox_locator_state_t attributes,
  uic_mqtt_dotdot_aox_locator_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
            if (DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_REPORTING_MODE == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION_VALID == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AZIMUTH_MASK == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ELEVATION_MASK == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ALLOW_LIST == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AOX_MODE == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_MODE == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_ARRAY == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_PERIOD_SAMPLES == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING_WEIGHT == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_TIMEOUT == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_DELAY == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_MODE == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_SAMPLING_INTERVAL == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_LENGTH == child.type()) {
              return SL_STATUS_OK;
            }
            if (DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_SLOT_DURATION == child.type()) {
              return SL_STATUS_OK;
            }
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "aox_locator: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;
      if (updated_attributes.reporting_mode) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_REPORTING_MODE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.reporting_mode);
                  }
      }
      if (updated_attributes.position_and_orientation_valid) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION_VALID);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.position_and_orientation_valid);
                  }
      }
      if (updated_attributes.position_and_orientation) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION);
        if (updated_node.is_valid()) {
          // Skip attribute PositionAndOrientation because it is a struct,
          // we typically don't save them as structs in the attribute store.
          sl_log_error(LOG_TAG,
                       "Error, skipping to change the desired value of PositionAndOrientation, "
                       "because it is a complicated type (struct: CoordinateAndOrientation). "
                       "Please change the code to do this manually.");
        }
      }
      if (updated_attributes.azimuth_mask) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AZIMUTH_MASK);
        if (updated_node.is_valid()) {
          // Skip attribute AzimuthMask because it is an array,
          // we typically don't save them as array in the attribute store.
          sl_log_error(LOG_TAG,
                       "Error, skipping to change the desired value of AzimuthMask, "
                       "because it is a complicated type (array: MinMaxPair). "
                       "Please change the code to do this manually.");
        }
      }
      if (updated_attributes.elevation_mask) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ELEVATION_MASK);
        if (updated_node.is_valid()) {
          // Skip attribute ElevationMask because it is an array,
          // we typically don't save them as array in the attribute store.
          sl_log_error(LOG_TAG,
                       "Error, skipping to change the desired value of ElevationMask, "
                       "because it is a complicated type (array: MinMaxPair). "
                       "Please change the code to do this manually.");
        }
      }
      if (updated_attributes.allow_list) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ALLOW_LIST);
        if (updated_node.is_valid()) {
          // Skip attribute AllowList because it is an array,
          // we typically don't save them as array in the attribute store.
          sl_log_error(LOG_TAG,
                       "Error, skipping to change the desired value of AllowList, "
                       "because it is a complicated type (array: string). "
                       "Please change the code to do this manually.");
        }
      }
      if (updated_attributes.aox_mode) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AOX_MODE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.aox_mode);
                  }
      }
      if (updated_attributes.antenna_mode) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_MODE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.antenna_mode);
                  }
      }
      if (updated_attributes.antenna_array) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_ARRAY);
        if (updated_node.is_valid()) {
          // Skip attribute AntennaArray because it is an array,
          // we typically don't save them as array in the attribute store.
          sl_log_error(LOG_TAG,
                       "Error, skipping to change the desired value of AntennaArray, "
                       "because it is a complicated type (array: int8). "
                       "Please change the code to do this manually.");
        }
      }
      if (updated_attributes.period_samples) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_PERIOD_SAMPLES);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.period_samples);
                  }
      }
      if (updated_attributes.angle_filtering) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.angle_filtering);
                  }
      }
      if (updated_attributes.angle_filtering_weight) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING_WEIGHT);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.angle_filtering_weight);
                  }
      }
      if (updated_attributes.angle_correction_timeout) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_TIMEOUT);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.angle_correction_timeout);
                  }
      }
      if (updated_attributes.angle_correction_delay) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_DELAY);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.angle_correction_delay);
                  }
      }
      if (updated_attributes.cte_mode) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_MODE);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.cte_mode);
                  }
      }
      if (updated_attributes.cte_sampling_interval) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_SAMPLING_INTERVAL);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.cte_sampling_interval);
                  }
      }
      if (updated_attributes.cte_length) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_LENGTH);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.cte_length);
                  }
      }
      if (updated_attributes.slot_duration) {
        updated_node = attr.child_by_type(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_SLOT_DURATION);
        if (updated_node.is_valid()) {
            attribute_store_set_desired_number(updated_node,attributes.slot_duration);
                  }
      }

  return SL_STATUS_OK;
}

static void aox_locator_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/AoXLocator/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_aox_locator_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster aox_position_estimation
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void aox_position_estimation_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"aox_position_estimation_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
      // Skip attribute Position because it is a struct,
      // we typically don't save them as structs in the attribute store.
    } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void aox_position_estimation_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"aox_position_estimation_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
      // Skip attribute Position because it is a struct,
      // we typically don't save them as structs in the attribute store.
    } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks aox_position_estimation
static sl_status_t aox_position_estimation_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_aox_position_estimation_state_t attributes,
  uic_mqtt_dotdot_aox_position_estimation_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "aox_position_estimation: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;

  return SL_STATUS_OK;
}

static void aox_position_estimation_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);
  base_topic << "/ep"<< std::to_string(endpoint_id);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/AoXPositionEstimation/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_aox_position_estimation_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}
////////////////////////////////////////////////////////////////////////////////
// Start of cluster protocol_controller_network_management
////////////////////////////////////////////////////////////////////////////////
//Publishing the desired attribute state
static void protocol_controller_network_management_cluster_attrs_desired_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"protocol_controller_network_management_cluster_attrs_desired_state_publisher_callback");

  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
      // Skip attribute NetworkManagementState because it is a struct,
      // we typically don't save them as structs in the attribute store.
    } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
    }
  }

}

//Publishing the Reported attribute state
static void protocol_controller_network_management_cluster_attrs_reported_state_publisher_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED){
    return;
  }
  //sl_log_debug(LOG_TAG,"protocol_controller_network_management_cluster_attrs_reported_state_publisher_callback");
  // Get the UNID and EndPoint, and prepare the basic topic
  std::stringstream base_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  if (unid_ep_status != SL_STATUS_OK) {
    sl_log_warning(LOG_TAG,
                  "Cannot determine UNID / Endpoint ID from Attribute Store node %d",
                  updated_node);
    return;
  }

  base_topic << "ucl/by-unid/" << std::string(unid);

  attribute_store_type_t attr_node_type = attribute_store_get_node_type(updated_node);
  if (attr_node_type != ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
    try {
      attribute_store::attribute attr(updated_node);
      // Skip attribute NetworkManagementState because it is a struct,
      // we typically don't save them as structs in the attribute store.
    } catch (std::exception &ex) {
      sl_log_warning(LOG_TAG, "Failed to publish Reported attribute value: %s", ex.what());
    }
  }
}

// WriteAttribute Callbacks protocol_controller_network_management
static sl_status_t protocol_controller_network_management_cluster_mapper_write_attributes_callback(
  const char* unid,
  const uint8_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_protocol_controller_network_management_state_t attributes,
  uic_mqtt_dotdot_protocol_controller_network_management_updated_state_t updated_attributes)
{
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    attribute_store::attribute
      endpoint_node(attribute_store_network_helper_get_endpoint_node(unid, endpoint));
    if (endpoint_node.is_valid()){
      for (const auto& child : endpoint_node.children()) {
      }
    }
    return SL_STATUS_NOT_AVAILABLE;
  }

  sl_log_debug(LOG_TAG,
               "protocol_controller_network_management: Incoming WriteAttributes command for %s, endpoint %d.\n",
               unid,
               endpoint);

  attribute_store_node_t endpoint_node
    = attribute_store_network_helper_get_endpoint_node(unid, endpoint);
  attribute_store::attribute attr(endpoint_node);
  attribute_store::attribute updated_node;

  return SL_STATUS_OK;
}

static void protocol_controller_network_management_cluster_attrs_creation_callback(
   attribute_store_node_t updated_node, attribute_store_change_t change)
{
  // Get the UNID and EndPoint, and prepare the cluster revision topic
  std::stringstream base_topic, revision_topic;
  unid_t unid;
  zwave_endpoint_id_t endpoint_id;
  sl_status_t unid_ep_status
    = attribute_store_network_helper_get_unid_endpoint_from_node(updated_node,
                                                                 unid,
                                                                 &endpoint_id);
  base_topic << "ucl/by-unid/" << std::string(unid);

  if (unid_ep_status == SL_STATUS_OK){
    revision_topic << base_topic.str() << "/ProtocolController/NetworkManagement/Attributes/ClusterRevision";
  } else {
    sl_log_debug(LOG_TAG, "Cannot find UNID and endpoint of %i attribute id", updated_node);
    return;
  }

  if (change == ATTRIBUTE_UPDATED){
    if (uic_mqtt_count_topics(revision_topic.str().c_str()) == 0){
      uic_mqtt_dotdot_protocol_controller_network_management_publish_cluster_revision(base_topic.str().c_str(), 1);
    }
  }

  if (change == ATTRIBUTE_DELETED) {
    // If the an attribute under a given cluster is deleted, we believe
    // that the mapper engine will delete all attributes per the cluster
    // therefore we unretain the ClusterRevision mqtt publication
     if ((uic_mqtt_count_topics(revision_topic.str().c_str()) != 0)) {
      uic_mqtt_unretain(revision_topic.str().c_str());
    }
  }
}

// Create a set of attribute types per Cluster
const std::set<attribute_store_type_t> zcl_basic_attributes {
 (attribute_store_type_t) 0xba5c0000,
 (attribute_store_type_t) 0xba5c0001,
 (attribute_store_type_t) 0xba5c0002,
 (attribute_store_type_t) 0xba5c0003,
 (attribute_store_type_t) 0xba5c0004,
 (attribute_store_type_t) 0xba5c0005,
 (attribute_store_type_t) 0xba5c0006,
 (attribute_store_type_t) 0xba5c0007,
 (attribute_store_type_t) 0xba5c0008,
 (attribute_store_type_t) 0xba5c0009,
 (attribute_store_type_t) 0xba5c000a,
 (attribute_store_type_t) 0xba5c000b,
 (attribute_store_type_t) 0xba5c000c,
 (attribute_store_type_t) 0xba5c000d,
 (attribute_store_type_t) 0xba5c000e,
 (attribute_store_type_t) 0xba5c0010,
 (attribute_store_type_t) 0xba5c0011,
 (attribute_store_type_t) 0xba5c0012,
 (attribute_store_type_t) 0xba5c0013,
 (attribute_store_type_t) 0xba5c0014,
 (attribute_store_type_t) 0xba5c4000
};
const std::set<attribute_store_type_t> zcl_power_configuration_attributes {
 (attribute_store_type_t) 0x00010000,
 (attribute_store_type_t) 0x00010001,
 (attribute_store_type_t) 0x00010010,
 (attribute_store_type_t) 0x00010011,
 (attribute_store_type_t) 0x00010012,
 (attribute_store_type_t) 0x00010013,
 (attribute_store_type_t) 0x00010020,
 (attribute_store_type_t) 0x00010021,
 (attribute_store_type_t) 0x00010030,
 (attribute_store_type_t) 0x00010031,
 (attribute_store_type_t) 0x00010032,
 (attribute_store_type_t) 0x00010033,
 (attribute_store_type_t) 0x00010034,
 (attribute_store_type_t) 0x00010035,
 (attribute_store_type_t) 0x00010036,
 (attribute_store_type_t) 0x00010037,
 (attribute_store_type_t) 0x00010038,
 (attribute_store_type_t) 0x00010039,
 (attribute_store_type_t) 0x0001003a,
 (attribute_store_type_t) 0x0001003b,
 (attribute_store_type_t) 0x0001003c,
 (attribute_store_type_t) 0x0001003d,
 (attribute_store_type_t) 0x0001003e,
 (attribute_store_type_t) 0x00010040,
 (attribute_store_type_t) 0x00010041,
 (attribute_store_type_t) 0x00010050,
 (attribute_store_type_t) 0x00010051,
 (attribute_store_type_t) 0x00010052,
 (attribute_store_type_t) 0x00010053,
 (attribute_store_type_t) 0x00010054,
 (attribute_store_type_t) 0x00010055,
 (attribute_store_type_t) 0x00010056,
 (attribute_store_type_t) 0x00010057,
 (attribute_store_type_t) 0x00010058,
 (attribute_store_type_t) 0x00010059,
 (attribute_store_type_t) 0x0001005a,
 (attribute_store_type_t) 0x0001005b,
 (attribute_store_type_t) 0x0001005c,
 (attribute_store_type_t) 0x0001005d,
 (attribute_store_type_t) 0x0001005e,
 (attribute_store_type_t) 0x00010060,
 (attribute_store_type_t) 0x00010061,
 (attribute_store_type_t) 0x00010070,
 (attribute_store_type_t) 0x00010071,
 (attribute_store_type_t) 0x00010072,
 (attribute_store_type_t) 0x00010073,
 (attribute_store_type_t) 0x00010074,
 (attribute_store_type_t) 0x00010075,
 (attribute_store_type_t) 0x00010076,
 (attribute_store_type_t) 0x00010077,
 (attribute_store_type_t) 0x00010078,
 (attribute_store_type_t) 0x00010079,
 (attribute_store_type_t) 0x0001007a,
 (attribute_store_type_t) 0x0001007b,
 (attribute_store_type_t) 0x0001007c,
 (attribute_store_type_t) 0x0001007d,
 (attribute_store_type_t) 0x0001007e
};
const std::set<attribute_store_type_t> zcl_device_temperature_configuration_attributes {
 (attribute_store_type_t) 0x00020000,
 (attribute_store_type_t) 0x00020001,
 (attribute_store_type_t) 0x00020002,
 (attribute_store_type_t) 0x00020003,
 (attribute_store_type_t) 0x00020010,
 (attribute_store_type_t) 0x00020011,
 (attribute_store_type_t) 0x00020012,
 (attribute_store_type_t) 0x00020013,
 (attribute_store_type_t) 0x00020014
};
const std::set<attribute_store_type_t> zcl_identify_attributes {
 (attribute_store_type_t) 0x00030000
};
const std::set<attribute_store_type_t> zcl_groups_attributes {
 (attribute_store_type_t) 0x00040000
};
const std::set<attribute_store_type_t> zcl_scenes_attributes {
 (attribute_store_type_t) 0x00050000,
 (attribute_store_type_t) 0x00050001,
 (attribute_store_type_t) 0x00050002,
 (attribute_store_type_t) 0x00050003,
 (attribute_store_type_t) 0x00050004,
 (attribute_store_type_t) 0x00050005
};
const std::set<attribute_store_type_t> zcl_on_off_attributes {
 (attribute_store_type_t) 0x00060000,
 (attribute_store_type_t) 0x00064000,
 (attribute_store_type_t) 0x00064001,
 (attribute_store_type_t) 0x00064002,
 (attribute_store_type_t) 0x00064003
};
const std::set<attribute_store_type_t> zcl_level_attributes {
 (attribute_store_type_t) 0x00080000,
 (attribute_store_type_t) 0x00080001,
 (attribute_store_type_t) 0x00080002,
 (attribute_store_type_t) 0x00080003,
 (attribute_store_type_t) 0x00080004,
 (attribute_store_type_t) 0x00080005,
 (attribute_store_type_t) 0x00080006,
 (attribute_store_type_t) 0x0008000f,
 (attribute_store_type_t) 0x00080010,
 (attribute_store_type_t) 0x00080011,
 (attribute_store_type_t) 0x00080012,
 (attribute_store_type_t) 0x00080013,
 (attribute_store_type_t) 0x00080014,
 (attribute_store_type_t) 0x00084000
};
const std::set<attribute_store_type_t> zcl_alarms_attributes {
 (attribute_store_type_t) 0x00090000
};
const std::set<attribute_store_type_t> zcl_time_attributes {
 (attribute_store_type_t) 0x000a0000,
 (attribute_store_type_t) 0x000a0001,
 (attribute_store_type_t) 0x000a0002,
 (attribute_store_type_t) 0x000a0003,
 (attribute_store_type_t) 0x000a0004,
 (attribute_store_type_t) 0x000a0005,
 (attribute_store_type_t) 0x000a0006,
 (attribute_store_type_t) 0x000a0007,
 (attribute_store_type_t) 0x000a0008,
 (attribute_store_type_t) 0x000a0009
};
const std::set<attribute_store_type_t> zcl_ota_upgrade_attributes {
 (attribute_store_type_t) 0x00190000,
 (attribute_store_type_t) 0x00190001,
 (attribute_store_type_t) 0x00190002,
 (attribute_store_type_t) 0x00190003,
 (attribute_store_type_t) 0x00190004,
 (attribute_store_type_t) 0x00190005,
 (attribute_store_type_t) 0x00190006,
 (attribute_store_type_t) 0x00190007,
 (attribute_store_type_t) 0x00190008,
 (attribute_store_type_t) 0x00190009,
 (attribute_store_type_t) 0x0019000a,
 (attribute_store_type_t) 0x0019000b,
 (attribute_store_type_t) 0x0019000c
};
const std::set<attribute_store_type_t> zcl_poll_control_attributes {
 (attribute_store_type_t) 0x00200000,
 (attribute_store_type_t) 0x00200001,
 (attribute_store_type_t) 0x00200002,
 (attribute_store_type_t) 0x00200003,
 (attribute_store_type_t) 0x00200004,
 (attribute_store_type_t) 0x00200005,
 (attribute_store_type_t) 0x00200006
};
const std::set<attribute_store_type_t> zcl_shade_configuration_attributes {
 (attribute_store_type_t) 0x01000000,
 (attribute_store_type_t) 0x01000001,
 (attribute_store_type_t) 0x01000002,
 (attribute_store_type_t) 0x01000010,
 (attribute_store_type_t) 0x01000011
};
const std::set<attribute_store_type_t> zcl_door_lock_attributes {
 (attribute_store_type_t) 0x01010000,
 (attribute_store_type_t) 0x01010001,
 (attribute_store_type_t) 0x01010002,
 (attribute_store_type_t) 0x01010003,
 (attribute_store_type_t) 0x01010004,
 (attribute_store_type_t) 0x01010005,
 (attribute_store_type_t) 0x01010006,
 (attribute_store_type_t) 0x01010010,
 (attribute_store_type_t) 0x01010011,
 (attribute_store_type_t) 0x01010012,
 (attribute_store_type_t) 0x01010013,
 (attribute_store_type_t) 0x01010014,
 (attribute_store_type_t) 0x01010015,
 (attribute_store_type_t) 0x01010016,
 (attribute_store_type_t) 0x01010017,
 (attribute_store_type_t) 0x01010018,
 (attribute_store_type_t) 0x01010019,
 (attribute_store_type_t) 0x0101001a,
 (attribute_store_type_t) 0x01010020,
 (attribute_store_type_t) 0x01010021,
 (attribute_store_type_t) 0x01010022,
 (attribute_store_type_t) 0x01010023,
 (attribute_store_type_t) 0x01010024,
 (attribute_store_type_t) 0x01010025,
 (attribute_store_type_t) 0x01010026,
 (attribute_store_type_t) 0x01010027,
 (attribute_store_type_t) 0x01010028,
 (attribute_store_type_t) 0x01010029,
 (attribute_store_type_t) 0x0101002a,
 (attribute_store_type_t) 0x0101002b,
 (attribute_store_type_t) 0x01010030,
 (attribute_store_type_t) 0x01010031,
 (attribute_store_type_t) 0x01010032,
 (attribute_store_type_t) 0x01010033,
 (attribute_store_type_t) 0x01010034,
 (attribute_store_type_t) 0x01010040,
 (attribute_store_type_t) 0x01010041,
 (attribute_store_type_t) 0x01010042,
 (attribute_store_type_t) 0x01010043,
 (attribute_store_type_t) 0x01010044,
 (attribute_store_type_t) 0x01010045,
 (attribute_store_type_t) 0x01010046,
 (attribute_store_type_t) 0x01010047
};
const std::set<attribute_store_type_t> zcl_window_covering_attributes {
 (attribute_store_type_t) 0x01020000,
 (attribute_store_type_t) 0x01020001,
 (attribute_store_type_t) 0x01020002,
 (attribute_store_type_t) 0x01020003,
 (attribute_store_type_t) 0x01020004,
 (attribute_store_type_t) 0x01020005,
 (attribute_store_type_t) 0x01020006,
 (attribute_store_type_t) 0x01020007,
 (attribute_store_type_t) 0x01020008,
 (attribute_store_type_t) 0x01020009,
 (attribute_store_type_t) 0x01020100,
 (attribute_store_type_t) 0x01020101,
 (attribute_store_type_t) 0x01020102,
 (attribute_store_type_t) 0x01020103,
 (attribute_store_type_t) 0x01020104,
 (attribute_store_type_t) 0x01020105,
 (attribute_store_type_t) 0x01020106,
 (attribute_store_type_t) 0x01020107,
 (attribute_store_type_t) 0x01020108,
 (attribute_store_type_t) 0x01020109
};
const std::set<attribute_store_type_t> zcl_barrier_control_attributes {
 (attribute_store_type_t) 0x01030001,
 (attribute_store_type_t) 0x01030002,
 (attribute_store_type_t) 0x01030003,
 (attribute_store_type_t) 0x01030004,
 (attribute_store_type_t) 0x01030005,
 (attribute_store_type_t) 0x01030006,
 (attribute_store_type_t) 0x01030007,
 (attribute_store_type_t) 0x01030008,
 (attribute_store_type_t) 0x01030009,
 (attribute_store_type_t) 0x0103000a
};
const std::set<attribute_store_type_t> zcl_pump_configuration_and_control_attributes {
 (attribute_store_type_t) 0x02000000,
 (attribute_store_type_t) 0x02000001,
 (attribute_store_type_t) 0x02000002,
 (attribute_store_type_t) 0x02000003,
 (attribute_store_type_t) 0x02000004,
 (attribute_store_type_t) 0x02000005,
 (attribute_store_type_t) 0x02000006,
 (attribute_store_type_t) 0x02000007,
 (attribute_store_type_t) 0x02000008,
 (attribute_store_type_t) 0x02000009,
 (attribute_store_type_t) 0x0200000a,
 (attribute_store_type_t) 0x0200000b,
 (attribute_store_type_t) 0x0200000c,
 (attribute_store_type_t) 0x02000010,
 (attribute_store_type_t) 0x02000011,
 (attribute_store_type_t) 0x02000012,
 (attribute_store_type_t) 0x02000013,
 (attribute_store_type_t) 0x02000014,
 (attribute_store_type_t) 0x02000015,
 (attribute_store_type_t) 0x02000016,
 (attribute_store_type_t) 0x02000017,
 (attribute_store_type_t) 0x02000020,
 (attribute_store_type_t) 0x02000021,
 (attribute_store_type_t) 0x02000022
};
const std::set<attribute_store_type_t> zcl_thermostat_attributes {
 (attribute_store_type_t) 0x02010000,
 (attribute_store_type_t) 0x02010001,
 (attribute_store_type_t) 0x02010002,
 (attribute_store_type_t) 0x02010003,
 (attribute_store_type_t) 0x02010004,
 (attribute_store_type_t) 0x02010005,
 (attribute_store_type_t) 0x02010006,
 (attribute_store_type_t) 0x02010007,
 (attribute_store_type_t) 0x02010008,
 (attribute_store_type_t) 0x02010009,
 (attribute_store_type_t) 0x02010010,
 (attribute_store_type_t) 0x02010011,
 (attribute_store_type_t) 0x02010012,
 (attribute_store_type_t) 0x02010013,
 (attribute_store_type_t) 0x02010014,
 (attribute_store_type_t) 0x02010015,
 (attribute_store_type_t) 0x02010016,
 (attribute_store_type_t) 0x02010017,
 (attribute_store_type_t) 0x02010018,
 (attribute_store_type_t) 0x02010019,
 (attribute_store_type_t) 0x0201001a,
 (attribute_store_type_t) 0x0201001b,
 (attribute_store_type_t) 0x0201001c,
 (attribute_store_type_t) 0x0201001d,
 (attribute_store_type_t) 0x0201001e,
 (attribute_store_type_t) 0x02010020,
 (attribute_store_type_t) 0x02010021,
 (attribute_store_type_t) 0x02010022,
 (attribute_store_type_t) 0x02010023,
 (attribute_store_type_t) 0x02010024,
 (attribute_store_type_t) 0x02010025,
 (attribute_store_type_t) 0x02010029,
 (attribute_store_type_t) 0x02010030,
 (attribute_store_type_t) 0x02010031,
 (attribute_store_type_t) 0x02010032,
 (attribute_store_type_t) 0x02010034,
 (attribute_store_type_t) 0x02010035,
 (attribute_store_type_t) 0x02010036,
 (attribute_store_type_t) 0x02010037,
 (attribute_store_type_t) 0x02010038,
 (attribute_store_type_t) 0x02010039,
 (attribute_store_type_t) 0x0201003a,
 (attribute_store_type_t) 0x02010040,
 (attribute_store_type_t) 0x02010041,
 (attribute_store_type_t) 0x02010042,
 (attribute_store_type_t) 0x02010043,
 (attribute_store_type_t) 0x02010044,
 (attribute_store_type_t) 0x02010045,
 (attribute_store_type_t) 0x02010046,
 (attribute_store_type_t) 0x02010047
};
const std::set<attribute_store_type_t> zcl_fan_control_attributes {
 (attribute_store_type_t) 0x02020000,
 (attribute_store_type_t) 0x02020001
};
const std::set<attribute_store_type_t> zcl_dehumidification_control_attributes {
 (attribute_store_type_t) 0x02030000,
 (attribute_store_type_t) 0x02030001,
 (attribute_store_type_t) 0x02030010,
 (attribute_store_type_t) 0x02030011,
 (attribute_store_type_t) 0x02030012,
 (attribute_store_type_t) 0x02030013,
 (attribute_store_type_t) 0x02030014,
 (attribute_store_type_t) 0x02030015
};
const std::set<attribute_store_type_t> zcl_thermostat_user_interface_configuration_attributes {
 (attribute_store_type_t) 0x02040000,
 (attribute_store_type_t) 0x02040001,
 (attribute_store_type_t) 0x02040002
};
const std::set<attribute_store_type_t> zcl_color_control_attributes {
 (attribute_store_type_t) 0x03000000,
 (attribute_store_type_t) 0x03000001,
 (attribute_store_type_t) 0x03000002,
 (attribute_store_type_t) 0x03000003,
 (attribute_store_type_t) 0x03000004,
 (attribute_store_type_t) 0x03000005,
 (attribute_store_type_t) 0x03000006,
 (attribute_store_type_t) 0x03000007,
 (attribute_store_type_t) 0x03000008,
 (attribute_store_type_t) 0x0300000f,
 (attribute_store_type_t) 0x03000010,
 (attribute_store_type_t) 0x03000011,
 (attribute_store_type_t) 0x03000012,
 (attribute_store_type_t) 0x03000013,
 (attribute_store_type_t) 0x03000015,
 (attribute_store_type_t) 0x03000016,
 (attribute_store_type_t) 0x03000017,
 (attribute_store_type_t) 0x03000019,
 (attribute_store_type_t) 0x0300001a,
 (attribute_store_type_t) 0x0300001b,
 (attribute_store_type_t) 0x03000020,
 (attribute_store_type_t) 0x03000021,
 (attribute_store_type_t) 0x03000022,
 (attribute_store_type_t) 0x03000024,
 (attribute_store_type_t) 0x03000025,
 (attribute_store_type_t) 0x03000026,
 (attribute_store_type_t) 0x03000028,
 (attribute_store_type_t) 0x03000029,
 (attribute_store_type_t) 0x0300002a,
 (attribute_store_type_t) 0x03000030,
 (attribute_store_type_t) 0x03000031,
 (attribute_store_type_t) 0x03000032,
 (attribute_store_type_t) 0x03000033,
 (attribute_store_type_t) 0x03000034,
 (attribute_store_type_t) 0x03000036,
 (attribute_store_type_t) 0x03000037,
 (attribute_store_type_t) 0x03000038,
 (attribute_store_type_t) 0x0300003a,
 (attribute_store_type_t) 0x0300003b,
 (attribute_store_type_t) 0x0300003c,
 (attribute_store_type_t) 0x03004000,
 (attribute_store_type_t) 0x03004001,
 (attribute_store_type_t) 0x03004002,
 (attribute_store_type_t) 0x03004003,
 (attribute_store_type_t) 0x03004004,
 (attribute_store_type_t) 0x03004005,
 (attribute_store_type_t) 0x03004006,
 (attribute_store_type_t) 0x0300400a,
 (attribute_store_type_t) 0x0300400b,
 (attribute_store_type_t) 0x0300400c,
 (attribute_store_type_t) 0x0300400d,
 (attribute_store_type_t) 0x03004010
};
const std::set<attribute_store_type_t> zcl_ballast_configuration_attributes {
 (attribute_store_type_t) 0x03010000,
 (attribute_store_type_t) 0x03010001,
 (attribute_store_type_t) 0x03010002,
 (attribute_store_type_t) 0x03010010,
 (attribute_store_type_t) 0x03010011,
 (attribute_store_type_t) 0x03010012,
 (attribute_store_type_t) 0x03010013,
 (attribute_store_type_t) 0x03010014,
 (attribute_store_type_t) 0x03010015,
 (attribute_store_type_t) 0x03010020,
 (attribute_store_type_t) 0x03010030,
 (attribute_store_type_t) 0x03010031,
 (attribute_store_type_t) 0x03010032,
 (attribute_store_type_t) 0x03010033,
 (attribute_store_type_t) 0x03010034,
 (attribute_store_type_t) 0x03010035
};
const std::set<attribute_store_type_t> zcl_illuminance_measurement_attributes {
 (attribute_store_type_t) 0x04000000,
 (attribute_store_type_t) 0x04000001,
 (attribute_store_type_t) 0x04000002,
 (attribute_store_type_t) 0x04000003,
 (attribute_store_type_t) 0x04000004
};
const std::set<attribute_store_type_t> zcl_illuminance_level_sensing_attributes {
 (attribute_store_type_t) 0x04010000,
 (attribute_store_type_t) 0x04010001,
 (attribute_store_type_t) 0x04010010
};
const std::set<attribute_store_type_t> zcl_temperature_measurement_attributes {
 (attribute_store_type_t) 0x04020000,
 (attribute_store_type_t) 0x04020001,
 (attribute_store_type_t) 0x04020002,
 (attribute_store_type_t) 0x04020003
};
const std::set<attribute_store_type_t> zcl_pressure_measurement_attributes {
 (attribute_store_type_t) 0x04030000,
 (attribute_store_type_t) 0x04030001,
 (attribute_store_type_t) 0x04030002,
 (attribute_store_type_t) 0x04030003,
 (attribute_store_type_t) 0x04030010,
 (attribute_store_type_t) 0x04030011,
 (attribute_store_type_t) 0x04030012,
 (attribute_store_type_t) 0x04030013,
 (attribute_store_type_t) 0x04030014
};
const std::set<attribute_store_type_t> zcl_flow_measurement_attributes {
 (attribute_store_type_t) 0x04040000,
 (attribute_store_type_t) 0x04040001,
 (attribute_store_type_t) 0x04040002,
 (attribute_store_type_t) 0x04040003
};
const std::set<attribute_store_type_t> zcl_relativity_humidity_attributes {
 (attribute_store_type_t) 0x04050000,
 (attribute_store_type_t) 0x04050001,
 (attribute_store_type_t) 0x04050002,
 (attribute_store_type_t) 0x04050003
};
const std::set<attribute_store_type_t> zcl_occupancy_sensing_attributes {
 (attribute_store_type_t) 0x04060000,
 (attribute_store_type_t) 0x04060001,
 (attribute_store_type_t) 0x04060002,
 (attribute_store_type_t) 0x04060010,
 (attribute_store_type_t) 0x04060011,
 (attribute_store_type_t) 0x04060012,
 (attribute_store_type_t) 0x04060020,
 (attribute_store_type_t) 0x04060021,
 (attribute_store_type_t) 0x04060022,
 (attribute_store_type_t) 0x04060030,
 (attribute_store_type_t) 0x04060031,
 (attribute_store_type_t) 0x04060032
};
const std::set<attribute_store_type_t> zcl_ph_measurement_attributes {
 (attribute_store_type_t) 0x04090000,
 (attribute_store_type_t) 0x04090001,
 (attribute_store_type_t) 0x04090002,
 (attribute_store_type_t) 0x04090003
};
const std::set<attribute_store_type_t> zcl_electrical_conductivity_measurement_attributes {
 (attribute_store_type_t) 0x040a0000,
 (attribute_store_type_t) 0x040a0001,
 (attribute_store_type_t) 0x040a0002,
 (attribute_store_type_t) 0x040a0003
};
const std::set<attribute_store_type_t> zcl_wind_speed_measurement_attributes {
 (attribute_store_type_t) 0x040b0000,
 (attribute_store_type_t) 0x040b0001,
 (attribute_store_type_t) 0x040b0002,
 (attribute_store_type_t) 0x040b0003
};
const std::set<attribute_store_type_t> zcl_carbon_monoxide_attributes {
 (attribute_store_type_t) 0x040c0000,
 (attribute_store_type_t) 0x040c0001,
 (attribute_store_type_t) 0x040c0002,
 (attribute_store_type_t) 0x040c0003
};
const std::set<attribute_store_type_t> zcl_ias_zone_attributes {
 (attribute_store_type_t) 0x05000000,
 (attribute_store_type_t) 0x05000001,
 (attribute_store_type_t) 0x05000002,
 (attribute_store_type_t) 0x05000010,
 (attribute_store_type_t) 0x05000011,
 (attribute_store_type_t) 0x05000012,
 (attribute_store_type_t) 0x05000013
};
const std::set<attribute_store_type_t> zcl_iaswd_attributes {
 (attribute_store_type_t) 0x05020000
};
const std::set<attribute_store_type_t> zcl_metering_attributes {
 (attribute_store_type_t) 0x07020000,
 (attribute_store_type_t) 0x07020001,
 (attribute_store_type_t) 0x07020002,
 (attribute_store_type_t) 0x07020003,
 (attribute_store_type_t) 0x07020006,
 (attribute_store_type_t) 0x07020007,
 (attribute_store_type_t) 0x07020008,
 (attribute_store_type_t) 0x07020009,
 (attribute_store_type_t) 0x0702000a,
 (attribute_store_type_t) 0x07020014,
 (attribute_store_type_t) 0x07020015,
 (attribute_store_type_t) 0x07020016,
 (attribute_store_type_t) 0x07020017,
 (attribute_store_type_t) 0x07020018,
 (attribute_store_type_t) 0x07020300,
 (attribute_store_type_t) 0x07020301,
 (attribute_store_type_t) 0x07020302,
 (attribute_store_type_t) 0x07020303,
 (attribute_store_type_t) 0x07020304,
 (attribute_store_type_t) 0x07020305,
 (attribute_store_type_t) 0x07020306,
 (attribute_store_type_t) 0x07020309,
 (attribute_store_type_t) 0x0702030a,
 (attribute_store_type_t) 0x0702030b,
 (attribute_store_type_t) 0x0702030c,
 (attribute_store_type_t) 0x0702030d
};
const std::set<attribute_store_type_t> zcl_electrical_measurement_attributes {
 (attribute_store_type_t) 0x0b040000,
 (attribute_store_type_t) 0x0b040100,
 (attribute_store_type_t) 0x0b040101,
 (attribute_store_type_t) 0x0b040102,
 (attribute_store_type_t) 0x0b040103,
 (attribute_store_type_t) 0x0b040104,
 (attribute_store_type_t) 0x0b040105,
 (attribute_store_type_t) 0x0b040106,
 (attribute_store_type_t) 0x0b040107,
 (attribute_store_type_t) 0x0b040108,
 (attribute_store_type_t) 0x0b040200,
 (attribute_store_type_t) 0x0b040201,
 (attribute_store_type_t) 0x0b040202,
 (attribute_store_type_t) 0x0b040203,
 (attribute_store_type_t) 0x0b040204,
 (attribute_store_type_t) 0x0b040205,
 (attribute_store_type_t) 0x0b040300,
 (attribute_store_type_t) 0x0b040301,
 (attribute_store_type_t) 0x0b040302,
 (attribute_store_type_t) 0x0b040303,
 (attribute_store_type_t) 0x0b040304,
 (attribute_store_type_t) 0x0b040305,
 (attribute_store_type_t) 0x0b040306,
 (attribute_store_type_t) 0x0b040307,
 (attribute_store_type_t) 0x0b040308,
 (attribute_store_type_t) 0x0b040309,
 (attribute_store_type_t) 0x0b04030a,
 (attribute_store_type_t) 0x0b04030b,
 (attribute_store_type_t) 0x0b04030c,
 (attribute_store_type_t) 0x0b04030d,
 (attribute_store_type_t) 0x0b04030e,
 (attribute_store_type_t) 0x0b04030f,
 (attribute_store_type_t) 0x0b040310,
 (attribute_store_type_t) 0x0b040311,
 (attribute_store_type_t) 0x0b040312,
 (attribute_store_type_t) 0x0b040400,
 (attribute_store_type_t) 0x0b040401,
 (attribute_store_type_t) 0x0b040402,
 (attribute_store_type_t) 0x0b040403,
 (attribute_store_type_t) 0x0b040404,
 (attribute_store_type_t) 0x0b040405,
 (attribute_store_type_t) 0x0b040501,
 (attribute_store_type_t) 0x0b040502,
 (attribute_store_type_t) 0x0b040503,
 (attribute_store_type_t) 0x0b040505,
 (attribute_store_type_t) 0x0b040506,
 (attribute_store_type_t) 0x0b040507,
 (attribute_store_type_t) 0x0b040508,
 (attribute_store_type_t) 0x0b040509,
 (attribute_store_type_t) 0x0b04050a,
 (attribute_store_type_t) 0x0b04050b,
 (attribute_store_type_t) 0x0b04050c,
 (attribute_store_type_t) 0x0b04050d,
 (attribute_store_type_t) 0x0b04050e,
 (attribute_store_type_t) 0x0b04050f,
 (attribute_store_type_t) 0x0b040510,
 (attribute_store_type_t) 0x0b040511,
 (attribute_store_type_t) 0x0b040512,
 (attribute_store_type_t) 0x0b040513,
 (attribute_store_type_t) 0x0b040514,
 (attribute_store_type_t) 0x0b040515,
 (attribute_store_type_t) 0x0b040516,
 (attribute_store_type_t) 0x0b040517,
 (attribute_store_type_t) 0x0b040600,
 (attribute_store_type_t) 0x0b040601,
 (attribute_store_type_t) 0x0b040602,
 (attribute_store_type_t) 0x0b040603,
 (attribute_store_type_t) 0x0b040604,
 (attribute_store_type_t) 0x0b040605,
 (attribute_store_type_t) 0x0b040700,
 (attribute_store_type_t) 0x0b040701,
 (attribute_store_type_t) 0x0b040702,
 (attribute_store_type_t) 0x0b040800,
 (attribute_store_type_t) 0x0b040801,
 (attribute_store_type_t) 0x0b040802,
 (attribute_store_type_t) 0x0b040803,
 (attribute_store_type_t) 0x0b040804,
 (attribute_store_type_t) 0x0b040805,
 (attribute_store_type_t) 0x0b040806,
 (attribute_store_type_t) 0x0b040807,
 (attribute_store_type_t) 0x0b040808,
 (attribute_store_type_t) 0x0b040809,
 (attribute_store_type_t) 0x0b04080a,
 (attribute_store_type_t) 0x0b040901,
 (attribute_store_type_t) 0x0b040902,
 (attribute_store_type_t) 0x0b040903,
 (attribute_store_type_t) 0x0b040905,
 (attribute_store_type_t) 0x0b040906,
 (attribute_store_type_t) 0x0b040907,
 (attribute_store_type_t) 0x0b040908,
 (attribute_store_type_t) 0x0b040909,
 (attribute_store_type_t) 0x0b04090a,
 (attribute_store_type_t) 0x0b04090b,
 (attribute_store_type_t) 0x0b04090c,
 (attribute_store_type_t) 0x0b04090d,
 (attribute_store_type_t) 0x0b04090e,
 (attribute_store_type_t) 0x0b04090f,
 (attribute_store_type_t) 0x0b040910,
 (attribute_store_type_t) 0x0b040911,
 (attribute_store_type_t) 0x0b040912,
 (attribute_store_type_t) 0x0b040913,
 (attribute_store_type_t) 0x0b040914,
 (attribute_store_type_t) 0x0b040915,
 (attribute_store_type_t) 0x0b040916,
 (attribute_store_type_t) 0x0b040917,
 (attribute_store_type_t) 0x0b040a01,
 (attribute_store_type_t) 0x0b040a02,
 (attribute_store_type_t) 0x0b040a03,
 (attribute_store_type_t) 0x0b040a05,
 (attribute_store_type_t) 0x0b040a06,
 (attribute_store_type_t) 0x0b040a07,
 (attribute_store_type_t) 0x0b040a08,
 (attribute_store_type_t) 0x0b040a09,
 (attribute_store_type_t) 0x0b040a0a,
 (attribute_store_type_t) 0x0b040a0b,
 (attribute_store_type_t) 0x0b040a0c,
 (attribute_store_type_t) 0x0b040a0d,
 (attribute_store_type_t) 0x0b040a0e,
 (attribute_store_type_t) 0x0b040a0f,
 (attribute_store_type_t) 0x0b040a10,
 (attribute_store_type_t) 0x0b040a11,
 (attribute_store_type_t) 0x0b040a12,
 (attribute_store_type_t) 0x0b040a13,
 (attribute_store_type_t) 0x0b040a14,
 (attribute_store_type_t) 0x0b040a15,
 (attribute_store_type_t) 0x0b040a16,
 (attribute_store_type_t) 0x0b040a17
};
const std::set<attribute_store_type_t> zcl_diagnostics_attributes {
 (attribute_store_type_t) 0x0b050000,
 (attribute_store_type_t) 0x0b050001,
 (attribute_store_type_t) 0x0b050100,
 (attribute_store_type_t) 0x0b050101,
 (attribute_store_type_t) 0x0b050102,
 (attribute_store_type_t) 0x0b050103,
 (attribute_store_type_t) 0x0b050104,
 (attribute_store_type_t) 0x0b050105,
 (attribute_store_type_t) 0x0b050106,
 (attribute_store_type_t) 0x0b050107,
 (attribute_store_type_t) 0x0b050108,
 (attribute_store_type_t) 0x0b050109,
 (attribute_store_type_t) 0x0b05010a,
 (attribute_store_type_t) 0x0b05010b,
 (attribute_store_type_t) 0x0b05010c,
 (attribute_store_type_t) 0x0b05010d,
 (attribute_store_type_t) 0x0b05010e,
 (attribute_store_type_t) 0x0b05010f,
 (attribute_store_type_t) 0x0b050110,
 (attribute_store_type_t) 0x0b050111,
 (attribute_store_type_t) 0x0b050112,
 (attribute_store_type_t) 0x0b050113,
 (attribute_store_type_t) 0x0b050114,
 (attribute_store_type_t) 0x0b050115,
 (attribute_store_type_t) 0x0b050116,
 (attribute_store_type_t) 0x0b050117,
 (attribute_store_type_t) 0x0b050118,
 (attribute_store_type_t) 0x0b050119,
 (attribute_store_type_t) 0x0b05011a,
 (attribute_store_type_t) 0x0b05011b,
 (attribute_store_type_t) 0x0b05011c,
 (attribute_store_type_t) 0x0b05011d
};
const std::set<attribute_store_type_t> zcl_protocol_controller_rf_telemetry_attributes {
 (attribute_store_type_t) 0xfd010000,
 (attribute_store_type_t) 0xfd010001
};
const std::set<attribute_store_type_t> zcl_state_attributes {
 (attribute_store_type_t) 0xfd020000
};
const std::set<attribute_store_type_t> zcl_binding_attributes {
 (attribute_store_type_t) 0xfd030000,
 (attribute_store_type_t) 0xfd030001,
 (attribute_store_type_t) 0xfd030002
};
const std::set<attribute_store_type_t> zcl_system_metrics_attributes {
 (attribute_store_type_t) 0xfd040000,
 (attribute_store_type_t) 0xfd040010,
 (attribute_store_type_t) 0xfd040011,
 (attribute_store_type_t) 0xfd040012,
 (attribute_store_type_t) 0xfd040013,
 (attribute_store_type_t) 0xfd040014,
 (attribute_store_type_t) 0xfd040020,
 (attribute_store_type_t) 0xfd040021,
 (attribute_store_type_t) 0xfd040022,
 (attribute_store_type_t) 0xfd040023,
 (attribute_store_type_t) 0xfd040024,
 (attribute_store_type_t) 0xfd040025,
 (attribute_store_type_t) 0xfd040026,
 (attribute_store_type_t) 0xfd040027,
 (attribute_store_type_t) 0xfd040028,
 (attribute_store_type_t) 0xfd040030,
 (attribute_store_type_t) 0xfd040031,
 (attribute_store_type_t) 0xfd040032,
 (attribute_store_type_t) 0xfd040033,
 (attribute_store_type_t) 0xfd040040,
 (attribute_store_type_t) 0xfd040050,
 (attribute_store_type_t) 0xfd040051,
 (attribute_store_type_t) 0xfd040052,
 (attribute_store_type_t) 0xfd040053,
 (attribute_store_type_t) 0xfd040060,
 (attribute_store_type_t) 0xfd040061,
 (attribute_store_type_t) 0xfd040070
};
const std::set<attribute_store_type_t> zcl_application_monitoring_attributes {
 (attribute_store_type_t) 0xfd050000,
 (attribute_store_type_t) 0xfd050001,
 (attribute_store_type_t) 0xfd050002,
 (attribute_store_type_t) 0xfd050005,
 (attribute_store_type_t) 0xfd050010,
 (attribute_store_type_t) 0xfd050011,
 (attribute_store_type_t) 0xfd050012,
 (attribute_store_type_t) 0xfd050013,
 (attribute_store_type_t) 0xfd050021,
 (attribute_store_type_t) 0xfd050022,
 (attribute_store_type_t) 0xfd050030,
 (attribute_store_type_t) 0xfd050031,
 (attribute_store_type_t) 0xfd050032,
 (attribute_store_type_t) 0xfd050033,
 (attribute_store_type_t) 0xfd050034,
 (attribute_store_type_t) 0xfd050035,
 (attribute_store_type_t) 0xfd050036,
 (attribute_store_type_t) 0xfd050040,
 (attribute_store_type_t) 0xfd050041,
 (attribute_store_type_t) 0xfd050042,
 (attribute_store_type_t) 0xfd050043,
 (attribute_store_type_t) 0xfd050044,
 (attribute_store_type_t) 0xfd050045
};
const std::set<attribute_store_type_t> zcl_name_and_location_attributes {
 (attribute_store_type_t) 0xfd060000,
 (attribute_store_type_t) 0xfd060001
};
const std::set<attribute_store_type_t> zcl_configuration_parameters_attributes {
 (attribute_store_type_t) 0xfd070000
};
const std::set<attribute_store_type_t> zcl_aox_locator_attributes {
 (attribute_store_type_t) 0xfd100001,
 (attribute_store_type_t) 0xfd100002,
 (attribute_store_type_t) 0xfd100003,
 (attribute_store_type_t) 0xfd100005,
 (attribute_store_type_t) 0xfd100006,
 (attribute_store_type_t) 0xfd100007,
 (attribute_store_type_t) 0xfd100008,
 (attribute_store_type_t) 0xfd100009,
 (attribute_store_type_t) 0xfd10000a,
 (attribute_store_type_t) 0xfd10000b,
 (attribute_store_type_t) 0xfd10000c,
 (attribute_store_type_t) 0xfd10000d,
 (attribute_store_type_t) 0xfd10000e,
 (attribute_store_type_t) 0xfd10000f,
 (attribute_store_type_t) 0xfd100010,
 (attribute_store_type_t) 0xfd100011,
 (attribute_store_type_t) 0xfd100012,
 (attribute_store_type_t) 0xfd100013
};
const std::set<attribute_store_type_t> zcl_aox_position_estimation_attributes {
 (attribute_store_type_t) 0xfd110001
};
const std::set<attribute_store_type_t> zcl_protocol_controller_network_management_attributes {
 (attribute_store_type_t) 0xfd120001
};

// clang-format on
/**
 * @brief Wrapper that calls on_pan_node_interview_done. This function matches
 * the attribute_timeout_callback_t signature
 *
 * @param updated_node Network Status node.
 */
static void
  on_pan_node_interview_done_callback(attribute_store_node_t updated_node)
{
  on_pan_node_interview_done(updated_node, ATTRIBUTE_UPDATED);
}
// clang-format off

// A Network Status callback function which will be called when
// a node is included and interviewed and publish all supported
// dotdot cluster commands per each endpoint
static void on_pan_node_interview_done(attribute_store_node_t updated_node,
                                       attribute_store_change_t change)
{
  if (attribute_store_is_value_defined(updated_node, REPORTED_ATTRIBUTE)
      == false) {
    return;
  }
  node_state_topic_state_t network_status = NODE_STATE_TOPIC_STATE_UNAVAILABLE;
  attribute_store_get_reported(updated_node,
                               &network_status,
                               sizeof(network_status));
  if ((network_status == NODE_STATE_TOPIC_STATE_NODEID_ASSIGNED)
      || (network_status == NODE_STATE_TOPIC_STATE_UNAVAILABLE)) {
    // Wait for the node to be fully included before publishing anything.
    return;
  }
  if (attribute_mapper_has_pending_evaluations()) {
    // Wait that the mapper has reached a final state.
    // Try again in 200 ms
    sl_log_debug(LOG_TAG,
                   "Mapper is still working. "
                   "Postponing DotDot attribute publications by 200ms.");
    attribute_timeout_set_callback(updated_node,
                                   200,
                                   &on_pan_node_interview_done_callback);
    return;
  }

  try {
    unid_t unid                     = "\0";
    zwave_endpoint_id_t endpoint_id = 0;
    sl_status_t status_unid
      = attribute_store_network_helper_get_unid_from_node(updated_node, unid);
    attribute_store::attribute node_id_node
      = attribute_store_get_first_parent_with_type(updated_node,
                                                   ATTRIBUTE_NODE_ID);

   if (network_status == NODE_STATE_TOPIC_STATE_INCLUDED) {
      if (status_unid == SL_STATUS_OK){
        for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID)) {
          // Publish the SupportedCommands if the node has just become functional
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();
          uic_mqtt_dotdot_publish_supported_commands(unid, endpoint_id);
        }
      }
    } else if ((network_status == NODE_STATE_TOPIC_STATE_INTERVIEW_FAIL)
                || (network_status == NODE_STATE_TOPIC_INTERVIEWING)
                || (network_status == NODE_STATE_TOPIC_STATE_OFFLINE)) {
      // unretain SupportedCommands during node interview and fail
      std::string topic_no_commands;
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/Basic/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/PowerConfiguration/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/DeviceTemperatureConfiguration/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/Identify/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/Groups/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/Scenes/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/OnOff/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/Level/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/Alarms/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/Time/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/Commissioning/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/OTAUpgrade/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/PollControl/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/ShadeConfiguration/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/DoorLock/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/WindowCovering/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/BarrierControl/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/PumpConfigurationAndControl/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/Thermostat/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/FanControl/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/DehumidificationControl/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/ThermostatUserInterfaceConfiguration/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/ColorControl/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/BallastConfiguration/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/IlluminanceMeasurement/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/IlluminanceLevelSensing/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/TemperatureMeasurement/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/PressureMeasurement/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/FlowMeasurement/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/RelativityHumidity/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/OccupancySensing/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/PhMeasurement/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/ElectricalConductivityMeasurement/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/WindSpeedMeasurement/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/CarbonMonoxide/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/IASZone/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/IASACE/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/IASWD/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/Metering/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/ElectricalMeasurement/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/Diagnostics/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/TouchlinkCommissioning/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ProtocolController/RFTelemetry/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/State/SupportedCommands";
          if ((network_status == NODE_STATE_TOPIC_INTERVIEWING)
               || (network_status == NODE_STATE_TOPIC_STATE_INTERVIEW_FAIL)) {
            // If state is interviewing or interview fail we publish all available commands
            std::string message_interview = R"({"value": ["Interview", "DiscoverNeighbors", "RemoveOffline"]})";
            uic_mqtt_publish(topic_no_commands.c_str(), message_interview.c_str(), message_interview.size(), true);
          } else if (network_status == NODE_STATE_TOPIC_STATE_OFFLINE){
            // When the node state is offline we only publish RemoveOffline command
            std::string message = R"({"value": ["RemoveOffline"]})";
            uic_mqtt_publish(topic_no_commands.c_str(), message.c_str(), message.size(), true);
          }
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/Binding/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/SystemMetrics/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ApplicationMonitoring/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/NameAndLocation/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/ConfigurationParameters/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/AoXLocator/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ep" + std::to_string(endpoint_id);
          topic_no_commands += "/AoXPositionEstimation/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
      for(attribute_store::attribute endpoint_node : node_id_node.children(ATTRIBUTE_ENDPOINT_ID) ){
          endpoint_id = endpoint_node.reported<zwave_endpoint_id_t>();

          topic_no_commands = "ucl/by-unid/" + std::string(unid);
          topic_no_commands += "/ProtocolController/NetworkManagement/SupportedCommands";
          uic_mqtt_unretain(topic_no_commands.c_str());
      }
    } else {
      sl_log_warning(
        LOG_TAG,
        "Unknown network status: %d. "
        "SupportedCommands will not be published for UNID %s Ep %d",
        network_status,
        unid,
        endpoint_id);
    }
  } catch (std::exception &ex) {
    sl_log_warning(LOG_TAG, "Cannot publish supported commands %s", ex.what());
  }
}

// Initialization of the component.
sl_status_t dotdot_mqtt_topics_handler_init()
{
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_basic_write_attributes_callback(
    basic_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_ZCL_VERSION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_ZCL_VERSION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_ZCL_VERSION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_APPLICATION_VERSION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_APPLICATION_VERSION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_APPLICATION_VERSION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_STACK_VERSION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_STACK_VERSION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_STACK_VERSION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_HW_VERSION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_HW_VERSION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_HW_VERSION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_NAME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_NAME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_NAME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_MODEL_IDENTIFIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_MODEL_IDENTIFIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_MODEL_IDENTIFIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_DATE_CODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_DATE_CODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_DATE_CODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_POWER_SOURCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_POWER_SOURCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_POWER_SOURCE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_CLASS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_CLASS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_CLASS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_CODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_CODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_CODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCTURL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCTURL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCTURL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_VERSION_DETAILS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_VERSION_DETAILS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_VERSION_DETAILS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_SERIAL_NUMBER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_SERIAL_NUMBER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_SERIAL_NUMBER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_LABEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_LABEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_LABEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_LOCATION_DESCRIPTION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_LOCATION_DESCRIPTION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_LOCATION_DESCRIPTION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PHYSICAL_ENVIRONMENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PHYSICAL_ENVIRONMENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_PHYSICAL_ENVIRONMENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_DEVICE_ENABLED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_DEVICE_ENABLED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_DEVICE_ENABLED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_ALARM_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_ALARM_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_ALARM_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_DISABLE_LOCAL_CONFIG,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_DISABLE_LOCAL_CONFIG,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_DISABLE_LOCAL_CONFIG);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_SW_BUILDID,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      basic_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_SW_BUILDID,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      basic_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BASIC_SW_BUILDID);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_power_configuration_write_attributes_callback(
    power_configuration_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_FREQUENCY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_FREQUENCY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_FREQUENCY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_ALARM_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_ALARM_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_ALARM_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MIN_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MIN_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MIN_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MAX_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MAX_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MAX_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_DWELL_TRIP_POINT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_DWELL_TRIP_POINT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_DWELL_TRIP_POINT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_REMAINING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_REMAINING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_REMAINING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_MANUFACTURER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_MANUFACTURER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_MANUFACTURER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_SIZE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_SIZE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_SIZE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERYA_HR_RATING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERYA_HR_RATING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERYA_HR_RATING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_QUANTITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_QUANTITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_QUANTITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_RATED_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_RATED_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_RATED_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_MIN_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_MIN_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_MIN_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD1,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD1,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD1);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD2,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD2,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD2);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD3,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD3,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD3);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_MIN_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_MIN_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_MIN_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD1,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD1,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD1);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD2,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD2,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD2);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD3,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD3,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD3);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_STATE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_STATE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_STATE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_REMAINING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_REMAINING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_REMAINING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_MANUFACTURER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_MANUFACTURER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_MANUFACTURER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_SIZE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_SIZE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_SIZE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2A_HR_RATING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2A_HR_RATING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2A_HR_RATING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_QUANTITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_QUANTITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_QUANTITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_RATED_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_RATED_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_RATED_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_MIN_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_MIN_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_MIN_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD1,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD1,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD1);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD2,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD2,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD2);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD3,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD3,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD3);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_MIN_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_MIN_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_MIN_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD1,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD1,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD1);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD2,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD2,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD2);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD3,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD3,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD3);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_STATE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_STATE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_STATE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_REMAINING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_REMAINING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_REMAINING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_MANUFACTURER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_MANUFACTURER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_MANUFACTURER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_SIZE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_SIZE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_SIZE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3A_HR_RATING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3A_HR_RATING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3A_HR_RATING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_QUANTITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_QUANTITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_QUANTITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_RATED_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_RATED_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_RATED_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_MIN_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_MIN_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_MIN_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD1,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD1,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD1);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD2,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD2,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD2);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD3,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD3,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD3);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_MIN_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_MIN_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_MIN_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD1,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD1,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD1);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD2,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD2,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD2);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD3,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD3,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD3);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_STATE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      power_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_STATE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      power_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_STATE);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_device_temperature_configuration_write_attributes_callback(
    device_temperature_configuration_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_CURRENT_TEMPERATURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_CURRENT_TEMPERATURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      device_temperature_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_CURRENT_TEMPERATURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MIN_TEMP_EXPERIENCED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MIN_TEMP_EXPERIENCED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      device_temperature_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MIN_TEMP_EXPERIENCED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MAX_TEMP_EXPERIENCED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MAX_TEMP_EXPERIENCED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      device_temperature_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MAX_TEMP_EXPERIENCED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_OVER_TEMP_TOTAL_DWELL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_OVER_TEMP_TOTAL_DWELL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      device_temperature_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_OVER_TEMP_TOTAL_DWELL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_DEVICE_TEMP_ALARM_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_DEVICE_TEMP_ALARM_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      device_temperature_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_DEVICE_TEMP_ALARM_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      device_temperature_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      device_temperature_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_DWELL_TRIP_POINT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_DWELL_TRIP_POINT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      device_temperature_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_DWELL_TRIP_POINT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_DWELL_TRIP_POINT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      device_temperature_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_DWELL_TRIP_POINT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      device_temperature_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_DWELL_TRIP_POINT);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_identify_write_attributes_callback(
    identify_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      identify_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_IDENTIFY_IDENTIFY_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      identify_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_IDENTIFY_IDENTIFY_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      identify_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_IDENTIFY_IDENTIFY_TIME);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_groups_write_attributes_callback(
    groups_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      groups_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_GROUPS_NAME_SUPPORT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      groups_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_GROUPS_NAME_SUPPORT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      groups_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_GROUPS_NAME_SUPPORT);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_scenes_write_attributes_callback(
    scenes_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_COUNT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_COUNT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      scenes_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_COUNT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_SCENE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_SCENE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      scenes_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_SCENE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_GROUP,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_GROUP,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      scenes_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_GROUP);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_VALID,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_VALID,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      scenes_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_VALID);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_NAME_SUPPORT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_NAME_SUPPORT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      scenes_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_NAME_SUPPORT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_LAST_CONFIGURED_BY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      scenes_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_LAST_CONFIGURED_BY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      scenes_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SCENES_LAST_CONFIGURED_BY);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_on_off_write_attributes_callback(
    on_off_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      on_off_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_OFF,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      on_off_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_OFF,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      on_off_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_OFF);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      on_off_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_GLOBAL_SCENE_CONTROL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      on_off_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_GLOBAL_SCENE_CONTROL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      on_off_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_GLOBAL_SCENE_CONTROL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      on_off_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      on_off_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      on_off_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      on_off_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_OFF_WAIT_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      on_off_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_OFF_WAIT_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      on_off_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_OFF_WAIT_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      on_off_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_START_UP_ON_OFF,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      on_off_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_START_UP_ON_OFF,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      on_off_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ON_OFF_START_UP_ON_OFF);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_level_write_attributes_callback(
    level_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_REMAINING_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_REMAINING_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_REMAINING_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_FREQUENCY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_FREQUENCY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_FREQUENCY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_FREQUENCY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_FREQUENCY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_FREQUENCY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_FREQUENCY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_FREQUENCY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_FREQUENCY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_OPTIONS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_OPTIONS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_OPTIONS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_ON_OFF_TRANSITION_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_ON_OFF_TRANSITION_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_ON_OFF_TRANSITION_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_ON_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_ON_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_ON_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_ON_TRANSITION_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_ON_TRANSITION_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_ON_TRANSITION_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_OFF_TRANSITION_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_OFF_TRANSITION_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_OFF_TRANSITION_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_DEFAULT_MOVE_RATE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_DEFAULT_MOVE_RATE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_DEFAULT_MOVE_RATE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_START_UP_CURRENT_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      level_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_START_UP_CURRENT_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      level_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_LEVEL_START_UP_CURRENT_LEVEL);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_alarms_write_attributes_callback(
    alarms_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      alarms_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ALARMS_ALARM_COUNT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      alarms_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ALARMS_ALARM_COUNT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      alarms_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ALARMS_ALARM_COUNT);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_time_write_attributes_callback(
    time_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      time_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_TIME_STATUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_TIME_STATUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      time_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_TIME_STATUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_TIME_ZONE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_TIME_ZONE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      time_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_TIME_ZONE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_DST_START,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_DST_START,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      time_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_DST_START);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_DST_END,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_DST_END,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      time_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_DST_END);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_DST_SHIFT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_DST_SHIFT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      time_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_DST_SHIFT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_STANDARD_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_STANDARD_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      time_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_STANDARD_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_LOCAL_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_LOCAL_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      time_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_LOCAL_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_LAST_SET_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_LAST_SET_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      time_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_LAST_SET_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_VALID_UNTIL_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      time_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_VALID_UNTIL_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      time_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_TIME_VALID_UNTIL_TIME);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_ota_upgrade_write_attributes_callback(
    ota_upgrade_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_UPGRADE_SERVERID,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_UPGRADE_SERVERID,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ota_upgrade_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_UPGRADE_SERVERID);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_FILE_OFFSET,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_FILE_OFFSET,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ota_upgrade_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_FILE_OFFSET);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_CURRENT_FILE_VERSION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_CURRENT_FILE_VERSION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ota_upgrade_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_CURRENT_FILE_VERSION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_CURRENT_ZIG_BEE_STACK_VERSION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_CURRENT_ZIG_BEE_STACK_VERSION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ota_upgrade_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_CURRENT_ZIG_BEE_STACK_VERSION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_DOWNLOADED_FILE_VERSION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_DOWNLOADED_FILE_VERSION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ota_upgrade_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_DOWNLOADED_FILE_VERSION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_DOWNLOADED_ZIG_BEE_STACK_VERSION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_DOWNLOADED_ZIG_BEE_STACK_VERSION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ota_upgrade_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_DOWNLOADED_ZIG_BEE_STACK_VERSION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_IMAGE_UPGRADE_STATUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_IMAGE_UPGRADE_STATUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ota_upgrade_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_IMAGE_UPGRADE_STATUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_MANUFACTURERID,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_MANUFACTURERID,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ota_upgrade_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_MANUFACTURERID);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_IMAGE_TYPEID,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_IMAGE_TYPEID,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ota_upgrade_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_IMAGE_TYPEID);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_MINIMUM_BLOCK_PERIOD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_MINIMUM_BLOCK_PERIOD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ota_upgrade_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_MINIMUM_BLOCK_PERIOD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_IMAGE_STAMP,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_IMAGE_STAMP,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ota_upgrade_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_IMAGE_STAMP);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_UPGRADE_ACTIVATION_POLICY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_UPGRADE_ACTIVATION_POLICY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ota_upgrade_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_UPGRADE_ACTIVATION_POLICY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_UPGRADE_TIMEOUT_POLICY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ota_upgrade_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_UPGRADE_TIMEOUT_POLICY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ota_upgrade_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_UPGRADE_TIMEOUT_POLICY);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_poll_control_write_attributes_callback(
    poll_control_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      poll_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      poll_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_SHORT_POLL_INTERVAL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_SHORT_POLL_INTERVAL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      poll_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_SHORT_POLL_INTERVAL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      poll_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL_MIN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL_MIN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      poll_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL_MIN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL_MIN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL_MIN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      poll_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL_MIN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT_MAX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      poll_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT_MAX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      poll_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT_MAX);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_shade_configuration_write_attributes_callback(
    shade_configuration_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      shade_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_PHYSICAL_CLOSED_LIMIT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      shade_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_PHYSICAL_CLOSED_LIMIT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      shade_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_PHYSICAL_CLOSED_LIMIT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      shade_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MOTOR_STEP_SIZE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      shade_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MOTOR_STEP_SIZE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      shade_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MOTOR_STEP_SIZE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      shade_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_STATUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      shade_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_STATUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      shade_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_STATUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      shade_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_CLOSED_LIMIT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      shade_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_CLOSED_LIMIT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      shade_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_CLOSED_LIMIT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      shade_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      shade_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      shade_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MODE);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_door_lock_write_attributes_callback(
    door_lock_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_STATE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_STATE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_STATE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ACTUATOR_ENABLED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ACTUATOR_ENABLED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ACTUATOR_ENABLED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_STATE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_STATE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_STATE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_OPEN_EVENTS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_OPEN_EVENTS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_OPEN_EVENTS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_CLOSED_EVENTS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_CLOSED_EVENTS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_CLOSED_EVENTS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPEN_PERIOD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPEN_PERIOD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPEN_PERIOD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_LOG_RECORDS_SUPPORTED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_LOG_RECORDS_SUPPORTED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_LOG_RECORDS_SUPPORTED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_TOTAL_USERS_SUPPORTED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_TOTAL_USERS_SUPPORTED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_TOTAL_USERS_SUPPORTED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OFPIN_USERS_SUPPORTED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OFPIN_USERS_SUPPORTED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OFPIN_USERS_SUPPORTED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OFRFID_USERS_SUPPORTED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OFRFID_USERS_SUPPORTED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OFRFID_USERS_SUPPORTED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_WEEK_DAY_SCHEDULES_SUPPORTED_PER_USER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_WEEK_DAY_SCHEDULES_SUPPORTED_PER_USER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_WEEK_DAY_SCHEDULES_SUPPORTED_PER_USER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_YEAR_DAY_SCHEDULES_SUPPORTED_PER_USER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_YEAR_DAY_SCHEDULES_SUPPORTED_PER_USER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_YEAR_DAY_SCHEDULES_SUPPORTED_PER_USER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_HOLIDAY_SCHEDULES_SUPPORTED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_HOLIDAY_SCHEDULES_SUPPORTED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_HOLIDAY_SCHEDULES_SUPPORTED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAXPIN_CODE_LENGTH,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAXPIN_CODE_LENGTH,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAXPIN_CODE_LENGTH);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MINPIN_CODE_LENGTH,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MINPIN_CODE_LENGTH,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MINPIN_CODE_LENGTH);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAXRFID_CODE_LENGTH,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAXRFID_CODE_LENGTH,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAXRFID_CODE_LENGTH);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MINRFID_CODE_LENGTH,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MINRFID_CODE_LENGTH,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MINRFID_CODE_LENGTH);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOGGING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOGGING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOGGING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LANGUAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LANGUAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LANGUAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LED_SETTINGS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LED_SETTINGS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LED_SETTINGS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_AUTO_RELOCK_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_AUTO_RELOCK_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_AUTO_RELOCK_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SOUND_VOLUME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SOUND_VOLUME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SOUND_VOLUME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPERATING_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPERATING_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPERATING_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SUPPORTED_OPERATING_MODES,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SUPPORTED_OPERATING_MODES,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SUPPORTED_OPERATING_MODES);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DEFAULT_CONFIGURATION_REGISTER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DEFAULT_CONFIGURATION_REGISTER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DEFAULT_CONFIGURATION_REGISTER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOCAL_PROGRAMMING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOCAL_PROGRAMMING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOCAL_PROGRAMMING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_ONE_TOUCH_LOCKING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_ONE_TOUCH_LOCKING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_ONE_TOUCH_LOCKING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_INSIDE_STATUSLED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_INSIDE_STATUSLED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_INSIDE_STATUSLED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_PRIVACY_MODE_BUTTON,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_PRIVACY_MODE_BUTTON,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_PRIVACY_MODE_BUTTON);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_WRONG_CODE_ENTRY_LIMIT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_WRONG_CODE_ENTRY_LIMIT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_WRONG_CODE_ENTRY_LIMIT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_USER_CODE_TEMPORARY_DISABLE_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_USER_CODE_TEMPORARY_DISABLE_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_USER_CODE_TEMPORARY_DISABLE_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SENDPIN_OVER_THE_AIR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SENDPIN_OVER_THE_AIR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SENDPIN_OVER_THE_AIR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_REQUIREPI_NFORRF_OPERATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_REQUIREPI_NFORRF_OPERATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_REQUIREPI_NFORRF_OPERATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SECURITY_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SECURITY_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SECURITY_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ALARM_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ALARM_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ALARM_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_OPERATION_EVENT_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_OPERATION_EVENT_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_OPERATION_EVENT_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_OPERATION_EVENT_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_OPERATION_EVENT_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_OPERATION_EVENT_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MANUAL_OPERATION_EVENT_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MANUAL_OPERATION_EVENT_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MANUAL_OPERATION_EVENT_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_OPERATION_EVENT_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_OPERATION_EVENT_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_OPERATION_EVENT_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_PROGRAMMING_EVENT_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_PROGRAMMING_EVENT_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_PROGRAMMING_EVENT_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_PROGRAMMING_EVENT_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_PROGRAMMING_EVENT_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_PROGRAMMING_EVENT_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_PROGRAMMING_EVENT_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      door_lock_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_PROGRAMMING_EVENT_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      door_lock_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_PROGRAMMING_EVENT_MASK);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_window_covering_write_attributes_callback(
    window_covering_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_WINDOW_COVERING_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_WINDOW_COVERING_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_WINDOW_COVERING_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_LIFT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_LIFT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_LIFT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_TILT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_TILT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_TILT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_LIFT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_LIFT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_LIFT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_TILT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_TILT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_TILT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CONFIG_OR_STATUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CONFIG_OR_STATUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CONFIG_OR_STATUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT_PERCENTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT_PERCENTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT_PERCENTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT_PERCENTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT_PERCENTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT_PERCENTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_LIFT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_LIFT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_LIFT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_LIFT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_LIFT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_LIFT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_TILT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_TILT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_TILT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_TILT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_TILT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_TILT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_VELOCITY_LIFT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_VELOCITY_LIFT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_VELOCITY_LIFT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_ACCELERATION_TIME_LIFT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_ACCELERATION_TIME_LIFT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_ACCELERATION_TIME_LIFT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_DECELERATION_TIME_LIFT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_DECELERATION_TIME_LIFT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_DECELERATION_TIME_LIFT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_LIFT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_LIFT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_LIFT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_TILT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      window_covering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_TILT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      window_covering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_TILT);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_barrier_control_write_attributes_callback(
    barrier_control_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_MOVING_STATE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_MOVING_STATE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      barrier_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_MOVING_STATE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_SAFETY_STATUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_SAFETY_STATUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      barrier_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_SAFETY_STATUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CAPABILITIES,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CAPABILITIES,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      barrier_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CAPABILITIES);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_EVENTS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_EVENTS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      barrier_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_EVENTS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_EVENTS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_EVENTS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      barrier_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_EVENTS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_OPEN_EVENTS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_OPEN_EVENTS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      barrier_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_OPEN_EVENTS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_CLOSE_EVENTS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_CLOSE_EVENTS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      barrier_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_CLOSE_EVENTS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_PERIOD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_PERIOD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      barrier_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_PERIOD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_PERIOD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_PERIOD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      barrier_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_PERIOD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_BARRIER_POSITION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      barrier_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_BARRIER_POSITION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      barrier_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_BARRIER_POSITION);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_pump_configuration_and_control_write_attributes_callback(
    pump_configuration_and_control_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_PRESSURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_PRESSURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_PRESSURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_SPEED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_SPEED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_SPEED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_FLOW,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_FLOW,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_FLOW);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_PRESSURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_PRESSURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_PRESSURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_PRESSURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_PRESSURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_PRESSURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_COMP_PRESSURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_COMP_PRESSURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_COMP_PRESSURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_COMP_PRESSURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_COMP_PRESSURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_COMP_PRESSURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_SPEED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_SPEED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_SPEED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_SPEED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_SPEED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_SPEED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_FLOW,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_FLOW,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_FLOW);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_FLOW,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_FLOW,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_FLOW);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_TEMP,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_TEMP,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_TEMP);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_TEMP,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_TEMP,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_TEMP);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_PUMP_STATUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_PUMP_STATUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_PUMP_STATUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_OPERATION_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_OPERATION_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_OPERATION_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_CONTROL_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_CONTROL_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_CONTROL_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CAPACITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CAPACITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CAPACITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_SPEED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_SPEED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_SPEED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_RUNNING_HOURS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_RUNNING_HOURS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_RUNNING_HOURS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_POWER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_POWER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_POWER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_ENERGY_CONSUMED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_ENERGY_CONSUMED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_ENERGY_CONSUMED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_OPERATION_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_OPERATION_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_OPERATION_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CONTROL_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CONTROL_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CONTROL_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_ALARM_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pump_configuration_and_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_ALARM_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pump_configuration_and_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_ALARM_MASK);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_thermostat_write_attributes_callback(
    thermostat_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OUTDOOR_TEMPERATURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OUTDOOR_TEMPERATURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OUTDOOR_TEMPERATURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPANCY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPANCY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPANCY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_HEAT_SETPOINT_LIMIT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_HEAT_SETPOINT_LIMIT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_HEAT_SETPOINT_LIMIT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_HEAT_SETPOINT_LIMIT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_HEAT_SETPOINT_LIMIT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_HEAT_SETPOINT_LIMIT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_COOL_SETPOINT_LIMIT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_COOL_SETPOINT_LIMIT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_COOL_SETPOINT_LIMIT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_COOL_SETPOINT_LIMIT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_COOL_SETPOINT_LIMIT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_COOL_SETPOINT_LIMIT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_COOLING_DEMAND,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_COOLING_DEMAND,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_COOLING_DEMAND);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_HEATING_DEMAND,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_HEATING_DEMAND,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_HEATING_DEMAND);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_HVAC_SYSTEM_TYPE_CONFIGURATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_HVAC_SYSTEM_TYPE_CONFIGURATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_HVAC_SYSTEM_TYPE_CONFIGURATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE_CALIBRATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE_CALIBRATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE_CALIBRATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_COOLING_SETPOINT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_COOLING_SETPOINT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_COOLING_SETPOINT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_HEATING_SETPOINT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_HEATING_SETPOINT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_HEATING_SETPOINT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_COOLING_SETPOINT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_COOLING_SETPOINT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_COOLING_SETPOINT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_HEATING_SETPOINT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_HEATING_SETPOINT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_HEATING_SETPOINT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_HEAT_SETPOINT_LIMIT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_HEAT_SETPOINT_LIMIT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_HEAT_SETPOINT_LIMIT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_HEAT_SETPOINT_LIMIT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_HEAT_SETPOINT_LIMIT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_HEAT_SETPOINT_LIMIT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_COOL_SETPOINT_LIMIT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_COOL_SETPOINT_LIMIT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_COOL_SETPOINT_LIMIT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_COOL_SETPOINT_LIMIT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_COOL_SETPOINT_LIMIT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_COOL_SETPOINT_LIMIT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_SETPOINT_DEAD_BAND,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_SETPOINT_DEAD_BAND,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_SETPOINT_DEAD_BAND);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_REMOTE_SENSING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_REMOTE_SENSING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_REMOTE_SENSING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_CONTROL_SEQUENCE_OF_OPERATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_CONTROL_SEQUENCE_OF_OPERATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_CONTROL_SEQUENCE_OF_OPERATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SYSTEM_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SYSTEM_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SYSTEM_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ALARM_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ALARM_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ALARM_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_START_OF_WEEK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_START_OF_WEEK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_START_OF_WEEK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_WEEKLY_TRANSITIONS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_WEEKLY_TRANSITIONS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_WEEKLY_TRANSITIONS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_DAILY_TRANSITIONS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_DAILY_TRANSITIONS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_DAILY_TRANSITIONS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD_DURATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD_DURATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD_DURATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_PROGRAMMING_OPERATION_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_PROGRAMMING_OPERATION_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_PROGRAMMING_OPERATION_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_STATE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_STATE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_STATE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_AMOUNT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_AMOUNT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_AMOUNT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE_TIMESTAMP,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE_TIMESTAMP,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE_TIMESTAMP);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MIN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MIN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MIN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MAX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MAX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MAX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MIN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MIN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MIN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MAX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MAX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MAX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_EMERGENCY_HEAT_DELTA,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_EMERGENCY_HEAT_DELTA,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_EMERGENCY_HEAT_DELTA);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_REFRIGERANT_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_REFRIGERANT_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_REFRIGERANT_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COMPRESSOR_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COMPRESSOR_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COMPRESSOR_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_ERROR_CODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_ERROR_CODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_ERROR_CODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_LOUVER_POSITION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_LOUVER_POSITION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_LOUVER_POSITION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COIL_TEMPERATURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COIL_TEMPERATURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COIL_TEMPERATURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY_FORMAT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY_FORMAT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY_FORMAT);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_fan_control_write_attributes_callback(
    fan_control_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      fan_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      fan_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      fan_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      fan_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE_SEQUENCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      fan_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE_SEQUENCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      fan_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE_SEQUENCE);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_dehumidification_control_write_attributes_callback(
    dehumidification_control_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      dehumidification_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_COOLING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_COOLING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      dehumidification_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_COOLING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RH_DEHUMIDIFICATION_SETPOINT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RH_DEHUMIDIFICATION_SETPOINT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      dehumidification_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RH_DEHUMIDIFICATION_SETPOINT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      dehumidification_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_LOCKOUT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_LOCKOUT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      dehumidification_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_LOCKOUT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_HYSTERESIS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_HYSTERESIS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      dehumidification_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_HYSTERESIS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_MAX_COOL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_MAX_COOL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      dehumidification_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_MAX_COOL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_DISPLAY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      dehumidification_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_DISPLAY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      dehumidification_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_DISPLAY);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_thermostat_user_interface_configuration_write_attributes_callback(
    thermostat_user_interface_configuration_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_user_interface_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_TEMPERATURE_DISPLAY_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_user_interface_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_TEMPERATURE_DISPLAY_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_user_interface_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_TEMPERATURE_DISPLAY_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_user_interface_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_KEYPAD_LOCKOUT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_user_interface_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_KEYPAD_LOCKOUT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_user_interface_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_KEYPAD_LOCKOUT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_user_interface_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_SCHEDULE_PROGRAMMING_VISIBILITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      thermostat_user_interface_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_SCHEDULE_PROGRAMMING_VISIBILITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      thermostat_user_interface_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_SCHEDULE_PROGRAMMING_VISIBILITY);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_color_control_write_attributes_callback(
    color_control_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_HUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_HUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_HUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_SATURATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_SATURATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_SATURATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_REMAINING_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_REMAINING_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_REMAINING_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_DRIFT_COMPENSATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_DRIFT_COMPENSATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_DRIFT_COMPENSATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COMPENSATION_TEXT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COMPENSATION_TEXT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COMPENSATION_TEXT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMPERATURE_MIREDS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMPERATURE_MIREDS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMPERATURE_MIREDS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_OPTIONS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_OPTIONS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_OPTIONS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_NUMBER_OF_PRIMARIES,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_NUMBER_OF_PRIMARIES,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_NUMBER_OF_PRIMARIES);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1X,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1X,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1X);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1Y,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1Y,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1Y);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1_INTENSITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1_INTENSITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1_INTENSITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2X,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2X,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2X);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2Y,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2Y,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2Y);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2_INTENSITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2_INTENSITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2_INTENSITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3X,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3X,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3X);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3Y,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3Y,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3Y);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3_INTENSITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3_INTENSITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3_INTENSITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4X,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4X,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4X);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4Y,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4Y,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4Y);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4_INTENSITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4_INTENSITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4_INTENSITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5X,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5X,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5X);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5Y,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5Y,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5Y);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5_INTENSITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5_INTENSITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5_INTENSITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6X,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6X,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6X);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6Y,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6Y,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6Y);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6_INTENSITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6_INTENSITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6_INTENSITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTR_INTENSITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTR_INTENSITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTR_INTENSITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTG_INTENSITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTG_INTENSITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTG_INTENSITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTB_INTENSITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTB_INTENSITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTB_INTENSITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_CURRENT_HUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_CURRENT_HUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_CURRENT_HUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_COLOR_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_COLOR_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_COLOR_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_ACTIVE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_ACTIVE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_ACTIVE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_DIRECTION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_DIRECTION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_DIRECTION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_START_ENHANCED_HUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_START_ENHANCED_HUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_START_ENHANCED_HUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_STORED_ENHANCED_HUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_STORED_ENHANCED_HUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_STORED_ENHANCED_HUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_CAPABILITIES,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_CAPABILITIES,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_CAPABILITIES);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MIN_MIREDS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MIN_MIREDS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MIN_MIREDS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MAX_MIREDS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MAX_MIREDS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MAX_MIREDS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COUPLE_COLOR_TEMP_TO_LEVEL_MIN_MIREDS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COUPLE_COLOR_TEMP_TO_LEVEL_MIN_MIREDS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COUPLE_COLOR_TEMP_TO_LEVEL_MIN_MIREDS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_START_UP_COLOR_TEMPERATURE_MIREDS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      color_control_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_START_UP_COLOR_TEMPERATURE_MIREDS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      color_control_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_START_UP_COLOR_TEMPERATURE_MIREDS);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_ballast_configuration_write_attributes_callback(
    ballast_configuration_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MIN_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MIN_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MIN_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MAX_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MAX_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MAX_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_STATUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_STATUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_STATUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MIN_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MIN_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MIN_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MAX_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MAX_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MAX_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_FADE_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_FADE_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_FADE_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_INTRINSIC_BALLAST_FACTOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_INTRINSIC_BALLAST_FACTOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_INTRINSIC_BALLAST_FACTOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_FACTOR_ADJUSTMENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_FACTOR_ADJUSTMENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_FACTOR_ADJUSTMENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_QUANTITY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_QUANTITY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_QUANTITY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_MANUFACTURER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_MANUFACTURER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_MANUFACTURER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_RATED_HOURS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_RATED_HOURS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_RATED_HOURS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_ALARM_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_ALARM_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_ALARM_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS_TRIP_POINT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ballast_configuration_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS_TRIP_POINT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ballast_configuration_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS_TRIP_POINT);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_illuminance_measurement_write_attributes_callback(
    illuminance_measurement_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      illuminance_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MIN_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MIN_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      illuminance_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MIN_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MAX_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MAX_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      illuminance_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MAX_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_TOLERANCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_TOLERANCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      illuminance_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_TOLERANCE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_LIGHT_SENSOR_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_LIGHT_SENSOR_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      illuminance_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_LIGHT_SENSOR_TYPE);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_illuminance_level_sensing_write_attributes_callback(
    illuminance_level_sensing_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_level_sensing_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LEVEL_STATUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_level_sensing_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LEVEL_STATUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      illuminance_level_sensing_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LEVEL_STATUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_level_sensing_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LIGHT_SENSOR_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_level_sensing_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LIGHT_SENSOR_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      illuminance_level_sensing_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LIGHT_SENSOR_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_level_sensing_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_ILLUMINANCE_TARGET_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      illuminance_level_sensing_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_ILLUMINANCE_TARGET_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      illuminance_level_sensing_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_ILLUMINANCE_TARGET_LEVEL);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_temperature_measurement_write_attributes_callback(
    temperature_measurement_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      temperature_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      temperature_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      temperature_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      temperature_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MIN_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      temperature_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MIN_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      temperature_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MIN_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      temperature_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MAX_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      temperature_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MAX_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      temperature_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MAX_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      temperature_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_TOLERANCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      temperature_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_TOLERANCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      temperature_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_TOLERANCE);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_pressure_measurement_write_attributes_callback(
    pressure_measurement_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pressure_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pressure_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pressure_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_TOLERANCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_TOLERANCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pressure_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_TOLERANCE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pressure_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_SCALED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_SCALED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pressure_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_SCALED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_SCALED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_SCALED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pressure_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_SCALED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_TOLERANCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_TOLERANCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pressure_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_TOLERANCE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      pressure_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      pressure_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALE);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_flow_measurement_write_attributes_callback(
    flow_measurement_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      flow_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      flow_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      flow_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      flow_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MIN_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      flow_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MIN_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      flow_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MIN_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      flow_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MAX_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      flow_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MAX_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      flow_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MAX_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      flow_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_TOLERANCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      flow_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_TOLERANCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      flow_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_TOLERANCE);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_relativity_humidity_write_attributes_callback(
    relativity_humidity_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      relativity_humidity_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      relativity_humidity_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      relativity_humidity_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      relativity_humidity_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MIN_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      relativity_humidity_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MIN_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      relativity_humidity_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MIN_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      relativity_humidity_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MAX_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      relativity_humidity_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MAX_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      relativity_humidity_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MAX_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      relativity_humidity_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_TOLERANCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      relativity_humidity_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_TOLERANCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      relativity_humidity_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_TOLERANCE);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_occupancy_sensing_write_attributes_callback(
    occupancy_sensing_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE_BITMAP,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE_BITMAP,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE_BITMAP);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_OCCUPIED_TO_UNOCCUPIED_DELAY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_OCCUPIED_TO_UNOCCUPIED_DELAY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_OCCUPIED_TO_UNOCCUPIED_DELAY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_DELAY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_DELAY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_DELAY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_OCCUPIED_TO_UNOCCUPIED_DELAY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_OCCUPIED_TO_UNOCCUPIED_DELAY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_OCCUPIED_TO_UNOCCUPIED_DELAY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_DELAY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_DELAY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_DELAY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_THRESHOLD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_OCCUPIED_TO_UNOCCUPIED_DELAY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_OCCUPIED_TO_UNOCCUPIED_DELAY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_OCCUPIED_TO_UNOCCUPIED_DELAY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_DELAY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_DELAY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_DELAY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_THRESHOLD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      occupancy_sensing_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_THRESHOLD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      occupancy_sensing_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_THRESHOLD);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_ph_measurement_write_attributes_callback(
    ph_measurement_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ph_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ph_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ph_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ph_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MIN_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ph_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MIN_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ph_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MIN_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ph_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MAX_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ph_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MAX_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ph_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MAX_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ph_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_TOLERANCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ph_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_TOLERANCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ph_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_TOLERANCE);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_electrical_conductivity_measurement_write_attributes_callback(
    electrical_conductivity_measurement_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_conductivity_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_conductivity_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_conductivity_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_conductivity_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MIN_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_conductivity_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MIN_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_conductivity_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MIN_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_conductivity_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MAX_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_conductivity_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MAX_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_conductivity_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MAX_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_conductivity_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_TOLERANCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_conductivity_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_TOLERANCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_conductivity_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_TOLERANCE);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_wind_speed_measurement_write_attributes_callback(
    wind_speed_measurement_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      wind_speed_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      wind_speed_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      wind_speed_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      wind_speed_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MIN_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      wind_speed_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MIN_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      wind_speed_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MIN_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      wind_speed_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MAX_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      wind_speed_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MAX_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      wind_speed_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MAX_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      wind_speed_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_TOLERANCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      wind_speed_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_TOLERANCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      wind_speed_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_TOLERANCE);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_carbon_monoxide_write_attributes_callback(
    carbon_monoxide_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_monoxide_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_monoxide_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      carbon_monoxide_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_monoxide_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MIN_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_monoxide_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MIN_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      carbon_monoxide_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MIN_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_monoxide_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MAX_MEASURED_VALUE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_monoxide_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MAX_MEASURED_VALUE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      carbon_monoxide_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MAX_MEASURED_VALUE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_monoxide_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_TOLERANCE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      carbon_monoxide_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_TOLERANCE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      carbon_monoxide_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_TOLERANCE);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_ias_zone_write_attributes_callback(
    ias_zone_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ias_zone_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ias_zone_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ias_zone_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_IASCIE_ADDRESS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_IASCIE_ADDRESS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ias_zone_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_IASCIE_ADDRESS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONEID,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONEID,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ias_zone_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONEID);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_NUMBER_OF_ZONE_SENSITIVITY_LEVELS_SUPPORTED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_NUMBER_OF_ZONE_SENSITIVITY_LEVELS_SUPPORTED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ias_zone_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_NUMBER_OF_ZONE_SENSITIVITY_LEVELS_SUPPORTED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_CURRENT_ZONE_SENSITIVITY_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      ias_zone_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_CURRENT_ZONE_SENSITIVITY_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      ias_zone_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_IAS_ZONE_CURRENT_ZONE_SENSITIVITY_LEVEL);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_iaswd_write_attributes_callback(
    iaswd_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      iaswd_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_IASWD_MAX_DURATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      iaswd_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_IASWD_MAX_DURATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      iaswd_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_IASWD_MAX_DURATION);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_metering_write_attributes_callback(
    metering_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_DELIVERED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_DELIVERED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_DELIVERED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_RECEIVED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_RECEIVED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_RECEIVED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_POWER_FACTOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_POWER_FACTOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_POWER_FACTOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_READING_SNAP_SHOT_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_READING_SNAP_SHOT_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_READING_SNAP_SHOT_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED_TIME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED_TIME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED_TIME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_DEFAULT_UPDATE_PERIOD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_DEFAULT_UPDATE_PERIOD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_DEFAULT_UPDATE_PERIOD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_SUPPLY_STATUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_SUPPLY_STATUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_SUPPLY_STATUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_INLET_ENERGY_CARRIER_SUMMATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_INLET_ENERGY_CARRIER_SUMMATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_INLET_ENERGY_CARRIER_SUMMATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_OUTLET_ENERGY_CARRIER_SUMMATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_OUTLET_ENERGY_CARRIER_SUMMATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_OUTLET_ENERGY_CARRIER_SUMMATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_INLET_TEMPERATURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_INLET_TEMPERATURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_INLET_TEMPERATURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_OUTLET_TEMPERATURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_OUTLET_TEMPERATURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_OUTLET_TEMPERATURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_UNITOF_MEASURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_UNITOF_MEASURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_UNITOF_MEASURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_MULTIPLIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_MULTIPLIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_MULTIPLIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_DIVISOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_DIVISOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_DIVISOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_SUMMATION_FORMATTING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_SUMMATION_FORMATTING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_SUMMATION_FORMATTING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_DEMAND_FORMATTING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_DEMAND_FORMATTING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_DEMAND_FORMATTING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_HISTORICAL_CONSUMPTION_FORMATTING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_HISTORICAL_CONSUMPTION_FORMATTING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_HISTORICAL_CONSUMPTION_FORMATTING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_METERING_DEVICE_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_METERING_DEVICE_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_METERING_DEVICE_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_UNIT_OF_MEASURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_UNIT_OF_MEASURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_UNIT_OF_MEASURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_SUMMATION_FORMATTING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_SUMMATION_FORMATTING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_SUMMATION_FORMATTING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_DEMAND_FORMATTING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_DEMAND_FORMATTING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_DEMAND_FORMATTING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_UNIT_OF_MEASURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_UNIT_OF_MEASURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_UNIT_OF_MEASURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_FORMATTING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      metering_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_FORMATTING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      metering_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_FORMATTING);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_electrical_measurement_write_attributes_callback(
    electrical_measurement_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASUREMENT_TYPE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASUREMENT_TYPE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASUREMENT_TYPE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MIN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MIN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MIN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MAX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MAX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MAX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MIN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MIN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MIN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MAX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MAX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MAX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MIN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MIN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MIN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MAX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MAX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MAX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MULTIPLIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MULTIPLIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MULTIPLIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_DIVISOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_DIVISOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_DIVISOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MULTIPLIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MULTIPLIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MULTIPLIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_DIVISOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_DIVISOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_DIVISOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MULTIPLIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MULTIPLIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MULTIPLIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_DIVISOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_DIVISOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_DIVISOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MIN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MIN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MIN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MAX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MAX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MAX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_NEUTRAL_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_NEUTRAL_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_NEUTRAL_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_ACTIVE_POWER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_ACTIVE_POWER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_ACTIVE_POWER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_REACTIVE_POWER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_REACTIVE_POWER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_REACTIVE_POWER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_APPARENT_POWER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_APPARENT_POWER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_APPARENT_POWER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED1ST_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED1ST_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED1ST_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED3RD_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED3RD_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED3RD_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED5TH_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED5TH_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED5TH_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED7TH_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED7TH_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED7TH_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED9TH_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED9TH_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED9TH_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED11TH_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED11TH_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED11TH_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE1ST_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE1ST_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE1ST_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE3RD_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE3RD_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE3RD_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE5TH_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE5TH_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE5TH_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE7TH_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE7TH_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE7TH_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE9TH_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE9TH_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE9TH_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE11TH_HARMONIC_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE11TH_HARMONIC_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE11TH_HARMONIC_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MULTIPLIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MULTIPLIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MULTIPLIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_DIVISOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_DIVISOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_DIVISOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_MULTIPLIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_MULTIPLIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_MULTIPLIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_DIVISOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_DIVISOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_DIVISOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_HARMONIC_CURRENT_MULTIPLIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_HARMONIC_CURRENT_MULTIPLIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_HARMONIC_CURRENT_MULTIPLIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_PHASE_HARMONIC_CURRENT_MULTIPLIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_PHASE_HARMONIC_CURRENT_MULTIPLIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_PHASE_HARMONIC_CURRENT_MULTIPLIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_MULTIPLIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_MULTIPLIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_MULTIPLIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_DIVISOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_DIVISOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_DIVISOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_MULTIPLIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_MULTIPLIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_MULTIPLIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_DIVISOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_DIVISOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_DIVISOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_MULTIPLIER,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_MULTIPLIER,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_MULTIPLIER);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_DIVISOR,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_DIVISOR,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_DIVISOR);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_OVERLOAD_ALARMS_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_OVERLOAD_ALARMS_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_OVERLOAD_ALARMS_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_OVERLOAD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_OVERLOAD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_OVERLOAD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_OVERLOAD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_OVERLOAD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_OVERLOAD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ALARMS_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ALARMS_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ALARMS_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_OVERLOAD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_OVERLOAD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_OVERLOAD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_OVERLOAD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_OVERLOAD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_OVERLOAD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ACTIVE_POWER_OVERLOAD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ACTIVE_POWER_OVERLOAD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ACTIVE_POWER_OVERLOAD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_REACTIVE_POWER_OVERLOAD,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_REACTIVE_POWER_OVERLOAD,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_REACTIVE_POWER_OVERLOAD);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHC);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHC,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      electrical_measurement_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHC,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      electrical_measurement_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHC);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_diagnostics_write_attributes_callback(
    diagnostics_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NUMBER_OF_RESETS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NUMBER_OF_RESETS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NUMBER_OF_RESETS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PERSISTENT_MEMORY_WRITES,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PERSISTENT_MEMORY_WRITES,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PERSISTENT_MEMORY_WRITES);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_BCAST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_BCAST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_BCAST);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_BCAST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_BCAST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_BCAST);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_UCAST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_UCAST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_UCAST);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_RETRY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_RETRY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_RETRY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_FAIL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_FAIL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_FAIL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_BCAST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_BCAST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_BCAST);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_BCAST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_BCAST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_BCAST);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_UCAST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_UCAST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_UCAST);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_SUCCESS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_SUCCESS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_SUCCESS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_RETRY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_RETRY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_RETRY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_FAIL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_FAIL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_FAIL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_ROUTE_DISC_INITIATED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_ROUTE_DISC_INITIATED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_ROUTE_DISC_INITIATED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_ADDED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_ADDED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_ADDED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_REMOVED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_REMOVED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_REMOVED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_STALE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_STALE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_STALE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_JOIN_INDICATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_JOIN_INDICATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_JOIN_INDICATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_CHILD_MOVED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_CHILD_MOVED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_CHILD_MOVED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWKFC_FAILURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWKFC_FAILURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWKFC_FAILURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APSFC_FAILURE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APSFC_FAILURE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APSFC_FAILURE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_UNAUTHORIZED_KEY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_UNAUTHORIZED_KEY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_UNAUTHORIZED_KEY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWK_DECRYPT_FAILURES,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWK_DECRYPT_FAILURES,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWK_DECRYPT_FAILURES);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_DECRYPT_FAILURES,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_DECRYPT_FAILURES,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_DECRYPT_FAILURES);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_BUFFER_ALLOCATE_FAILURES,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_BUFFER_ALLOCATE_FAILURES,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_BUFFER_ALLOCATE_FAILURES);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_RELAYED_UCAST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_RELAYED_UCAST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_RELAYED_UCAST);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PHY_TOMAC_QUEUE_LIMIT_REACHED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PHY_TOMAC_QUEUE_LIMIT_REACHED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PHY_TOMAC_QUEUE_LIMIT_REACHED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_VALIDATE_DROP_COUNT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_VALIDATE_DROP_COUNT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_VALIDATE_DROP_COUNT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_AVERAGEMAC_RETRY_PERAPS_MESSAGE_SENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_AVERAGEMAC_RETRY_PERAPS_MESSAGE_SENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_AVERAGEMAC_RETRY_PERAPS_MESSAGE_SENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGELQI,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGELQI,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGELQI);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGERSSI,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      diagnostics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGERSSI,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      diagnostics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGERSSI);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_protocol_controller_rf_telemetry_write_attributes_callback(
    protocol_controller_rf_telemetry_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      protocol_controller_rf_telemetry_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_TX_REPORT_ENABLED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      protocol_controller_rf_telemetry_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_TX_REPORT_ENABLED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      protocol_controller_rf_telemetry_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_TX_REPORT_ENABLED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      protocol_controller_rf_telemetry_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_PTI_ENABLED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      protocol_controller_rf_telemetry_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_PTI_ENABLED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      protocol_controller_rf_telemetry_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_PTI_ENABLED);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_state_write_attributes_callback(
    state_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      state_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_STATE_ENDPOINT_ID_LIST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      state_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_STATE_ENDPOINT_ID_LIST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      state_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_STATE_ENDPOINT_ID_LIST);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_binding_write_attributes_callback(
    binding_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      binding_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BINDING_BINDING_TABLE_FULL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      binding_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BINDING_BINDING_TABLE_FULL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      binding_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BINDING_BINDING_TABLE_FULL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      binding_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BINDING_BINDABLE_CLUSTER_LIST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      binding_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BINDING_BINDABLE_CLUSTER_LIST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      binding_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BINDING_BINDABLE_CLUSTER_LIST);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      binding_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BINDING_BINDING_TABLE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      binding_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_BINDING_BINDING_TABLE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      binding_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_BINDING_BINDING_TABLE);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_system_metrics_write_attributes_callback(
    system_metrics_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_REPORTING_INTERVAL_SECONDS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_REPORTING_INTERVAL_SECONDS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_REPORTING_INTERVAL_SECONDS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_USAGE_PERCENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_USAGE_PERCENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_USAGE_PERCENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_FREQUENCYM_HZ,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_FREQUENCYM_HZ,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_FREQUENCYM_HZ);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_AVERAGE_USAGE_PERCENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_AVERAGE_USAGE_PERCENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_AVERAGE_USAGE_PERCENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_MIN_USAGE_PERCENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_MIN_USAGE_PERCENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_MIN_USAGE_PERCENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_MAX_USAGE_PERCENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_MAX_USAGE_PERCENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_MAX_USAGE_PERCENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_TOTALMB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_TOTALMB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_TOTALMB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_FREEMB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_FREEMB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_FREEMB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_AVAILABLEMB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_AVAILABLEMB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_AVAILABLEMB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_TOTALMB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_TOTALMB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_TOTALMB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_USEDMB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_USEDMB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_USEDMB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_TOTALMB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_TOTALMB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_TOTALMB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_USEDMB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_USEDMB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_USEDMB);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_DISKS_USAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_DISKS_USAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_DISKS_USAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_DISKS_COUNTERS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_DISKS_COUNTERS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_DISKS_COUNTERS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_NETWORK_INTERFACES_DATA,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_NETWORK_INTERFACES_DATA,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_NETWORK_INTERFACES_DATA);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_WIRELESS_NETWORK_INTERFACES_DATA,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_WIRELESS_NETWORK_INTERFACES_DATA,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_WIRELESS_NETWORK_INTERFACES_DATA);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_HOSTNAME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_HOSTNAME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_HOSTNAME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_FQDN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_FQDN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_FQDN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_UPTIME_MINUTES,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_UPTIME_MINUTES,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_UPTIME_MINUTES);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CURRENT_TEMPERATURE_CELCIUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CURRENT_TEMPERATURE_CELCIUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CURRENT_TEMPERATURE_CELCIUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_AVERAGE_TEMPERATURE_CELCIUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_AVERAGE_TEMPERATURE_CELCIUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_AVERAGE_TEMPERATURE_CELCIUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MIN_TEMPERATURE_CELCIUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MIN_TEMPERATURE_CELCIUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MIN_TEMPERATURE_CELCIUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MAX_TEMPERATURE_CELCIUS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MAX_TEMPERATURE_CELCIUS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MAX_TEMPERATURE_CELCIUS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_POWER_PLUGGED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_POWER_PLUGGED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_POWER_PLUGGED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_BATTERY_PERCENTAGE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_BATTERY_PERCENTAGE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_BATTERY_PERCENTAGE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SYSTEM_INTERRUPTS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      system_metrics_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SYSTEM_INTERRUPTS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      system_metrics_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SYSTEM_INTERRUPTS);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_application_monitoring_write_attributes_callback(
    application_monitoring_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_NAME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_NAME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_NAME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_VERSION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_VERSION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_VERSION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CONNECTED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CONNECTED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CONNECTED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONMQTT_TOPICS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONMQTT_TOPICS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONMQTT_TOPICS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_UPTIME_MINUTES,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_UPTIME_MINUTES,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_UPTIME_MINUTES);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_PROCESS_ID,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_PROCESS_ID,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_PROCESS_ID);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_HOSTNAME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_HOSTNAME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_HOSTNAME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_FQDN,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_FQDN,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_FQDN);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_ENABLED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_ENABLED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_ENABLED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_LEVEL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_LEVEL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_LEVEL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_STATISTICS_REPORTING_INTERVAL_SECONDS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_STATISTICS_REPORTING_INTERVAL_SECONDS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_STATISTICS_REPORTING_INTERVAL_SECONDS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_SENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_SENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_SENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_RECEIVED,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_RECEIVED,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_RECEIVED);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_SUBSCRIPTION_COUNT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_SUBSCRIPTION_COUNT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_SUBSCRIPTION_COUNT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_AVERAGE_DELIVERY_TIME_SECONDS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_AVERAGE_DELIVERY_TIME_SECONDS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_AVERAGE_DELIVERY_TIME_SECONDS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MIN_DELIVERY_TIME_SECONDS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MIN_DELIVERY_TIME_SECONDS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MIN_DELIVERY_TIME_SECONDS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MAX_DELIVERY_TIME_SECONDS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MAX_DELIVERY_TIME_SECONDS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MAX_DELIVERY_TIME_SECONDS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_STATISTICS_REPORTING_INTERVAL_SECONDS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_STATISTICS_REPORTING_INTERVAL_SECONDS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_STATISTICS_REPORTING_INTERVAL_SECONDS);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_USAGE_PERCENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_USAGE_PERCENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_USAGE_PERCENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_AVERAGE_USAGE_PERCENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_AVERAGE_USAGE_PERCENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_AVERAGE_USAGE_PERCENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_MIN_USAGE_PERCENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_MIN_USAGE_PERCENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_MIN_USAGE_PERCENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_MAX_USAGE_PERCENT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_MAX_USAGE_PERCENT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_MAX_USAGE_PERCENT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONRAM_USAGEMB,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      application_monitoring_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONRAM_USAGEMB,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      application_monitoring_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONRAM_USAGEMB);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_name_and_location_write_attributes_callback(
    name_and_location_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      name_and_location_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_NAME,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      name_and_location_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_NAME,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      name_and_location_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_NAME);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      name_and_location_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_LOCATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      name_and_location_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_LOCATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      name_and_location_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_LOCATION);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_configuration_parameters_write_attributes_callback(
    configuration_parameters_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      configuration_parameters_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_CONFIGURATION_PARAMETERS_CONFIGURATION_PARAMETERS,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      configuration_parameters_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_CONFIGURATION_PARAMETERS_CONFIGURATION_PARAMETERS,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      configuration_parameters_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_CONFIGURATION_PARAMETERS_CONFIGURATION_PARAMETERS);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_aox_locator_write_attributes_callback(
    aox_locator_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_REPORTING_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_REPORTING_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_REPORTING_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION_VALID,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION_VALID,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION_VALID);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AZIMUTH_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AZIMUTH_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AZIMUTH_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ELEVATION_MASK,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ELEVATION_MASK,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ELEVATION_MASK);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ALLOW_LIST,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ALLOW_LIST,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ALLOW_LIST);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AOX_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AOX_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AOX_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_ARRAY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_ARRAY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_ARRAY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_PERIOD_SAMPLES,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_PERIOD_SAMPLES,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_PERIOD_SAMPLES);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING_WEIGHT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING_WEIGHT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING_WEIGHT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_TIMEOUT,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_TIMEOUT,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_TIMEOUT);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_DELAY,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_DELAY,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_DELAY);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_MODE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_MODE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_MODE);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_SAMPLING_INTERVAL,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_SAMPLING_INTERVAL,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_SAMPLING_INTERVAL);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_LENGTH,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_LENGTH,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_LENGTH);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_SLOT_DURATION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_locator_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_SLOT_DURATION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_locator_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_SLOT_DURATION);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_aox_position_estimation_write_attributes_callback(
    aox_position_estimation_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_position_estimation_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_POSITION_ESTIMATION_POSITION,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      aox_position_estimation_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_POSITION_ESTIMATION_POSITION,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      aox_position_estimation_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_AOX_POSITION_ESTIMATION_POSITION);
  // Register WriteAttribute Callbacks
  uic_mqtt_dotdot_set_protocol_controller_network_management_write_attributes_callback(
    protocol_controller_network_management_cluster_mapper_write_attributes_callback);
    //Desired attribute state
    attribute_store_register_callback_by_type_and_state(
      protocol_controller_network_management_cluster_attrs_desired_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_NETWORK_MANAGEMENT_NETWORK_MANAGEMENT_STATE,
      DESIRED_ATTRIBUTE);
    //Reported attribute state
    attribute_store_register_callback_by_type_and_state(
      protocol_controller_network_management_cluster_attrs_reported_state_publisher_callback,
      DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_NETWORK_MANAGEMENT_NETWORK_MANAGEMENT_STATE,
      REPORTED_ATTRIBUTE);
    //registering a callback when an attribute is created for publishing cluster revision
    attribute_store_register_callback_by_type(
      protocol_controller_network_management_cluster_attrs_creation_callback,
      DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_NETWORK_MANAGEMENT_NETWORK_MANAGEMENT_STATE);

  // Register a callback for Networkstatus attribute update
  attribute_store_register_callback_by_type_and_state(
    on_pan_node_interview_done,
    ATTRIBUTE_NETWORK_STATUS,
    REPORTED_ATTRIBUTE);

  return SL_STATUS_OK;
}
