<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Z-Wave Protocol Controller: Unify Coding Standard</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Z-Wave Protocol Controller
   &#160;<span id="projectnumber">1.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_doc_standards_coding-standard.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Unify Coding Standard </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md107"></a>
1 Introduction</h1>
<h2><a class="anchor" id="autotoc_md108"></a>
1.1 Purpose of this document</h2>
<p>The purpose of this document is to describe the coding standard used by the components of the Unify SDK. It is a modified version of the standard for Silicon Labs MCU customer facing firmware.</p>
<p>A unified coding standard is necessary to provide a professional look &amp; feel in the source code that we provide to our customers. Furthermore, it reduces cognitive load, when you need to work with another group's code. Coding style and preferences differ from person to person, which means that there will be rules in this document that you will disagree with. However, please adhere to the rules described here, as having a coding standard that you (somewhat) disagree with is better than having no coding standard.</p>
<h2><a class="anchor" id="autotoc_md109"></a>
1.2 Latest version of this document</h2>
<p>This document is version <b>0.1</b>.</p>
<p>The latest version of this document can always be found in Stash:</p>
<p><a href="https://stash.silabs.com/projects/UIC/repos/uic/browse/doc/standards/coding-standard.md">coding_standard</a></p>
<p><b>Note:</b> The reason why this document is in git is so that we can use pull- requests for changes and make it easier for people to track changes to the standard.</p>
<h2><a class="anchor" id="autotoc_md110"></a>
1.3 Changing this document</h2>
<p>Any change made to this document must comply with following procedure.</p>
<p><b>Note:</b> This includes adding yourself to this list!</p>
<p>Additionally, please make sure that your commit has a good commit message.</p>
<h3><a class="anchor" id="autotoc_md111"></a>
1.3.1 Versioning</h3>
<p>Whenever a new coding standard is released, a PR will be merged back in the <code>master</code> branch and the version number of the standard will be incremented.</p>
<p>Therefore, each commit on the <code>master</code> branch will be a new, stable version of this coding standard. For small additions to the standard, only the minor number version should be incremented. For versions not compatible with previous ones, the major version number should be incremented.</p>
<p>TBD has control on when this happens. Whenever this happens, a notification should be sent to all developers, indicating what has changed and if existing code needs to be updated in some way or can remain the same, with only new code following the new standard. If a legacy layer needs to be created, the notification should also mention it.</p>
<h3><a class="anchor" id="autotoc_md112"></a>
1.3.2 Review committee</h3>
<p>The pull request to merge in to <code>master</code> needs to be approved by one of the following people:</p>
<ul>
<li>Jonas Roum-MÃ¸ller</li>
<li>Anders Esbensen</li>
<li>Jakob Buron</li>
</ul>
<p>Additionally, the following people should be on the review list:</p>
<ul>
<li>All members of the Unify development team</li>
</ul>
<h2><a class="anchor" id="autotoc_md113"></a>
1.4 Structure and wording of this document</h2>
<p>This document contains three separate parts: Coding guidelines, coding style and documentation. The coding guidelines deal with the structure of your code. This part is split into a general and a C specific part. The coding style guide details how your code should look, e.g. brace style, comment style etc. Documentation deals with how you should document your code to make it easy for other people to use and modify the code.</p>
<h3><a class="anchor" id="autotoc_md114"></a>
1.4.1 Source Code</h3>
<p>In this document, <b>Source code</b> is used as a common name for any C, C++ or header file from Silicon Labs that is being provided to customers. It applies to both manually created as well as autogenerated code.</p>
<h3><a class="anchor" id="autotoc_md115"></a>
1.4.2 Required</h3>
<p>Some of the coding standards are required and some are recommendations. All required coding standards are tagged with <b>Required</b>.</p>
<h3><a class="anchor" id="autotoc_md116"></a>
1.4.3 Recommended</h3>
<p>Recommended rules should generally be followed. However, recommended rules can be broken in special circumstances. All recommended coding standards are tagged <b>Recommended</b>.</p>
<h3><a class="anchor" id="autotoc_md117"></a>
1.4.4 Should</h3>
<p>The word "should" is used throughout this document. In this context, "should" is used to indicate best practice. You should strive to meet these guidelines. However, it is possible to break these rules, if that results in a better end result.</p>
<h2><a class="anchor" id="autotoc_md118"></a>
1.5 Application of this standard</h2>
<h3><a class="anchor" id="autotoc_md119"></a>
1.5.1 New modules</h3>
<p>This standard applies unconditionally to new modules.</p>
<p>Please note that a new software module does not need to be a new full stack. This could be only a new part in an existing stack.</p>
<h3><a class="anchor" id="autotoc_md120"></a>
1.5.2 Existing modules</h3>
<p>Existing components will continue to use the coding standard they are already using (there is still some differences between the various stacks).</p>
<hr  />
<h1><a class="anchor" id="autotoc_md121"></a>
2 General Guidelines</h1>
<h2><a class="anchor" id="autotoc_md122"></a>
2.1 General Guidelines</h2>
<p>We can't put everything into these guidelines, for things not covered in the guidelines, try to make your code blend in with the code you are editing. Use your best judgment!</p>
<h3><a class="anchor" id="autotoc_md123"></a>
2.1.1 Use peer review</h3>
<p>A coworker should review all code. In practice, pull requests are encouraged as it allows people to comment on your work easily and it makes it possible to have good discussions about specific lines of code.</p>
<h3><a class="anchor" id="autotoc_md124"></a>
2.1.3 Be a Boy Scout</h3>
<p>Leave the source code in a better condition than you found it!</p>
<h3><a class="anchor" id="autotoc_md125"></a>
2.1.4 Avoid reinventing the Wheel</h3>
<p>If somebody has implemented some functionality before, you should use that rather than developing it again from scratch. This could be a function in a standard library, or a module that was internally developed. Silicon Labs is a large company with many different groups developing software for various use. What you need might already exist! If the existing code doesn't suit your needs exactly but is close, consider whether the required changes would make it more generally useful. If so, change it.</p>
<h3><a class="anchor" id="autotoc_md126"></a>
2.1.5 Refactor code</h3>
<p>Try to refactor code instead of duplicating it. Extract common functionality into functions, parameterize or abstract differences, etc.</p>
<h2><a class="anchor" id="autotoc_md127"></a>
2.2 Testing</h2>
<h3><a class="anchor" id="autotoc_md128"></a>
2.2.1 Testability</h3>
<p>Design the code in a modular fashion that allows functional testing. If possible, create unit tests for your software.</p>
<h3><a class="anchor" id="autotoc_md129"></a>
2.2.2 Regression Test</h3>
<p>It is encouraged to add a decent level of automated regression tests.</p>
<h2><a class="anchor" id="autotoc_md130"></a>
2.3 Embedded Coding</h2>
<h3><a class="anchor" id="autotoc_md131"></a>
2.3.1 Write energy friendly code</h3>
<p>The code should be energy friendly. This means taking advantage of hardware features available and always going down to the lowest energy mode possible. Try to always keep this in mind when writing energy aware code:</p>
<ul>
<li>Make sure all hardware modules or functions that are not needed by the application are disabled or shut down as often as possible</li>
<li>Use DMA whenever possible and put the device in the lowest possible sleep mode</li>
<li>Faster code = more time to sleep</li>
<li>Avoid busy waiting unless absolutely necessary!</li>
<li>Remember: everything matters!</li>
<li>Energy aware code can get complicated and difficult to debug. That is why it adds more value!</li>
<li>Use Simplicity Studio or similar tool to profile the energy usage of your code. The results are often surprising.</li>
</ul>
<h3><a class="anchor" id="autotoc_md132"></a>
2.3.2 Interrupts</h3>
<p>Interrupts shall have as minimal processing as possible. If possible it should just send an event to a task for later processing. Having long interrupt processing times might cause problems when other time-critical pieces of code are blocked from executing (radio protocols being a prime example).</p>
<hr  />
<h1><a class="anchor" id="autotoc_md133"></a>
3 C Specific Guidelines</h1>
<h2><a class="anchor" id="autotoc_md134"></a>
3.1 Compilers</h2>
<h3><a class="anchor" id="autotoc_md135"></a>
3.1.1 C standards version (Required)</h3>
<p>Unify uses GNU99 (C99 with GNU Extensions).</p>
<h3><a class="anchor" id="autotoc_md136"></a>
3.1.1.1 C++ standards version (Required)</h3>
<p>Unify uses C++11 with GNU extensions.</p>
<h3><a class="anchor" id="autotoc_md137"></a>
3.1.2 Support mixing C++ and C (Recommended)</h3>
<p>C++ is increasing in popularity. To make sure that our libraries and code are compatible with C++ code, functions in header files should be defined inside an <code>extern "C"</code> block. This makes it possible to call C functions from C++.</p>
<p><b>Example</b> </p><pre class="fragment">#ifdef __cplusplus
extern "C" {
#endif

void foo(void);

// other functions ...

#ifdef __cplusplus
}
#endif
</pre><p>&gt;<b>Comment:</b> Do not add an extra layer of indentation between the opening and closing braces in this case. This is also an exception to the rule that requires braces to be on line by themselves.</p>
<h3><a class="anchor" id="autotoc_md138"></a>
3.1.3 Multiple build tool support (Recommended)</h3>
<p>Not relevant for Unify.</p>
<h3><a class="anchor" id="autotoc_md139"></a>
3.1.4 Compile with warnings (Required)</h3>
<p>Compiler warnings often indicate bugs that will only be seen at runtime and that may be very difficult to find during testing. For example, the compiler may warn you about using an uninitialized variable. This can be difficult to find during testing.</p>
<p>Use the compiler option -Wall to enable all warnings.</p>
<h3><a class="anchor" id="autotoc_md140"></a>
3.1.5 Treat warnings as errors (Required)</h3>
<p>Warnings should be treated as errors so that the build does not complete until the warning if fixed. Having a zero tolerance for warnings will help keep our code cleaner and contain fewer bugs.</p>
<p>Use the compiler option -Werror to treat warnings as errors. This applies to builds that are part of "make test". It does not apply to build mechanisms passed through to customer projects.</p>
<p>Exceptions to Werror have to be approved in code review and have their rationale documented. Exceptions should disable errors, but leave warning intact (-wno-error=some-kind-of-warning) unless the warning is so noisy as flood build output. In that case it should be disabled entirely. (-wno-some-kind-of-warning)</p>
<h2><a class="anchor" id="autotoc_md141"></a>
3.2 Preprocessor</h2>
<h3><a class="anchor" id="autotoc_md142"></a>
3.2.1 Use header file guards (Required)</h3>
<p>A header file guard must cover all header files unless they are intended to be included multiple times from the same source file (which should be rare and justified). The name of the guard is of the form:</p>
<p><em>upper case file name</em></p>
<p>where characters in the file name other than alphanumerics are replaced with underscores and leading underscores are stripped. Guards should guard all other code in the file except comment headers. In particular, they should guard <code>extern</code> declarations and <code>#include</code> statements.</p>
<p><b>Example</b> </p><pre class="fragment">#ifndef MY_FILE_H
#define MY_FILE_H

#include &lt;stdint.h&gt;

extern volatile uint64_t jiffies;

// ...

#endif  // MY_FILE_H
</pre><h3><a class="anchor" id="autotoc_md143"></a>
3.2.2 Preprocessor conditional compilation (Recommended)</h3>
<p>Limit the use of preprocessor conditional compile statements like <code>#if</code> and <code>#ifdef</code>. If used, avoid using preprocessor conditions inside functions.</p>
<p><b>Example</b> </p><pre class="fragment">#if !defined(LINUX_DBG)
#define sl_enable_interrupts()   __restore_interrupt()
#define sl_disable_interrupts()  __disable_interrupt()
#else
#define sl_enable_interrupts()   (void)0
#define sl_disable_interrupts()  (void)0
#endif

void sl_do_something(void)
{
  sl_enable_interrupts();
  sl_do_atomic_operation();
  sl_disable_interrupts();
}
</pre><p>&gt;<b>Comment</b>: The above is a cleaner way to write code that in this example has more than one way to enable/disable interrupts. Below is the original, not so clean, code from the example above. </p><pre class="fragment">void sl_do_something(void)
{
#if !defined(LINUX_DBG)
  __disable_interrupt();
#endif
  sl_do_atomic_operation();
#ifndef LINUX_DBG
  __restore_interrupt();
#endif
}
</pre><h3><a class="anchor" id="autotoc_md144"></a>
3.2.3 Use of preprocessor directive #error (Recommended)</h3>
<p>Use <code>#error</code> when <code>#defines</code> can only be set to certain values, or other configuration problems.</p>
<p><b>Example</b> </p><pre class="fragment">#if (DEFAULT_SAMPLE_RATE8 == 44)
#define DEFAULT_SAMPLE_FREQ 44100
#elif (DEFAULT_SAMPLE_RATE8 == 48)
#define DEFAULT_SAMPLE_FREQ 48000
#else
#error Invalid value: DEFAULT_SAMPLE_RATE8
#endif
</pre><h3><a class="anchor" id="autotoc_md145"></a>
3.2.4 Use of preprocessor directive #include (Recommended)</h3>
<p>Header files should generally list their dependencies explicitly. The preferred way is to <code>#include</code> prerequisite header files. Alternatively, the header file may validate that an appropriate macro is defined.</p>
<p><b>Preferred</b> </p><pre class="fragment">#include "sl_foo.h"

void sl_bar(sl_foo_t baz);     // sl_foo_t is defined in sl_foo.h
</pre><p><b>Alternative</b> </p><pre class="fragment">// sl_foo_t is defined in sl_foo.h
#ifndef FOO_T_DEFINED
#error This source file needs to #include sl_foo.h
#endif

void sl_bar(sl_foo_t baz);     // sl_foo_t is defined in sl_foo.h
</pre><p>You should strive to not include more header files than you really require in a given C file. Having more than you need increases compilation time and increases the chance of unintended side effects. <code>&lt;&gt;</code> and <code>""</code> are used by the compiler to change the search path for included files. In general, <code>&lt;&gt;</code> should only be used for C standard libraries. <code>#include</code> should generally not be used for C files.</p>
<p><b>Example</b> </p><pre class="fragment">#include &lt;stdlib.h&gt;
#include "SI_C8051F850_Register_Enums.h"
#include "SI_Bluetooth_Init.h"
</pre><h2><a class="anchor" id="autotoc_md146"></a>
3.2.5 Use of preprocessor directive &lt;tt&gt;#undef&lt;/tt&gt; (Recommended)</h2>
<p>Using <code>#undef</code> should be avoided as it can lead to weird behaviors that are often fairly difficult to detect and solve. For example, errors can occur only when compiling files in a certain order.</p>
<h2><a class="anchor" id="autotoc_md147"></a>
3.2.6 Use of preprocessor 'stringify' and concatenation (Recommended)</h2>
<p>Use of the preprocessor 'stringify' or string concatenation operations should be avoided or kept to a minimum. Manipulations such as these can quickly become quite complex to understand, maintain or debug and should be avoided whenever possible.</p>
<h2><a class="anchor" id="autotoc_md148"></a>
3.2.7 General use of preprocessor  (Recommended)</h2>
<p>The preprocessor should be used reasonably, mostly for usual operations such as doing conditional compilation including that described in section 3.2.2, including files, reporting an error, etc. Using the preprocessor to do complex or unusual operations should normally be avoided.</p>
<h2><a class="anchor" id="autotoc_md149"></a>
3.3 Standard Libraries</h2>
<h3><a class="anchor" id="autotoc_md150"></a>
3.3.1 Use of stdint.h and stdbool.h (Required)</h3>
<p>Use <code>stdint.h</code> and <code>stdbool.h</code> types whenever possible. This makes types unambiguous, more portable and opens up compiler optimizations.</p>
<p>This means that you should always use C99 types like <code>uint8_t</code>. Do not use other types such as <code>U8</code> or <code>UINT8</code> unless needed to maintain compatibility with older code or third party library.</p>
<h3><a class="anchor" id="autotoc_md151"></a>
3.3.2 Use of stdlib (Recommended)</h3>
<p>You can use the stdlib functions <em>memset</em>, <em>memcpy</em>, <em>memmove</em>, <em>memcmp</em>, <em>strcmp</em>, etc. instead of writing your own for-loops. In code bases where these functions have been abstracted (e.g., by MEMSET, MEMCMP, and friends in the base repo), it is recommended to use those abstractions. Otherwise, for Cortex-M class devices it is recommended to use the stdlib versions as they are often heavily optimized.</p>
<h3><a class="anchor" id="autotoc_md152"></a>
3.3.3 Use of dynamic memory / the heap (Recommended)</h3>
<p>Allowed, but should be kept to a minimum in Unify.</p>
<p>Dynamic memory allocation with <code>malloc()</code> and <code>free()</code> should generally not be used. Some of our customers have strict rules in their QA procedures that dictate that malloc() cannot be used in embedded software. If we use it, then our libraries become unusable for them. The problem with malloc()/free() is fragmentation. Because our micros are memory constrained and have no virtual memory, malloc() can over time fragment memory, which in turn can cause a malloc() to fail down the road.</p>
<h3><a class="anchor" id="autotoc_md153"></a>
3.3.4 Do not use the standard C assert() (Required)</h3>
<p>It is strongly recommended to not use the <a class="el" href="assert_8h.html#ad6d5aaa966ca7424f7cb9bd01f2c838b">assert()</a> function that comes with the standard C/C++ library. If the Silicon Labs libraries used in your project contains assert function(s), then use them. If no Silicon Labs specific assert function is available, then use the code from the example below. The rationale for this rule is that a number of toolchains will bring in their standard library versions of printf and friends in order to implement assert. This can bring in unwanted side effects, such as code size increases.</p>
<p><b>Example</b> </p><pre class="fragment">// void user_assert (int file, int line);                   /* declaration */
// #define USER_ASSERT(file, line) user_assert(file, line)  /* definition  */

void sl_assert(const char *file, int line)
{
  (void)file;  // Unused parameter
  (void)line;  // Unused parameter
  // Wait forever until the watchdog fires
  while (1);
}

#if defined(NDEBUG)
#define SL_ASSERT(expr)
#else
#if defined(USER_ASSERT)
#define SL_ASSERT(expr)   ((expr) ? ((void)0) : USER_ASSERT(__FILE__, __LINE__))
#else
#define SL_ASSERT(expr)   ((expr) ? ((void)0) : sl_assert(__FILE__, __LINE__))
#endif
#endif
</pre><p>&gt;<b>Comment:</b> Below are the steps to overwrite Silicon Labs assert function &gt;with a user defined assert. &gt;1. define a <code>void user_assert(const char *, int)</code> function &gt;2. Uncomment the two lines below (marked "declaration" and "definition"). </p><blockquote class="doxtable">
<p></p>
<p>&gt;<code><a class="el" href="assert_8h.html#ad6d5aaa966ca7424f7cb9bd01f2c838b">assert()</a></code> is a void function and never return any value. If you like &gt;a function to return a value depending on the evaluation of an expression, &gt;then feel free to create a new function for that purpose. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md154"></a>
3.4 Keywords</h2>
<h3><a class="anchor" id="autotoc_md155"></a>
3.4.1 The "volatile" keyword (Recommended)</h3>
<p>Not relevant in Unify. We expect no or very few volatile variables.</p>
<h3><a class="anchor" id="autotoc_md156"></a>
3.4.2 The "inline" keyword (Recommended)</h3>
<p>Not relevant to Unify.</p>
<h3><a class="anchor" id="autotoc_md157"></a>
3.4.3 The "static" keyword (Required)</h3>
<p>For file global variables (variables that are global to a file but not visible outside the file) should always use the <code>static</code> keyword. This should also apply to any functions that are used only within a single file.</p>
<p>Keep in mind the difference between a static variable at the file scope level, and a static variable declared within a function.</p>
<p><b>Example</b> </p><pre class="fragment">// A variable that is only visible within a file
static uint32_t my_local_variable = 0xFF;

// A function that is used only within a file
static void do_something(void)
{
  // ...
}
</pre><p>For Cortex-Mx devices, use the CMSIS <code>__STATIC_INLINE</code> macro if you need something to be both static and inline.</p>
<h2><a class="anchor" id="autotoc_md158"></a>
3.5 Data Types</h2>
<h3><a class="anchor" id="autotoc_md159"></a>
3.5.1 Avoid enums in arrays, structures, or unions (Required)</h3>
<p>Not used in Unify. The full source is shared with customers, so there is no toolchain mismatch. Serialized format must be decoupled from the in-memory representation anyway, so this will not affect the persistent data formats.</p>
<h3><a class="anchor" id="autotoc_md160"></a>
3.5.2 Avoid bitfields in structures/unions (Required)</h3>
<p>Also relevant for Unify, for two reasons: 1) Bitfields cannot be used for wire formats, because the bit-layout is compiler-implemnentation defined; by disallowing it we prevent this type of mistakes. And 2) for performance reasons: Bitfields are typically slower to manipulate, and we are not trying to optimize the Unify SDK for memory size.</p>
<p>This is also especially important for aggregate types shared between libraries and customer-compiled code. As with enums, the size and bit layout of bitfields is not standardized, but is compiler-defined or subject to compiler options. Libraries built with one compiler or options will not interface properly to non-library code built with a different compiler or options.</p>
<p><b>Example</b> </p><pre class="fragment">// sl_lib.h include file:

typedef struct {
  bool    ena          : 1;
  uint8_t some_setting : 5;
} sl_lib_struct_t;

// Library could be built such that this structure is laid out in a byte:
//   7   6   5   4   3   2   1   0
// [ x | x |     some_setting  |ena]
// while application could be built such that this structure is laid out
// across two bytes, or in different endian order:
//   7   6   5   4   3   2   1   0
// [ena| x | x | x | x | x | x | x ]
// [   some_setting    | x | x | x ]
</pre><h2><a class="anchor" id="autotoc_md161"></a>
3.6 Variables</h2>
<h3><a class="anchor" id="autotoc_md162"></a>
3.6.1 Using global variables (Recommended)</h3>
<p>Minimize use of global variables. It is hard for a compiler to optimize code using them. The compiler (usually) only sees one C file at the time and does not know if the global has been changed between accesses.</p>
<p>In Unify always prefer inter-component communications (events, API function calls etc. over shared global variables). Global variables inside a component is allowed.</p>
<p>A way around this might be to copy the global to a static/auto variable and use the copy in your code.</p>
<p>Global variables can also easily become a source for confusion and errors in the application code as time goes on. As different developers work on the code they might use the global in slightly different ways and accidentally break something in parts of the code they are not working on. This recommendation should be evaluated at an architecture/project level to determine if it applies.</p>
<p>&gt;<b>8051 Note:</b> The 8051 compiler will often produce more efficient code when using a project global instead of sharing global data through a handle pointer or other mechanism. This trade-off should be taken into account when writing code targeted for 8051. As much as possible, steps should still be taken to minimize the use of global variables.</p>
<h2><a class="anchor" id="autotoc_md163"></a>
3.7 Functions</h2>
<h3><a class="anchor" id="autotoc_md164"></a>
3.7.1 Prototype functions (Required)</h3>
<p>Make sure either the full implementation or a prototype precedes any call to a function. For external functions, this should be done by with a <code>#include</code> of the appropriate header.</p>
<h3><a class="anchor" id="autotoc_md165"></a>
3.7.2 Functions return data types (Required)</h3>
<p>All <b>public and private functions</b> that can fail should return either:</p>
<ol type="1">
<li>In case the possible outcomes is binary SUCCESS or FAILURE use <code>sl_status_t</code>. The idea is to be as consistent and predictable throughout all of our code base to make it easier for customers to know what to expect from our functions.</li>
<li>In case of multiple error outcomes, define an enum with the with the possible error and success values and return that. The enum should have its own Doxygen and be linked from the function Doxygen.</li>
</ol>
<h4><a class="anchor" id="autotoc_md166"></a>
Exceptions</h4>
<p>There will be functions that will not return <code>sl_status_t</code>or a function specific error enum. For example, functions returning <code>void</code>; simple "getter" functions that cannot fail or that we don't need to differentiate between error cases; a function checking if a condition is true or false could return a <code>bool</code>; a function adding data to a string or buffer could return the number of bytes added to the string or buffer; or a callback function could return an indicator to let the stack know how to act. Other examples may exist but all of these exceptions should be used sparingly and with good reason. Please check with your team and/or manager before doing so.</p>
<p>In any case, the following requirements must be complied with:</p><ul>
<li>if a function can fail, there must be a clear indication as to how to detect a failure. This is preferrably done through returning <code>sl_status</code>or a function specific error enum, but having a special 'invalid' value returned in case of failure is also allowed. No matter how this is achieved, it must be documented in the doxygen function header.</li>
<li><code>bool</code> must not be returned to indicate success or failure. <code>bool</code> should only be used to indicate if a given condition is true or false. Even then, using an <code>enum</code> should be considered for future-proofing the function, should it need to return more than a true/false value in the future.</li>
</ul>
<h3><a class="anchor" id="autotoc_md167"></a>
3.7.3 Return values should always be checked and propagated (Recommended)</h3>
<p>Values returned by any function should always be checked to see if an error occurred. Such return values should normally be propagated up the callers tree up to the application or to a function that can react to it.</p>
<h3><a class="anchor" id="autotoc_md168"></a>
3.7.4 Functions replicating a standard API can follow that API (Recommended)</h3>
<p>If a function aims to replicate a standard API (like <code>strcpy</code> or <code>printf</code>), our version of the function can replicate that standard function's API. These functions do not need to follow our coding standards' directives relating to data types, return values or status. It should still follow our naming convention.</p>
<h2><a class="anchor" id="autotoc_md169"></a>
3.8 Macros</h2>
<h3><a class="anchor" id="autotoc_md170"></a>
3.8.1 Macros with side-effects (Recommended)</h3>
<p>Macros that may have have side-effects should be function-like and named appropriately.</p>
<p><b>Example</b> </p><pre class="fragment">#define sl_lock()     do {__acquire_mutex(&amp;sl_top_level_mutex);} while(0)
#define sl_unlock()   do {__release_mutex(&amp;sl_top_level_mutex);} while(0)
</pre><h3><a class="anchor" id="autotoc_md171"></a>
3.8.2 Macros with statement(s) (Required)</h3>
<p>If a macro expands into one or more full statements, make sure it consumes a subsequent semicolon. Furthermore, multiple-statement macros must be wrapped in a block. These rules ensure that the expanded macro will have the same syntax as a non-compound statement. Otherwise, it may cause undesirable parsing if a customer uses it without braces in a selection (<code>if (...) FOO();</code>) or iteration (<code>while (...) FOO();</code>) statement.</p>
<p><b>Example</b> </p><pre class="fragment">#define SL_FOO(x, y)          \
          do {                \
            ga = (x);         \
            gb = (y);         \
            gc = ga + gb;     \
          } while (0)

#define do_nothing()   (void)0

void sl_bar(int baz)
{
  if (baz) {
    SL_FOO(123, 321);
  } else {
    do_nothing();
  }
}
</pre><h3><a class="anchor" id="autotoc_md172"></a>
3.8.3 Functional macros with argument(s) (Required)</h3>
<p>Uses of arguments within macros, and the macro body itself, if it is an expression, should be wrapped in parentheses. This avoids problems stemming from unintended precedence groupings. Arguments should be used only once if possible to avoid problems when a statement or expression with side effects is passed.</p>
<p><b>Note:</b> In general, static inline functions are preferred to macros as they have less weird side-effects and are easier to read.</p>
<p><b>Example</b> </p><pre class="fragment">#define sl_bar(x, y, z) (0xFFFF | ((x) &amp; ((y) | (z))))
</pre><h2><a class="anchor" id="autotoc_md173"></a>
3.9 goto statements</h2>
<h3><a class="anchor" id="autotoc_md174"></a>
3.9.1 &lt;tt&gt;goto&lt;/tt&gt; statements should only be used for cleanup purposes or early exit in case of an error, when there is no simple workaround (Required)</h3>
<p><code>goto</code>s should never be used, except when needing to cleanup (free resources, release a lock, exit a critical section, etc.) in the case an error occurred in the function. If a simple workaround can be used instead of <code>goto</code>, the workaround should be used instead.</p>
<p><b>Example</b> </p><pre class="fragment">// Using goto, if no simple workaround available
void sli_usb_function(void)
{
  // Acquire lock
  // [...]
  if (!ok) {
    goto release;
  }
  // [...]
release:
  // Release lock
}

// Workaround, whenever possible
void sli_usb_function(void)
{
  // Acquire lock
  // [...]
  if (ok) {
    // [...]
  }
  // Release lock
}
</pre><h3><a class="anchor" id="autotoc_md175"></a>
3.9.2 &lt;tt&gt;goto&lt;/tt&gt;s should only refer to a label declared after them (Required)</h3>
<p>A <code>goto</code> statement should only refer to a label declared after (below) them, in the code.</p>
<p>No <code>goto</code> shall ever cause the code to go back "up", it should always jump "down", towards the end of the function.</p>
<p><b>Example</b> </p><pre class="fragment">// Don't do:
void sli_usb_function(void)
{
  // [...]
loop_start:
  // [...]
  if (loop) {
    goto loop_start;
  }
}

// Instead do:
void sli_usb_function(void)
{
  // Acquire lock
  // [...]
  if (!ok) {
    goto release;
  }
  // [...]
release:
  // Release lock
}
</pre><h3><a class="anchor" id="autotoc_md176"></a>
3.9.3 &lt;tt&gt;goto&lt;/tt&gt;s should only refer to a static label located in the same function (Required)</h3>
<p>No computed <code>goto</code> statement (as available in some GCC extensions) shall be used. <code>setjmp</code> and <code>longjmp</code> should never be used. The label referred to by a <code>goto</code> statement needs to be in the same function as the goto statement itself.</p>
<h3><a class="anchor" id="autotoc_md177"></a>
3.9.4 Any label referenced by a &lt;tt&gt;goto&lt;/tt&gt; need to be declared in the same block or a block enclosing the &lt;tt&gt;goto&lt;/tt&gt; (Required)</h3>
<p><code>goto</code> statements and labels should not be used to jump between blocks, as it can easily lead to unstructured code. <code>goto</code> should not be used either to jump between <code>case</code>s of a <code>switch</code>.</p>
<p><b>Example</b> </p><pre class="fragment">// Don't do:
void sli_usb_function(uint8_t bar)
{
  if (bar &gt; 0) {
    goto label;
  }
  // [...]
  goto label;
  // [...]
  if (foo &gt; 0) {
label:
    // [...]
  }
}

// Instead do:
void sli_usb_function(uint8_t bar)
{
  // [...]
  goto label;
  // [...]
  if (bar &gt; 0) {
    goto label;
  }
  // [...]
label:
  // [...]
}

// Don't do:
void sli_usb_function(uint8_t bar)
{
  switch(bar) {
    case 1:
      if (x == y) {
        goto label;
      }
      break;

    case 2:
      doThat();
label:
      doTheOtherThing();
      break;

    default:
      break;
  }
}
</pre><h2><a class="anchor" id="autotoc_md178"></a>
3.10 Libraries</h2>
<h3><a class="anchor" id="autotoc_md179"></a>
3.10.1 Dependencies (Required)</h3>
<p>Be conscious about what code the library depends on. To avoid excessive code footprint, we must be aware of what external functions each library pulls in.</p>
<h3><a class="anchor" id="autotoc_md180"></a>
3.10.2 Including third party code (Required)</h3>
<p>For all open source or third party software that we include in our software releases, we need to have an acceptable license that allows us to do so. That means we need to send an email to our legal department (DL.Legal) and ask for permission before introducing new open source software into our distributions. Consult the Software Manager before including any third party software code intended to be released.</p>
<h3><a class="anchor" id="autotoc_md181"></a>
3.10.3 Configuring libraries in source form (Required)</h3>
<p>The customer should never have to change the original source files to configure the library (this creates problems when upgrading the library to a newer version, and also makes it impossible to have two projects with different configuration settings using the same instance of the library). Instead, it should be possible to set all configurations settings from the customer's application project. Normally this can be done with macros that allow a customer to configure library settings from within the application.</p>
<p><b>Example</b> </p><pre class="fragment">#if !defined(EM_SETTING)                   // If EM_SETTING is not defined by user,
#define EM_SETTING default_value_for_em    // then we set our default value/function.
#endif
</pre><h3><a class="anchor" id="autotoc_md182"></a>
3.10.4 Configuring libraries in binary form (Recommended)</h3>
<p>If a library is provided in binary form, then macros cannot be used for configuration settings.</p>
<p>A good alternative is to use callback functions or static variables. Callbacks might not be appropriate for 8-bit code, so use your judgment.</p>
<p><b>Example</b> </p><pre class="fragment">// We call sl_custom_configuration_callback() from our library to get the
// user defined configuration.
//
int configuration = sl_custom_configuration_callback();

// The user have to define sl_custom_configuration_callback() and return a
// valid configuration for the application.
//
int sl_custom_configuration_callback(void)
{
  return OPT_SIZE | MAX_BUF_SIZE;
}
</pre><p>&gt;<b>Comment:</b> sl_custom_configuration_callback is defined in user application and returns different values depending on the user implementation.</p>
<p><b>Example</b> </p><pre class="fragment">// We initialize configuration with a sensible default that is suitable
// for the largest number of applications
//
int configuration = SL_DEFAULT_CONFIGURATION;

// The user application can customize the behavior by calling
// sl_set_configuration
//
void sl_set_configuration(int user_config)
{
  configuration = user_config;
}
</pre><h2><a class="anchor" id="autotoc_md183"></a>
3.11 Misc</h2>
<h3><a class="anchor" id="autotoc_md184"></a>
3.11.1 Avoid embedding assignments in expressions (Recommended)</h3>
<p>Embedding assignments in expressions makes for all kinds of wacky bugs. When scanning some code it is easy to miss that a complicated expression contains an assignment deep inside.</p>
<p><b>Example</b> </p><pre class="fragment">++ceiling;
*handle = ceiling;
</pre><p>&gt;<b>Comment:</b> The above is easy to understand, hard to get wrong and most compilers today will generate the same optimized code that that example as it will for the below code; </p><pre class="fragment">*handle = ++ceiling;
</pre><hr  />
<h1><a class="anchor" id="autotoc_md185"></a>
4 Coding style and formatting</h1>
<h2><a class="anchor" id="autotoc_md186"></a>
4.1 General formatting</h2>
<h3><a class="anchor" id="autotoc_md187"></a>
4.1.1 Use spaces, not tabs (Required)</h3>
<p>For indenting files, use spaces and never tabs. A mix of tabs and spaces is never acceptable.</p>
<h3><a class="anchor" id="autotoc_md188"></a>
4.1.2 Indents are 2 spaces per level (Required)</h3>
<p>Indent each nested level with 2 spaces of indent.</p>
<h4><a class="anchor" id="autotoc_md189"></a>
4.1.2.1 Preprocessor indentation (Recommended)</h4>
<p>Preprocessor directives historically have not been indented, but they may be indented to make them less distracting to the module's code flow (though the technique described in the section 3.2.2 offers an even cleaner alternative where it makes sense). When indented, the # should remain attached to the directive and not remain in the first column &ndash; no modern preprocessor still requires the # be in the first column. When an <code>#if</code> or <code>#ifdef</code> is indented, its <code>#else</code>, <code>#elif</code>, and <code>#endif</code> shall also be identically indented. The code between the preprocessor directives may also be indented.</p>
<p><b>Example</b> </p><pre class="fragment">void sl_set_xyz_option(xyz_option_t xyz_option)
{
  #if defined( _XYZ_LFCCLKEN0_MASK ) // XYZ supports LFC clock
    if (xyz_option == xyz_clock_lfc) {
      xyz_clock_set_lfc();
      return;
    }
  #endif
  #if defined( _XYZ_LFECLKSEL_MASK ) // XYZ supports LFE clock
    if (xyz_option == xyz_clock_lfe) {
      xyz_clock_set_lfe();
      return;
    }
  #endif
}
</pre><h3><a class="anchor" id="autotoc_md190"></a>
4.1.3 Lines should not be longer than 80 characters (Recommended)</h3>
<p>We enforce an 80 characters limit per line of source code. This lets people set up their editors such that they can have multiple editors side-by-side. Although 80 characters are little by modern standards, it mixes well with existing code.</p>
<h3><a class="anchor" id="autotoc_md191"></a>
4.1.4 Line endings (Required)</h3>
<p>We use line ending normalization in our repositories. This means that all text files are converted to '<br  />
' line endings when they are stored in git. However most customers are using Windows operating system which expects a CRLF line ending. Therefore, with rare exception, all source code delivered to customers should have CRLF (DOS) line endings. There are two ways to accomplish this. First, if you are using a Windows host operating system, set your git autocrlf setting as follows: </p><pre class="fragment">core.autocrlf true
</pre><p>This will ensure all text files have DOS line endings when checked out from the repository.</p>
<p>The second method is to use a release script that forces all text file line endings to CRLF when a source code release package is built by the release script.</p>
<p>&gt;<b>Exceptions:</b> if the source code is intended for a system that &gt;use normal line endings, for example a OS X or Linux system, then &gt;the source line endings can be left as '<br  />
'.</p>
<p>&gt;<b>Note:</b> All repositories should include a .gitattributes file to explicitly specify file types for line endings.</p>
<h3><a class="anchor" id="autotoc_md192"></a>
4.1.5 Use only plain ASCII or UTF-8 (Required)</h3>
<p>Text files should almost always contain only plain ASCII. Specifically, avoid characters outside the usual whitespace and printable ones (0x9-0xD and 0x20-0x7E, inclusive). Internationalized strings, when used, are best placed in a resource file.</p>
<p>In the rare case that other characters are needed in a text file and cannot be escaped, the file should be UTF-8 encoded with no byte-order mark.</p>
<h3><a class="anchor" id="autotoc_md193"></a>
4.1.6 Use ISO8601 formatting for dates (Required)</h3>
<p>If you use a date in the comments or elsewhere, specify it using the unambiguous ISO8601 format, i.e. <code>2013-11-26</code>.</p>
<h3><a class="anchor" id="autotoc_md194"></a>
4.1.7 Inserting empty and blank lines (Required)</h3>
<p>There should never be consecutive blank rows.</p>
<p>Use two slashes (C++ comment) and 77 dashes to separate logical parts of the code. Use 2 slashes and 32 dashes for minor sections. Use of section separators as shown here is optional.</p>
<p><b>Example</b> </p><pre class="fragment">// -----------------------------------------------------------------------------
// Here we start a new logical part in this source/header file...

// -------------------------------
// And here comes a new minor section...
</pre><h3><a class="anchor" id="autotoc_md195"></a>
4.1.8 Use parentheses liberally (Required)</h3>
<p>Add parentheses if you have any doubt at all about precedence, not doing so has led to some very obscure bugs. This is especially true of the bitwise binary operators <code>{&amp;, |, ^}</code> and Boolean operators <code>{&amp;&amp;, ||}</code>.</p>
<h3><a class="anchor" id="autotoc_md196"></a>
4.1.9 Break up long expressions (Required)</h3>
<p>Whenever there are long expressions, it should be broken into multiple lines. When a line is broken into multiple lines, each line should start with the operator that operates on that full line (single element or a group of elements within parentheses). The operator must be the first thing on the line, and it should be indented appropriately.</p>
<p><b>Example</b> </p><pre class="fragment">int bitmask = (OPTION_1
               | OPTION_2
               | (IS_THIS_SET
                  ? OPTION_3
                  : OPTION_4));

int bitmask = (OPTION_1
               | OPTION_2
               | (IS_THIS_SET ? OPTION_3 : OPTION_4));

int bitmask = (OPTION_1
               | OPTION_2
               | (OPTION_3 &amp; OPTION_4));
</pre><p>&gt;<b>Comment:</b> All the above are examples of nicely formatted long expressions. </p><blockquote class="doxtable">
<p></p>
<p>&gt;Below is an example how you should not format long and complex expressions.</p>
<p></p>
</blockquote>
<p>// Avoid this... int no_good_formatting = (OPTION_1 | OPTION_2 | OPTION_3 &amp; OPTION_4);</p>
<h3><a class="anchor" id="autotoc_md197"></a>
4.1.10 &lt;tt&gt;goto&lt;/tt&gt; labels should be on column 1 (Required)</h3>
<p>Labels referred to by <code>goto</code>s need to be located at column 1, disregarding any indentation.</p>
<p><b>Example</b> </p><pre class="fragment">// Don't do:
void sli_usb_function(void)
{
  // Acquire lock
  // [...]
  if (!ok) {
    goto release;
  }
  // [...]
  release:
  // Release lock
}

// Instead do:
void sli_usb_function(void)
{
  // Acquire lock
  // [...]
  if (!ok) {
    goto release;
  }
  // [...]
release:
  // Release lock
}
</pre><h2><a class="anchor" id="autotoc_md198"></a>
4.2 Commenting code (Required)</h2>
<h3><a class="anchor" id="autotoc_md199"></a>
4.2.1 Use C++ style comments ("//")</h3>
<p>All inline code comments should use the C++ style <code>//</code>. However there are two exceptions to this rule. First, function and file documentation blocks use a different style (see documentation section below).</p>
<p>Second, for multi-line macros using <code>#define</code>, C style comments <code>/* ... */</code> should be used for embedded comments (see example below).</p>
<p>For both kinds of comments, there should be a space following the opening comment marker. For example <code>// My comment</code>.</p>
<p>Make sure constant values in the code are explained. Function calls with raw constants should be labeled based on the parameter that is being passed in.</p>
<p><b>Example</b> </p><pre class="fragment">// Example for the exception
// This type is needed because using // would swallow the line continuation marker.
#define MY_CLI_COMMANDS \
  /* This command takes 3 arguments: */           \
  /*  Node ID - a 2-byte node ID destination */   \
  /*  Endpoint - a 1-byte node ID */              \
  /*  Cluster  - a 2-byte cluster ID */           \
  { "my_command", my_command_function, "vuv" },

// Example of how to comment constant values.
// For the function declaration below
void function(int seconds, boolean print_output);

// we add comments after each parameter (OPTIONAL)
function(0,        // seconds
         FALSE);   // print_output
</pre><h2><a class="anchor" id="autotoc_md200"></a>
4.3 Bracing style (Required)</h2>
<p>Use the so called "One True Brace Style" (see [<a href="https://en.wikipedia.org/wiki/Indent_style#Variant:_1TBS">https://en.wikipedia.org/wiki/Indent_style#Variant:_1TBS</a>]) Indent increases one level after an opening brace, and decreases one level before a closing brace. Opening braces do not go on their own separate line, except for free standing blocks and function definitions. Closing braces are on their own separate line with nothing else on these lines.</p>
<p><b>Clarification: The paragraph above takes precedence over the linked "One True
Brace Style" definition. In particular, opening braces must go on their own line for function definitions even though this is a deviation from the linked "One
True Brace Style".</b></p>
<p><b>All if/else/while/for/do-while blocks must be enclosed by braces, even if there is only one statement in the block.</b></p>
<p>Exceptions for the above rule are;</p>
<ol type="1">
<li>The typedef alias for a composite (<code>struct</code>/<code>union</code>) or <code>enum</code> type is on the same line as the closing brace.</li>
<li>In a do-while loop the condition (<code>while (...);</code>) is on the same line as the closing brace.</li>
<li>else and else if are on the same line as the closing brace.</li>
</ol>
<p><b>Example</b> </p><pre class="fragment">void sl_do_something(uint8_t bar)
{
  if (foo &gt; bar) { // The preceding brace is *required*
    do_this();
  } else if (for &lt; bar) {
    do_that();
  } else {
    do_another_thing();
  }

  if (foo &gt; bar) {
    do_this();
  }

  while (1) {
  }

  do {
    sli_do_work();
  } while (foo);
}

typedef enum {
  SL_CARD_SPADE,
  SL_CARD_HEART,
  SL_CARD_CLUB,
  SL_CARD_DIAMOND
} sl_card_suit_t;
</pre><h2><a class="anchor" id="autotoc_md201"></a>
4.4 Switch statements and labels</h2>
<h3><a class="anchor" id="autotoc_md202"></a>
4.4.1 Using labels (Required)</h3>
<p>Switch-case labels should be indented as any other line of code would be.</p>
<p><b>Example</b> </p><pre class="fragment">if (foo) {
  sl_bsp_set_leds(0xff00);

  testing:

  sl_bsp_set_leds(0x00ff);
}
</pre><h3><a class="anchor" id="autotoc_md203"></a>
4.4.2 Labels with block (Required)</h3>
<p>If a block is desired after a label, then the opening brace should be by itself on the line following the label, at the same indentation.</p>
<p>The closing brace should be on a line by itself after the last statement in the block, at the same indent level as the opening brace.</p>
<p><b>Example</b> </p><pre class="fragment">if (foo) {
  sl_bsp_set_leds(0xff00);

  testing:
  {
    sl_bsp_set_leds(0x00ff);
    sl_bsp_set_leds(0x0000);
  }
}
</pre><h3><a class="anchor" id="autotoc_md204"></a>
4.4.3 Switch statements (Required)</h3>
<p>The cases in switch statements should be indented one level from the enclosing braces. Separate case blocks with a blank line after each <code>break;</code>. All switch statements should include a <code>default</code> block unless there is a good reason not to. The default block can collapse into one of the other cases but it should clearly show what happens when there is no matching case. Finally, if a case block does not end with an unconditional jump, there should be a comment clearly stating that the code is intentionally meant to fall through.</p>
<p><b>Example</b> </p><pre class="fragment">switch(baz) {
  case 1:
    sli_do_this();
    break;

  case 2:
    sli_do_that();
    // This case is meant to fall through to the next

  case 3: {
    sli_do_the_other_thing();
    break;
  }

  case 0:
  default:
    sli_do_what();
    break;
}
</pre><h2><a class="anchor" id="autotoc_md205"></a>
4.5 Functions, operators and C keywords</h2>
<h3><a class="anchor" id="autotoc_md206"></a>
4.5.1 Listing function parameters (Required)</h3>
<p>Whenever there is a list of function parameters, they should all fit on a single line or be listed one parameter per line. If listed on separate lines, each parameter has the same indent level as the first parameter.</p>
<p><b>Example</b> </p><pre class="fragment">void sl_do_something(int a,
                     int b,
                     int c,
                     const char *string1,
                     const char *string2)
{
  // ...
}

void sl_do_something2(int a, int b, int c)
{
  // ...
}
</pre><h3><a class="anchor" id="autotoc_md207"></a>
4.5.2 Using function parentheses (Required)</h3>
<p>For function declarations, definitions and calls, there shall be no spaces before or after the opening parentheses, or before the closing parentheses.</p>
<p><b>Example</b> </p><pre class="fragment">int sl_foo(int days, int seconds);
// ...
ret = sl_foo(days, seconds);
</pre><h3><a class="anchor" id="autotoc_md208"></a>
4.5.3 Binary and ternary operators (Required)</h3>
<p>Use spaces around binary &amp; ternary operators in expressions. C expressions are hard enough to parse without running them altogether.</p>
<p><b>Example</b> </p><pre class="fragment">for (j = 0; j &lt; parameter_sizes[i]; j++) {
</pre><h3><a class="anchor" id="autotoc_md209"></a>
4.5.4 Use a single space after C keywords (Required)</h3>
<p>C keywords (ex. <code>for</code>, <code>switch</code>, <code>while</code>, <code>if</code>, <code>do</code>) â should have a single space after the keyword.</p>
<p><b>Example</b> </p><pre class="fragment">while (counter &lt; UART_MAX_IO_BUFFER) {
</pre><h3><a class="anchor" id="autotoc_md210"></a>
4.5.5 Additional space within expressions</h3>
<p>Use of additional whitespace within expressions to improve readability is permitted as long as it doesn't interfere with appropriate multi-line expression indentation. Such style should be consistent within the module.</p>
<h3><a class="anchor" id="autotoc_md211"></a>
4.5.6 Identify do-nothing code (Recommended)</h3>
<p>Avoid loops that do not make it obvious that they do nothing. Add a comment to explain the reason for the do-nothing loop. This applies to any code that does not do anything.</p>
<p><b>Example</b> </p><pre class="fragment">// Don't do:
while (waiting_for_something);

// Instead do:
// Useful comment explaining why you are waiting
while (waiting_for_something);
</pre><h3><a class="anchor" id="autotoc_md212"></a>
4.5.7 Pointer asterisk position (Required)</h3>
<p>When declaring a pointer to a variable, the pointer asterisk should be placed together with the variable name, not together with the type.</p>
<p><b>Example</b> </p><pre class="fragment">// Don't do:
char* c = (char*)a;
void sl_foo(uint32_t* bar);

// Instead do:
char *c = (char *)a;
void sl_foo(uint32_t *bar);
</pre><h3><a class="anchor" id="autotoc_md213"></a>
4.5.8 Don't mix pointer and value type declarations (Required)</h3>
<p>Don't mix declarations of pointer type variables and value type variables on the same line.</p>
<p><b>Example</b> </p><pre class="fragment">// Don't do:
uint32_t *a, b;

// Instead do:
uint32_t *a;
uint32_t b;
</pre><h2><a class="anchor" id="autotoc_md214"></a>
4.6 Naming</h2>
<h3><a class="anchor" id="autotoc_md215"></a>
4.6.1 General Considerations</h3>
<h4><a class="anchor" id="autotoc_md216"></a>
4.6.1.1 Use meaningful names (Required)</h4>
<p>Special care should be taken when naming anything. The name should convey the purpose of the construct as clearly as possible.</p>
<h4><a class="anchor" id="autotoc_md217"></a>
4.6.1.2 Avoid abbreviations (Required)</h4>
<p>In general, use long names and avoid unclear abbreviations and other cryptic notations.</p>
<p>Prefixes such as <code>sl_</code> and <code>sli_</code> are exceptions to this rule and therefore can and need to be used where appropriate.</p>
<p><b>Exception:</b> Well-known abbreviations in the Unify project can be used. But they must be documented in the Unify repo in the file <a class="el" href="known-abbreviations_8md.html">doc/standards/known-abbreviations.md</a>.</p>
<h3><a class="anchor" id="autotoc_md218"></a>
4.6.2 Namespaces (Required)</h3>
<p>All constructs will have a prefix, with the exception of function parameters, variables local to a function and structure fields.</p>
<p>The purpose of using namespace prefixes is to prevent namespace collisions and not necessarily for branding.</p>
<p>All constructs will start with the module/component prefix. The Unify SDK does not use the sl or sli_ prefix because it is a complete application and does not need namespace separation from customer code. The reason for this exception is to avoid overly long function names. Code intended for re-use in other protocol controllers shall use the sl_ prefix to indicate that both customers and Silicon Labs developers are expected to develop protocol controllers.</p>
<h3><a class="anchor" id="autotoc_md219"></a>
4.6.3 Naming (Required)</h3>
<p>The following section (4.6.3.*) contains information on how to name anything. This acts as a default, if nothing more specific exists for a particular construct. In general, construct-specific standards should be avoided.</p>
<h4><a class="anchor" id="autotoc_md220"></a>
4.6.3.1 Casing (Required)</h4>
<p>Every construct's name needs to be all lower-case, with each word or abbreviation separated by an underscore. This is also known as <a href="https://en.wikipedia.org/wiki/Snake_case">snake case</a>.</p>
<p><b>Example</b> </p><pre class="fragment">// Global variable
uint8_t sl_uart_char; // Publicly available
uint8_t sli_usbd_endpoint_buffer[32]; // Internal use only

// File-local variable
static sl_usbd_urb_t *urb_list_head;

// Functions
void sl_led_turn_on(void);
void sli_nvic_set_priority(ADC_IRQ);

// Data types
typedef uint32_t sli_kernel_flags_t;
typedef struct {
  uint8_t *data_start;
} sl_usbd_urb_t;
</pre><h4><a class="anchor" id="autotoc_md221"></a>
4.6.3.2 Casing and acronyms (Required)</h4>
<p>Acronyms and abbreviations are treated like any other word. Do not put in lower-case or upper-case some or all letters of an abbreviation, even if it is normally written that way. Instead, comply with the standard about that particular construct and treat acronyms as a regular word.</p>
<p><b>Example</b> </p><pre class="fragment">static sl_usbd_urb_t *urb_list_head;

sl_led_turn_on();

sl_irq_priority_t irq_priority = sl_nvic_get_priority(ADC_IRQ);
</pre><h3><a class="anchor" id="autotoc_md222"></a>
4.6.4 Naming functions and variables</h3>
<h4><a class="anchor" id="autotoc_md223"></a>
4.6.4.1 Functions and variables names have the form verb_noun (Required)</h4>
<p>When a verb and a noun the verb acts on are in a function name, the verb should come first (<code>xxxx_get_power</code>, not <code>xxxx_power_get</code>). It should feel natural to read the name. Most functions should contain both a verb and a noun and therefore need to follow this rule. Notable exceptions are functions that are callbacks, interrupt handlers and tasks, which typically do not have a verb. These functions follow their own naming convention, as stated in 4.6.4.5, 4.6.4.6 and 4.6.4.7, respectively.</p>
<p>Variables and functions of boolean type should use a naming style indicating the sense of the boolean. For example <code>sl_usbd_device_is_connected</code>.</p>
<p><b>Example</b> </p><pre class="fragment">// This is for legacy EM code and does not apply to 8051
// code base.

sl_get_power();    // Call to a new-style API function.

// Below is an example of how to redefine old style API calls to the new syntax.
#if (SLAB_OLD_API == SLAB_REPLACE_OLD_API_CALLS)
#define power_get sl_get_power
#define power_set sl_set_power
#endif
</pre><h4><a class="anchor" id="autotoc_md224"></a>
4.6.4.2 Function parameters should not have any prefix (Required)</h4>
<p>Do not prefix any function parameter with any <code>sl_</code>, <code>sli_</code> or <code>&lt;module&gt;_</code> prefix.</p>
<h4><a class="anchor" id="autotoc_md225"></a>
4.6.4.3 Function-local variables should not have any prefix (Required)</h4>
<p>Do not prefix any function-local variable with any <code>sl_</code>, <code>sli_</code> or <code>&lt;module&gt;_</code> prefix.</p>
<h4><a class="anchor" id="autotoc_md226"></a>
4.6.4.4 Variable and Function Names Indicate Units for Time (Required)</h4>
<p>When a variable is used for time, it must include the units in the name. When a function returns a value that is used for time it must include units in the name. This is important to prevent problems with accidentally utilizing one unit of time in a function or variable that takes a different unit of time.</p>
<p>Variables and function names may either use abbreviations or spell out the units. If abbreviations are used, the following shall be the abbreviations:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Full Name  </th><th class="markdownTableHeadNone">Abbreviation (if applicable)   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Years  </td><td class="markdownTableBodyNone">Years   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Days  </td><td class="markdownTableBodyNone">Days   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Hours  </td><td class="markdownTableBodyNone">Hours   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Minutes  </td><td class="markdownTableBodyNone">Minutes   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Seconds  </td><td class="markdownTableBodyNone">Sec   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Milliseconds  </td><td class="markdownTableBodyNone">Ms   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Microseconds  </td><td class="markdownTableBodyNone">Us   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Nanoseconds  </td><td class="markdownTableBodyNone">Ns   </td></tr>
</table>
<p><b>Example</b> </p><pre class="fragment">#define SLI_JITTER_DELAY_MS 100

static void restart_discovery_after_delay(uint8_t delay_ms);

uint8_t sli_get_discovery_time_remaining_ms(void);
</pre><h4><a class="anchor" id="autotoc_md227"></a>
4.6.4.5 Functions/stubs called on specific events/callbacks should start 'on' in their name (Required)</h4>
<p>Whenever a function is called to indicate an event occurred, or is called in 'reaction' to an event happenning, this function should have <code>on</code> in its name, directly after the <code>&lt;module&gt;_</code> prefix. This also applies to callbacks or function stubs shipped to the user.</p>
<p><b>Example</b> void sl_usb_on_device_connection(void);</p>
<p>void sl_kernel_on_task_deletion(void);</p>
<p>static void on_transmit_completed(void);</p>
<h4><a class="anchor" id="autotoc_md228"></a>
4.6.4.6 Interrupt handlers should be suffixed by 'IRQHandler' or 'irq_handler' (Required)</h4>
<p>If a function is an interrupt handler, it should either be suffixed by <code>IRQHandler</code> if it needs to follow CMSIS' format or by <code>irq_handler</code> if it doesn't (for example, if an interrupt source is shared and multiplexed) between several handlers.</p>
<p><b>Example</b> void RTCC_IRQHandler(void);</p>
<p>void sl_gpio_irq_handler(void);</p>
<h4><a class="anchor" id="autotoc_md229"></a>
4.6.4.7 Non-blocking functions executed periodically in a main loop should be suffixed by 'step' (Required)</h4>
<p>If a non-blocking function (a function that doesn't pend or delay before returning) needs to be called periodically in order to check if it has something to process and then process what it can, this function needs to be suffixed with <code>step</code>, to indicate it executes a single round of processing. It should not be called <code>tick</code>, since <code>tick</code> can lead to confusion with timer or OS ticks.</p>
<p><b>Example</b> void sl_cli_step(void);</p>
<p>void sli_usb_msc_step(void);</p>
<h4><a class="anchor" id="autotoc_md230"></a>
4.6.4.8 Functions that are tasks should be suffixed by 'task' (Required)</h4>
<p>If a function is a task (in an OS environment), this function needs to be suffixed with <code>task</code>, to indicate it is a task and needs to loop indefinitely and never return.</p>
<p><b>Example</b> void sl_cli_task(void *task_argument);</p>
<p>void sli_usb_task(void *task_argument);</p>
<p><b>Unify comment:</b> Contiki processes are exempted from this rule and follow the Contiki convention of a _process suffix.</p>
<h3><a class="anchor" id="autotoc_md231"></a>
4.6.5 Naming constants</h3>
<h4><a class="anchor" id="autotoc_md232"></a>
4.6.5.1 Constants should use upper case (Required)</h4>
<p>All constants should be named and use upper case letters. Avoid raw numbers in code. This includes <code>#defines</code> constants, <code>const</code> variables and enum values.</p>
<p><b>Example</b> </p><pre class="fragment">#define SLI_NET_ARP_FLAG 0x0040
const unsigned int SL_MAX_UART_CONNECTIONS = 3;

typedef enum {
    SL_USBH_HC_TYPE_LIST,
    SL_USBH_HC_TYPE_PIPE
} sl_usbh_hc_type_t;
</pre><h3><a class="anchor" id="autotoc_md233"></a>
4.6.6 Naming function-like macros</h3>
<h4><a class="anchor" id="autotoc_md234"></a>
4.6.6.1 Follow the naming convention for regular functions (Required)</h4>
<p>Functional macros that can be used in the same way as functions follow the same naming conventions as regular functions.</p>
<h4><a class="anchor" id="autotoc_md235"></a>
4.6.6.2 Use all caps for macros that can't be functions (Required)</h4>
<p>All caps with underscores are used for macros that cannot be made into semantically equivalent functions.</p>
<p><b>Example</b> </p><pre class="fragment">// This is a macro function that can be used as a regular function.
#define sl_uart_init_default_uart(x) init_uart(UART0, (x))

// This is a macro function that cannot be used as a function.
#define SL_SOME_NUMBERS(x) {(x), ((x)+(x)), ((x)*(x))}
</pre><h3><a class="anchor" id="autotoc_md236"></a>
4.6.7 Naming types</h3>
<h4><a class="anchor" id="autotoc_md237"></a>
4.6.7.1 Public typedefs (Required)</h4>
<p>Each typedef must end with a '_t' suffix and cannot start with 'int', 'uint' or 'unicode'.</p>
<h4><a class="anchor" id="autotoc_md238"></a>
4.6.7.2 Structure fields should be snake_case, without any prefixes (Required)</h4>
<p>There should not be any prefix (no <code>sl_</code> and no <code>&lt;module&gt;_</code>) in the name of any structure field.</p>
<p><b>Example</b> </p><pre class="fragment">// Don't do
typedef struct
{
  uint32_t sl_nvm_page_header_offset;
  uint32_t sl_nvm_page_header_size;
} sl_nvm_page_header_t;

// Instead do:
typedef struct
{
  uint32_t offset;
  uint32_t size;
} sl_nvm_page_header_t;
</pre><h4><a class="anchor" id="autotoc_md239"></a>
4.6.7.3 Type from typedef (Optional)</h4>
<p>If the type is a typedef, you can optionally add a type name if there is a reason the anonymous type does not work. In this case use the same name as the typedef name, without the '_t'.</p>
<p><b>Example</b> </p><pre class="fragment">// Anonymous structure name ...
// Use this style in most cases.
typedef struct
{
  // ...
} sl_nvm_page_header_t;

// You can use this style if the struct needs a name.
typedef struct sl_nvm_page_header
{
  // ...
} sl_nvm_page_header_t;
</pre><h3><a class="anchor" id="autotoc_md240"></a>
4.6.8 Files and directory structure</h3>
<h4><a class="anchor" id="autotoc_md241"></a>
4.6.8.1 Filenames and directories use lower case (Required)</h4>
<p>All file names are lower case and multiple words are separated with one underscore '_'.</p>
<p><b>Example</b> </p><pre class="fragment">sl_packet_buffer.c
</pre><h4><a class="anchor" id="autotoc_md242"></a>
4.6.8.2 Avoid duplicate filenames</h4>
<p>Avoid using the same file name for source files.</p>
<p><b>Note:</b> Among our entire source code there will be files with the same name. This cannot be avoided. But files with the same name should never be used in the same project/build.</p>
<h4><a class="anchor" id="autotoc_md243"></a>
4.6.8.3 File names (Required)</h4>
<p>File names (both for library and source) should include the namespace prefix of the module.</p>
<p><b>Example</b> </p><pre class="fragment">foobar_controller.c
mymod_status.h
</pre><p>The <code>sl_</code> prefix is not used in the Unify SDK, because it produces an integrated application without clear distinction between customer and company modules.</p>
<h4><a class="anchor" id="autotoc_md244"></a>
4.6.8.4 Directory names (Required)</h4>
<p>Directories use lower case names and underscores as word separators. Subfolder names do not need to be unique.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md245"></a>
5 Documentation</h1>
<h2><a class="anchor" id="autotoc_md246"></a>
5.1 General</h2>
<p>Write documentation so that others can easily pick up the code. It makes life easier for everyone. In particular, it makes supports job a lot easier as it will generate less support requests.</p>
<h2><a class="anchor" id="autotoc_md247"></a>
5.2 Comments should answer the question "Why?" (Required)</h2>
<p>Write comments that say why the code is the way it is. What the code does, and how it does it, can usually be figured out from the code itself. Why it does it, and why it does it the way that it does, cannot. If you write it the obvious way, and it doesn't work, explain in a comment why it didn't. Otherwise the next person to come along is going to convert it back to the obvious method and have to learn the same painful lesson (or even worse, force you to relearn it).</p>
<p>There needs to be enough documentation that a peer can read and understand the code without having to ask the author for explanations. If a code reviewer feels the need to ask for explanations about how stuff works, then the code author should add this additional information as comments in the code.</p>
<p>Comments should use correct grammar and full sentences.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md248"></a>
6 Doxygen Coding Style Guide</h1>
<p>Doxygen is used to document all code that is released to customers, with a focus on functions that are part of an API. For code that is only used internally it is still strongly recommended to use Doxygen commenting as internal users will find it useful.</p>
<p>For file and function comment blocks, the following style is used: </p><pre class="fragment">/**
 * doc comments ...
 */
</pre><p>For all other doc comments, the C++ style <code>///</code> is used.</p>
<h2><a class="anchor" id="autotoc_md249"></a>
6.1 File comment header (Required)</h2>
<p>All source files should have a file comment header that looks similar to the following. The actual license text will depend on the project. See section 7 for details about licenses.</p>
<h2><a class="anchor" id="autotoc_md250"></a>
6.2 Grouping modules (@addtogroup) (Recommended)</h2>
<p>Use the Doxygen command <code>@addtogroup</code> to group together source code that belongs to the same module, for example UART and SPI and so on. This will make it easier for customers to find the API documentation for the modules they are interested in.</p>
<p>It is also possible to create groups hierarchies, for example to have an ADC group in the EM_Library group.</p>
<p><b>Example</b> </p><pre class="fragment">/**
 * @addtogroup EM_Library
 * @{
 */

/// variable, constants and code belonging to EM_Library
/// (but not in the ADC module).
uint32_t sl_some_global_variable;

/**
 * @addtogroup ADC
 * @brief Analog to Digital Converter (ADC) Peripheral API
 * @{
 */

/// variable, constants and code belonging to EM_Library and ADC module
bool sl_is_adc_configured;

/** @} (end addtogroup ADC) */

/** @} (end addtogroup EM_Library) */

/// @} (end groupName)
</pre><h2><a class="anchor" id="autotoc_md251"></a>
6.3 File/module level documentation (Recommended)</h2>
<p>If a file is part of a module, it may be desirable to include file-level documentation. For example, the file level documentation may provide an overview of how to use an API. To provide file-level documentation, a Javadoc style Doxygen comment block should follow the file include statements.</p>
<p><b>Example</b> </p><pre class="fragment">/**
 *
 * @addtogroup adc_group ADC API
 *
 * @brief Brief one-sentence description of ADC module.
 *
 * The rest of this section can be multi paragraph explanation of the
 * module. It can include tables and code examples. End the description
 * as shown below and this will collect the remaining API documentation
 * into this group.
 *
 * @{
 *
 */
</pre><p>If a group is created as shown above, it needs to be closed at the end of the file using one of the two methods shown below: </p><pre class="fragment">// The following is used if there is only one group in a file or
// groups are not nested.

/// @} end adc_group

// The following is used when groups are nested. This is needed so
// that doxygen does not pick up the "end adc_group" as part of a doc
// comment for a following or enclosing group.

/** @} end adc_group */
</pre><p>&gt;<b>Comment:</b> The method used is optional. If in doubt about whether the second method is needed, run Doxygen on your file and see if the "end" comment is being picked up in the documentation.</p>
<h2><a class="anchor" id="autotoc_md252"></a>
6.4 Function documentation (Required)</h2>
<p>This is required for any library or module code that will be customer facing. It is also highly recommended to document any other code in the same way, even if it is not expected to be customer-facing. Often times non-customer-facing code ends up being delivered to a customer anyway.</p>
<p>Normally, functions that are part of an example (like main) or other simple functions that are part of the application and not library or module functions are not documented with Doxygen. It may still be useful to use Doxygen to provide documentation for complex examples.</p>
<p>Each function definition contains at least a function brief statement and list of parameters and return value if any. Doxygen will pick up a single sentence at the start of the comment block as the brief description, so the <code>@brief</code> tag is not necessary.</p>
<p>If the function contains parameters and a return value, then these parameters and return value must also be documented in Doxygen.</p>
<p>Optionally the <code>@note</code> command can be used to highlight anything that the user should pay extra attention to when using this function.</p>
<p>It is useful to read the Doxygen documentation about how you can write good documentation for your functions. Besides <code>@note</code>, there are other tags that can also be used. For example <code>@sa</code> (see also) can be used to create a link to another documented section. If you put a full function name or variable name that Doxygen knows about, it will automatically create a link to the documentation for that other function or variable. For macros you can add the <code>@ref</code> tag before the item name and a link will be generated.</p>
<p><b>Example</b> </p><pre class="fragment">/**
 * Brief description of function.
 *
 * @param myParam1 is a parameter that is most excellent
 * @param myParam2 is not such a good parameter
 * @returns Returns true on Tuesdays or whenever it is raining.
 *
 * Detailed description here. Can be multiple sentences. Can
 * contain markdown (tables, code examples, bulleted lists)
 *
 * Can add as many additional paragraphs as needed.
 *
 * @note A note if the API needs a note.
 */
 uint8_t sl_my_public_function(uint8_t my_param1, uint16_t my_param2)
 {
   // ...
 }
</pre><h2><a class="anchor" id="autotoc_md253"></a>
6.5 Variable documentation (Required)</h2>
<p>All public variables that are part of an API must be documented. It is also recommended to document all file-level global variables even if they are not public.</p>
<p><b>Note:</b> It is not necessary to document local (automatic) variables.</p>
<p>Many variable will only require a single line or brief comment. In this case you should use a C++ style doxygen comment <code>///</code>. You can use this same style even for several lines of a documenting comment. However, if the variable requires a large documentation block or needs to be visually separated from other sections of the source code file, then use the same style blocks as used for functions.</p>
<p><b>Example</b> </p><pre class="fragment">/// A brief description of this variable.
uint8_t sl_meaningful_variable_name;

/// This variable has a brief line of documentation.
/// Then it also has some additional lines of documentation.
uint32_t sl_another_variable;

/**
 * Brief description of complicated variable.
 * Additional extra documentation for this complicated variable that
 * needs a bigger explanation. Or perhaps I just want this variable to
 * stand out in my source file so I use the large comment blocks.
 */
</pre><p>For fields of a structure, or a list of constants or anything that requires just a brief comment, there is another style (post) that can be used. In this case you put the doc comment on the same line as the item (instead of before it). To do this the comment needs to start like this: <code>///&lt; Brief comment.</code></p>
<p><b>Example</b> </p><pre class="fragment">/// A brief comment about this data type.
/// I can follow with additional explanation as needed, perhaps how
/// it is used or allowed values or constraints.
typedef struct
{
    uint8_t r;    ///&lt; Brief comment about this field.
    uint8_t g;    ///&lt; Green pixel value.
    uint8_t b;    ///&lt; Blue pixel value.
} sl_pixel_t;
</pre><h2><a class="anchor" id="autotoc_md254"></a>
6.6 Header file vs. implementation file (Recommended)</h2>
<p>To keep a simple distinction between public documentation and internal documentation, all public documentation comments should be placed into the library or module header (.h) file. This allows us to just pull in header files when generating public-facing documentation and not need to worry about separation of public or private content.</p>
<p>The implementation file (.c) should also be documented if there additional non- public functions or variables that are not part of the public documentation. The .c doc comments can be used for generating internal documentation.</p>
<p>If a function in a .c file is already documented in the header file, then it is not necessary to repeat the documentation. However, a comment block should be used with the brief description to visually mark the function in the source file.</p>
<p><b>Example</b> </p><pre class="fragment">/**
 * Brief description of function.
 */
 uint8_t sl_do_something(uint8_t my_param1, uint16_t my_param2)
</pre><p>If the function is a private (<code>static</code>) function then it should use a normal comment block (same as public function in a header file). Private variables should also be documented.</p>
<h2><a class="anchor" id="autotoc_md255"></a>
6.7 Do not document sections (Recommended)</h2>
<p>The Doxygen configuration file for the project should be configured to exclude undocumented objects. Therefore it is not necessary to add extra statements to exclude Doxygen processing. Simply do not add Doxygen comments to the code you do not want documented.</p>
<p><b>Example</b> </p><pre class="fragment">/// The following variable will be picked as part of the
/// documentation.
uint8_t sl_my_public_variable;

// This variable should also have a comment to explain it,
// but by using only double-slash, it will not get picked
// up by Doxygen.
static uint8_t my_private_variable;

/**
 * This is a function that will not be documented.
 *
 * Note the lack of the double slash at the end of the top line. That
 * means this is not a true Javadoc comment block and Doxygen will not
 * see it.
 */
void sli_do_something_secret(void)
{
  // ...
}
</pre><h2><a class="anchor" id="autotoc_md256"></a>
6.8 Do not release sections (Recommended)</h2>
<p>There may be instances where there are source files which contain sections that should not be released, for example references to an emulator or todo comments. In some build systems, you may use commented double square brackets (<code>//[[...]] or</code>//[[<code>and</code>//]]`) to hide such code. You must make sure that the build system used on said source runs the codestripper before relying on this functionality.</p>
<p><b>Example</b> </p><pre class="fragment">//[[
// Don't release this define
#define SL_EMULATOR_CONFIG 1
//]]
</pre><hr  />
<h1><a class="anchor" id="autotoc_md257"></a>
7 Licensing</h1>
<h2><a class="anchor" id="autotoc_md258"></a>
7.1 Silicon Labs Licenses</h2>
<p>All of our released source files (.c, .h, others; generated and manually written) should fall under one of the few licenses approved by our legal team. All source files are therefore required to have a file comment header containing the correct license type.</p>
<ul>
<li>The <a href="license-header-standard.h">default license text</a> must be used unless otherwise specified.</li>
<li>The <a href="license-header-third-party.h">third-party license text</a> is added on top of any third-party code. It does not remove the existing text. If we include any third party software, we need a way to clearly identify it as such. Yes, this is extra work, but is required by our legal team. Using and releasing third-party code has more constraints, see section 7.2 for the details.</li>
</ul>
<p>Please note that the version field in these headers is optional. If used, the version field should be used to denote the component version, not the Gecko SDK version.</p>
<h2><a class="anchor" id="autotoc_md259"></a>
7.2 Third-Party Code</h2>
<p>We generally favor writing and maintaining our own code when the differences (in effort, quality, market acceptance, etc.) with an open-source one are small.</p>
<p>The VP of Software must give his consent before any kind of third-party code is allowed to be used, as special care must be taken when dealing with this type of code. Specifically, content licensed to us under a "copyleft" license (GPL and other viral open-source licenses) <b>must not be released</b>, including in compiled form (such as a library or binary).</p>
<p>New copyleft content should not be added. Existing copyleft released content must be audited against this rule, documented and flagged to the VP of Software for quick resolution. Whenever feasible and regardless of whether it is being released or is a documented exception, existing copyleft content should be replaced.</p>
<p>Content that is "multi-licensed" (offered to us under our choice of more than one license) is not considered copyleft if at least one of the offered licenses is not copyleft.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md260"></a>
8 C++ Specific Guidelines</h1>
<p>C is our primary language because we assume that a larger customer base will be familiar with C. We are gradually introducing C++ where it makes sense. Essentially, where the benefits of a particular C++ language feature outweighs the maintenance cost associated with customer education, tooling maintenance and developer cognitive overhead.</p>
<p>Automatic mocking with CMock is an integral part of our effort to have comprehensive unit test coverage. Automatic mocks of C++ code present unique challenges. Particularly, there is no C++ equivalent of the automatic mock creation feature of CMock.</p>
<ol type="1">
<li>Components must expose a C API even when using C++ internally for the implementation. This can be a thin C wrapper around a C++ component. This requirement may however be omitted for some cases, which are described below.</li>
</ol>
<ol type="1">
<li>Component may expose C++ APIs that are mockable using CMock. E.g. by also exposing a C API wrapping the C++ API and mocking that with CMock.</li>
</ol>
<ol type="1">
<li>Trivial components that do not require unit testing may expose C++ APIs that are not mockable with CMock. E.g. simple converters. </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Aug 30 2021 13:07:55 for Z-Wave Protocol Controller by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
