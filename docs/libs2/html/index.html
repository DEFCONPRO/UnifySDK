<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libs2: libs2 API Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libs2
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">libs2 API Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Silicon Laboratories Inc. </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0</dd></dl>
<p>libs2 is an library which implements all functionality related to Z-Wave S2 security. libs2 is deviced into 4 major components. Z-Wave S2 security is extensively described in SDS11274.</p>
<ul>
<li>crypto functions, both raw aes modules, eliptic curve functions and higher level functions, such a random number generator, key derivation functions and streaming functions such as AESCCM. </li>
<li>S2trans functions. Responsible for frame exchange during normal S2 communication. </li>
<li>s2incl functions. These function are responsible for secure key exchange during inclusion. This is the module which used the ECDH functions. </li>
<li>keystore functions. These are not really implemented by libs2, but is an abstract description of functions needed by libs2 to store ECDH keys and network keys.</li>
</ul>
<h1><a class="anchor" id="integration"></a>
Integrating libs2</h1>
<p>This section describes how in integrate libs2 into a existing Z-Wave application. Throughout this section we will refer to sections of the Z/IP Gateway source code. The Z/IP Gateway is a Z-Wave reference implementation that uses libs2. In the Z/IP Gateway, the important places to look is the source file S2_wrap.c and CC_Networkmanagement.c.</p>
<h2><a class="anchor" id="tran_int"></a>
Transport Layer Integration</h2>
<p>To get started an application using libs2 must implement the functions defined in s2external. In the Z/IP Gateway these are all implemented in S2_wrap.c.</p>
<p>Fist we will describe all the calls from libs2 and upward to your application.</p>
<p>First the functions S2_send_frame and S2_send_frame_multi must be implemented. These function maps directly to ZW_SendData or ZW_SendDataBridge if a bridge library is used. When sending is done, the S2 layer need to be notified using the function S2_send_frame_done_notify.</p>
<p>An implementations may look like this:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> S2_send_frame_callback(BYTE txStatus) {</div>
<div class="line">  S2_send_frame_done_notify((<span class="keyword">struct</span> S2*) user,</div>
<div class="line">      txStatus == TRANSMIT_COMPLETE_OK ? S2_TRANSMIT_COMPLETE_OK : S2_TRANSMIT_COMPLETE_NO_ACK,</div>
<div class="line">          clock_time()-transmit_start_time + NONCE_REP_TIME);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">uint8_t S2_send_frame(<span class="keyword">struct</span> S2* ctxt,<span class="keyword">const</span> s2_connection_t* conn, uint8_t* buf, uint16_t len) {</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">return</span> ZW_SendData(conn-&gt;r_node,</div>
<div class="line">                (BYTE*) buf,</div>
<div class="line">                len,</div>
<div class="line">                conn-&gt;zw_tx_options, S2_send_frame_callback);</div>
<div class="line">}                </div>
<div class="line"> </div>
<div class="line">uint8_t S2_send_frame_multi(<span class="keyword">struct</span> S2* ctxt,<span class="keyword">const</span> s2_connection_t* conn, uint8_t* buf, uint16_t len) {</div>
<div class="line">   transmit_start_time = clock_time();</div>
<div class="line">   <span class="keywordflow">return</span> ZW_SendData(0xFF,</div>
<div class="line">                (BYTE*) buf,</div>
<div class="line">                len,</div>
<div class="line">                conn-&gt;zw_tx_options, S2_send_frame_callback);</div>
<div class="line">}                </div>
</div><!-- fragment --><p>The next thing is a timer the function S2_set_timeout must start a timer and then call S2_timeout_notify on timeout.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> timeout() {</div>
<div class="line">  S2_timeout_notify(ctxt);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> S2_set_timeout(<span class="keyword">struct</span> S2* ctxt, uint32_t interval) {</div>
<div class="line">  ZW_TimerStart(interval/10, timeout,TIMER_ONE_TIME)</div>
<div class="line">} </div>
</div><!-- fragment --><p>Now we need to interface a HW random number generator. Make sure that this a hardware seeded random number.</p>
<div class="fragment"><div class="line">S2_get_hw_random(</div>
<div class="line">  uint8_t *buf,</div>
<div class="line">  uint8_t len)</div>
<div class="line">{</div>
<div class="line">  uint8_t *pbuf;</div>
<div class="line">  uint8_t rnd[2];</div>
<div class="line">  uint8_t left, pos;</div>
<div class="line"> </div>
<div class="line">  pbuf = buf;</div>
<div class="line">  left = len;</div>
<div class="line">  <span class="keywordflow">while</span> (left &gt; 0)</div>
<div class="line">  {</div>
<div class="line">    ZW_GetRandomWord(rnd);    </div>
<div class="line">    *pbuf++ = *rnd;</div>
<div class="line">    left--;</div>
<div class="line">    <span class="keywordflow">if</span> (left &gt; 0)</div>
<div class="line">    {</div>
<div class="line">      *pbuf++ = *(rnd + 1);</div>
<div class="line">      left--;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>We also need to setup command list, which is sent in the S2 commands supported get. This is the "S2 NIF".</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> S2_get_commands_supported(uint8_t class_id, uint8_t** cmdClasses, uint8_t* length) {</div>
<div class="line">  *cmdClasses = &amp;SecureClasses[0];</div>
<div class="line">  *length  = nSecureClasses;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Finally what to do when a S2 frame has been received:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> S2_msg_received_event(<span class="keyword">struct</span> S2* ctxt,s2_connection_t* src , uint8_t* buf, uint16_t len) {</div>
<div class="line">  ts_param_t p;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> scheme_map[] = {</div>
<div class="line">      SECURITY_SCHEME_2_UNAUTHENTICATED,</div>
<div class="line">      SECURITY_SCHEME_2_AUTHENTICATED,</div>
<div class="line">      SECURITY_SCHEME_2_ACCESS};</div>
<div class="line">  ts_set_std(&amp;p,0);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  p.scheme = scheme_map[src-&gt;class_id];</div>
<div class="line">  p.snode = src-&gt;r_node;</div>
<div class="line">  p.dnode = src-&gt;l_node;</div>
<div class="line"> </div>
<div class="line">  ApplicationCommandHandlerZIP(&amp;p,(ZW_APPLICATION_TX_BUFFER*)buf,len);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This was all the functions which are calling upward. Now we cover all the functions calling downward. Ie, from you application into libs2.</p>
<p>On application boot fist thing to do is to initiate the S2 context. This is done with S2_init_ctx. This must be done on application startup and when the homeid changes. In this example we also check if the context has already been initialized. </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(s2_ctx) S2_destroy(s2_ctx);</div>
<div class="line">s2_ctx = S2_init_ctx(UIP_HTONL(homeID));</div>
</div><!-- fragment --><p>The function S2_init_ctx will also read the keys from the keystore, and initialize the prng.</p>
<p>When the application receives a COMMAND_CLASS_SECURITY2 frame, it must call the S2_application_command_handler. It is important that the S2_RXOPTION_MULTICAST is set when receiving multicast or broadcast frame.</p>
<div class="fragment"><div class="line">security2_CommandHandler(ts_param_t* p,</div>
<div class="line"><span class="keyword">const</span> ZW_APPLICATION_TX_BUFFER *pCmd, uint16_t cmdLength) <span class="comment">/* IN Number of command bytes including the command */</span></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> uint8_t s2_cap_report[] = {COMMAND_CLASS_SECURITY_2, SECURITY_2_CAPABILITIES_REPORT,0};</div>
<div class="line"> </div>
<div class="line">  s2_connection_t conn;</div>
<div class="line">  conn.r_node = p-&gt;snode;</div>
<div class="line">  conn.l_node = p-&gt;dnode;</div>
<div class="line">  conn.zw_tx_options = p-&gt;tx_flags;</div>
<div class="line">  conn.rx_options = 0;</div>
<div class="line"> </div>
<div class="line">  conn.tx_options = p-&gt;rx_flags &amp; ( RECEIVE_STATUS_TYPE_BROAD |  RECEIVE_STATUS_TYPE_MULTI) ? S2_RXOPTION_MULTICAST : 0;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span>( (pCmd-&gt;ZW_Common.cmd == SECURITY_2_CONTROLLER_CAPABILITIES_GET)  &amp;&amp; (p-&gt;scheme == SECURITY_SCHEME_2_ACCESS)) {</div>
<div class="line">    S2_send_data(s2_ctx,&amp;conn,s2_cap_report,<span class="keyword">sizeof</span>(s2_cap_report));</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    S2_application_command_handler(s2_ctx,&amp;conn,(uint8_t*) pCmd,cmdLength);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="single_trans"></a>
Singlecast frame transmission.</h2>
<p>When the application needs to send a S2 singlecast frame it just calls S2_send_data. It is important to select the desired security class. And also which verification strategy to use when sending. See S2_TXOPTION_VERIFY_DELIVERY. When frame transmission has completed libs2 will call the function S2_send_done_event.</p>
<h2><a class="anchor" id="multicst_trans"></a>
Multicast frame transmission</h2>
<p>When sending multicast frames the application needs to go though multiple steps.</p>
<ul>
<li>A group id must be selected. A group id is just a byte representing the group of nodes the multicast frame is destened for. It is the application which is responsible for mapping multicast node lists and multicast group ids.</li>
</ul>
<ul>
<li>Then the application sends a S2 multi cast frame with S2_send_data_multicast here the r_node must be set to the group id. </li>
<li>Then the application must send a singlecast folloup message to the first node in the node list. Here the application will set S2_TXOPTION_SINGLECAST_FOLLOWUP, S2_TXOPTION_VERIFY_DELIVERY and S2_TXOPTION_FIRST_SINGLECAST_FOLLOWUP. </li>
<li>now the application may sync up the next nodes, but this time it must only set S2_TXOPTION_SINGLECAST_FOLLOWUP, S2_TXOPTION_VERIFY_DELIVERY </li>
<li>the last step must be repeated for the rest of the nodes.</li>
</ul>
<h2><a class="anchor" id="key_int"></a>
Keystore Layer Integration</h2>
<p>Here we must interface routines which stores the network and ECDH keys to a file or flash storange. In the Z/IP Gateway this is implemented in s2_keystore.c. Integration of this should be straight forward. See keystore.</p>
<p>Notice on the ECDH keypair generations. The private EDCH key may just be any 128 random number. The public ECDH key may be generated from the private key using the funciton crypto_scalarmult_curve25519_base. This means that in reality the application only needs to actually store the private ECDH key.</p>
<p>The function keystore_public_key_read, may be implemented like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div>
<div class="line">keystore_public_key_read(uint8_t *pub_key)</div>
<div class="line">{</div>
<div class="line">  uint8_t priv_key[32];</div>
<div class="line">  keystore_private_key_read(priv_key);</div>
<div class="line">  crypto_scalarmult_curve25519_base(pub_key,priv_key);</div>
<div class="line">  memset(priv_key,0,<span class="keyword">sizeof</span>(priv_key));</div>
<div class="line">} </div>
</div><!-- fragment --><h2><a class="anchor" id="incl_int"></a>
Inclusion Layer Integration</h2>
<p>The inclusion layer integration, mainly require the application to setup an event handler which need to act on cirtan events. There is also a timer associated with the inclusion module. The functions related to the inclusion module is described in s2incl. In the Z/IP Gateway these functions are referred in S2_wrap.c.</p>
<p>In S2 incluison the application user need to verify the identity as well as the security level of a node being included. When a controller or slave is being included into a network the user may optionally verify the including controler.</p>
<p>This means that the appliction needs to handle user inteaction durring inclusion.</p>
<p>Fist the application must initailise the inclusion layer on boot, and setup the event handler, see <a class="el" href="index.html#incl_event_handler">Setting up the user libs2 inclusion event handler.</a>. </p><div class="fragment"><div class="line">s2_inclusion_init(SECURITY_2_SCHEME_1_SUPPORT,KEX_REPORT_CURVE_25519,</div>
<div class="line">    SECURITY_2_SECURITY_2_CLASS_0|SECURITY_2_SECURITY_2_CLASS_1 | SECURITY_2_SECURITY_2_CLASS_2 | SECURITY_2_SECURITY_0_NETWORK_KEY);</div>
<div class="line">s2_inclusion_set_event_handler(&amp;sec2_event_handler);</div>
</div><!-- fragment --><h2><a class="anchor" id="incl_event_handler"></a>
Setting up the user libs2 inclusion event handler.</h2>
<p>The event handler is registered into libs2 using the function s2_inclusion_set_event_handler. The events that must be handled by the event handler is described in zwave_event_codes_t.</p>
<p>This is an example of an event handler </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> sec2_event_handler(zwave_event_t* ev) {</div>
<div class="line">  uint8_t flags;</div>
<div class="line">  <span class="keywordflow">switch</span>(ev-&gt;event_type) {</div>
<div class="line">    <span class="keywordflow">case</span> S2_NODE_INCLUSION_INITIATED_EVENT:</div>
<div class="line">      sec0_abort_inclusion(); <span class="comment">//Here we abort S0 inclusion</span></div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> S2_NODE_INCLUSION_PUBLIC_KEY_CHALLENGE_EVENT:</div>
<div class="line">      <span class="comment">/* Here we ask the user to verify the public key */</span></div>
<div class="line">      NetworkManagement_dsk_challenge(ev-&gt;evt.s2_event.s2_data.challenge_req.public_key);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> S2_NODE_INCLUSION_KEX_REPORT_EVENT:</div>
<div class="line">      <span class="comment">/* Here we ask the user to verify that the node is allowed to get the security classes it has asked for*/</span></div>
<div class="line">      NetworkManagement_key_request(ev-&gt;evt.s2_event.s2_data.kex_report.security_keys);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> S2_NODE_INCLUSION_COMPLETE_EVENT:</div>
<div class="line">      <span class="comment">/* The new node has been S2 included */</span></div>
<div class="line">      <span class="keywordflow">if</span>(sec_incl_cb) {</div>
<div class="line">        sec_incl_cb(keystore_flags_2_node_flags(ev-&gt;evt.s2_event.s2_data.inclusion_complete.exchanged_keys));</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> S2_NODE_JOINING_COMPLETE_EVENT:</div>
<div class="line">      <span class="comment">/* The controller has now been included. Here we ask the keystore which keys has been granted.*/</span></div>
<div class="line">      nvm_config_get(assigned_keys,&amp;flags);</div>
<div class="line">      <span class="keywordflow">if</span>(sec_incl_cb) {</div>
<div class="line">        sec_incl_cb(keystore_flags_2_node_flags(flags));</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> S2_NODE_INCLUSION_FAILED_EVENT:</div>
<div class="line">      <span class="comment">/* We have failed to S2 include the new node, or failed to be included ourselevs */</span></div>
<div class="line">      <span class="keywordflow">if</span>(sec_incl_cb) {</div>
<div class="line">        sec_incl_cb(NODE_FLAG_KNOWN_BAD | (ev-&gt;evt.s2_event.s2_data.inclusion_fail.kex_fail_type &lt;&lt; 16));</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> S2_JOINING_COMPLETE_NEVER_STARTED_EVENT:</div>
<div class="line">      <span class="comment">/* The S2 bootstrapping never started. If this was a SmartStart learn mode, we must</span></div>
<div class="line"><span class="comment">       * self-destruct now. */</span></div>
<div class="line">      <span class="keywordflow">if</span>(is_smart_start_learn_mode) {</div>
<div class="line">        do_self_destruct();</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> In the example above NetworkManagement_key_request, will ask the user if the device is allowed to get the S2 keys which it has asked for. There is not requirement for user interaction in this step. The controller may choose just to call s2_inclusion_key_grant with the same keys as requested.</p>
<p>In addition NetworkManagement_dsk_challenge will ask the user to verify the public key. Please not that for S2 access class devices ev-&gt;evt.s2_event.s2_data.challenge_req.public_key will not contain the first two bytes of the DSK. These two bytes must be entered by the user. Then the user has verified the DSK (and optionally typed in two bytes), s2_inclusion_challenge_response must be called.</p>
<p>The S2_JOINING_COMPLETE_NEVER_STARTED_EVENT is emitted when the S2 bootstrapping never started. If the device is a controller and is adding another device, this event can be safely ignored. A device in classic learn mode can also ignore this event. This event is only important for devices which have just completed a Smart Start learn mode - they must initiate a self-destruct when receiving upon receiving the event. Smart Start included devices receiving the S2_NODE_INCLUSION_FAILED_EVENT must also self-destruct. In the example above, this happens in sec_incl_cb().</p>
<h2><a class="anchor" id="incl_timer"></a>
Inclusion timer.</h2>
<p>Setting the inclusion timer(s2_inclusion_set_timeout) is straight forward.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> incl_timeout(<span class="keywordtype">void</span>* ctxt) {</div>
<div class="line">  s2_inclusion_notify_timeout((<span class="keyword">struct</span> S2*)ctxt);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">uint8_t s2_inclusion_set_timeout(<span class="keyword">struct</span> S2* ctxt, uint32_t interval) {</div>
<div class="line">  ctimer_set(&amp;s2_inclusion_timer,interval * 10,incl_timeout,ctxt);</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="do_inclusion"></a>
Perfoming a inclusion or learnmode.</h2>
<p>The two relevant functions are s2_inclusion_including_start and s2_inclusion_joining_start which should be executed right after the Z-Wave protocol inclusion is done.</p>
<dl class="section see"><dt>See also</dt><dd>Initiating Add mode s2_inclusion_including_start.<br  />
 A state diagram for add mode is seen in add_mode_fsm.<br  />
 Initiation Learn mode s2_inclusion_joining_start.<br  />
 A state diagram for learn mode is seen in learn_mode_fsm.<br  />
 </dd></dl>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Mar 23 2022 08:49:24 for libs2 by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
