/******************************************************************************
 * # License
 * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>
 ******************************************************************************
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 *****************************************************************************/

// This file is generated by ZCL Advanced Platform generator. Please don't edit manually.
#include "uic_mqtt.h"
#include "sl_log.h"
#include "sl_status.h"
#include "json_helpers.hpp"

#include <iostream>
#include <sstream>
#include <string>
#include <unordered_map>
#include <vector>
#include <inttypes.h>
#include <stdexcept>

#include <boost/algorithm/string.hpp>

#include "dotdot_mqtt.h"
#include "dotdot_mqtt.hpp"
#include "dotdot_bitmap.hpp"
#include "dotdot_mqtt_command_helpers.hpp"
#include "dotdot_mqtt_internals.hpp"
#include "dotdot_mqtt_attributes.h"
#include "dotdot_mqtt_translators.h"

#include <nlohmann/json.hpp>

static constexpr char LOG_TAG[] = "dotdot_mqtt";
static constexpr char LOG_FMT_JSON_PARSE_FAIL[] = "by-unid %s::%s: Unable to parse JSON payload: check payload syntax";
static constexpr char LOG_FMT_JSON_ERROR[] = "by-unid %s::%s: Unable to parse JSON payload: %s";




// Callbacks pointers
uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback_t uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback = nullptr;
static uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback_t uic_mqtt_dotdot_basic_generated_reset_to_factory_defaults_callback = nullptr;
uic_mqtt_dotdot_basic_write_attributes_callback_t uic_mqtt_dotdot_basic_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_basic_force_read_attributes_callback_t uic_mqtt_dotdot_basic_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback_set(const uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback_t callback)
{
  uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback = callback;
}
void uic_mqtt_dotdot_basic_generated_reset_to_factory_defaults_callback_set(const uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback_t callback)
{
  uic_mqtt_dotdot_basic_generated_reset_to_factory_defaults_callback = callback;
}


void uic_mqtt_dotdot_set_basic_write_attributes_callback(
  const uic_mqtt_dotdot_basic_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_basic_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_basic_force_read_attributes_callback(
  const uic_mqtt_dotdot_basic_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_basic_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/Basic/Commands/ResetToFactoryDefaults
void uic_mqtt_dotdot_on_basic_reset_to_factory_defaults(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Basic", "ResetToFactoryDefaults");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic", "ResetToFactoryDefaults", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic", "ResetToFactoryDefaults", "");
    return;
  }

  uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Basic/GeneratedCommands/ResetToFactoryDefaults
static void uic_mqtt_dotdot_on_generated_basic_reset_to_factory_defaults(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_basic_generated_reset_to_factory_defaults_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Basic", "ResetToFactoryDefaults");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic", "ResetToFactoryDefaults", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic", "ResetToFactoryDefaults", "");
    return;
  }

  uic_mqtt_dotdot_basic_generated_reset_to_factory_defaults_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Basic/Commands/WriteAttributes
void uic_mqtt_dotdot_on_basic_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_basic_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_basic_state_t new_state = {};
  uic_mqtt_dotdot_basic_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_basic_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Basic", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_basic_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_basic_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_basic_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_basic_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.zcl_version = true;
        force_update.application_version = true;
        force_update.stack_version = true;
        force_update.hw_version = true;
        force_update.manufacturer_name = true;
        force_update.model_identifier = true;
        force_update.date_code = true;
        force_update.power_source = true;
        force_update.generic_device_class = true;
        force_update.generic_device_type = true;
        force_update.product_code = true;
        force_update.producturl = true;
        force_update.manufacturer_version_details = true;
        force_update.serial_number = true;
        force_update.product_label = true;
        force_update.location_description = true;
        force_update.physical_environment = true;
        force_update.device_enabled = true;
        force_update.alarm_mask = true;
        force_update.disable_local_config = true;
        force_update.sw_buildid = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"ZCLVersion", &force_update.zcl_version },
          {"ApplicationVersion", &force_update.application_version },
          {"StackVersion", &force_update.stack_version },
          {"HWVersion", &force_update.hw_version },
          {"ManufacturerName", &force_update.manufacturer_name },
          {"ModelIdentifier", &force_update.model_identifier },
          {"DateCode", &force_update.date_code },
          {"PowerSource", &force_update.power_source },
          {"GenericDevice-Class", &force_update.generic_device_class },
          {"GenericDevice-Type", &force_update.generic_device_type },
          {"ProductCode", &force_update.product_code },
          {"ProductURL", &force_update.producturl },
          {"ManufacturerVersionDetails", &force_update.manufacturer_version_details },
          {"SerialNumber", &force_update.serial_number },
          {"ProductLabel", &force_update.product_label },
          {"LocationDescription", &force_update.location_description },
          {"PhysicalEnvironment", &force_update.physical_environment },
          {"DeviceEnabled", &force_update.device_enabled },
          {"AlarmMask", &force_update.alarm_mask },
          {"DisableLocalConfig", &force_update.disable_local_config },
          {"SWBuildID", &force_update.sw_buildid },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_basic_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "Basic/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_basic_zcl_version_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/ZCLVersion", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/ZCLVersion";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_basic_application_version_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/ApplicationVersion", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/ApplicationVersion";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_basic_stack_version_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/StackVersion", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/StackVersion";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_basic_hw_version_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/HWVersion", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/HWVersion";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_basic_manufacturer_name_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/ManufacturerName", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/ManufacturerName";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_basic_model_identifier_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/ModelIdentifier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/ModelIdentifier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_basic_date_code_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/DateCode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/DateCode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_basic_power_source_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef BASIC_POWER_SOURCE_ENUM_NAME_AVAILABLE
  jsn["value"] = basic_power_source_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<BasicPowerSource>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/PowerSource", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/PowerSource";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_basic_generic_device_class_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef BASIC_GENERIC_DEVICE_CLASS_ENUM_NAME_AVAILABLE
  jsn["value"] = basic_generic_device_class_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<BasicGenericDeviceClass>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/GenericDevice-Class", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/GenericDevice-Class";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_basic_generic_device_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef BASIC_GENERIC_DEVICE_TYPE_ENUM_NAME_AVAILABLE
  jsn["value"] = basic_generic_device_type_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<BasicGenericDeviceType>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/GenericDevice-Type", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/GenericDevice-Type";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_basic_product_code_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/ProductCode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/ProductCode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_basic_producturl_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/ProductURL", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/ProductURL";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_basic_manufacturer_version_details_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/ManufacturerVersionDetails", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/ManufacturerVersionDetails";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_basic_serial_number_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/SerialNumber", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/SerialNumber";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_basic_product_label_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/ProductLabel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/ProductLabel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_basic_location_description_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/LocationDescription", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/LocationDescription";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_basic_physical_environment_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef BASIC_PHYSICAL_ENVIRONMENT_ENUM_NAME_AVAILABLE
  jsn["value"] = basic_physical_environment_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<BasicPhysicalEnvironment>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/PhysicalEnvironment", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/PhysicalEnvironment";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_basic_device_enabled_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/DeviceEnabled", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/DeviceEnabled";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_basic_alarm_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BasicAlarmMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/AlarmMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Basic/Attributes/AlarmMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_basic_disable_local_config_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BasicDisableLocalConfig.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/DisableLocalConfig", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Basic/Attributes/DisableLocalConfig";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_basic_sw_buildid_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/SWBuildID", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/SWBuildID";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_basic_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_basic_write_attributes_callback) {
    subscription_topic = base_topic + "Basic/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_basic_WriteAttributes);
  }

  if(uic_mqtt_dotdot_basic_force_read_attributes_callback) {
    subscription_topic = base_topic + "Basic/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_basic_force_read_attributes);
  }
  if (uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback) {
    subscription_topic = base_topic + "Basic/Commands/ResetToFactoryDefaults";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_basic_reset_to_factory_defaults);
  }
  if (uic_mqtt_dotdot_basic_generated_reset_to_factory_defaults_callback) {
    subscription_topic = base_topic + "Basic/GeneratedCommands/ResetToFactoryDefaults";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_basic_reset_to_factory_defaults);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_basic_attributes_init();

  uic_mqtt_dotdot_by_group_basic_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_power_configuration_write_attributes_callback_t uic_mqtt_dotdot_power_configuration_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_power_configuration_force_read_attributes_callback_t uic_mqtt_dotdot_power_configuration_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_power_configuration_write_attributes_callback(
  const uic_mqtt_dotdot_power_configuration_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_power_configuration_force_read_attributes_callback(
  const uic_mqtt_dotdot_power_configuration_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/PowerConfiguration/Commands/WriteAttributes
void uic_mqtt_dotdot_on_power_configuration_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_power_configuration_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_power_configuration_state_t new_state = {};
  uic_mqtt_dotdot_power_configuration_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_power_configuration_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PowerConfiguration", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_power_configuration_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_power_configuration_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_power_configuration_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_power_configuration_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.mains_voltage = true;
        force_update.mains_frequency = true;
        force_update.mains_alarm_mask = true;
        force_update.mains_voltage_min_threshold = true;
        force_update.mains_voltage_max_threshold = true;
        force_update.mains_voltage_dwell_trip_point = true;
        force_update.battery_voltage = true;
        force_update.battery_percentage_remaining = true;
        force_update.battery_manufacturer = true;
        force_update.battery_size = true;
        force_update.batterya_hr_rating = true;
        force_update.battery_quantity = true;
        force_update.battery_rated_voltage = true;
        force_update.battery_alarm_mask = true;
        force_update.battery_voltage_min_threshold = true;
        force_update.battery_voltage_threshold1 = true;
        force_update.battery_voltage_threshold2 = true;
        force_update.battery_voltage_threshold3 = true;
        force_update.battery_percentage_min_threshold = true;
        force_update.battery_percentage_threshold1 = true;
        force_update.battery_percentage_threshold2 = true;
        force_update.battery_percentage_threshold3 = true;
        force_update.battery_alarm_state = true;
        force_update.battery2_voltage = true;
        force_update.battery2_percentage_remaining = true;
        force_update.battery2_manufacturer = true;
        force_update.battery2_size = true;
        force_update.battery2a_hr_rating = true;
        force_update.battery2_quantity = true;
        force_update.battery2_rated_voltage = true;
        force_update.battery2_alarm_mask = true;
        force_update.battery2_voltage_min_threshold = true;
        force_update.battery2_voltage_threshold1 = true;
        force_update.battery2_voltage_threshold2 = true;
        force_update.battery2_voltage_threshold3 = true;
        force_update.battery2_percentage_min_threshold = true;
        force_update.battery2_percentage_threshold1 = true;
        force_update.battery2_percentage_threshold2 = true;
        force_update.battery2_percentage_threshold3 = true;
        force_update.battery2_alarm_state = true;
        force_update.battery3_voltage = true;
        force_update.battery3_percentage_remaining = true;
        force_update.battery3_manufacturer = true;
        force_update.battery3_size = true;
        force_update.battery3a_hr_rating = true;
        force_update.battery3_quantity = true;
        force_update.battery3_rated_voltage = true;
        force_update.battery3_alarm_mask = true;
        force_update.battery3_voltage_min_threshold = true;
        force_update.battery3_voltage_threshold1 = true;
        force_update.battery3_voltage_threshold2 = true;
        force_update.battery3_voltage_threshold3 = true;
        force_update.battery3_percentage_min_threshold = true;
        force_update.battery3_percentage_threshold1 = true;
        force_update.battery3_percentage_threshold2 = true;
        force_update.battery3_percentage_threshold3 = true;
        force_update.battery3_alarm_state = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"MainsVoltage", &force_update.mains_voltage },
          {"MainsFrequency", &force_update.mains_frequency },
          {"MainsAlarmMask", &force_update.mains_alarm_mask },
          {"MainsVoltageMinThreshold", &force_update.mains_voltage_min_threshold },
          {"MainsVoltageMaxThreshold", &force_update.mains_voltage_max_threshold },
          {"MainsVoltageDwellTripPoint", &force_update.mains_voltage_dwell_trip_point },
          {"BatteryVoltage", &force_update.battery_voltage },
          {"BatteryPercentageRemaining", &force_update.battery_percentage_remaining },
          {"BatteryManufacturer", &force_update.battery_manufacturer },
          {"BatterySize", &force_update.battery_size },
          {"BatteryAHrRating", &force_update.batterya_hr_rating },
          {"BatteryQuantity", &force_update.battery_quantity },
          {"BatteryRatedVoltage", &force_update.battery_rated_voltage },
          {"BatteryAlarmMask", &force_update.battery_alarm_mask },
          {"BatteryVoltageMinThreshold", &force_update.battery_voltage_min_threshold },
          {"BatteryVoltageThreshold1", &force_update.battery_voltage_threshold1 },
          {"BatteryVoltageThreshold2", &force_update.battery_voltage_threshold2 },
          {"BatteryVoltageThreshold3", &force_update.battery_voltage_threshold3 },
          {"BatteryPercentageMinThreshold", &force_update.battery_percentage_min_threshold },
          {"BatteryPercentageThreshold1", &force_update.battery_percentage_threshold1 },
          {"BatteryPercentageThreshold2", &force_update.battery_percentage_threshold2 },
          {"BatteryPercentageThreshold3", &force_update.battery_percentage_threshold3 },
          {"BatteryAlarmState", &force_update.battery_alarm_state },
          {"Battery2Voltage", &force_update.battery2_voltage },
          {"Battery2PercentageRemaining", &force_update.battery2_percentage_remaining },
          {"Battery2Manufacturer", &force_update.battery2_manufacturer },
          {"Battery2Size", &force_update.battery2_size },
          {"Battery2AHrRating", &force_update.battery2a_hr_rating },
          {"Battery2Quantity", &force_update.battery2_quantity },
          {"Battery2RatedVoltage", &force_update.battery2_rated_voltage },
          {"Battery2AlarmMask", &force_update.battery2_alarm_mask },
          {"Battery2VoltageMinThreshold", &force_update.battery2_voltage_min_threshold },
          {"Battery2VoltageThreshold1", &force_update.battery2_voltage_threshold1 },
          {"Battery2VoltageThreshold2", &force_update.battery2_voltage_threshold2 },
          {"Battery2VoltageThreshold3", &force_update.battery2_voltage_threshold3 },
          {"Battery2PercentageMinThreshold", &force_update.battery2_percentage_min_threshold },
          {"Battery2PercentageThreshold1", &force_update.battery2_percentage_threshold1 },
          {"Battery2PercentageThreshold2", &force_update.battery2_percentage_threshold2 },
          {"Battery2PercentageThreshold3", &force_update.battery2_percentage_threshold3 },
          {"Battery2AlarmState", &force_update.battery2_alarm_state },
          {"Battery3Voltage", &force_update.battery3_voltage },
          {"Battery3PercentageRemaining", &force_update.battery3_percentage_remaining },
          {"Battery3Manufacturer", &force_update.battery3_manufacturer },
          {"Battery3Size", &force_update.battery3_size },
          {"Battery3AHrRating", &force_update.battery3a_hr_rating },
          {"Battery3Quantity", &force_update.battery3_quantity },
          {"Battery3RatedVoltage", &force_update.battery3_rated_voltage },
          {"Battery3AlarmMask", &force_update.battery3_alarm_mask },
          {"Battery3VoltageMinThreshold", &force_update.battery3_voltage_min_threshold },
          {"Battery3VoltageThreshold1", &force_update.battery3_voltage_threshold1 },
          {"Battery3VoltageThreshold2", &force_update.battery3_voltage_threshold2 },
          {"Battery3VoltageThreshold3", &force_update.battery3_voltage_threshold3 },
          {"Battery3PercentageMinThreshold", &force_update.battery3_percentage_min_threshold },
          {"Battery3PercentageThreshold1", &force_update.battery3_percentage_threshold1 },
          {"Battery3PercentageThreshold2", &force_update.battery3_percentage_threshold2 },
          {"Battery3PercentageThreshold3", &force_update.battery3_percentage_threshold3 },
          {"Battery3AlarmState", &force_update.battery3_alarm_state },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_power_configuration_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "PowerConfiguration/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_power_configuration_mains_voltage_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/MainsVoltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/MainsVoltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_mains_frequency_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/MainsFrequency", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/MainsFrequency";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_mains_alarm_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = PowerConfigurationMainsAlarmMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/MainsAlarmMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/MainsAlarmMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_mains_voltage_min_threshold_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/MainsVoltageMinThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/MainsVoltageMinThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_mains_voltage_max_threshold_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/MainsVoltageMaxThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/MainsVoltageMaxThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_mains_voltage_dwell_trip_point_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/MainsVoltageDwellTripPoint", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/MainsVoltageDwellTripPoint";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery_voltage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryVoltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryVoltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery_percentage_remaining_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryPercentageRemaining", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryPercentageRemaining";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery_manufacturer_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryManufacturer", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryManufacturer";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery_size_publish(
  const char *base_topic,
  BatterySize value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef POWER_CONFIGURATION_BATTERY_SIZE_ENUM_NAME_AVAILABLE
  jsn["value"] = power_configuration_battery_size_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<BatterySize>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatterySize", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatterySize";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_batterya_hr_rating_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryAHrRating", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryAHrRating";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery_quantity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryQuantity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryQuantity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery_rated_voltage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryRatedVoltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryRatedVoltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery_alarm_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BatteryAlarmMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryAlarmMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryAlarmMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery_voltage_min_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryVoltageMinThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryVoltageMinThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery_voltage_threshold1_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryVoltageThreshold1", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryVoltageThreshold1";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery_voltage_threshold2_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryVoltageThreshold2", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryVoltageThreshold2";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery_voltage_threshold3_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryVoltageThreshold3", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryVoltageThreshold3";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery_percentage_min_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryPercentageMinThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryPercentageMinThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery_percentage_threshold1_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryPercentageThreshold1", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryPercentageThreshold1";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery_percentage_threshold2_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryPercentageThreshold2", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryPercentageThreshold2";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery_percentage_threshold3_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryPercentageThreshold3", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryPercentageThreshold3";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery_alarm_state_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BatteryAlarmState.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryAlarmState", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryAlarmState";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_voltage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2Voltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2Voltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_percentage_remaining_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2PercentageRemaining", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2PercentageRemaining";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_manufacturer_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2Manufacturer", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2Manufacturer";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_size_publish(
  const char *base_topic,
  BatterySize value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef POWER_CONFIGURATION_BATTERY2_SIZE_ENUM_NAME_AVAILABLE
  jsn["value"] = power_configuration_battery2_size_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<BatterySize>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2Size", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2Size";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery2a_hr_rating_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2AHrRating", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2AHrRating";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_quantity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2Quantity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2Quantity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_rated_voltage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2RatedVoltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2RatedVoltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_alarm_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BatteryAlarmMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2AlarmMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2AlarmMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_voltage_min_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2VoltageMinThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2VoltageMinThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold1_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2VoltageThreshold1", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2VoltageThreshold1";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold2_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2VoltageThreshold2", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2VoltageThreshold2";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold3_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2VoltageThreshold3", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2VoltageThreshold3";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_percentage_min_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2PercentageMinThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2PercentageMinThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold1_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2PercentageThreshold1", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2PercentageThreshold1";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold2_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2PercentageThreshold2", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2PercentageThreshold2";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold3_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2PercentageThreshold3", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2PercentageThreshold3";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_alarm_state_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BatteryAlarmState.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2AlarmState", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2AlarmState";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_voltage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3Voltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3Voltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_percentage_remaining_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3PercentageRemaining", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3PercentageRemaining";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_manufacturer_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3Manufacturer", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3Manufacturer";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_size_publish(
  const char *base_topic,
  BatterySize value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef POWER_CONFIGURATION_BATTERY3_SIZE_ENUM_NAME_AVAILABLE
  jsn["value"] = power_configuration_battery3_size_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<BatterySize>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3Size", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3Size";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery3a_hr_rating_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3AHrRating", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3AHrRating";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_quantity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3Quantity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3Quantity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_rated_voltage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3RatedVoltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3RatedVoltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_alarm_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BatteryAlarmMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3AlarmMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3AlarmMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_voltage_min_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3VoltageMinThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3VoltageMinThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold1_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3VoltageThreshold1", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3VoltageThreshold1";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold2_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3VoltageThreshold2", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3VoltageThreshold2";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold3_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3VoltageThreshold3", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3VoltageThreshold3";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_percentage_min_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3PercentageMinThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3PercentageMinThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold1_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3PercentageThreshold1", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3PercentageThreshold1";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold2_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3PercentageThreshold2", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3PercentageThreshold2";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold3_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3PercentageThreshold3", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3PercentageThreshold3";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_alarm_state_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BatteryAlarmState.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3AlarmState", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3AlarmState";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_power_configuration_write_attributes_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_power_configuration_WriteAttributes);
  }

  if(uic_mqtt_dotdot_power_configuration_force_read_attributes_callback) {
    subscription_topic = base_topic + "PowerConfiguration/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_power_configuration_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_power_configuration_attributes_init();

  uic_mqtt_dotdot_by_group_power_configuration_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback_t uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_callback_t uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_device_temperature_configuration_write_attributes_callback(
  const uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_device_temperature_configuration_force_read_attributes_callback(
  const uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/DeviceTemperatureConfiguration/Commands/WriteAttributes
void uic_mqtt_dotdot_on_device_temperature_configuration_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_device_temperature_configuration_state_t new_state = {};
  uic_mqtt_dotdot_device_temperature_configuration_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_device_temperature_configuration_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DeviceTemperatureConfiguration", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_device_temperature_configuration_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_device_temperature_configuration_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.current_temperature = true;
        force_update.min_temp_experienced = true;
        force_update.max_temp_experienced = true;
        force_update.over_temp_total_dwell = true;
        force_update.device_temp_alarm_mask = true;
        force_update.low_temp_threshold = true;
        force_update.high_temp_threshold = true;
        force_update.low_temp_dwell_trip_point = true;
        force_update.high_temp_dwell_trip_point = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"CurrentTemperature", &force_update.current_temperature },
          {"MinTempExperienced", &force_update.min_temp_experienced },
          {"MaxTempExperienced", &force_update.max_temp_experienced },
          {"OverTempTotalDwell", &force_update.over_temp_total_dwell },
          {"DeviceTempAlarmMask", &force_update.device_temp_alarm_mask },
          {"LowTempThreshold", &force_update.low_temp_threshold },
          {"HighTempThreshold", &force_update.high_temp_threshold },
          {"LowTempDwellTripPoint", &force_update.low_temp_dwell_trip_point },
          {"HighTempDwellTripPoint", &force_update.high_temp_dwell_trip_point },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "DeviceTemperatureConfiguration/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_device_temperature_configuration_current_temperature_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration/Attributes/CurrentTemperature", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DeviceTemperatureConfiguration/Attributes/CurrentTemperature";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_device_temperature_configuration_min_temp_experienced_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration/Attributes/MinTempExperienced", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DeviceTemperatureConfiguration/Attributes/MinTempExperienced";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_device_temperature_configuration_max_temp_experienced_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration/Attributes/MaxTempExperienced", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DeviceTemperatureConfiguration/Attributes/MaxTempExperienced";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_device_temperature_configuration_over_temp_total_dwell_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration/Attributes/OverTempTotalDwell", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DeviceTemperatureConfiguration/Attributes/OverTempTotalDwell";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_device_temperature_configuration_device_temp_alarm_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DeviceTemperatureConfigurationDeviceTempAlarmMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration/Attributes/DeviceTempAlarmMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DeviceTemperatureConfiguration/Attributes/DeviceTempAlarmMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_device_temperature_configuration_low_temp_threshold_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration/Attributes/LowTempThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DeviceTemperatureConfiguration/Attributes/LowTempThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_device_temperature_configuration_high_temp_threshold_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration/Attributes/HighTempThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DeviceTemperatureConfiguration/Attributes/HighTempThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_device_temperature_configuration_low_temp_dwell_trip_point_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration/Attributes/LowTempDwellTripPoint", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DeviceTemperatureConfiguration/Attributes/LowTempDwellTripPoint";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_device_temperature_configuration_high_temp_dwell_trip_point_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration/Attributes/HighTempDwellTripPoint", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DeviceTemperatureConfiguration/Attributes/HighTempDwellTripPoint";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_device_temperature_configuration_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback) {
    subscription_topic = base_topic + "DeviceTemperatureConfiguration/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_device_temperature_configuration_WriteAttributes);
  }

  if(uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_callback) {
    subscription_topic = base_topic + "DeviceTemperatureConfiguration/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_device_temperature_configuration_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_device_temperature_configuration_attributes_init();

  uic_mqtt_dotdot_by_group_device_temperature_configuration_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_identify_identify_callback_t uic_mqtt_dotdot_identify_identify_callback = nullptr;
static uic_mqtt_dotdot_identify_identify_callback_t uic_mqtt_dotdot_identify_generated_identify_callback = nullptr;
uic_mqtt_dotdot_identify_identify_query_response_callback_t uic_mqtt_dotdot_identify_identify_query_response_callback = nullptr;
static uic_mqtt_dotdot_identify_identify_query_response_callback_t uic_mqtt_dotdot_identify_generated_identify_query_response_callback = nullptr;
uic_mqtt_dotdot_identify_identify_query_callback_t uic_mqtt_dotdot_identify_identify_query_callback = nullptr;
static uic_mqtt_dotdot_identify_identify_query_callback_t uic_mqtt_dotdot_identify_generated_identify_query_callback = nullptr;
uic_mqtt_dotdot_identify_trigger_effect_callback_t uic_mqtt_dotdot_identify_trigger_effect_callback = nullptr;
static uic_mqtt_dotdot_identify_trigger_effect_callback_t uic_mqtt_dotdot_identify_generated_trigger_effect_callback = nullptr;
uic_mqtt_dotdot_identify_write_attributes_callback_t uic_mqtt_dotdot_identify_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_identify_force_read_attributes_callback_t uic_mqtt_dotdot_identify_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_identify_identify_callback_set(const uic_mqtt_dotdot_identify_identify_callback_t callback)
{
  uic_mqtt_dotdot_identify_identify_callback = callback;
}
void uic_mqtt_dotdot_identify_generated_identify_callback_set(const uic_mqtt_dotdot_identify_identify_callback_t callback)
{
  uic_mqtt_dotdot_identify_generated_identify_callback = callback;
}

void uic_mqtt_dotdot_identify_identify_query_response_callback_set(const uic_mqtt_dotdot_identify_identify_query_response_callback_t callback)
{
  uic_mqtt_dotdot_identify_identify_query_response_callback = callback;
}
void uic_mqtt_dotdot_identify_generated_identify_query_response_callback_set(const uic_mqtt_dotdot_identify_identify_query_response_callback_t callback)
{
  uic_mqtt_dotdot_identify_generated_identify_query_response_callback = callback;
}

void uic_mqtt_dotdot_identify_identify_query_callback_set(const uic_mqtt_dotdot_identify_identify_query_callback_t callback)
{
  uic_mqtt_dotdot_identify_identify_query_callback = callback;
}
void uic_mqtt_dotdot_identify_generated_identify_query_callback_set(const uic_mqtt_dotdot_identify_identify_query_callback_t callback)
{
  uic_mqtt_dotdot_identify_generated_identify_query_callback = callback;
}

void uic_mqtt_dotdot_identify_trigger_effect_callback_set(const uic_mqtt_dotdot_identify_trigger_effect_callback_t callback)
{
  uic_mqtt_dotdot_identify_trigger_effect_callback = callback;
}
void uic_mqtt_dotdot_identify_generated_trigger_effect_callback_set(const uic_mqtt_dotdot_identify_trigger_effect_callback_t callback)
{
  uic_mqtt_dotdot_identify_generated_trigger_effect_callback = callback;
}


void uic_mqtt_dotdot_set_identify_write_attributes_callback(
  const uic_mqtt_dotdot_identify_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_identify_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_identify_force_read_attributes_callback(
  const uic_mqtt_dotdot_identify_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_identify_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/Identify/Commands/Identify
void uic_mqtt_dotdot_on_identify_identify(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_identify_identify_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t identify_time = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_identify_identify(
      jsn,
      identify_time
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Identify", "Identify");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "Identify", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "Identify", "");
    return;
  }

  uic_mqtt_dotdot_identify_identify_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    identify_time

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Identify/GeneratedCommands/Identify
static void uic_mqtt_dotdot_on_generated_identify_identify(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_identify_generated_identify_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t identify_time;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_identify_identify(
      jsn,
      identify_time
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Identify", "Identify");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "Identify", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "Identify", "");
    return;
  }

  uic_mqtt_dotdot_identify_generated_identify_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    identify_time

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Identify/Commands/IdentifyQueryResponse
void uic_mqtt_dotdot_on_identify_identify_query_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_identify_identify_query_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t timeout = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_identify_identify_query_response(
      jsn,
      timeout
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Identify", "IdentifyQueryResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "IdentifyQueryResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "IdentifyQueryResponse", "");
    return;
  }

  uic_mqtt_dotdot_identify_identify_query_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    timeout

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Identify/GeneratedCommands/IdentifyQueryResponse
static void uic_mqtt_dotdot_on_generated_identify_identify_query_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_identify_generated_identify_query_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t timeout;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_identify_identify_query_response(
      jsn,
      timeout
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Identify", "IdentifyQueryResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "IdentifyQueryResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "IdentifyQueryResponse", "");
    return;
  }

  uic_mqtt_dotdot_identify_generated_identify_query_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    timeout

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Identify/Commands/IdentifyQuery
void uic_mqtt_dotdot_on_identify_identify_query(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_identify_identify_query_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Identify", "IdentifyQuery");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "IdentifyQuery", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "IdentifyQuery", "");
    return;
  }

  uic_mqtt_dotdot_identify_identify_query_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Identify/GeneratedCommands/IdentifyQuery
static void uic_mqtt_dotdot_on_generated_identify_identify_query(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_identify_generated_identify_query_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Identify", "IdentifyQuery");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "IdentifyQuery", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "IdentifyQuery", "");
    return;
  }

  uic_mqtt_dotdot_identify_generated_identify_query_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Identify/Commands/TriggerEffect
void uic_mqtt_dotdot_on_identify_trigger_effect(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_identify_trigger_effect_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  TriggerEffectEffectIdentifier effect_identifier = {};
  TriggerEffectEffectVariant effect_variant = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_identify_trigger_effect(
      jsn,
      effect_identifier,

      effect_variant
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Identify", "TriggerEffect");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "TriggerEffect", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "TriggerEffect", "");
    return;
  }

  uic_mqtt_dotdot_identify_trigger_effect_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    effect_identifier,

    effect_variant

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Identify/GeneratedCommands/TriggerEffect
static void uic_mqtt_dotdot_on_generated_identify_trigger_effect(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_identify_generated_trigger_effect_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  TriggerEffectEffectIdentifier effect_identifier;
  TriggerEffectEffectVariant effect_variant;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_identify_trigger_effect(
      jsn,
      effect_identifier,

      effect_variant
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Identify", "TriggerEffect");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "TriggerEffect", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "TriggerEffect", "");
    return;
  }

  uic_mqtt_dotdot_identify_generated_trigger_effect_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    effect_identifier,

    effect_variant

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Identify/Commands/WriteAttributes
void uic_mqtt_dotdot_on_identify_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_identify_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_identify_state_t new_state = {};
  uic_mqtt_dotdot_identify_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_identify_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Identify", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_identify_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_identify_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_identify_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_identify_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.identify_time = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"IdentifyTime", &force_update.identify_time },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_identify_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "Identify/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_identify_identify_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify/Attributes/IdentifyTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Identify/Attributes/IdentifyTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_identify_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_identify_write_attributes_callback) {
    subscription_topic = base_topic + "Identify/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_identify_WriteAttributes);
  }

  if(uic_mqtt_dotdot_identify_force_read_attributes_callback) {
    subscription_topic = base_topic + "Identify/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_identify_force_read_attributes);
  }
  if (uic_mqtt_dotdot_identify_identify_callback) {
    subscription_topic = base_topic + "Identify/Commands/Identify";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_identify_identify);
  }
  if (uic_mqtt_dotdot_identify_generated_identify_callback) {
    subscription_topic = base_topic + "Identify/GeneratedCommands/Identify";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_identify_identify);
  }
  if (uic_mqtt_dotdot_identify_identify_query_response_callback) {
    subscription_topic = base_topic + "Identify/Commands/IdentifyQueryResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_identify_identify_query_response);
  }
  if (uic_mqtt_dotdot_identify_generated_identify_query_response_callback) {
    subscription_topic = base_topic + "Identify/GeneratedCommands/IdentifyQueryResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_identify_identify_query_response);
  }
  if (uic_mqtt_dotdot_identify_identify_query_callback) {
    subscription_topic = base_topic + "Identify/Commands/IdentifyQuery";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_identify_identify_query);
  }
  if (uic_mqtt_dotdot_identify_generated_identify_query_callback) {
    subscription_topic = base_topic + "Identify/GeneratedCommands/IdentifyQuery";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_identify_identify_query);
  }
  if (uic_mqtt_dotdot_identify_trigger_effect_callback) {
    subscription_topic = base_topic + "Identify/Commands/TriggerEffect";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_identify_trigger_effect);
  }
  if (uic_mqtt_dotdot_identify_generated_trigger_effect_callback) {
    subscription_topic = base_topic + "Identify/GeneratedCommands/TriggerEffect";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_identify_trigger_effect);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_identify_attributes_init();

  uic_mqtt_dotdot_by_group_identify_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_groups_add_group_callback_t uic_mqtt_dotdot_groups_add_group_callback = nullptr;
static uic_mqtt_dotdot_groups_add_group_callback_t uic_mqtt_dotdot_groups_generated_add_group_callback = nullptr;
uic_mqtt_dotdot_groups_add_group_response_callback_t uic_mqtt_dotdot_groups_add_group_response_callback = nullptr;
static uic_mqtt_dotdot_groups_add_group_response_callback_t uic_mqtt_dotdot_groups_generated_add_group_response_callback = nullptr;
uic_mqtt_dotdot_groups_view_group_callback_t uic_mqtt_dotdot_groups_view_group_callback = nullptr;
static uic_mqtt_dotdot_groups_view_group_callback_t uic_mqtt_dotdot_groups_generated_view_group_callback = nullptr;
uic_mqtt_dotdot_groups_view_group_response_callback_t uic_mqtt_dotdot_groups_view_group_response_callback = nullptr;
static uic_mqtt_dotdot_groups_view_group_response_callback_t uic_mqtt_dotdot_groups_generated_view_group_response_callback = nullptr;
uic_mqtt_dotdot_groups_get_group_membership_callback_t uic_mqtt_dotdot_groups_get_group_membership_callback = nullptr;
static uic_mqtt_dotdot_groups_get_group_membership_callback_t uic_mqtt_dotdot_groups_generated_get_group_membership_callback = nullptr;
uic_mqtt_dotdot_groups_get_group_membership_response_callback_t uic_mqtt_dotdot_groups_get_group_membership_response_callback = nullptr;
static uic_mqtt_dotdot_groups_get_group_membership_response_callback_t uic_mqtt_dotdot_groups_generated_get_group_membership_response_callback = nullptr;
uic_mqtt_dotdot_groups_remove_group_callback_t uic_mqtt_dotdot_groups_remove_group_callback = nullptr;
static uic_mqtt_dotdot_groups_remove_group_callback_t uic_mqtt_dotdot_groups_generated_remove_group_callback = nullptr;
uic_mqtt_dotdot_groups_remove_group_response_callback_t uic_mqtt_dotdot_groups_remove_group_response_callback = nullptr;
static uic_mqtt_dotdot_groups_remove_group_response_callback_t uic_mqtt_dotdot_groups_generated_remove_group_response_callback = nullptr;
uic_mqtt_dotdot_groups_remove_all_groups_callback_t uic_mqtt_dotdot_groups_remove_all_groups_callback = nullptr;
static uic_mqtt_dotdot_groups_remove_all_groups_callback_t uic_mqtt_dotdot_groups_generated_remove_all_groups_callback = nullptr;
uic_mqtt_dotdot_groups_add_group_if_identifying_callback_t uic_mqtt_dotdot_groups_add_group_if_identifying_callback = nullptr;
static uic_mqtt_dotdot_groups_add_group_if_identifying_callback_t uic_mqtt_dotdot_groups_generated_add_group_if_identifying_callback = nullptr;
uic_mqtt_dotdot_groups_write_attributes_callback_t uic_mqtt_dotdot_groups_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_groups_force_read_attributes_callback_t uic_mqtt_dotdot_groups_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_groups_add_group_callback_set(const uic_mqtt_dotdot_groups_add_group_callback_t callback)
{
  uic_mqtt_dotdot_groups_add_group_callback = callback;
}
void uic_mqtt_dotdot_groups_generated_add_group_callback_set(const uic_mqtt_dotdot_groups_add_group_callback_t callback)
{
  uic_mqtt_dotdot_groups_generated_add_group_callback = callback;
}

void uic_mqtt_dotdot_groups_add_group_response_callback_set(const uic_mqtt_dotdot_groups_add_group_response_callback_t callback)
{
  uic_mqtt_dotdot_groups_add_group_response_callback = callback;
}
void uic_mqtt_dotdot_groups_generated_add_group_response_callback_set(const uic_mqtt_dotdot_groups_add_group_response_callback_t callback)
{
  uic_mqtt_dotdot_groups_generated_add_group_response_callback = callback;
}

void uic_mqtt_dotdot_groups_view_group_callback_set(const uic_mqtt_dotdot_groups_view_group_callback_t callback)
{
  uic_mqtt_dotdot_groups_view_group_callback = callback;
}
void uic_mqtt_dotdot_groups_generated_view_group_callback_set(const uic_mqtt_dotdot_groups_view_group_callback_t callback)
{
  uic_mqtt_dotdot_groups_generated_view_group_callback = callback;
}

void uic_mqtt_dotdot_groups_view_group_response_callback_set(const uic_mqtt_dotdot_groups_view_group_response_callback_t callback)
{
  uic_mqtt_dotdot_groups_view_group_response_callback = callback;
}
void uic_mqtt_dotdot_groups_generated_view_group_response_callback_set(const uic_mqtt_dotdot_groups_view_group_response_callback_t callback)
{
  uic_mqtt_dotdot_groups_generated_view_group_response_callback = callback;
}

void uic_mqtt_dotdot_groups_get_group_membership_callback_set(const uic_mqtt_dotdot_groups_get_group_membership_callback_t callback)
{
  uic_mqtt_dotdot_groups_get_group_membership_callback = callback;
}
void uic_mqtt_dotdot_groups_generated_get_group_membership_callback_set(const uic_mqtt_dotdot_groups_get_group_membership_callback_t callback)
{
  uic_mqtt_dotdot_groups_generated_get_group_membership_callback = callback;
}

void uic_mqtt_dotdot_groups_get_group_membership_response_callback_set(const uic_mqtt_dotdot_groups_get_group_membership_response_callback_t callback)
{
  uic_mqtt_dotdot_groups_get_group_membership_response_callback = callback;
}
void uic_mqtt_dotdot_groups_generated_get_group_membership_response_callback_set(const uic_mqtt_dotdot_groups_get_group_membership_response_callback_t callback)
{
  uic_mqtt_dotdot_groups_generated_get_group_membership_response_callback = callback;
}

void uic_mqtt_dotdot_groups_remove_group_callback_set(const uic_mqtt_dotdot_groups_remove_group_callback_t callback)
{
  uic_mqtt_dotdot_groups_remove_group_callback = callback;
}
void uic_mqtt_dotdot_groups_generated_remove_group_callback_set(const uic_mqtt_dotdot_groups_remove_group_callback_t callback)
{
  uic_mqtt_dotdot_groups_generated_remove_group_callback = callback;
}

void uic_mqtt_dotdot_groups_remove_group_response_callback_set(const uic_mqtt_dotdot_groups_remove_group_response_callback_t callback)
{
  uic_mqtt_dotdot_groups_remove_group_response_callback = callback;
}
void uic_mqtt_dotdot_groups_generated_remove_group_response_callback_set(const uic_mqtt_dotdot_groups_remove_group_response_callback_t callback)
{
  uic_mqtt_dotdot_groups_generated_remove_group_response_callback = callback;
}

void uic_mqtt_dotdot_groups_remove_all_groups_callback_set(const uic_mqtt_dotdot_groups_remove_all_groups_callback_t callback)
{
  uic_mqtt_dotdot_groups_remove_all_groups_callback = callback;
}
void uic_mqtt_dotdot_groups_generated_remove_all_groups_callback_set(const uic_mqtt_dotdot_groups_remove_all_groups_callback_t callback)
{
  uic_mqtt_dotdot_groups_generated_remove_all_groups_callback = callback;
}

void uic_mqtt_dotdot_groups_add_group_if_identifying_callback_set(const uic_mqtt_dotdot_groups_add_group_if_identifying_callback_t callback)
{
  uic_mqtt_dotdot_groups_add_group_if_identifying_callback = callback;
}
void uic_mqtt_dotdot_groups_generated_add_group_if_identifying_callback_set(const uic_mqtt_dotdot_groups_add_group_if_identifying_callback_t callback)
{
  uic_mqtt_dotdot_groups_generated_add_group_if_identifying_callback = callback;
}


void uic_mqtt_dotdot_set_groups_write_attributes_callback(
  const uic_mqtt_dotdot_groups_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_groups_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_groups_force_read_attributes_callback(
  const uic_mqtt_dotdot_groups_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_groups_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/Groups/Commands/AddGroup
void uic_mqtt_dotdot_on_groups_add_group(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_add_group_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t group_id = {};
  const char* group_name = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_add_group(
      jsn,
      group_id,

      group_name
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "AddGroup");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroup", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroup", "");
    return;
  }

  uic_mqtt_dotdot_groups_add_group_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    group_id,

    group_name

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Groups/GeneratedCommands/AddGroup
static void uic_mqtt_dotdot_on_generated_groups_add_group(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_generated_add_group_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t group_id;
  const char* group_name;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_add_group(
      jsn,
      group_id,

      group_name
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "AddGroup");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroup", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroup", "");
    return;
  }

  uic_mqtt_dotdot_groups_generated_add_group_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    group_id,

    group_name

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Groups/Commands/AddGroupResponse
void uic_mqtt_dotdot_on_groups_add_group_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_add_group_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t status = {};
  uint16_t group_id = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_add_group_response(
      jsn,
      status,

      group_id
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "AddGroupResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroupResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroupResponse", "");
    return;
  }

  uic_mqtt_dotdot_groups_add_group_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    group_id

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Groups/GeneratedCommands/AddGroupResponse
static void uic_mqtt_dotdot_on_generated_groups_add_group_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_generated_add_group_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t status;
  uint16_t group_id;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_add_group_response(
      jsn,
      status,

      group_id
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "AddGroupResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroupResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroupResponse", "");
    return;
  }

  uic_mqtt_dotdot_groups_generated_add_group_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    group_id

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Groups/Commands/ViewGroup
void uic_mqtt_dotdot_on_groups_view_group(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_view_group_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t group_id = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_view_group(
      jsn,
      group_id
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "ViewGroup");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "ViewGroup", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "ViewGroup", "");
    return;
  }

  uic_mqtt_dotdot_groups_view_group_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    group_id

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Groups/GeneratedCommands/ViewGroup
static void uic_mqtt_dotdot_on_generated_groups_view_group(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_generated_view_group_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t group_id;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_view_group(
      jsn,
      group_id
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "ViewGroup");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "ViewGroup", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "ViewGroup", "");
    return;
  }

  uic_mqtt_dotdot_groups_generated_view_group_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    group_id

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Groups/Commands/ViewGroupResponse
void uic_mqtt_dotdot_on_groups_view_group_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_view_group_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t status = {};
  uint16_t group_id = {};
  const char* group_name = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_view_group_response(
      jsn,
      status,

      group_id,

      group_name
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "ViewGroupResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "ViewGroupResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "ViewGroupResponse", "");
    return;
  }

  uic_mqtt_dotdot_groups_view_group_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    group_id,

    group_name

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Groups/GeneratedCommands/ViewGroupResponse
static void uic_mqtt_dotdot_on_generated_groups_view_group_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_generated_view_group_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t status;
  uint16_t group_id;
  const char* group_name;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_view_group_response(
      jsn,
      status,

      group_id,

      group_name
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "ViewGroupResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "ViewGroupResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "ViewGroupResponse", "");
    return;
  }

  uic_mqtt_dotdot_groups_generated_view_group_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    group_id,

    group_name

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Groups/Commands/GetGroupMembership
void uic_mqtt_dotdot_on_groups_get_group_membership(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_get_group_membership_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::vector<uint16_t> group_list;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_get_group_membership(
      jsn,
      group_list
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "GetGroupMembership");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "GetGroupMembership", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "GetGroupMembership", "");
    return;
  }

  uic_mqtt_dotdot_groups_get_group_membership_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    group_list.size(),
    group_list.data()

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Groups/GeneratedCommands/GetGroupMembership
static void uic_mqtt_dotdot_on_generated_groups_get_group_membership(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_generated_get_group_membership_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::vector<uint16_t> group_list;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_get_group_membership(
      jsn,
      group_list
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "GetGroupMembership");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "GetGroupMembership", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "GetGroupMembership", "");
    return;
  }

  uic_mqtt_dotdot_groups_generated_get_group_membership_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    group_list.size(),
    group_list.data()

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Groups/Commands/GetGroupMembershipResponse
void uic_mqtt_dotdot_on_groups_get_group_membership_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_get_group_membership_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t capacity = {};
  std::vector<uint16_t> group_list;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_get_group_membership_response(
      jsn,
      capacity,

      group_list
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "GetGroupMembershipResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "GetGroupMembershipResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "GetGroupMembershipResponse", "");
    return;
  }

  uic_mqtt_dotdot_groups_get_group_membership_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    capacity,

    group_list.size(),
    group_list.data()

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Groups/GeneratedCommands/GetGroupMembershipResponse
static void uic_mqtt_dotdot_on_generated_groups_get_group_membership_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_generated_get_group_membership_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t capacity;
  std::vector<uint16_t> group_list;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_get_group_membership_response(
      jsn,
      capacity,

      group_list
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "GetGroupMembershipResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "GetGroupMembershipResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "GetGroupMembershipResponse", "");
    return;
  }

  uic_mqtt_dotdot_groups_generated_get_group_membership_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    capacity,

    group_list.size(),
    group_list.data()

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Groups/Commands/RemoveGroup
void uic_mqtt_dotdot_on_groups_remove_group(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_remove_group_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t group_id = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_remove_group(
      jsn,
      group_id
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "RemoveGroup");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveGroup", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveGroup", "");
    return;
  }

  uic_mqtt_dotdot_groups_remove_group_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    group_id

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Groups/GeneratedCommands/RemoveGroup
static void uic_mqtt_dotdot_on_generated_groups_remove_group(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_generated_remove_group_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t group_id;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_remove_group(
      jsn,
      group_id
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "RemoveGroup");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveGroup", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveGroup", "");
    return;
  }

  uic_mqtt_dotdot_groups_generated_remove_group_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    group_id

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Groups/Commands/RemoveGroupResponse
void uic_mqtt_dotdot_on_groups_remove_group_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_remove_group_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t status = {};
  uint16_t group_id = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_remove_group_response(
      jsn,
      status,

      group_id
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "RemoveGroupResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveGroupResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveGroupResponse", "");
    return;
  }

  uic_mqtt_dotdot_groups_remove_group_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    group_id

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Groups/GeneratedCommands/RemoveGroupResponse
static void uic_mqtt_dotdot_on_generated_groups_remove_group_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_generated_remove_group_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t status;
  uint16_t group_id;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_remove_group_response(
      jsn,
      status,

      group_id
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "RemoveGroupResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveGroupResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveGroupResponse", "");
    return;
  }

  uic_mqtt_dotdot_groups_generated_remove_group_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    group_id

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Groups/Commands/RemoveAllGroups
void uic_mqtt_dotdot_on_groups_remove_all_groups(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_remove_all_groups_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "RemoveAllGroups");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveAllGroups", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveAllGroups", "");
    return;
  }

  uic_mqtt_dotdot_groups_remove_all_groups_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Groups/GeneratedCommands/RemoveAllGroups
static void uic_mqtt_dotdot_on_generated_groups_remove_all_groups(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_generated_remove_all_groups_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "RemoveAllGroups");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveAllGroups", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveAllGroups", "");
    return;
  }

  uic_mqtt_dotdot_groups_generated_remove_all_groups_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Groups/Commands/AddGroupIfIdentifying
void uic_mqtt_dotdot_on_groups_add_group_if_identifying(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_add_group_if_identifying_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t group_id = {};
  const char* group_name = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_add_group_if_identifying(
      jsn,
      group_id,

      group_name
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "AddGroupIfIdentifying");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroupIfIdentifying", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroupIfIdentifying", "");
    return;
  }

  uic_mqtt_dotdot_groups_add_group_if_identifying_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    group_id,

    group_name

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Groups/GeneratedCommands/AddGroupIfIdentifying
static void uic_mqtt_dotdot_on_generated_groups_add_group_if_identifying(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_generated_add_group_if_identifying_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t group_id;
  const char* group_name;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_add_group_if_identifying(
      jsn,
      group_id,

      group_name
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "AddGroupIfIdentifying");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroupIfIdentifying", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroupIfIdentifying", "");
    return;
  }

  uic_mqtt_dotdot_groups_generated_add_group_if_identifying_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    group_id,

    group_name

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Groups/Commands/WriteAttributes
void uic_mqtt_dotdot_on_groups_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_groups_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_groups_state_t new_state = {};
  uic_mqtt_dotdot_groups_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_groups_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_groups_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_groups_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_groups_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_groups_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.name_support = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"NameSupport", &force_update.name_support },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_groups_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "Groups/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_groups_name_support_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = GroupsNameSupport.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups/Attributes/NameSupport", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Groups/Attributes/NameSupport";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_groups_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_groups_write_attributes_callback) {
    subscription_topic = base_topic + "Groups/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_WriteAttributes);
  }

  if(uic_mqtt_dotdot_groups_force_read_attributes_callback) {
    subscription_topic = base_topic + "Groups/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_force_read_attributes);
  }
  if (uic_mqtt_dotdot_groups_add_group_callback) {
    subscription_topic = base_topic + "Groups/Commands/AddGroup";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_add_group);
  }
  if (uic_mqtt_dotdot_groups_generated_add_group_callback) {
    subscription_topic = base_topic + "Groups/GeneratedCommands/AddGroup";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_groups_add_group);
  }
  if (uic_mqtt_dotdot_groups_add_group_response_callback) {
    subscription_topic = base_topic + "Groups/Commands/AddGroupResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_add_group_response);
  }
  if (uic_mqtt_dotdot_groups_generated_add_group_response_callback) {
    subscription_topic = base_topic + "Groups/GeneratedCommands/AddGroupResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_groups_add_group_response);
  }
  if (uic_mqtt_dotdot_groups_view_group_callback) {
    subscription_topic = base_topic + "Groups/Commands/ViewGroup";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_view_group);
  }
  if (uic_mqtt_dotdot_groups_generated_view_group_callback) {
    subscription_topic = base_topic + "Groups/GeneratedCommands/ViewGroup";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_groups_view_group);
  }
  if (uic_mqtt_dotdot_groups_view_group_response_callback) {
    subscription_topic = base_topic + "Groups/Commands/ViewGroupResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_view_group_response);
  }
  if (uic_mqtt_dotdot_groups_generated_view_group_response_callback) {
    subscription_topic = base_topic + "Groups/GeneratedCommands/ViewGroupResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_groups_view_group_response);
  }
  if (uic_mqtt_dotdot_groups_get_group_membership_callback) {
    subscription_topic = base_topic + "Groups/Commands/GetGroupMembership";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_get_group_membership);
  }
  if (uic_mqtt_dotdot_groups_generated_get_group_membership_callback) {
    subscription_topic = base_topic + "Groups/GeneratedCommands/GetGroupMembership";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_groups_get_group_membership);
  }
  if (uic_mqtt_dotdot_groups_get_group_membership_response_callback) {
    subscription_topic = base_topic + "Groups/Commands/GetGroupMembershipResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_get_group_membership_response);
  }
  if (uic_mqtt_dotdot_groups_generated_get_group_membership_response_callback) {
    subscription_topic = base_topic + "Groups/GeneratedCommands/GetGroupMembershipResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_groups_get_group_membership_response);
  }
  if (uic_mqtt_dotdot_groups_remove_group_callback) {
    subscription_topic = base_topic + "Groups/Commands/RemoveGroup";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_remove_group);
  }
  if (uic_mqtt_dotdot_groups_generated_remove_group_callback) {
    subscription_topic = base_topic + "Groups/GeneratedCommands/RemoveGroup";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_groups_remove_group);
  }
  if (uic_mqtt_dotdot_groups_remove_group_response_callback) {
    subscription_topic = base_topic + "Groups/Commands/RemoveGroupResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_remove_group_response);
  }
  if (uic_mqtt_dotdot_groups_generated_remove_group_response_callback) {
    subscription_topic = base_topic + "Groups/GeneratedCommands/RemoveGroupResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_groups_remove_group_response);
  }
  if (uic_mqtt_dotdot_groups_remove_all_groups_callback) {
    subscription_topic = base_topic + "Groups/Commands/RemoveAllGroups";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_remove_all_groups);
  }
  if (uic_mqtt_dotdot_groups_generated_remove_all_groups_callback) {
    subscription_topic = base_topic + "Groups/GeneratedCommands/RemoveAllGroups";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_groups_remove_all_groups);
  }
  if (uic_mqtt_dotdot_groups_add_group_if_identifying_callback) {
    subscription_topic = base_topic + "Groups/Commands/AddGroupIfIdentifying";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_add_group_if_identifying);
  }
  if (uic_mqtt_dotdot_groups_generated_add_group_if_identifying_callback) {
    subscription_topic = base_topic + "Groups/GeneratedCommands/AddGroupIfIdentifying";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_groups_add_group_if_identifying);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_groups_attributes_init();

  uic_mqtt_dotdot_by_group_groups_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_scenes_add_scene_callback_t uic_mqtt_dotdot_scenes_add_scene_callback = nullptr;
static uic_mqtt_dotdot_scenes_add_scene_callback_t uic_mqtt_dotdot_scenes_generated_add_scene_callback = nullptr;
uic_mqtt_dotdot_scenes_add_scene_response_callback_t uic_mqtt_dotdot_scenes_add_scene_response_callback = nullptr;
static uic_mqtt_dotdot_scenes_add_scene_response_callback_t uic_mqtt_dotdot_scenes_generated_add_scene_response_callback = nullptr;
uic_mqtt_dotdot_scenes_view_scene_callback_t uic_mqtt_dotdot_scenes_view_scene_callback = nullptr;
static uic_mqtt_dotdot_scenes_view_scene_callback_t uic_mqtt_dotdot_scenes_generated_view_scene_callback = nullptr;
uic_mqtt_dotdot_scenes_view_scene_response_callback_t uic_mqtt_dotdot_scenes_view_scene_response_callback = nullptr;
static uic_mqtt_dotdot_scenes_view_scene_response_callback_t uic_mqtt_dotdot_scenes_generated_view_scene_response_callback = nullptr;
uic_mqtt_dotdot_scenes_remove_scene_callback_t uic_mqtt_dotdot_scenes_remove_scene_callback = nullptr;
static uic_mqtt_dotdot_scenes_remove_scene_callback_t uic_mqtt_dotdot_scenes_generated_remove_scene_callback = nullptr;
uic_mqtt_dotdot_scenes_remove_scene_response_callback_t uic_mqtt_dotdot_scenes_remove_scene_response_callback = nullptr;
static uic_mqtt_dotdot_scenes_remove_scene_response_callback_t uic_mqtt_dotdot_scenes_generated_remove_scene_response_callback = nullptr;
uic_mqtt_dotdot_scenes_remove_all_scenes_callback_t uic_mqtt_dotdot_scenes_remove_all_scenes_callback = nullptr;
static uic_mqtt_dotdot_scenes_remove_all_scenes_callback_t uic_mqtt_dotdot_scenes_generated_remove_all_scenes_callback = nullptr;
uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback_t uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback = nullptr;
static uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback_t uic_mqtt_dotdot_scenes_generated_remove_all_scenes_response_callback = nullptr;
uic_mqtt_dotdot_scenes_store_scene_callback_t uic_mqtt_dotdot_scenes_store_scene_callback = nullptr;
static uic_mqtt_dotdot_scenes_store_scene_callback_t uic_mqtt_dotdot_scenes_generated_store_scene_callback = nullptr;
uic_mqtt_dotdot_scenes_store_scene_response_callback_t uic_mqtt_dotdot_scenes_store_scene_response_callback = nullptr;
static uic_mqtt_dotdot_scenes_store_scene_response_callback_t uic_mqtt_dotdot_scenes_generated_store_scene_response_callback = nullptr;
uic_mqtt_dotdot_scenes_recall_scene_callback_t uic_mqtt_dotdot_scenes_recall_scene_callback = nullptr;
static uic_mqtt_dotdot_scenes_recall_scene_callback_t uic_mqtt_dotdot_scenes_generated_recall_scene_callback = nullptr;
uic_mqtt_dotdot_scenes_get_scene_membership_callback_t uic_mqtt_dotdot_scenes_get_scene_membership_callback = nullptr;
static uic_mqtt_dotdot_scenes_get_scene_membership_callback_t uic_mqtt_dotdot_scenes_generated_get_scene_membership_callback = nullptr;
uic_mqtt_dotdot_scenes_get_scene_membership_response_callback_t uic_mqtt_dotdot_scenes_get_scene_membership_response_callback = nullptr;
static uic_mqtt_dotdot_scenes_get_scene_membership_response_callback_t uic_mqtt_dotdot_scenes_generated_get_scene_membership_response_callback = nullptr;
uic_mqtt_dotdot_scenes_enhanced_add_scene_callback_t uic_mqtt_dotdot_scenes_enhanced_add_scene_callback = nullptr;
static uic_mqtt_dotdot_scenes_enhanced_add_scene_callback_t uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_callback = nullptr;
uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback_t uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback = nullptr;
static uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback_t uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_response_callback = nullptr;
uic_mqtt_dotdot_scenes_enhanced_view_scene_callback_t uic_mqtt_dotdot_scenes_enhanced_view_scene_callback = nullptr;
static uic_mqtt_dotdot_scenes_enhanced_view_scene_callback_t uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_callback = nullptr;
uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback_t uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback = nullptr;
static uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback_t uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_response_callback = nullptr;
uic_mqtt_dotdot_scenes_copy_scene_callback_t uic_mqtt_dotdot_scenes_copy_scene_callback = nullptr;
static uic_mqtt_dotdot_scenes_copy_scene_callback_t uic_mqtt_dotdot_scenes_generated_copy_scene_callback = nullptr;
uic_mqtt_dotdot_scenes_copy_scene_response_callback_t uic_mqtt_dotdot_scenes_copy_scene_response_callback = nullptr;
static uic_mqtt_dotdot_scenes_copy_scene_response_callback_t uic_mqtt_dotdot_scenes_generated_copy_scene_response_callback = nullptr;
uic_mqtt_dotdot_scenes_write_attributes_callback_t uic_mqtt_dotdot_scenes_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_scenes_force_read_attributes_callback_t uic_mqtt_dotdot_scenes_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_scenes_add_scene_callback_set(const uic_mqtt_dotdot_scenes_add_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_add_scene_callback = callback;
}
void uic_mqtt_dotdot_scenes_generated_add_scene_callback_set(const uic_mqtt_dotdot_scenes_add_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_add_scene_callback = callback;
}

void uic_mqtt_dotdot_scenes_add_scene_response_callback_set(const uic_mqtt_dotdot_scenes_add_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_add_scene_response_callback = callback;
}
void uic_mqtt_dotdot_scenes_generated_add_scene_response_callback_set(const uic_mqtt_dotdot_scenes_add_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_add_scene_response_callback = callback;
}

void uic_mqtt_dotdot_scenes_view_scene_callback_set(const uic_mqtt_dotdot_scenes_view_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_view_scene_callback = callback;
}
void uic_mqtt_dotdot_scenes_generated_view_scene_callback_set(const uic_mqtt_dotdot_scenes_view_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_view_scene_callback = callback;
}

void uic_mqtt_dotdot_scenes_view_scene_response_callback_set(const uic_mqtt_dotdot_scenes_view_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_view_scene_response_callback = callback;
}
void uic_mqtt_dotdot_scenes_generated_view_scene_response_callback_set(const uic_mqtt_dotdot_scenes_view_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_view_scene_response_callback = callback;
}

void uic_mqtt_dotdot_scenes_remove_scene_callback_set(const uic_mqtt_dotdot_scenes_remove_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_remove_scene_callback = callback;
}
void uic_mqtt_dotdot_scenes_generated_remove_scene_callback_set(const uic_mqtt_dotdot_scenes_remove_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_remove_scene_callback = callback;
}

void uic_mqtt_dotdot_scenes_remove_scene_response_callback_set(const uic_mqtt_dotdot_scenes_remove_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_remove_scene_response_callback = callback;
}
void uic_mqtt_dotdot_scenes_generated_remove_scene_response_callback_set(const uic_mqtt_dotdot_scenes_remove_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_remove_scene_response_callback = callback;
}

void uic_mqtt_dotdot_scenes_remove_all_scenes_callback_set(const uic_mqtt_dotdot_scenes_remove_all_scenes_callback_t callback)
{
  uic_mqtt_dotdot_scenes_remove_all_scenes_callback = callback;
}
void uic_mqtt_dotdot_scenes_generated_remove_all_scenes_callback_set(const uic_mqtt_dotdot_scenes_remove_all_scenes_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_remove_all_scenes_callback = callback;
}

void uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback_set(const uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback = callback;
}
void uic_mqtt_dotdot_scenes_generated_remove_all_scenes_response_callback_set(const uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_remove_all_scenes_response_callback = callback;
}

void uic_mqtt_dotdot_scenes_store_scene_callback_set(const uic_mqtt_dotdot_scenes_store_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_store_scene_callback = callback;
}
void uic_mqtt_dotdot_scenes_generated_store_scene_callback_set(const uic_mqtt_dotdot_scenes_store_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_store_scene_callback = callback;
}

void uic_mqtt_dotdot_scenes_store_scene_response_callback_set(const uic_mqtt_dotdot_scenes_store_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_store_scene_response_callback = callback;
}
void uic_mqtt_dotdot_scenes_generated_store_scene_response_callback_set(const uic_mqtt_dotdot_scenes_store_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_store_scene_response_callback = callback;
}

void uic_mqtt_dotdot_scenes_recall_scene_callback_set(const uic_mqtt_dotdot_scenes_recall_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_recall_scene_callback = callback;
}
void uic_mqtt_dotdot_scenes_generated_recall_scene_callback_set(const uic_mqtt_dotdot_scenes_recall_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_recall_scene_callback = callback;
}

void uic_mqtt_dotdot_scenes_get_scene_membership_callback_set(const uic_mqtt_dotdot_scenes_get_scene_membership_callback_t callback)
{
  uic_mqtt_dotdot_scenes_get_scene_membership_callback = callback;
}
void uic_mqtt_dotdot_scenes_generated_get_scene_membership_callback_set(const uic_mqtt_dotdot_scenes_get_scene_membership_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_get_scene_membership_callback = callback;
}

void uic_mqtt_dotdot_scenes_get_scene_membership_response_callback_set(const uic_mqtt_dotdot_scenes_get_scene_membership_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_get_scene_membership_response_callback = callback;
}
void uic_mqtt_dotdot_scenes_generated_get_scene_membership_response_callback_set(const uic_mqtt_dotdot_scenes_get_scene_membership_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_get_scene_membership_response_callback = callback;
}

void uic_mqtt_dotdot_scenes_enhanced_add_scene_callback_set(const uic_mqtt_dotdot_scenes_enhanced_add_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_enhanced_add_scene_callback = callback;
}
void uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_callback_set(const uic_mqtt_dotdot_scenes_enhanced_add_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_callback = callback;
}

void uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback_set(const uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback = callback;
}
void uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_response_callback_set(const uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_response_callback = callback;
}

void uic_mqtt_dotdot_scenes_enhanced_view_scene_callback_set(const uic_mqtt_dotdot_scenes_enhanced_view_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_enhanced_view_scene_callback = callback;
}
void uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_callback_set(const uic_mqtt_dotdot_scenes_enhanced_view_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_callback = callback;
}

void uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback_set(const uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback = callback;
}
void uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_response_callback_set(const uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_response_callback = callback;
}

void uic_mqtt_dotdot_scenes_copy_scene_callback_set(const uic_mqtt_dotdot_scenes_copy_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_copy_scene_callback = callback;
}
void uic_mqtt_dotdot_scenes_generated_copy_scene_callback_set(const uic_mqtt_dotdot_scenes_copy_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_copy_scene_callback = callback;
}

void uic_mqtt_dotdot_scenes_copy_scene_response_callback_set(const uic_mqtt_dotdot_scenes_copy_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_copy_scene_response_callback = callback;
}
void uic_mqtt_dotdot_scenes_generated_copy_scene_response_callback_set(const uic_mqtt_dotdot_scenes_copy_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_copy_scene_response_callback = callback;
}


void uic_mqtt_dotdot_set_scenes_write_attributes_callback(
  const uic_mqtt_dotdot_scenes_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_scenes_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_scenes_force_read_attributes_callback(
  const uic_mqtt_dotdot_scenes_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_scenes_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/AddScene
void uic_mqtt_dotdot_on_scenes_add_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_add_scene_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};
  uint8_t sceneid = {};
  uint16_t transition_time = {};
  SSceneName scene_name = {};
  std::vector<SExtensionFieldSetList> extension_field_sets;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_add_scene(
      jsn,
      groupid,

      sceneid,

      transition_time,

      scene_name,

      extension_field_sets
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "AddScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "AddScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "AddScene", "");
    return;
  }

  uic_mqtt_dotdot_scenes_add_scene_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    groupid,

    sceneid,

    transition_time,

    scene_name,

    extension_field_sets.size(),
    extension_field_sets.data()

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/AddScene
static void uic_mqtt_dotdot_on_generated_scenes_add_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_add_scene_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid;
  uint8_t sceneid;
  uint16_t transition_time;
  SSceneName scene_name;
  std::vector<SExtensionFieldSetList> extension_field_sets;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_add_scene(
      jsn,
      groupid,

      sceneid,

      transition_time,

      scene_name,

      extension_field_sets
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "AddScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "AddScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "AddScene", "");
    return;
  }

  uic_mqtt_dotdot_scenes_generated_add_scene_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    groupid,

    sceneid,

    transition_time,

    scene_name,

    extension_field_sets.size(),
    extension_field_sets.data()

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/AddSceneResponse
void uic_mqtt_dotdot_on_scenes_add_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_add_scene_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_add_scene_response(
      jsn,
      status,

      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "AddSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "AddSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "AddSceneResponse", "");
    return;
  }

  uic_mqtt_dotdot_scenes_add_scene_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    groupid,

    sceneid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/AddSceneResponse
static void uic_mqtt_dotdot_on_generated_scenes_add_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_add_scene_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status;
  SGroupId groupid;
  uint8_t sceneid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_add_scene_response(
      jsn,
      status,

      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "AddSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "AddSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "AddSceneResponse", "");
    return;
  }

  uic_mqtt_dotdot_scenes_generated_add_scene_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    groupid,

    sceneid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/ViewScene
void uic_mqtt_dotdot_on_scenes_view_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_view_scene_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_view_scene(
      jsn,
      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "ViewScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "ViewScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "ViewScene", "");
    return;
  }

  uic_mqtt_dotdot_scenes_view_scene_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    groupid,

    sceneid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/ViewScene
static void uic_mqtt_dotdot_on_generated_scenes_view_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_view_scene_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid;
  uint8_t sceneid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_view_scene(
      jsn,
      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "ViewScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "ViewScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "ViewScene", "");
    return;
  }

  uic_mqtt_dotdot_scenes_generated_view_scene_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    groupid,

    sceneid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/ViewSceneResponse
void uic_mqtt_dotdot_on_scenes_view_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_view_scene_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId groupid = {};
  uint8_t sceneid = {};
  uint16_t transition_time = {};
  SSceneName scene_name = {};
  std::vector<SExtensionFieldSetList> extension_field_sets;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_view_scene_response(
      jsn,
      status,

      groupid,

      sceneid,

      transition_time,

      scene_name,

      extension_field_sets
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "ViewSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "ViewSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "ViewSceneResponse", "");
    return;
  }

  uic_mqtt_dotdot_scenes_view_scene_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    groupid,

    sceneid,

    transition_time,

    scene_name,

    extension_field_sets.size(),
    extension_field_sets.data()

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/ViewSceneResponse
static void uic_mqtt_dotdot_on_generated_scenes_view_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_view_scene_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status;
  SGroupId groupid;
  uint8_t sceneid;
  uint16_t transition_time;
  SSceneName scene_name;
  std::vector<SExtensionFieldSetList> extension_field_sets;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_view_scene_response(
      jsn,
      status,

      groupid,

      sceneid,

      transition_time,

      scene_name,

      extension_field_sets
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "ViewSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "ViewSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "ViewSceneResponse", "");
    return;
  }

  uic_mqtt_dotdot_scenes_generated_view_scene_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    groupid,

    sceneid,

    transition_time,

    scene_name,

    extension_field_sets.size(),
    extension_field_sets.data()

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/RemoveScene
void uic_mqtt_dotdot_on_scenes_remove_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_remove_scene_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_remove_scene(
      jsn,
      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RemoveScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveScene", "");
    return;
  }

  uic_mqtt_dotdot_scenes_remove_scene_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    groupid,

    sceneid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/RemoveScene
static void uic_mqtt_dotdot_on_generated_scenes_remove_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_remove_scene_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid;
  uint8_t sceneid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_remove_scene(
      jsn,
      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RemoveScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveScene", "");
    return;
  }

  uic_mqtt_dotdot_scenes_generated_remove_scene_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    groupid,

    sceneid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/RemoveSceneResponse
void uic_mqtt_dotdot_on_scenes_remove_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_remove_scene_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_remove_scene_response(
      jsn,
      status,

      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RemoveSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveSceneResponse", "");
    return;
  }

  uic_mqtt_dotdot_scenes_remove_scene_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    groupid,

    sceneid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/RemoveSceneResponse
static void uic_mqtt_dotdot_on_generated_scenes_remove_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_remove_scene_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status;
  SGroupId groupid;
  uint8_t sceneid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_remove_scene_response(
      jsn,
      status,

      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RemoveSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveSceneResponse", "");
    return;
  }

  uic_mqtt_dotdot_scenes_generated_remove_scene_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    groupid,

    sceneid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/RemoveAllScenes
void uic_mqtt_dotdot_on_scenes_remove_all_scenes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_remove_all_scenes_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_remove_all_scenes(
      jsn,
      groupid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RemoveAllScenes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveAllScenes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveAllScenes", "");
    return;
  }

  uic_mqtt_dotdot_scenes_remove_all_scenes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    groupid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/RemoveAllScenes
static void uic_mqtt_dotdot_on_generated_scenes_remove_all_scenes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_remove_all_scenes_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_remove_all_scenes(
      jsn,
      groupid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RemoveAllScenes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveAllScenes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveAllScenes", "");
    return;
  }

  uic_mqtt_dotdot_scenes_generated_remove_all_scenes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    groupid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/RemoveAllScenesResponse
void uic_mqtt_dotdot_on_scenes_remove_all_scenes_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId groupid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_remove_all_scenes_response(
      jsn,
      status,

      groupid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RemoveAllScenesResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveAllScenesResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveAllScenesResponse", "");
    return;
  }

  uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    groupid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/RemoveAllScenesResponse
static void uic_mqtt_dotdot_on_generated_scenes_remove_all_scenes_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_remove_all_scenes_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status;
  SGroupId groupid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_remove_all_scenes_response(
      jsn,
      status,

      groupid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RemoveAllScenesResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveAllScenesResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveAllScenesResponse", "");
    return;
  }

  uic_mqtt_dotdot_scenes_generated_remove_all_scenes_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    groupid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/StoreScene
void uic_mqtt_dotdot_on_scenes_store_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_store_scene_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_store_scene(
      jsn,
      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "StoreScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "StoreScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "StoreScene", "");
    return;
  }

  uic_mqtt_dotdot_scenes_store_scene_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    groupid,

    sceneid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/StoreScene
static void uic_mqtt_dotdot_on_generated_scenes_store_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_store_scene_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid;
  uint8_t sceneid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_store_scene(
      jsn,
      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "StoreScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "StoreScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "StoreScene", "");
    return;
  }

  uic_mqtt_dotdot_scenes_generated_store_scene_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    groupid,

    sceneid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/StoreSceneResponse
void uic_mqtt_dotdot_on_scenes_store_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_store_scene_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_store_scene_response(
      jsn,
      status,

      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "StoreSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "StoreSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "StoreSceneResponse", "");
    return;
  }

  uic_mqtt_dotdot_scenes_store_scene_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    groupid,

    sceneid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/StoreSceneResponse
static void uic_mqtt_dotdot_on_generated_scenes_store_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_store_scene_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status;
  SGroupId groupid;
  uint8_t sceneid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_store_scene_response(
      jsn,
      status,

      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "StoreSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "StoreSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "StoreSceneResponse", "");
    return;
  }

  uic_mqtt_dotdot_scenes_generated_store_scene_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    groupid,

    sceneid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/RecallScene
void uic_mqtt_dotdot_on_scenes_recall_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_recall_scene_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};
  uint8_t sceneid = {};
  uint16_t transition_time = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_recall_scene(
      jsn,
      groupid,

      sceneid,

      transition_time
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RecallScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RecallScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RecallScene", "");
    return;
  }

  uic_mqtt_dotdot_scenes_recall_scene_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    groupid,

    sceneid,

    transition_time

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/RecallScene
static void uic_mqtt_dotdot_on_generated_scenes_recall_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_recall_scene_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid;
  uint8_t sceneid;
  uint16_t transition_time;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_recall_scene(
      jsn,
      groupid,

      sceneid,

      transition_time
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RecallScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RecallScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RecallScene", "");
    return;
  }

  uic_mqtt_dotdot_scenes_generated_recall_scene_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    groupid,

    sceneid,

    transition_time

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/GetSceneMembership
void uic_mqtt_dotdot_on_scenes_get_scene_membership(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_get_scene_membership_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_get_scene_membership(
      jsn,
      groupid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "GetSceneMembership");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "GetSceneMembership", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "GetSceneMembership", "");
    return;
  }

  uic_mqtt_dotdot_scenes_get_scene_membership_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    groupid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/GetSceneMembership
static void uic_mqtt_dotdot_on_generated_scenes_get_scene_membership(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_get_scene_membership_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_get_scene_membership(
      jsn,
      groupid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "GetSceneMembership");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "GetSceneMembership", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "GetSceneMembership", "");
    return;
  }

  uic_mqtt_dotdot_scenes_generated_get_scene_membership_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    groupid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/GetSceneMembershipResponse
void uic_mqtt_dotdot_on_scenes_get_scene_membership_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_get_scene_membership_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  uint8_t capacity = {};
  SGroupId groupid = {};
  std::vector<uint8_t> scene_list;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_get_scene_membership_response(
      jsn,
      status,

      capacity,

      groupid,

      scene_list
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "GetSceneMembershipResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "GetSceneMembershipResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "GetSceneMembershipResponse", "");
    return;
  }

  uic_mqtt_dotdot_scenes_get_scene_membership_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    capacity,

    groupid,

    scene_list.size(),
    scene_list.data()

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/GetSceneMembershipResponse
static void uic_mqtt_dotdot_on_generated_scenes_get_scene_membership_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_get_scene_membership_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status;
  uint8_t capacity;
  SGroupId groupid;
  std::vector<uint8_t> scene_list;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_get_scene_membership_response(
      jsn,
      status,

      capacity,

      groupid,

      scene_list
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "GetSceneMembershipResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "GetSceneMembershipResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "GetSceneMembershipResponse", "");
    return;
  }

  uic_mqtt_dotdot_scenes_generated_get_scene_membership_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    capacity,

    groupid,

    scene_list.size(),
    scene_list.data()

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/EnhancedAddScene
void uic_mqtt_dotdot_on_scenes_enhanced_add_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_enhanced_add_scene_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};
  uint8_t sceneid = {};
  uint16_t transition_time = {};
  SSceneName scene_name = {};
  std::vector<SExtensionFieldSetList> extension_field_sets;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_enhanced_add_scene(
      jsn,
      groupid,

      sceneid,

      transition_time,

      scene_name,

      extension_field_sets
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "EnhancedAddScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedAddScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedAddScene", "");
    return;
  }

  uic_mqtt_dotdot_scenes_enhanced_add_scene_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    groupid,

    sceneid,

    transition_time,

    scene_name,

    extension_field_sets.size(),
    extension_field_sets.data()

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/EnhancedAddScene
static void uic_mqtt_dotdot_on_generated_scenes_enhanced_add_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid;
  uint8_t sceneid;
  uint16_t transition_time;
  SSceneName scene_name;
  std::vector<SExtensionFieldSetList> extension_field_sets;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_enhanced_add_scene(
      jsn,
      groupid,

      sceneid,

      transition_time,

      scene_name,

      extension_field_sets
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "EnhancedAddScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedAddScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedAddScene", "");
    return;
  }

  uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    groupid,

    sceneid,

    transition_time,

    scene_name,

    extension_field_sets.size(),
    extension_field_sets.data()

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/EnhancedAddSceneResponse
void uic_mqtt_dotdot_on_scenes_enhanced_add_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_enhanced_add_scene_response(
      jsn,
      status,

      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "EnhancedAddSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedAddSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedAddSceneResponse", "");
    return;
  }

  uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    groupid,

    sceneid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/EnhancedAddSceneResponse
static void uic_mqtt_dotdot_on_generated_scenes_enhanced_add_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status;
  SGroupId groupid;
  uint8_t sceneid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_enhanced_add_scene_response(
      jsn,
      status,

      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "EnhancedAddSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedAddSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedAddSceneResponse", "");
    return;
  }

  uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    groupid,

    sceneid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/EnhancedViewScene
void uic_mqtt_dotdot_on_scenes_enhanced_view_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_enhanced_view_scene_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_enhanced_view_scene(
      jsn,
      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "EnhancedViewScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedViewScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedViewScene", "");
    return;
  }

  uic_mqtt_dotdot_scenes_enhanced_view_scene_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    groupid,

    sceneid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/EnhancedViewScene
static void uic_mqtt_dotdot_on_generated_scenes_enhanced_view_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid;
  uint8_t sceneid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_enhanced_view_scene(
      jsn,
      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "EnhancedViewScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedViewScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedViewScene", "");
    return;
  }

  uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    groupid,

    sceneid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/EnhancedViewSceneResponse
void uic_mqtt_dotdot_on_scenes_enhanced_view_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId groupid = {};
  uint8_t sceneid = {};
  uint16_t transition_time = {};
  SSceneName scene_name = {};
  std::vector<SExtensionFieldSetList> extension_field_sets;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_enhanced_view_scene_response(
      jsn,
      status,

      groupid,

      sceneid,

      transition_time,

      scene_name,

      extension_field_sets
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "EnhancedViewSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedViewSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedViewSceneResponse", "");
    return;
  }

  uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    groupid,

    sceneid,

    transition_time,

    scene_name,

    extension_field_sets.size(),
    extension_field_sets.data()

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/EnhancedViewSceneResponse
static void uic_mqtt_dotdot_on_generated_scenes_enhanced_view_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status;
  SGroupId groupid;
  uint8_t sceneid;
  uint16_t transition_time;
  SSceneName scene_name;
  std::vector<SExtensionFieldSetList> extension_field_sets;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_enhanced_view_scene_response(
      jsn,
      status,

      groupid,

      sceneid,

      transition_time,

      scene_name,

      extension_field_sets
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "EnhancedViewSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedViewSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedViewSceneResponse", "");
    return;
  }

  uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    groupid,

    sceneid,

    transition_time,

    scene_name,

    extension_field_sets.size(),
    extension_field_sets.data()

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/CopyScene
void uic_mqtt_dotdot_on_scenes_copy_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_copy_scene_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t mode = {};
  SGroupId group_identifier_from = {};
  uint8_t scene_identifier_from = {};
  SGroupId group_identifier_to = {};
  uint8_t scene_identifier_to = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_copy_scene(
      jsn,
      mode,

      group_identifier_from,

      scene_identifier_from,

      group_identifier_to,

      scene_identifier_to
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "CopyScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "CopyScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "CopyScene", "");
    return;
  }

  uic_mqtt_dotdot_scenes_copy_scene_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    mode,

    group_identifier_from,

    scene_identifier_from,

    group_identifier_to,

    scene_identifier_to

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/CopyScene
static void uic_mqtt_dotdot_on_generated_scenes_copy_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_copy_scene_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t mode;
  SGroupId group_identifier_from;
  uint8_t scene_identifier_from;
  SGroupId group_identifier_to;
  uint8_t scene_identifier_to;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_copy_scene(
      jsn,
      mode,

      group_identifier_from,

      scene_identifier_from,

      group_identifier_to,

      scene_identifier_to
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "CopyScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "CopyScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "CopyScene", "");
    return;
  }

  uic_mqtt_dotdot_scenes_generated_copy_scene_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    mode,

    group_identifier_from,

    scene_identifier_from,

    group_identifier_to,

    scene_identifier_to

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/CopySceneResponse
void uic_mqtt_dotdot_on_scenes_copy_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_copy_scene_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId group_identifier_from = {};
  uint8_t scene_identifier_from = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_copy_scene_response(
      jsn,
      status,

      group_identifier_from,

      scene_identifier_from
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "CopySceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "CopySceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "CopySceneResponse", "");
    return;
  }

  uic_mqtt_dotdot_scenes_copy_scene_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    group_identifier_from,

    scene_identifier_from

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/CopySceneResponse
static void uic_mqtt_dotdot_on_generated_scenes_copy_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_copy_scene_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status;
  SGroupId group_identifier_from;
  uint8_t scene_identifier_from;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_copy_scene_response(
      jsn,
      status,

      group_identifier_from,

      scene_identifier_from
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "CopySceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "CopySceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "CopySceneResponse", "");
    return;
  }

  uic_mqtt_dotdot_scenes_generated_copy_scene_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    group_identifier_from,

    scene_identifier_from

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/WriteAttributes
void uic_mqtt_dotdot_on_scenes_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_scenes_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_scenes_state_t new_state = {};
  uic_mqtt_dotdot_scenes_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_scenes_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_scenes_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_scenes_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_scenes_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_scenes_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.scene_count = true;
        force_update.current_scene = true;
        force_update.current_group = true;
        force_update.scene_valid = true;
        force_update.name_support = true;
        force_update.last_configured_by = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"SceneCount", &force_update.scene_count },
          {"CurrentScene", &force_update.current_scene },
          {"CurrentGroup", &force_update.current_group },
          {"SceneValid", &force_update.scene_valid },
          {"NameSupport", &force_update.name_support },
          {"LastConfiguredBy", &force_update.last_configured_by },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_scenes_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "Scenes/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_scenes_scene_count_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes/Attributes/SceneCount", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Scenes/Attributes/SceneCount";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_scenes_current_scene_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes/Attributes/CurrentScene", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Scenes/Attributes/CurrentScene";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_scenes_current_group_publish(
  const char *base_topic,
  SGroupId value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes/Attributes/CurrentGroup", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Scenes/Attributes/CurrentGroup";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_scenes_scene_valid_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes/Attributes/SceneValid", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Scenes/Attributes/SceneValid";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_scenes_name_support_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ScenesNameSupport.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes/Attributes/NameSupport", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Scenes/Attributes/NameSupport";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_scenes_last_configured_by_publish(
  const char *base_topic,
  EUI64 value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes/Attributes/LastConfiguredBy", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Scenes/Attributes/LastConfiguredBy";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_scenes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_scenes_write_attributes_callback) {
    subscription_topic = base_topic + "Scenes/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_WriteAttributes);
  }

  if(uic_mqtt_dotdot_scenes_force_read_attributes_callback) {
    subscription_topic = base_topic + "Scenes/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_force_read_attributes);
  }
  if (uic_mqtt_dotdot_scenes_add_scene_callback) {
    subscription_topic = base_topic + "Scenes/Commands/AddScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_add_scene);
  }
  if (uic_mqtt_dotdot_scenes_generated_add_scene_callback) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/AddScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_add_scene);
  }
  if (uic_mqtt_dotdot_scenes_add_scene_response_callback) {
    subscription_topic = base_topic + "Scenes/Commands/AddSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_add_scene_response);
  }
  if (uic_mqtt_dotdot_scenes_generated_add_scene_response_callback) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/AddSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_add_scene_response);
  }
  if (uic_mqtt_dotdot_scenes_view_scene_callback) {
    subscription_topic = base_topic + "Scenes/Commands/ViewScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_view_scene);
  }
  if (uic_mqtt_dotdot_scenes_generated_view_scene_callback) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/ViewScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_view_scene);
  }
  if (uic_mqtt_dotdot_scenes_view_scene_response_callback) {
    subscription_topic = base_topic + "Scenes/Commands/ViewSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_view_scene_response);
  }
  if (uic_mqtt_dotdot_scenes_generated_view_scene_response_callback) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/ViewSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_view_scene_response);
  }
  if (uic_mqtt_dotdot_scenes_remove_scene_callback) {
    subscription_topic = base_topic + "Scenes/Commands/RemoveScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_remove_scene);
  }
  if (uic_mqtt_dotdot_scenes_generated_remove_scene_callback) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/RemoveScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_remove_scene);
  }
  if (uic_mqtt_dotdot_scenes_remove_scene_response_callback) {
    subscription_topic = base_topic + "Scenes/Commands/RemoveSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_remove_scene_response);
  }
  if (uic_mqtt_dotdot_scenes_generated_remove_scene_response_callback) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/RemoveSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_remove_scene_response);
  }
  if (uic_mqtt_dotdot_scenes_remove_all_scenes_callback) {
    subscription_topic = base_topic + "Scenes/Commands/RemoveAllScenes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_remove_all_scenes);
  }
  if (uic_mqtt_dotdot_scenes_generated_remove_all_scenes_callback) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/RemoveAllScenes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_remove_all_scenes);
  }
  if (uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback) {
    subscription_topic = base_topic + "Scenes/Commands/RemoveAllScenesResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_remove_all_scenes_response);
  }
  if (uic_mqtt_dotdot_scenes_generated_remove_all_scenes_response_callback) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/RemoveAllScenesResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_remove_all_scenes_response);
  }
  if (uic_mqtt_dotdot_scenes_store_scene_callback) {
    subscription_topic = base_topic + "Scenes/Commands/StoreScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_store_scene);
  }
  if (uic_mqtt_dotdot_scenes_generated_store_scene_callback) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/StoreScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_store_scene);
  }
  if (uic_mqtt_dotdot_scenes_store_scene_response_callback) {
    subscription_topic = base_topic + "Scenes/Commands/StoreSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_store_scene_response);
  }
  if (uic_mqtt_dotdot_scenes_generated_store_scene_response_callback) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/StoreSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_store_scene_response);
  }
  if (uic_mqtt_dotdot_scenes_recall_scene_callback) {
    subscription_topic = base_topic + "Scenes/Commands/RecallScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_recall_scene);
  }
  if (uic_mqtt_dotdot_scenes_generated_recall_scene_callback) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/RecallScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_recall_scene);
  }
  if (uic_mqtt_dotdot_scenes_get_scene_membership_callback) {
    subscription_topic = base_topic + "Scenes/Commands/GetSceneMembership";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_get_scene_membership);
  }
  if (uic_mqtt_dotdot_scenes_generated_get_scene_membership_callback) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/GetSceneMembership";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_get_scene_membership);
  }
  if (uic_mqtt_dotdot_scenes_get_scene_membership_response_callback) {
    subscription_topic = base_topic + "Scenes/Commands/GetSceneMembershipResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_get_scene_membership_response);
  }
  if (uic_mqtt_dotdot_scenes_generated_get_scene_membership_response_callback) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/GetSceneMembershipResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_get_scene_membership_response);
  }
  if (uic_mqtt_dotdot_scenes_enhanced_add_scene_callback) {
    subscription_topic = base_topic + "Scenes/Commands/EnhancedAddScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_enhanced_add_scene);
  }
  if (uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_callback) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/EnhancedAddScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_enhanced_add_scene);
  }
  if (uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback) {
    subscription_topic = base_topic + "Scenes/Commands/EnhancedAddSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_enhanced_add_scene_response);
  }
  if (uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_response_callback) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/EnhancedAddSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_enhanced_add_scene_response);
  }
  if (uic_mqtt_dotdot_scenes_enhanced_view_scene_callback) {
    subscription_topic = base_topic + "Scenes/Commands/EnhancedViewScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_enhanced_view_scene);
  }
  if (uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_callback) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/EnhancedViewScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_enhanced_view_scene);
  }
  if (uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback) {
    subscription_topic = base_topic + "Scenes/Commands/EnhancedViewSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_enhanced_view_scene_response);
  }
  if (uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_response_callback) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/EnhancedViewSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_enhanced_view_scene_response);
  }
  if (uic_mqtt_dotdot_scenes_copy_scene_callback) {
    subscription_topic = base_topic + "Scenes/Commands/CopyScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_copy_scene);
  }
  if (uic_mqtt_dotdot_scenes_generated_copy_scene_callback) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/CopyScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_copy_scene);
  }
  if (uic_mqtt_dotdot_scenes_copy_scene_response_callback) {
    subscription_topic = base_topic + "Scenes/Commands/CopySceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_copy_scene_response);
  }
  if (uic_mqtt_dotdot_scenes_generated_copy_scene_response_callback) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/CopySceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_copy_scene_response);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_scenes_attributes_init();

  uic_mqtt_dotdot_by_group_scenes_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_on_off_off_callback_t uic_mqtt_dotdot_on_off_off_callback = nullptr;
static uic_mqtt_dotdot_on_off_off_callback_t uic_mqtt_dotdot_on_off_generated_off_callback = nullptr;
uic_mqtt_dotdot_on_off_on_callback_t uic_mqtt_dotdot_on_off_on_callback = nullptr;
static uic_mqtt_dotdot_on_off_on_callback_t uic_mqtt_dotdot_on_off_generated_on_callback = nullptr;
uic_mqtt_dotdot_on_off_toggle_callback_t uic_mqtt_dotdot_on_off_toggle_callback = nullptr;
static uic_mqtt_dotdot_on_off_toggle_callback_t uic_mqtt_dotdot_on_off_generated_toggle_callback = nullptr;
uic_mqtt_dotdot_on_off_off_with_effect_callback_t uic_mqtt_dotdot_on_off_off_with_effect_callback = nullptr;
static uic_mqtt_dotdot_on_off_off_with_effect_callback_t uic_mqtt_dotdot_on_off_generated_off_with_effect_callback = nullptr;
uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback_t uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback = nullptr;
static uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback_t uic_mqtt_dotdot_on_off_generated_on_with_recall_global_scene_callback = nullptr;
uic_mqtt_dotdot_on_off_on_with_timed_off_callback_t uic_mqtt_dotdot_on_off_on_with_timed_off_callback = nullptr;
static uic_mqtt_dotdot_on_off_on_with_timed_off_callback_t uic_mqtt_dotdot_on_off_generated_on_with_timed_off_callback = nullptr;
uic_mqtt_dotdot_on_off_write_attributes_callback_t uic_mqtt_dotdot_on_off_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_on_off_force_read_attributes_callback_t uic_mqtt_dotdot_on_off_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_on_off_off_callback_set(const uic_mqtt_dotdot_on_off_off_callback_t callback)
{
  uic_mqtt_dotdot_on_off_off_callback = callback;
}
void uic_mqtt_dotdot_on_off_generated_off_callback_set(const uic_mqtt_dotdot_on_off_off_callback_t callback)
{
  uic_mqtt_dotdot_on_off_generated_off_callback = callback;
}

void uic_mqtt_dotdot_on_off_on_callback_set(const uic_mqtt_dotdot_on_off_on_callback_t callback)
{
  uic_mqtt_dotdot_on_off_on_callback = callback;
}
void uic_mqtt_dotdot_on_off_generated_on_callback_set(const uic_mqtt_dotdot_on_off_on_callback_t callback)
{
  uic_mqtt_dotdot_on_off_generated_on_callback = callback;
}

void uic_mqtt_dotdot_on_off_toggle_callback_set(const uic_mqtt_dotdot_on_off_toggle_callback_t callback)
{
  uic_mqtt_dotdot_on_off_toggle_callback = callback;
}
void uic_mqtt_dotdot_on_off_generated_toggle_callback_set(const uic_mqtt_dotdot_on_off_toggle_callback_t callback)
{
  uic_mqtt_dotdot_on_off_generated_toggle_callback = callback;
}

void uic_mqtt_dotdot_on_off_off_with_effect_callback_set(const uic_mqtt_dotdot_on_off_off_with_effect_callback_t callback)
{
  uic_mqtt_dotdot_on_off_off_with_effect_callback = callback;
}
void uic_mqtt_dotdot_on_off_generated_off_with_effect_callback_set(const uic_mqtt_dotdot_on_off_off_with_effect_callback_t callback)
{
  uic_mqtt_dotdot_on_off_generated_off_with_effect_callback = callback;
}

void uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback_set(const uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback_t callback)
{
  uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback = callback;
}
void uic_mqtt_dotdot_on_off_generated_on_with_recall_global_scene_callback_set(const uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback_t callback)
{
  uic_mqtt_dotdot_on_off_generated_on_with_recall_global_scene_callback = callback;
}

void uic_mqtt_dotdot_on_off_on_with_timed_off_callback_set(const uic_mqtt_dotdot_on_off_on_with_timed_off_callback_t callback)
{
  uic_mqtt_dotdot_on_off_on_with_timed_off_callback = callback;
}
void uic_mqtt_dotdot_on_off_generated_on_with_timed_off_callback_set(const uic_mqtt_dotdot_on_off_on_with_timed_off_callback_t callback)
{
  uic_mqtt_dotdot_on_off_generated_on_with_timed_off_callback = callback;
}


void uic_mqtt_dotdot_set_on_off_write_attributes_callback(
  const uic_mqtt_dotdot_on_off_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_on_off_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_on_off_force_read_attributes_callback(
  const uic_mqtt_dotdot_on_off_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_on_off_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/Commands/Off
void uic_mqtt_dotdot_on_on_off_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_off_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "Off");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "Off", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "Off", "");
    return;
  }

  uic_mqtt_dotdot_on_off_off_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/GeneratedCommands/Off
static void uic_mqtt_dotdot_on_generated_on_off_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_generated_off_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "Off");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "Off", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "Off", "");
    return;
  }

  uic_mqtt_dotdot_on_off_generated_off_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/Commands/On
void uic_mqtt_dotdot_on_on_off_on(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_on_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "On");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "On", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "On", "");
    return;
  }

  uic_mqtt_dotdot_on_off_on_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/GeneratedCommands/On
static void uic_mqtt_dotdot_on_generated_on_off_on(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_generated_on_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "On");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "On", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "On", "");
    return;
  }

  uic_mqtt_dotdot_on_off_generated_on_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/Commands/Toggle
void uic_mqtt_dotdot_on_on_off_toggle(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_toggle_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "Toggle");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "Toggle", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "Toggle", "");
    return;
  }

  uic_mqtt_dotdot_on_off_toggle_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/GeneratedCommands/Toggle
static void uic_mqtt_dotdot_on_generated_on_off_toggle(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_generated_toggle_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "Toggle");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "Toggle", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "Toggle", "");
    return;
  }

  uic_mqtt_dotdot_on_off_generated_toggle_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/Commands/OffWithEffect
void uic_mqtt_dotdot_on_on_off_off_with_effect(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_off_with_effect_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  OffWithEffectEffectIdentifier effect_identifier = {};
  uint8_t effect_variant = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_on_off_off_with_effect(
      jsn,
      effect_identifier,

      effect_variant
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "OffWithEffect");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OffWithEffect", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OffWithEffect", "");
    return;
  }

  uic_mqtt_dotdot_on_off_off_with_effect_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    effect_identifier,

    effect_variant

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/GeneratedCommands/OffWithEffect
static void uic_mqtt_dotdot_on_generated_on_off_off_with_effect(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_generated_off_with_effect_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  OffWithEffectEffectIdentifier effect_identifier;
  uint8_t effect_variant;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_on_off_off_with_effect(
      jsn,
      effect_identifier,

      effect_variant
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "OffWithEffect");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OffWithEffect", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OffWithEffect", "");
    return;
  }

  uic_mqtt_dotdot_on_off_generated_off_with_effect_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    effect_identifier,

    effect_variant

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/Commands/OnWithRecallGlobalScene
void uic_mqtt_dotdot_on_on_off_on_with_recall_global_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "OnWithRecallGlobalScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OnWithRecallGlobalScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OnWithRecallGlobalScene", "");
    return;
  }

  uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/GeneratedCommands/OnWithRecallGlobalScene
static void uic_mqtt_dotdot_on_generated_on_off_on_with_recall_global_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_generated_on_with_recall_global_scene_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "OnWithRecallGlobalScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OnWithRecallGlobalScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OnWithRecallGlobalScene", "");
    return;
  }

  uic_mqtt_dotdot_on_off_generated_on_with_recall_global_scene_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/Commands/OnWithTimedOff
void uic_mqtt_dotdot_on_on_off_on_with_timed_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_on_with_timed_off_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t on_off_control = {};
  uint16_t on_time = {};
  uint16_t off_wait_time = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_on_off_on_with_timed_off(
      jsn,
      on_off_control,

      on_time,

      off_wait_time
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "OnWithTimedOff");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OnWithTimedOff", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OnWithTimedOff", "");
    return;
  }

  uic_mqtt_dotdot_on_off_on_with_timed_off_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    on_off_control,

    on_time,

    off_wait_time

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/GeneratedCommands/OnWithTimedOff
static void uic_mqtt_dotdot_on_generated_on_off_on_with_timed_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_generated_on_with_timed_off_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t on_off_control;
  uint16_t on_time;
  uint16_t off_wait_time;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_on_off_on_with_timed_off(
      jsn,
      on_off_control,

      on_time,

      off_wait_time
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "OnWithTimedOff");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OnWithTimedOff", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OnWithTimedOff", "");
    return;
  }

  uic_mqtt_dotdot_on_off_generated_on_with_timed_off_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    on_off_control,

    on_time,

    off_wait_time

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/Commands/WriteAttributes
void uic_mqtt_dotdot_on_on_off_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_on_off_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_on_off_state_t new_state = {};
  uic_mqtt_dotdot_on_off_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_on_off_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_on_off_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_on_off_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_on_off_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_on_off_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.on_off = true;
        force_update.global_scene_control = true;
        force_update.on_time = true;
        force_update.off_wait_time = true;
        force_update.start_up_on_off = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"OnOff", &force_update.on_off },
          {"GlobalSceneControl", &force_update.global_scene_control },
          {"OnTime", &force_update.on_time },
          {"OffWaitTime", &force_update.off_wait_time },
          {"StartUpOnOff", &force_update.start_up_on_off },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_on_off_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "OnOff/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_on_off_on_off_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff/Attributes/OnOff", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OnOff/Attributes/OnOff";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_on_off_global_scene_control_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff/Attributes/GlobalSceneControl", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OnOff/Attributes/GlobalSceneControl";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_on_off_on_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff/Attributes/OnTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OnOff/Attributes/OnTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_on_off_off_wait_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff/Attributes/OffWaitTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OnOff/Attributes/OffWaitTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_on_off_start_up_on_off_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef ON_OFF_START_UP_ON_OFF_ENUM_NAME_AVAILABLE
  jsn["value"] = on_off_start_up_on_off_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<OnOffStartUpOnOff>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff/Attributes/StartUpOnOff", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OnOff/Attributes/StartUpOnOff";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_on_off_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_on_off_write_attributes_callback) {
    subscription_topic = base_topic + "OnOff/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_on_off_WriteAttributes);
  }

  if(uic_mqtt_dotdot_on_off_force_read_attributes_callback) {
    subscription_topic = base_topic + "OnOff/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_on_off_force_read_attributes);
  }
  if (uic_mqtt_dotdot_on_off_off_callback) {
    subscription_topic = base_topic + "OnOff/Commands/Off";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_on_off_off);
  }
  if (uic_mqtt_dotdot_on_off_generated_off_callback) {
    subscription_topic = base_topic + "OnOff/GeneratedCommands/Off";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_on_off_off);
  }
  if (uic_mqtt_dotdot_on_off_on_callback) {
    subscription_topic = base_topic + "OnOff/Commands/On";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_on_off_on);
  }
  if (uic_mqtt_dotdot_on_off_generated_on_callback) {
    subscription_topic = base_topic + "OnOff/GeneratedCommands/On";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_on_off_on);
  }
  if (uic_mqtt_dotdot_on_off_toggle_callback) {
    subscription_topic = base_topic + "OnOff/Commands/Toggle";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_on_off_toggle);
  }
  if (uic_mqtt_dotdot_on_off_generated_toggle_callback) {
    subscription_topic = base_topic + "OnOff/GeneratedCommands/Toggle";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_on_off_toggle);
  }
  if (uic_mqtt_dotdot_on_off_off_with_effect_callback) {
    subscription_topic = base_topic + "OnOff/Commands/OffWithEffect";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_on_off_off_with_effect);
  }
  if (uic_mqtt_dotdot_on_off_generated_off_with_effect_callback) {
    subscription_topic = base_topic + "OnOff/GeneratedCommands/OffWithEffect";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_on_off_off_with_effect);
  }
  if (uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback) {
    subscription_topic = base_topic + "OnOff/Commands/OnWithRecallGlobalScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_on_off_on_with_recall_global_scene);
  }
  if (uic_mqtt_dotdot_on_off_generated_on_with_recall_global_scene_callback) {
    subscription_topic = base_topic + "OnOff/GeneratedCommands/OnWithRecallGlobalScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_on_off_on_with_recall_global_scene);
  }
  if (uic_mqtt_dotdot_on_off_on_with_timed_off_callback) {
    subscription_topic = base_topic + "OnOff/Commands/OnWithTimedOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_on_off_on_with_timed_off);
  }
  if (uic_mqtt_dotdot_on_off_generated_on_with_timed_off_callback) {
    subscription_topic = base_topic + "OnOff/GeneratedCommands/OnWithTimedOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_on_off_on_with_timed_off);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_on_off_attributes_init();

  uic_mqtt_dotdot_by_group_on_off_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_level_move_to_level_callback_t uic_mqtt_dotdot_level_move_to_level_callback = nullptr;
static uic_mqtt_dotdot_level_move_to_level_callback_t uic_mqtt_dotdot_level_generated_move_to_level_callback = nullptr;
uic_mqtt_dotdot_level_move_callback_t uic_mqtt_dotdot_level_move_callback = nullptr;
static uic_mqtt_dotdot_level_move_callback_t uic_mqtt_dotdot_level_generated_move_callback = nullptr;
uic_mqtt_dotdot_level_step_callback_t uic_mqtt_dotdot_level_step_callback = nullptr;
static uic_mqtt_dotdot_level_step_callback_t uic_mqtt_dotdot_level_generated_step_callback = nullptr;
uic_mqtt_dotdot_level_stop_callback_t uic_mqtt_dotdot_level_stop_callback = nullptr;
static uic_mqtt_dotdot_level_stop_callback_t uic_mqtt_dotdot_level_generated_stop_callback = nullptr;
uic_mqtt_dotdot_level_move_to_level_with_on_off_callback_t uic_mqtt_dotdot_level_move_to_level_with_on_off_callback = nullptr;
static uic_mqtt_dotdot_level_move_to_level_with_on_off_callback_t uic_mqtt_dotdot_level_generated_move_to_level_with_on_off_callback = nullptr;
uic_mqtt_dotdot_level_move_with_on_off_callback_t uic_mqtt_dotdot_level_move_with_on_off_callback = nullptr;
static uic_mqtt_dotdot_level_move_with_on_off_callback_t uic_mqtt_dotdot_level_generated_move_with_on_off_callback = nullptr;
uic_mqtt_dotdot_level_step_with_on_off_callback_t uic_mqtt_dotdot_level_step_with_on_off_callback = nullptr;
static uic_mqtt_dotdot_level_step_with_on_off_callback_t uic_mqtt_dotdot_level_generated_step_with_on_off_callback = nullptr;
uic_mqtt_dotdot_level_stop_with_on_off_callback_t uic_mqtt_dotdot_level_stop_with_on_off_callback = nullptr;
static uic_mqtt_dotdot_level_stop_with_on_off_callback_t uic_mqtt_dotdot_level_generated_stop_with_on_off_callback = nullptr;
uic_mqtt_dotdot_level_move_to_closest_frequency_callback_t uic_mqtt_dotdot_level_move_to_closest_frequency_callback = nullptr;
static uic_mqtt_dotdot_level_move_to_closest_frequency_callback_t uic_mqtt_dotdot_level_generated_move_to_closest_frequency_callback = nullptr;
uic_mqtt_dotdot_level_write_attributes_callback_t uic_mqtt_dotdot_level_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_level_force_read_attributes_callback_t uic_mqtt_dotdot_level_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_level_move_to_level_callback_set(const uic_mqtt_dotdot_level_move_to_level_callback_t callback)
{
  uic_mqtt_dotdot_level_move_to_level_callback = callback;
}
void uic_mqtt_dotdot_level_generated_move_to_level_callback_set(const uic_mqtt_dotdot_level_move_to_level_callback_t callback)
{
  uic_mqtt_dotdot_level_generated_move_to_level_callback = callback;
}

void uic_mqtt_dotdot_level_move_callback_set(const uic_mqtt_dotdot_level_move_callback_t callback)
{
  uic_mqtt_dotdot_level_move_callback = callback;
}
void uic_mqtt_dotdot_level_generated_move_callback_set(const uic_mqtt_dotdot_level_move_callback_t callback)
{
  uic_mqtt_dotdot_level_generated_move_callback = callback;
}

void uic_mqtt_dotdot_level_step_callback_set(const uic_mqtt_dotdot_level_step_callback_t callback)
{
  uic_mqtt_dotdot_level_step_callback = callback;
}
void uic_mqtt_dotdot_level_generated_step_callback_set(const uic_mqtt_dotdot_level_step_callback_t callback)
{
  uic_mqtt_dotdot_level_generated_step_callback = callback;
}

void uic_mqtt_dotdot_level_stop_callback_set(const uic_mqtt_dotdot_level_stop_callback_t callback)
{
  uic_mqtt_dotdot_level_stop_callback = callback;
}
void uic_mqtt_dotdot_level_generated_stop_callback_set(const uic_mqtt_dotdot_level_stop_callback_t callback)
{
  uic_mqtt_dotdot_level_generated_stop_callback = callback;
}

void uic_mqtt_dotdot_level_move_to_level_with_on_off_callback_set(const uic_mqtt_dotdot_level_move_to_level_with_on_off_callback_t callback)
{
  uic_mqtt_dotdot_level_move_to_level_with_on_off_callback = callback;
}
void uic_mqtt_dotdot_level_generated_move_to_level_with_on_off_callback_set(const uic_mqtt_dotdot_level_move_to_level_with_on_off_callback_t callback)
{
  uic_mqtt_dotdot_level_generated_move_to_level_with_on_off_callback = callback;
}

void uic_mqtt_dotdot_level_move_with_on_off_callback_set(const uic_mqtt_dotdot_level_move_with_on_off_callback_t callback)
{
  uic_mqtt_dotdot_level_move_with_on_off_callback = callback;
}
void uic_mqtt_dotdot_level_generated_move_with_on_off_callback_set(const uic_mqtt_dotdot_level_move_with_on_off_callback_t callback)
{
  uic_mqtt_dotdot_level_generated_move_with_on_off_callback = callback;
}

void uic_mqtt_dotdot_level_step_with_on_off_callback_set(const uic_mqtt_dotdot_level_step_with_on_off_callback_t callback)
{
  uic_mqtt_dotdot_level_step_with_on_off_callback = callback;
}
void uic_mqtt_dotdot_level_generated_step_with_on_off_callback_set(const uic_mqtt_dotdot_level_step_with_on_off_callback_t callback)
{
  uic_mqtt_dotdot_level_generated_step_with_on_off_callback = callback;
}

void uic_mqtt_dotdot_level_stop_with_on_off_callback_set(const uic_mqtt_dotdot_level_stop_with_on_off_callback_t callback)
{
  uic_mqtt_dotdot_level_stop_with_on_off_callback = callback;
}
void uic_mqtt_dotdot_level_generated_stop_with_on_off_callback_set(const uic_mqtt_dotdot_level_stop_with_on_off_callback_t callback)
{
  uic_mqtt_dotdot_level_generated_stop_with_on_off_callback = callback;
}

void uic_mqtt_dotdot_level_move_to_closest_frequency_callback_set(const uic_mqtt_dotdot_level_move_to_closest_frequency_callback_t callback)
{
  uic_mqtt_dotdot_level_move_to_closest_frequency_callback = callback;
}
void uic_mqtt_dotdot_level_generated_move_to_closest_frequency_callback_set(const uic_mqtt_dotdot_level_move_to_closest_frequency_callback_t callback)
{
  uic_mqtt_dotdot_level_generated_move_to_closest_frequency_callback = callback;
}


void uic_mqtt_dotdot_set_level_write_attributes_callback(
  const uic_mqtt_dotdot_level_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_level_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_level_force_read_attributes_callback(
  const uic_mqtt_dotdot_level_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_level_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/Level/Commands/MoveToLevel
void uic_mqtt_dotdot_on_level_move_to_level(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_move_to_level_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t level = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_move_to_level(
      jsn,
      level,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "MoveToLevel");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToLevel", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToLevel", "");
    return;
  }

  uic_mqtt_dotdot_level_move_to_level_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    level,

    transition_time,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Level/GeneratedCommands/MoveToLevel
static void uic_mqtt_dotdot_on_generated_level_move_to_level(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_generated_move_to_level_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t level;
  uint16_t transition_time;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_move_to_level(
      jsn,
      level,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "MoveToLevel");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToLevel", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToLevel", "");
    return;
  }

  uic_mqtt_dotdot_level_generated_move_to_level_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    level,

    transition_time,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Level/Commands/Move
void uic_mqtt_dotdot_on_level_move(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_move_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  MoveStepMode move_mode = {};
  uint8_t rate = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_move(
      jsn,
      move_mode,

      rate,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "Move");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Move", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Move", "");
    return;
  }

  uic_mqtt_dotdot_level_move_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    move_mode,

    rate,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Level/GeneratedCommands/Move
static void uic_mqtt_dotdot_on_generated_level_move(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_generated_move_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  MoveStepMode move_mode;
  uint8_t rate;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_move(
      jsn,
      move_mode,

      rate,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "Move");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Move", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Move", "");
    return;
  }

  uic_mqtt_dotdot_level_generated_move_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    move_mode,

    rate,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Level/Commands/Step
void uic_mqtt_dotdot_on_level_step(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_step_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  MoveStepMode step_mode = {};
  uint8_t step_size = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_step(
      jsn,
      step_mode,

      step_size,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "Step");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Step", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Step", "");
    return;
  }

  uic_mqtt_dotdot_level_step_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    step_mode,

    step_size,

    transition_time,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Level/GeneratedCommands/Step
static void uic_mqtt_dotdot_on_generated_level_step(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_generated_step_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  MoveStepMode step_mode;
  uint8_t step_size;
  uint16_t transition_time;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_step(
      jsn,
      step_mode,

      step_size,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "Step");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Step", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Step", "");
    return;
  }

  uic_mqtt_dotdot_level_generated_step_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    step_mode,

    step_size,

    transition_time,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Level/Commands/Stop
void uic_mqtt_dotdot_on_level_stop(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_stop_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_stop(
      jsn,
      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "Stop");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Stop", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Stop", "");
    return;
  }

  uic_mqtt_dotdot_level_stop_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Level/GeneratedCommands/Stop
static void uic_mqtt_dotdot_on_generated_level_stop(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_generated_stop_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_stop(
      jsn,
      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "Stop");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Stop", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Stop", "");
    return;
  }

  uic_mqtt_dotdot_level_generated_stop_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Level/Commands/MoveToLevelWithOnOff
void uic_mqtt_dotdot_on_level_move_to_level_with_on_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_move_to_level_with_on_off_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t level = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_move_to_level_with_on_off(
      jsn,
      level,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "MoveToLevelWithOnOff");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToLevelWithOnOff", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToLevelWithOnOff", "");
    return;
  }

  uic_mqtt_dotdot_level_move_to_level_with_on_off_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    level,

    transition_time,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Level/GeneratedCommands/MoveToLevelWithOnOff
static void uic_mqtt_dotdot_on_generated_level_move_to_level_with_on_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_generated_move_to_level_with_on_off_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t level;
  uint16_t transition_time;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_move_to_level_with_on_off(
      jsn,
      level,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "MoveToLevelWithOnOff");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToLevelWithOnOff", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToLevelWithOnOff", "");
    return;
  }

  uic_mqtt_dotdot_level_generated_move_to_level_with_on_off_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    level,

    transition_time,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Level/Commands/MoveWithOnOff
void uic_mqtt_dotdot_on_level_move_with_on_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_move_with_on_off_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  MoveStepMode move_mode = {};
  uint8_t rate = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_move_with_on_off(
      jsn,
      move_mode,

      rate,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "MoveWithOnOff");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveWithOnOff", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveWithOnOff", "");
    return;
  }

  uic_mqtt_dotdot_level_move_with_on_off_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    move_mode,

    rate,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Level/GeneratedCommands/MoveWithOnOff
static void uic_mqtt_dotdot_on_generated_level_move_with_on_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_generated_move_with_on_off_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  MoveStepMode move_mode;
  uint8_t rate;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_move_with_on_off(
      jsn,
      move_mode,

      rate,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "MoveWithOnOff");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveWithOnOff", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveWithOnOff", "");
    return;
  }

  uic_mqtt_dotdot_level_generated_move_with_on_off_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    move_mode,

    rate,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Level/Commands/StepWithOnOff
void uic_mqtt_dotdot_on_level_step_with_on_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_step_with_on_off_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  MoveStepMode step_mode = {};
  uint8_t step_size = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_step_with_on_off(
      jsn,
      step_mode,

      step_size,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "StepWithOnOff");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "StepWithOnOff", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "StepWithOnOff", "");
    return;
  }

  uic_mqtt_dotdot_level_step_with_on_off_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    step_mode,

    step_size,

    transition_time,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Level/GeneratedCommands/StepWithOnOff
static void uic_mqtt_dotdot_on_generated_level_step_with_on_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_generated_step_with_on_off_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  MoveStepMode step_mode;
  uint8_t step_size;
  uint16_t transition_time;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_step_with_on_off(
      jsn,
      step_mode,

      step_size,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "StepWithOnOff");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "StepWithOnOff", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "StepWithOnOff", "");
    return;
  }

  uic_mqtt_dotdot_level_generated_step_with_on_off_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    step_mode,

    step_size,

    transition_time,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Level/Commands/StopWithOnOff
void uic_mqtt_dotdot_on_level_stop_with_on_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_stop_with_on_off_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_stop_with_on_off(
      jsn,
      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "StopWithOnOff");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "StopWithOnOff", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "StopWithOnOff", "");
    return;
  }

  uic_mqtt_dotdot_level_stop_with_on_off_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Level/GeneratedCommands/StopWithOnOff
static void uic_mqtt_dotdot_on_generated_level_stop_with_on_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_generated_stop_with_on_off_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_stop_with_on_off(
      jsn,
      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "StopWithOnOff");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "StopWithOnOff", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "StopWithOnOff", "");
    return;
  }

  uic_mqtt_dotdot_level_generated_stop_with_on_off_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Level/Commands/MoveToClosestFrequency
void uic_mqtt_dotdot_on_level_move_to_closest_frequency(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_move_to_closest_frequency_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t frequency = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_move_to_closest_frequency(
      jsn,
      frequency
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "MoveToClosestFrequency");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToClosestFrequency", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToClosestFrequency", "");
    return;
  }

  uic_mqtt_dotdot_level_move_to_closest_frequency_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    frequency

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Level/GeneratedCommands/MoveToClosestFrequency
static void uic_mqtt_dotdot_on_generated_level_move_to_closest_frequency(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_generated_move_to_closest_frequency_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t frequency;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_move_to_closest_frequency(
      jsn,
      frequency
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "MoveToClosestFrequency");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToClosestFrequency", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToClosestFrequency", "");
    return;
  }

  uic_mqtt_dotdot_level_generated_move_to_closest_frequency_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    frequency

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Level/Commands/WriteAttributes
void uic_mqtt_dotdot_on_level_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_level_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_level_state_t new_state = {};
  uic_mqtt_dotdot_level_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_level_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_level_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_level_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_level_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_level_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.current_level = true;
        force_update.remaining_time = true;
        force_update.min_level = true;
        force_update.max_level = true;
        force_update.current_frequency = true;
        force_update.min_frequency = true;
        force_update.max_frequency = true;
        force_update.options = true;
        force_update.on_off_transition_time = true;
        force_update.on_level = true;
        force_update.on_transition_time = true;
        force_update.off_transition_time = true;
        force_update.default_move_rate = true;
        force_update.start_up_current_level = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"CurrentLevel", &force_update.current_level },
          {"RemainingTime", &force_update.remaining_time },
          {"MinLevel", &force_update.min_level },
          {"MaxLevel", &force_update.max_level },
          {"CurrentFrequency", &force_update.current_frequency },
          {"MinFrequency", &force_update.min_frequency },
          {"MaxFrequency", &force_update.max_frequency },
          {"Options", &force_update.options },
          {"OnOffTransitionTime", &force_update.on_off_transition_time },
          {"OnLevel", &force_update.on_level },
          {"OnTransitionTime", &force_update.on_transition_time },
          {"OffTransitionTime", &force_update.off_transition_time },
          {"DefaultMoveRate", &force_update.default_move_rate },
          {"StartUpCurrentLevel", &force_update.start_up_current_level },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_level_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "Level/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_level_current_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/CurrentLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/CurrentLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_level_remaining_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/RemainingTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/RemainingTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_level_min_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/MinLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/MinLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_level_max_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/MaxLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/MaxLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_level_current_frequency_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/CurrentFrequency", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/CurrentFrequency";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_level_min_frequency_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/MinFrequency", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/MinFrequency";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_level_max_frequency_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/MaxFrequency", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/MaxFrequency";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_level_options_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = LevelOptions.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/Options", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Level/Attributes/Options";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_level_on_off_transition_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/OnOffTransitionTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/OnOffTransitionTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_level_on_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/OnLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/OnLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_level_on_transition_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/OnTransitionTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/OnTransitionTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_level_off_transition_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/OffTransitionTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/OffTransitionTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_level_default_move_rate_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/DefaultMoveRate", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/DefaultMoveRate";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_level_start_up_current_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/StartUpCurrentLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/StartUpCurrentLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_level_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_level_write_attributes_callback) {
    subscription_topic = base_topic + "Level/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_level_WriteAttributes);
  }

  if(uic_mqtt_dotdot_level_force_read_attributes_callback) {
    subscription_topic = base_topic + "Level/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_level_force_read_attributes);
  }
  if (uic_mqtt_dotdot_level_move_to_level_callback) {
    subscription_topic = base_topic + "Level/Commands/MoveToLevel";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_level_move_to_level);
  }
  if (uic_mqtt_dotdot_level_generated_move_to_level_callback) {
    subscription_topic = base_topic + "Level/GeneratedCommands/MoveToLevel";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_level_move_to_level);
  }
  if (uic_mqtt_dotdot_level_move_callback) {
    subscription_topic = base_topic + "Level/Commands/Move";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_level_move);
  }
  if (uic_mqtt_dotdot_level_generated_move_callback) {
    subscription_topic = base_topic + "Level/GeneratedCommands/Move";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_level_move);
  }
  if (uic_mqtt_dotdot_level_step_callback) {
    subscription_topic = base_topic + "Level/Commands/Step";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_level_step);
  }
  if (uic_mqtt_dotdot_level_generated_step_callback) {
    subscription_topic = base_topic + "Level/GeneratedCommands/Step";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_level_step);
  }
  if (uic_mqtt_dotdot_level_stop_callback) {
    subscription_topic = base_topic + "Level/Commands/Stop";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_level_stop);
  }
  if (uic_mqtt_dotdot_level_generated_stop_callback) {
    subscription_topic = base_topic + "Level/GeneratedCommands/Stop";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_level_stop);
  }
  if (uic_mqtt_dotdot_level_move_to_level_with_on_off_callback) {
    subscription_topic = base_topic + "Level/Commands/MoveToLevelWithOnOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_level_move_to_level_with_on_off);
  }
  if (uic_mqtt_dotdot_level_generated_move_to_level_with_on_off_callback) {
    subscription_topic = base_topic + "Level/GeneratedCommands/MoveToLevelWithOnOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_level_move_to_level_with_on_off);
  }
  if (uic_mqtt_dotdot_level_move_with_on_off_callback) {
    subscription_topic = base_topic + "Level/Commands/MoveWithOnOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_level_move_with_on_off);
  }
  if (uic_mqtt_dotdot_level_generated_move_with_on_off_callback) {
    subscription_topic = base_topic + "Level/GeneratedCommands/MoveWithOnOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_level_move_with_on_off);
  }
  if (uic_mqtt_dotdot_level_step_with_on_off_callback) {
    subscription_topic = base_topic + "Level/Commands/StepWithOnOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_level_step_with_on_off);
  }
  if (uic_mqtt_dotdot_level_generated_step_with_on_off_callback) {
    subscription_topic = base_topic + "Level/GeneratedCommands/StepWithOnOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_level_step_with_on_off);
  }
  if (uic_mqtt_dotdot_level_stop_with_on_off_callback) {
    subscription_topic = base_topic + "Level/Commands/StopWithOnOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_level_stop_with_on_off);
  }
  if (uic_mqtt_dotdot_level_generated_stop_with_on_off_callback) {
    subscription_topic = base_topic + "Level/GeneratedCommands/StopWithOnOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_level_stop_with_on_off);
  }
  if (uic_mqtt_dotdot_level_move_to_closest_frequency_callback) {
    subscription_topic = base_topic + "Level/Commands/MoveToClosestFrequency";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_level_move_to_closest_frequency);
  }
  if (uic_mqtt_dotdot_level_generated_move_to_closest_frequency_callback) {
    subscription_topic = base_topic + "Level/GeneratedCommands/MoveToClosestFrequency";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_level_move_to_closest_frequency);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_level_attributes_init();

  uic_mqtt_dotdot_by_group_level_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_alarms_reset_alarm_callback_t uic_mqtt_dotdot_alarms_reset_alarm_callback = nullptr;
static uic_mqtt_dotdot_alarms_reset_alarm_callback_t uic_mqtt_dotdot_alarms_generated_reset_alarm_callback = nullptr;
uic_mqtt_dotdot_alarms_alarm_callback_t uic_mqtt_dotdot_alarms_alarm_callback = nullptr;
static uic_mqtt_dotdot_alarms_alarm_callback_t uic_mqtt_dotdot_alarms_generated_alarm_callback = nullptr;
uic_mqtt_dotdot_alarms_reset_all_alarms_callback_t uic_mqtt_dotdot_alarms_reset_all_alarms_callback = nullptr;
static uic_mqtt_dotdot_alarms_reset_all_alarms_callback_t uic_mqtt_dotdot_alarms_generated_reset_all_alarms_callback = nullptr;
uic_mqtt_dotdot_alarms_get_alarm_response_callback_t uic_mqtt_dotdot_alarms_get_alarm_response_callback = nullptr;
static uic_mqtt_dotdot_alarms_get_alarm_response_callback_t uic_mqtt_dotdot_alarms_generated_get_alarm_response_callback = nullptr;
uic_mqtt_dotdot_alarms_get_alarm_callback_t uic_mqtt_dotdot_alarms_get_alarm_callback = nullptr;
static uic_mqtt_dotdot_alarms_get_alarm_callback_t uic_mqtt_dotdot_alarms_generated_get_alarm_callback = nullptr;
uic_mqtt_dotdot_alarms_reset_alarm_log_callback_t uic_mqtt_dotdot_alarms_reset_alarm_log_callback = nullptr;
static uic_mqtt_dotdot_alarms_reset_alarm_log_callback_t uic_mqtt_dotdot_alarms_generated_reset_alarm_log_callback = nullptr;
uic_mqtt_dotdot_alarms_write_attributes_callback_t uic_mqtt_dotdot_alarms_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_alarms_force_read_attributes_callback_t uic_mqtt_dotdot_alarms_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_alarms_reset_alarm_callback_set(const uic_mqtt_dotdot_alarms_reset_alarm_callback_t callback)
{
  uic_mqtt_dotdot_alarms_reset_alarm_callback = callback;
}
void uic_mqtt_dotdot_alarms_generated_reset_alarm_callback_set(const uic_mqtt_dotdot_alarms_reset_alarm_callback_t callback)
{
  uic_mqtt_dotdot_alarms_generated_reset_alarm_callback = callback;
}

void uic_mqtt_dotdot_alarms_alarm_callback_set(const uic_mqtt_dotdot_alarms_alarm_callback_t callback)
{
  uic_mqtt_dotdot_alarms_alarm_callback = callback;
}
void uic_mqtt_dotdot_alarms_generated_alarm_callback_set(const uic_mqtt_dotdot_alarms_alarm_callback_t callback)
{
  uic_mqtt_dotdot_alarms_generated_alarm_callback = callback;
}

void uic_mqtt_dotdot_alarms_reset_all_alarms_callback_set(const uic_mqtt_dotdot_alarms_reset_all_alarms_callback_t callback)
{
  uic_mqtt_dotdot_alarms_reset_all_alarms_callback = callback;
}
void uic_mqtt_dotdot_alarms_generated_reset_all_alarms_callback_set(const uic_mqtt_dotdot_alarms_reset_all_alarms_callback_t callback)
{
  uic_mqtt_dotdot_alarms_generated_reset_all_alarms_callback = callback;
}

void uic_mqtt_dotdot_alarms_get_alarm_response_callback_set(const uic_mqtt_dotdot_alarms_get_alarm_response_callback_t callback)
{
  uic_mqtt_dotdot_alarms_get_alarm_response_callback = callback;
}
void uic_mqtt_dotdot_alarms_generated_get_alarm_response_callback_set(const uic_mqtt_dotdot_alarms_get_alarm_response_callback_t callback)
{
  uic_mqtt_dotdot_alarms_generated_get_alarm_response_callback = callback;
}

void uic_mqtt_dotdot_alarms_get_alarm_callback_set(const uic_mqtt_dotdot_alarms_get_alarm_callback_t callback)
{
  uic_mqtt_dotdot_alarms_get_alarm_callback = callback;
}
void uic_mqtt_dotdot_alarms_generated_get_alarm_callback_set(const uic_mqtt_dotdot_alarms_get_alarm_callback_t callback)
{
  uic_mqtt_dotdot_alarms_generated_get_alarm_callback = callback;
}

void uic_mqtt_dotdot_alarms_reset_alarm_log_callback_set(const uic_mqtt_dotdot_alarms_reset_alarm_log_callback_t callback)
{
  uic_mqtt_dotdot_alarms_reset_alarm_log_callback = callback;
}
void uic_mqtt_dotdot_alarms_generated_reset_alarm_log_callback_set(const uic_mqtt_dotdot_alarms_reset_alarm_log_callback_t callback)
{
  uic_mqtt_dotdot_alarms_generated_reset_alarm_log_callback = callback;
}


void uic_mqtt_dotdot_set_alarms_write_attributes_callback(
  const uic_mqtt_dotdot_alarms_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_alarms_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_alarms_force_read_attributes_callback(
  const uic_mqtt_dotdot_alarms_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_alarms_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/Commands/ResetAlarm
void uic_mqtt_dotdot_on_alarms_reset_alarm(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_reset_alarm_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t alarm_code = {};
  clusterId cluster_identifier = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_alarms_reset_alarm(
      jsn,
      alarm_code,

      cluster_identifier
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "ResetAlarm");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAlarm", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAlarm", "");
    return;
  }

  uic_mqtt_dotdot_alarms_reset_alarm_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    alarm_code,

    cluster_identifier

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/GeneratedCommands/ResetAlarm
static void uic_mqtt_dotdot_on_generated_alarms_reset_alarm(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_generated_reset_alarm_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t alarm_code;
  clusterId cluster_identifier;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_alarms_reset_alarm(
      jsn,
      alarm_code,

      cluster_identifier
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "ResetAlarm");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAlarm", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAlarm", "");
    return;
  }

  uic_mqtt_dotdot_alarms_generated_reset_alarm_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    alarm_code,

    cluster_identifier

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/Commands/Alarm
void uic_mqtt_dotdot_on_alarms_alarm(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_alarm_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t alarm_code = {};
  clusterId cluster_identifier = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_alarms_alarm(
      jsn,
      alarm_code,

      cluster_identifier
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "Alarm");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "Alarm", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "Alarm", "");
    return;
  }

  uic_mqtt_dotdot_alarms_alarm_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    alarm_code,

    cluster_identifier

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/GeneratedCommands/Alarm
static void uic_mqtt_dotdot_on_generated_alarms_alarm(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_generated_alarm_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t alarm_code;
  clusterId cluster_identifier;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_alarms_alarm(
      jsn,
      alarm_code,

      cluster_identifier
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "Alarm");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "Alarm", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "Alarm", "");
    return;
  }

  uic_mqtt_dotdot_alarms_generated_alarm_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    alarm_code,

    cluster_identifier

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/Commands/ResetAllAlarms
void uic_mqtt_dotdot_on_alarms_reset_all_alarms(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_reset_all_alarms_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "ResetAllAlarms");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAllAlarms", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAllAlarms", "");
    return;
  }

  uic_mqtt_dotdot_alarms_reset_all_alarms_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/GeneratedCommands/ResetAllAlarms
static void uic_mqtt_dotdot_on_generated_alarms_reset_all_alarms(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_generated_reset_all_alarms_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "ResetAllAlarms");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAllAlarms", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAllAlarms", "");
    return;
  }

  uic_mqtt_dotdot_alarms_generated_reset_all_alarms_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/Commands/GetAlarmResponse
void uic_mqtt_dotdot_on_alarms_get_alarm_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_get_alarm_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  uint8_t alarm_code = {};
  clusterId cluster_identifier = {};
  uint32_t time_stamp = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_alarms_get_alarm_response(
      jsn,
      status,

      alarm_code,

      cluster_identifier,

      time_stamp
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "GetAlarmResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "GetAlarmResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "GetAlarmResponse", "");
    return;
  }

  uic_mqtt_dotdot_alarms_get_alarm_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    alarm_code,

    cluster_identifier,

    time_stamp

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/GeneratedCommands/GetAlarmResponse
static void uic_mqtt_dotdot_on_generated_alarms_get_alarm_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_generated_get_alarm_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status;
  uint8_t alarm_code;
  clusterId cluster_identifier;
  uint32_t time_stamp;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_alarms_get_alarm_response(
      jsn,
      status,

      alarm_code,

      cluster_identifier,

      time_stamp
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "GetAlarmResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "GetAlarmResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "GetAlarmResponse", "");
    return;
  }

  uic_mqtt_dotdot_alarms_generated_get_alarm_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    alarm_code,

    cluster_identifier,

    time_stamp

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/Commands/GetAlarm
void uic_mqtt_dotdot_on_alarms_get_alarm(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_get_alarm_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "GetAlarm");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "GetAlarm", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "GetAlarm", "");
    return;
  }

  uic_mqtt_dotdot_alarms_get_alarm_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/GeneratedCommands/GetAlarm
static void uic_mqtt_dotdot_on_generated_alarms_get_alarm(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_generated_get_alarm_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "GetAlarm");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "GetAlarm", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "GetAlarm", "");
    return;
  }

  uic_mqtt_dotdot_alarms_generated_get_alarm_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/Commands/ResetAlarmLog
void uic_mqtt_dotdot_on_alarms_reset_alarm_log(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_reset_alarm_log_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "ResetAlarmLog");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAlarmLog", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAlarmLog", "");
    return;
  }

  uic_mqtt_dotdot_alarms_reset_alarm_log_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/GeneratedCommands/ResetAlarmLog
static void uic_mqtt_dotdot_on_generated_alarms_reset_alarm_log(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_generated_reset_alarm_log_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "ResetAlarmLog");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAlarmLog", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAlarmLog", "");
    return;
  }

  uic_mqtt_dotdot_alarms_generated_reset_alarm_log_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/Commands/WriteAttributes
void uic_mqtt_dotdot_on_alarms_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_alarms_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_alarms_state_t new_state = {};
  uic_mqtt_dotdot_alarms_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_alarms_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_alarms_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_alarms_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_alarms_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_alarms_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.alarm_count = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"AlarmCount", &force_update.alarm_count },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_alarms_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "Alarms/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_alarms_alarm_count_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms/Attributes/AlarmCount", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Alarms/Attributes/AlarmCount";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_alarms_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_alarms_write_attributes_callback) {
    subscription_topic = base_topic + "Alarms/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_alarms_WriteAttributes);
  }

  if(uic_mqtt_dotdot_alarms_force_read_attributes_callback) {
    subscription_topic = base_topic + "Alarms/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_alarms_force_read_attributes);
  }
  if (uic_mqtt_dotdot_alarms_reset_alarm_callback) {
    subscription_topic = base_topic + "Alarms/Commands/ResetAlarm";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_alarms_reset_alarm);
  }
  if (uic_mqtt_dotdot_alarms_generated_reset_alarm_callback) {
    subscription_topic = base_topic + "Alarms/GeneratedCommands/ResetAlarm";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_alarms_reset_alarm);
  }
  if (uic_mqtt_dotdot_alarms_alarm_callback) {
    subscription_topic = base_topic + "Alarms/Commands/Alarm";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_alarms_alarm);
  }
  if (uic_mqtt_dotdot_alarms_generated_alarm_callback) {
    subscription_topic = base_topic + "Alarms/GeneratedCommands/Alarm";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_alarms_alarm);
  }
  if (uic_mqtt_dotdot_alarms_reset_all_alarms_callback) {
    subscription_topic = base_topic + "Alarms/Commands/ResetAllAlarms";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_alarms_reset_all_alarms);
  }
  if (uic_mqtt_dotdot_alarms_generated_reset_all_alarms_callback) {
    subscription_topic = base_topic + "Alarms/GeneratedCommands/ResetAllAlarms";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_alarms_reset_all_alarms);
  }
  if (uic_mqtt_dotdot_alarms_get_alarm_response_callback) {
    subscription_topic = base_topic + "Alarms/Commands/GetAlarmResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_alarms_get_alarm_response);
  }
  if (uic_mqtt_dotdot_alarms_generated_get_alarm_response_callback) {
    subscription_topic = base_topic + "Alarms/GeneratedCommands/GetAlarmResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_alarms_get_alarm_response);
  }
  if (uic_mqtt_dotdot_alarms_get_alarm_callback) {
    subscription_topic = base_topic + "Alarms/Commands/GetAlarm";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_alarms_get_alarm);
  }
  if (uic_mqtt_dotdot_alarms_generated_get_alarm_callback) {
    subscription_topic = base_topic + "Alarms/GeneratedCommands/GetAlarm";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_alarms_get_alarm);
  }
  if (uic_mqtt_dotdot_alarms_reset_alarm_log_callback) {
    subscription_topic = base_topic + "Alarms/Commands/ResetAlarmLog";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_alarms_reset_alarm_log);
  }
  if (uic_mqtt_dotdot_alarms_generated_reset_alarm_log_callback) {
    subscription_topic = base_topic + "Alarms/GeneratedCommands/ResetAlarmLog";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_alarms_reset_alarm_log);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_alarms_attributes_init();

  uic_mqtt_dotdot_by_group_alarms_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_time_write_attributes_callback_t uic_mqtt_dotdot_time_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_time_force_read_attributes_callback_t uic_mqtt_dotdot_time_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_time_write_attributes_callback(
  const uic_mqtt_dotdot_time_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_time_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_time_force_read_attributes_callback(
  const uic_mqtt_dotdot_time_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_time_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/Time/Commands/WriteAttributes
void uic_mqtt_dotdot_on_time_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_time_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_time_state_t new_state = {};
  uic_mqtt_dotdot_time_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_time_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Time", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_time_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_time_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_time_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_time_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.time = true;
        force_update.time_status = true;
        force_update.time_zone = true;
        force_update.dst_start = true;
        force_update.dst_end = true;
        force_update.dst_shift = true;
        force_update.standard_time = true;
        force_update.local_time = true;
        force_update.last_set_time = true;
        force_update.valid_until_time = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"Time", &force_update.time },
          {"TimeStatus", &force_update.time_status },
          {"TimeZone", &force_update.time_zone },
          {"DstStart", &force_update.dst_start },
          {"DstEnd", &force_update.dst_end },
          {"DstShift", &force_update.dst_shift },
          {"StandardTime", &force_update.standard_time },
          {"LocalTime", &force_update.local_time },
          {"LastSetTime", &force_update.last_set_time },
          {"ValidUntilTime", &force_update.valid_until_time },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_time_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "Time/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_time_time_publish(
  const char *base_topic,
  UTC value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time/Attributes/Time", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Time/Attributes/Time";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_time_time_status_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = TimeTimeStatus.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time/Attributes/TimeStatus", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Time/Attributes/TimeStatus";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_time_time_zone_publish(
  const char *base_topic,
  int32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time/Attributes/TimeZone", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Time/Attributes/TimeZone";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_time_dst_start_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time/Attributes/DstStart", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Time/Attributes/DstStart";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_time_dst_end_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time/Attributes/DstEnd", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Time/Attributes/DstEnd";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_time_dst_shift_publish(
  const char *base_topic,
  int32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time/Attributes/DstShift", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Time/Attributes/DstShift";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_time_standard_time_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time/Attributes/StandardTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Time/Attributes/StandardTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_time_local_time_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time/Attributes/LocalTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Time/Attributes/LocalTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_time_last_set_time_publish(
  const char *base_topic,
  UTC value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time/Attributes/LastSetTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Time/Attributes/LastSetTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_time_valid_until_time_publish(
  const char *base_topic,
  UTC value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time/Attributes/ValidUntilTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Time/Attributes/ValidUntilTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_time_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_time_write_attributes_callback) {
    subscription_topic = base_topic + "Time/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_time_WriteAttributes);
  }

  if(uic_mqtt_dotdot_time_force_read_attributes_callback) {
    subscription_topic = base_topic + "Time/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_time_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_time_attributes_init();

  uic_mqtt_dotdot_by_group_time_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_ota_upgrade_image_notify_callback_t uic_mqtt_dotdot_ota_upgrade_image_notify_callback = nullptr;
static uic_mqtt_dotdot_ota_upgrade_image_notify_callback_t uic_mqtt_dotdot_ota_upgrade_generated_image_notify_callback = nullptr;
uic_mqtt_dotdot_ota_upgrade_query_next_image_request_callback_t uic_mqtt_dotdot_ota_upgrade_query_next_image_request_callback = nullptr;
static uic_mqtt_dotdot_ota_upgrade_query_next_image_request_callback_t uic_mqtt_dotdot_ota_upgrade_generated_query_next_image_request_callback = nullptr;
uic_mqtt_dotdot_ota_upgrade_query_next_image_response_callback_t uic_mqtt_dotdot_ota_upgrade_query_next_image_response_callback = nullptr;
static uic_mqtt_dotdot_ota_upgrade_query_next_image_response_callback_t uic_mqtt_dotdot_ota_upgrade_generated_query_next_image_response_callback = nullptr;
uic_mqtt_dotdot_ota_upgrade_image_block_request_callback_t uic_mqtt_dotdot_ota_upgrade_image_block_request_callback = nullptr;
static uic_mqtt_dotdot_ota_upgrade_image_block_request_callback_t uic_mqtt_dotdot_ota_upgrade_generated_image_block_request_callback = nullptr;
uic_mqtt_dotdot_ota_upgrade_image_page_request_callback_t uic_mqtt_dotdot_ota_upgrade_image_page_request_callback = nullptr;
static uic_mqtt_dotdot_ota_upgrade_image_page_request_callback_t uic_mqtt_dotdot_ota_upgrade_generated_image_page_request_callback = nullptr;
uic_mqtt_dotdot_ota_upgrade_image_block_response_callback_t uic_mqtt_dotdot_ota_upgrade_image_block_response_callback = nullptr;
static uic_mqtt_dotdot_ota_upgrade_image_block_response_callback_t uic_mqtt_dotdot_ota_upgrade_generated_image_block_response_callback = nullptr;
uic_mqtt_dotdot_ota_upgrade_upgrade_end_request_callback_t uic_mqtt_dotdot_ota_upgrade_upgrade_end_request_callback = nullptr;
static uic_mqtt_dotdot_ota_upgrade_upgrade_end_request_callback_t uic_mqtt_dotdot_ota_upgrade_generated_upgrade_end_request_callback = nullptr;
uic_mqtt_dotdot_ota_upgrade_upgrade_end_response_callback_t uic_mqtt_dotdot_ota_upgrade_upgrade_end_response_callback = nullptr;
static uic_mqtt_dotdot_ota_upgrade_upgrade_end_response_callback_t uic_mqtt_dotdot_ota_upgrade_generated_upgrade_end_response_callback = nullptr;
uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_request_callback_t uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_request_callback = nullptr;
static uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_request_callback_t uic_mqtt_dotdot_ota_upgrade_generated_query_device_specific_file_request_callback = nullptr;
uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_response_callback_t uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_response_callback = nullptr;
static uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_response_callback_t uic_mqtt_dotdot_ota_upgrade_generated_query_device_specific_file_response_callback = nullptr;
uic_mqtt_dotdot_ota_upgrade_write_attributes_callback_t uic_mqtt_dotdot_ota_upgrade_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_ota_upgrade_force_read_attributes_callback_t uic_mqtt_dotdot_ota_upgrade_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_ota_upgrade_image_notify_callback_set(const uic_mqtt_dotdot_ota_upgrade_image_notify_callback_t callback)
{
  uic_mqtt_dotdot_ota_upgrade_image_notify_callback = callback;
}
void uic_mqtt_dotdot_ota_upgrade_generated_image_notify_callback_set(const uic_mqtt_dotdot_ota_upgrade_image_notify_callback_t callback)
{
  uic_mqtt_dotdot_ota_upgrade_generated_image_notify_callback = callback;
}

void uic_mqtt_dotdot_ota_upgrade_query_next_image_request_callback_set(const uic_mqtt_dotdot_ota_upgrade_query_next_image_request_callback_t callback)
{
  uic_mqtt_dotdot_ota_upgrade_query_next_image_request_callback = callback;
}
void uic_mqtt_dotdot_ota_upgrade_generated_query_next_image_request_callback_set(const uic_mqtt_dotdot_ota_upgrade_query_next_image_request_callback_t callback)
{
  uic_mqtt_dotdot_ota_upgrade_generated_query_next_image_request_callback = callback;
}

void uic_mqtt_dotdot_ota_upgrade_query_next_image_response_callback_set(const uic_mqtt_dotdot_ota_upgrade_query_next_image_response_callback_t callback)
{
  uic_mqtt_dotdot_ota_upgrade_query_next_image_response_callback = callback;
}
void uic_mqtt_dotdot_ota_upgrade_generated_query_next_image_response_callback_set(const uic_mqtt_dotdot_ota_upgrade_query_next_image_response_callback_t callback)
{
  uic_mqtt_dotdot_ota_upgrade_generated_query_next_image_response_callback = callback;
}

void uic_mqtt_dotdot_ota_upgrade_image_block_request_callback_set(const uic_mqtt_dotdot_ota_upgrade_image_block_request_callback_t callback)
{
  uic_mqtt_dotdot_ota_upgrade_image_block_request_callback = callback;
}
void uic_mqtt_dotdot_ota_upgrade_generated_image_block_request_callback_set(const uic_mqtt_dotdot_ota_upgrade_image_block_request_callback_t callback)
{
  uic_mqtt_dotdot_ota_upgrade_generated_image_block_request_callback = callback;
}

void uic_mqtt_dotdot_ota_upgrade_image_page_request_callback_set(const uic_mqtt_dotdot_ota_upgrade_image_page_request_callback_t callback)
{
  uic_mqtt_dotdot_ota_upgrade_image_page_request_callback = callback;
}
void uic_mqtt_dotdot_ota_upgrade_generated_image_page_request_callback_set(const uic_mqtt_dotdot_ota_upgrade_image_page_request_callback_t callback)
{
  uic_mqtt_dotdot_ota_upgrade_generated_image_page_request_callback = callback;
}

void uic_mqtt_dotdot_ota_upgrade_image_block_response_callback_set(const uic_mqtt_dotdot_ota_upgrade_image_block_response_callback_t callback)
{
  uic_mqtt_dotdot_ota_upgrade_image_block_response_callback = callback;
}
void uic_mqtt_dotdot_ota_upgrade_generated_image_block_response_callback_set(const uic_mqtt_dotdot_ota_upgrade_image_block_response_callback_t callback)
{
  uic_mqtt_dotdot_ota_upgrade_generated_image_block_response_callback = callback;
}

void uic_mqtt_dotdot_ota_upgrade_upgrade_end_request_callback_set(const uic_mqtt_dotdot_ota_upgrade_upgrade_end_request_callback_t callback)
{
  uic_mqtt_dotdot_ota_upgrade_upgrade_end_request_callback = callback;
}
void uic_mqtt_dotdot_ota_upgrade_generated_upgrade_end_request_callback_set(const uic_mqtt_dotdot_ota_upgrade_upgrade_end_request_callback_t callback)
{
  uic_mqtt_dotdot_ota_upgrade_generated_upgrade_end_request_callback = callback;
}

void uic_mqtt_dotdot_ota_upgrade_upgrade_end_response_callback_set(const uic_mqtt_dotdot_ota_upgrade_upgrade_end_response_callback_t callback)
{
  uic_mqtt_dotdot_ota_upgrade_upgrade_end_response_callback = callback;
}
void uic_mqtt_dotdot_ota_upgrade_generated_upgrade_end_response_callback_set(const uic_mqtt_dotdot_ota_upgrade_upgrade_end_response_callback_t callback)
{
  uic_mqtt_dotdot_ota_upgrade_generated_upgrade_end_response_callback = callback;
}

void uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_request_callback_set(const uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_request_callback_t callback)
{
  uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_request_callback = callback;
}
void uic_mqtt_dotdot_ota_upgrade_generated_query_device_specific_file_request_callback_set(const uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_request_callback_t callback)
{
  uic_mqtt_dotdot_ota_upgrade_generated_query_device_specific_file_request_callback = callback;
}

void uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_response_callback_set(const uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_response_callback_t callback)
{
  uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_response_callback = callback;
}
void uic_mqtt_dotdot_ota_upgrade_generated_query_device_specific_file_response_callback_set(const uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_response_callback_t callback)
{
  uic_mqtt_dotdot_ota_upgrade_generated_query_device_specific_file_response_callback = callback;
}


void uic_mqtt_dotdot_set_ota_upgrade_write_attributes_callback(
  const uic_mqtt_dotdot_ota_upgrade_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_ota_upgrade_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_ota_upgrade_force_read_attributes_callback(
  const uic_mqtt_dotdot_ota_upgrade_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_ota_upgrade_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/OTAUpgrade/Commands/ImageNotify
void uic_mqtt_dotdot_on_ota_upgrade_image_notify(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ota_upgrade_image_notify_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  ImageNotifyPayloadType payload_type = {};
  uint8_t query_jitter = {};
  uint16_t manufacturer_code = {};
  uint16_t image_type = {};
  uint32_t new_file_version = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ota_upgrade_image_notify(
      jsn,
      payload_type,

      query_jitter,

      manufacturer_code,

      image_type,

      new_file_version
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "ImageNotify");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImageNotify", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImageNotify", "");
    return;
  }

  uic_mqtt_dotdot_ota_upgrade_image_notify_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    payload_type,

    query_jitter,

    manufacturer_code,

    image_type,

    new_file_version

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/OTAUpgrade/GeneratedCommands/ImageNotify
static void uic_mqtt_dotdot_on_generated_ota_upgrade_image_notify(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ota_upgrade_generated_image_notify_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  ImageNotifyPayloadType payload_type;
  uint8_t query_jitter;
  uint16_t manufacturer_code;
  uint16_t image_type;
  uint32_t new_file_version;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ota_upgrade_image_notify(
      jsn,
      payload_type,

      query_jitter,

      manufacturer_code,

      image_type,

      new_file_version
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "ImageNotify");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImageNotify", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImageNotify", "");
    return;
  }

  uic_mqtt_dotdot_ota_upgrade_generated_image_notify_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    payload_type,

    query_jitter,

    manufacturer_code,

    image_type,

    new_file_version

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/OTAUpgrade/Commands/QueryNextImageRequest
void uic_mqtt_dotdot_on_ota_upgrade_query_next_image_request(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ota_upgrade_query_next_image_request_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t field_control = {};
  uint16_t manufacturer_code = {};
  OTAImageType image_type = {};
  uint32_t current_file_version = {};
  uint16_t hardware_version = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ota_upgrade_query_next_image_request(
      jsn,
      field_control,

      manufacturer_code,

      image_type,

      current_file_version,

      hardware_version
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "QueryNextImageRequest");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryNextImageRequest", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryNextImageRequest", "");
    return;
  }

  uic_mqtt_dotdot_ota_upgrade_query_next_image_request_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    field_control,

    manufacturer_code,

    image_type,

    current_file_version,

    hardware_version

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/OTAUpgrade/GeneratedCommands/QueryNextImageRequest
static void uic_mqtt_dotdot_on_generated_ota_upgrade_query_next_image_request(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ota_upgrade_generated_query_next_image_request_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t field_control;
  uint16_t manufacturer_code;
  OTAImageType image_type;
  uint32_t current_file_version;
  uint16_t hardware_version;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ota_upgrade_query_next_image_request(
      jsn,
      field_control,

      manufacturer_code,

      image_type,

      current_file_version,

      hardware_version
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "QueryNextImageRequest");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryNextImageRequest", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryNextImageRequest", "");
    return;
  }

  uic_mqtt_dotdot_ota_upgrade_generated_query_next_image_request_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    field_control,

    manufacturer_code,

    image_type,

    current_file_version,

    hardware_version

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/OTAUpgrade/Commands/QueryNextImageResponse
void uic_mqtt_dotdot_on_ota_upgrade_query_next_image_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ota_upgrade_query_next_image_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  uint16_t manufacturer_code = {};
  OTAImageType image_type = {};
  uint32_t file_version = {};
  uint32_t image_size = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ota_upgrade_query_next_image_response(
      jsn,
      status,

      manufacturer_code,

      image_type,

      file_version,

      image_size
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "QueryNextImageResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryNextImageResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryNextImageResponse", "");
    return;
  }

  uic_mqtt_dotdot_ota_upgrade_query_next_image_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    manufacturer_code,

    image_type,

    file_version,

    image_size

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/OTAUpgrade/GeneratedCommands/QueryNextImageResponse
static void uic_mqtt_dotdot_on_generated_ota_upgrade_query_next_image_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ota_upgrade_generated_query_next_image_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status;
  uint16_t manufacturer_code;
  OTAImageType image_type;
  uint32_t file_version;
  uint32_t image_size;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ota_upgrade_query_next_image_response(
      jsn,
      status,

      manufacturer_code,

      image_type,

      file_version,

      image_size
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "QueryNextImageResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryNextImageResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryNextImageResponse", "");
    return;
  }

  uic_mqtt_dotdot_ota_upgrade_generated_query_next_image_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    manufacturer_code,

    image_type,

    file_version,

    image_size

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/OTAUpgrade/Commands/ImageBlockRequest
void uic_mqtt_dotdot_on_ota_upgrade_image_block_request(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ota_upgrade_image_block_request_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t field_control = {};
  uint16_t manufacturer_code = {};
  OTAImageType image_type = {};
  uint32_t file_version = {};
  uint32_t file_offset = {};
  uint8_t maximum_data_size = {};
  EUI64 request_node_address = {};
  uint16_t minimum_block_period = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ota_upgrade_image_block_request(
      jsn,
      field_control,

      manufacturer_code,

      image_type,

      file_version,

      file_offset,

      maximum_data_size,

      request_node_address,

      minimum_block_period
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "ImageBlockRequest");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImageBlockRequest", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImageBlockRequest", "");
    return;
  }

  uic_mqtt_dotdot_ota_upgrade_image_block_request_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    field_control,

    manufacturer_code,

    image_type,

    file_version,

    file_offset,

    maximum_data_size,

    request_node_address,

    minimum_block_period

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/OTAUpgrade/GeneratedCommands/ImageBlockRequest
static void uic_mqtt_dotdot_on_generated_ota_upgrade_image_block_request(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ota_upgrade_generated_image_block_request_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t field_control;
  uint16_t manufacturer_code;
  OTAImageType image_type;
  uint32_t file_version;
  uint32_t file_offset;
  uint8_t maximum_data_size;
  EUI64 request_node_address;
  uint16_t minimum_block_period;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ota_upgrade_image_block_request(
      jsn,
      field_control,

      manufacturer_code,

      image_type,

      file_version,

      file_offset,

      maximum_data_size,

      request_node_address,

      minimum_block_period
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "ImageBlockRequest");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImageBlockRequest", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImageBlockRequest", "");
    return;
  }

  uic_mqtt_dotdot_ota_upgrade_generated_image_block_request_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    field_control,

    manufacturer_code,

    image_type,

    file_version,

    file_offset,

    maximum_data_size,

    request_node_address,

    minimum_block_period

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/OTAUpgrade/Commands/ImagePageRequest
void uic_mqtt_dotdot_on_ota_upgrade_image_page_request(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ota_upgrade_image_page_request_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t field_control = {};
  uint16_t manufacturer_code = {};
  OTAImageType image_type = {};
  uint32_t file_version = {};
  uint32_t file_offset = {};
  uint8_t maximum_data_size = {};
  uint16_t page_size = {};
  uint16_t response_spacing = {};
  EUI64 request_node_address = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ota_upgrade_image_page_request(
      jsn,
      field_control,

      manufacturer_code,

      image_type,

      file_version,

      file_offset,

      maximum_data_size,

      page_size,

      response_spacing,

      request_node_address
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "ImagePageRequest");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImagePageRequest", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImagePageRequest", "");
    return;
  }

  uic_mqtt_dotdot_ota_upgrade_image_page_request_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    field_control,

    manufacturer_code,

    image_type,

    file_version,

    file_offset,

    maximum_data_size,

    page_size,

    response_spacing,

    request_node_address

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/OTAUpgrade/GeneratedCommands/ImagePageRequest
static void uic_mqtt_dotdot_on_generated_ota_upgrade_image_page_request(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ota_upgrade_generated_image_page_request_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t field_control;
  uint16_t manufacturer_code;
  OTAImageType image_type;
  uint32_t file_version;
  uint32_t file_offset;
  uint8_t maximum_data_size;
  uint16_t page_size;
  uint16_t response_spacing;
  EUI64 request_node_address;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ota_upgrade_image_page_request(
      jsn,
      field_control,

      manufacturer_code,

      image_type,

      file_version,

      file_offset,

      maximum_data_size,

      page_size,

      response_spacing,

      request_node_address
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "ImagePageRequest");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImagePageRequest", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImagePageRequest", "");
    return;
  }

  uic_mqtt_dotdot_ota_upgrade_generated_image_page_request_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    field_control,

    manufacturer_code,

    image_type,

    file_version,

    file_offset,

    maximum_data_size,

    page_size,

    response_spacing,

    request_node_address

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/OTAUpgrade/Commands/ImageBlockResponse
void uic_mqtt_dotdot_on_ota_upgrade_image_block_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ota_upgrade_image_block_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  uint16_t manufacturer_code = {};
  OTAImageType image_type = {};
  uint32_t file_version = {};
  uint32_t file_offset = {};
  const char* image_data = {};
  uint32_t current_time = {};
  uint32_t request_time = {};
  uint16_t minimum_block_period = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ota_upgrade_image_block_response(
      jsn,
      status,

      manufacturer_code,

      image_type,

      file_version,

      file_offset,

      image_data,

      current_time,

      request_time,

      minimum_block_period
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "ImageBlockResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImageBlockResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImageBlockResponse", "");
    return;
  }

  uic_mqtt_dotdot_ota_upgrade_image_block_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    manufacturer_code,

    image_type,

    file_version,

    file_offset,

    image_data,

    current_time,

    request_time,

    minimum_block_period

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/OTAUpgrade/GeneratedCommands/ImageBlockResponse
static void uic_mqtt_dotdot_on_generated_ota_upgrade_image_block_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ota_upgrade_generated_image_block_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status;
  uint16_t manufacturer_code;
  OTAImageType image_type;
  uint32_t file_version;
  uint32_t file_offset;
  const char* image_data;
  uint32_t current_time;
  uint32_t request_time;
  uint16_t minimum_block_period;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ota_upgrade_image_block_response(
      jsn,
      status,

      manufacturer_code,

      image_type,

      file_version,

      file_offset,

      image_data,

      current_time,

      request_time,

      minimum_block_period
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "ImageBlockResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImageBlockResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "ImageBlockResponse", "");
    return;
  }

  uic_mqtt_dotdot_ota_upgrade_generated_image_block_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    manufacturer_code,

    image_type,

    file_version,

    file_offset,

    image_data,

    current_time,

    request_time,

    minimum_block_period

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/OTAUpgrade/Commands/UpgradeEndRequest
void uic_mqtt_dotdot_on_ota_upgrade_upgrade_end_request(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ota_upgrade_upgrade_end_request_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  uint16_t manufacturer_code = {};
  OTAImageType image_type = {};
  uint32_t file_version = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ota_upgrade_upgrade_end_request(
      jsn,
      status,

      manufacturer_code,

      image_type,

      file_version
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "UpgradeEndRequest");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "UpgradeEndRequest", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "UpgradeEndRequest", "");
    return;
  }

  uic_mqtt_dotdot_ota_upgrade_upgrade_end_request_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    manufacturer_code,

    image_type,

    file_version

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/OTAUpgrade/GeneratedCommands/UpgradeEndRequest
static void uic_mqtt_dotdot_on_generated_ota_upgrade_upgrade_end_request(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ota_upgrade_generated_upgrade_end_request_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status;
  uint16_t manufacturer_code;
  OTAImageType image_type;
  uint32_t file_version;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ota_upgrade_upgrade_end_request(
      jsn,
      status,

      manufacturer_code,

      image_type,

      file_version
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "UpgradeEndRequest");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "UpgradeEndRequest", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "UpgradeEndRequest", "");
    return;
  }

  uic_mqtt_dotdot_ota_upgrade_generated_upgrade_end_request_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    manufacturer_code,

    image_type,

    file_version

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/OTAUpgrade/Commands/UpgradeEndResponse
void uic_mqtt_dotdot_on_ota_upgrade_upgrade_end_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ota_upgrade_upgrade_end_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t manufacturer_code = {};
  OTAImageType image_type = {};
  uint32_t file_version = {};
  UTC current_time = {};
  UTC upgrade_time = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ota_upgrade_upgrade_end_response(
      jsn,
      manufacturer_code,

      image_type,

      file_version,

      current_time,

      upgrade_time
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "UpgradeEndResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "UpgradeEndResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "UpgradeEndResponse", "");
    return;
  }

  uic_mqtt_dotdot_ota_upgrade_upgrade_end_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    manufacturer_code,

    image_type,

    file_version,

    current_time,

    upgrade_time

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/OTAUpgrade/GeneratedCommands/UpgradeEndResponse
static void uic_mqtt_dotdot_on_generated_ota_upgrade_upgrade_end_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ota_upgrade_generated_upgrade_end_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t manufacturer_code;
  OTAImageType image_type;
  uint32_t file_version;
  UTC current_time;
  UTC upgrade_time;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ota_upgrade_upgrade_end_response(
      jsn,
      manufacturer_code,

      image_type,

      file_version,

      current_time,

      upgrade_time
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "UpgradeEndResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "UpgradeEndResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "UpgradeEndResponse", "");
    return;
  }

  uic_mqtt_dotdot_ota_upgrade_generated_upgrade_end_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    manufacturer_code,

    image_type,

    file_version,

    current_time,

    upgrade_time

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/OTAUpgrade/Commands/QueryDeviceSpecificFileRequest
void uic_mqtt_dotdot_on_ota_upgrade_query_device_specific_file_request(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_request_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  EUI64 request_node_address = {};
  uint16_t manufacturer_code = {};
  OTADeviceSpecificImageType image_type = {};
  uint32_t file_version = {};
  uint16_t current_zigbee_stack_version = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ota_upgrade_query_device_specific_file_request(
      jsn,
      request_node_address,

      manufacturer_code,

      image_type,

      file_version,

      current_zigbee_stack_version
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "QueryDeviceSpecificFileRequest");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryDeviceSpecificFileRequest", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryDeviceSpecificFileRequest", "");
    return;
  }

  uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_request_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    request_node_address,

    manufacturer_code,

    image_type,

    file_version,

    current_zigbee_stack_version

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/OTAUpgrade/GeneratedCommands/QueryDeviceSpecificFileRequest
static void uic_mqtt_dotdot_on_generated_ota_upgrade_query_device_specific_file_request(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ota_upgrade_generated_query_device_specific_file_request_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  EUI64 request_node_address;
  uint16_t manufacturer_code;
  OTADeviceSpecificImageType image_type;
  uint32_t file_version;
  uint16_t current_zigbee_stack_version;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ota_upgrade_query_device_specific_file_request(
      jsn,
      request_node_address,

      manufacturer_code,

      image_type,

      file_version,

      current_zigbee_stack_version
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "QueryDeviceSpecificFileRequest");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryDeviceSpecificFileRequest", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryDeviceSpecificFileRequest", "");
    return;
  }

  uic_mqtt_dotdot_ota_upgrade_generated_query_device_specific_file_request_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    request_node_address,

    manufacturer_code,

    image_type,

    file_version,

    current_zigbee_stack_version

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/OTAUpgrade/Commands/QueryDeviceSpecificFileResponse
void uic_mqtt_dotdot_on_ota_upgrade_query_device_specific_file_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  uint16_t manufacturer_code = {};
  OTADeviceSpecificImageType image_type = {};
  uint32_t file_version = {};
  uint32_t image_size = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ota_upgrade_query_device_specific_file_response(
      jsn,
      status,

      manufacturer_code,

      image_type,

      file_version,

      image_size
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "QueryDeviceSpecificFileResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryDeviceSpecificFileResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryDeviceSpecificFileResponse", "");
    return;
  }

  uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    manufacturer_code,

    image_type,

    file_version,

    image_size

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/OTAUpgrade/GeneratedCommands/QueryDeviceSpecificFileResponse
static void uic_mqtt_dotdot_on_generated_ota_upgrade_query_device_specific_file_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ota_upgrade_generated_query_device_specific_file_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status;
  uint16_t manufacturer_code;
  OTADeviceSpecificImageType image_type;
  uint32_t file_version;
  uint32_t image_size;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ota_upgrade_query_device_specific_file_response(
      jsn,
      status,

      manufacturer_code,

      image_type,

      file_version,

      image_size
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "QueryDeviceSpecificFileResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryDeviceSpecificFileResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "QueryDeviceSpecificFileResponse", "");
    return;
  }

  uic_mqtt_dotdot_ota_upgrade_generated_query_device_specific_file_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status,

    manufacturer_code,

    image_type,

    file_version,

    image_size

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/OTAUpgrade/Commands/WriteAttributes
void uic_mqtt_dotdot_on_ota_upgrade_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_ota_upgrade_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_ota_upgrade_state_t new_state = {};
  uic_mqtt_dotdot_ota_upgrade_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_ota_upgrade_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OTAUpgrade", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_ota_upgrade_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_ota_upgrade_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_ota_upgrade_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_ota_upgrade_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.upgrade_serverid = true;
        force_update.file_offset = true;
        force_update.current_file_version = true;
        force_update.current_zig_bee_stack_version = true;
        force_update.downloaded_file_version = true;
        force_update.downloaded_zig_bee_stack_version = true;
        force_update.image_upgrade_status = true;
        force_update.manufacturerid = true;
        force_update.image_typeid = true;
        force_update.minimum_block_period = true;
        force_update.image_stamp = true;
        force_update.upgrade_activation_policy = true;
        force_update.upgrade_timeout_policy = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"UpgradeServerID", &force_update.upgrade_serverid },
          {"FileOffset", &force_update.file_offset },
          {"CurrentFileVersion", &force_update.current_file_version },
          {"CurrentZigBeeStackVersion", &force_update.current_zig_bee_stack_version },
          {"DownloadedFileVersion", &force_update.downloaded_file_version },
          {"DownloadedZigBeeStackVersion", &force_update.downloaded_zig_bee_stack_version },
          {"ImageUpgradeStatus", &force_update.image_upgrade_status },
          {"ManufacturerID", &force_update.manufacturerid },
          {"ImageTypeID", &force_update.image_typeid },
          {"MinimumBlockPeriod", &force_update.minimum_block_period },
          {"ImageStamp", &force_update.image_stamp },
          {"UpgradeActivationPolicy", &force_update.upgrade_activation_policy },
          {"UpgradeTimeoutPolicy", &force_update.upgrade_timeout_policy },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_ota_upgrade_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "OTAUpgrade/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_ota_upgrade_upgrade_serverid_publish(
  const char *base_topic,
  EUI64 value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade/Attributes/UpgradeServerID", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OTAUpgrade/Attributes/UpgradeServerID";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ota_upgrade_file_offset_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade/Attributes/FileOffset", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OTAUpgrade/Attributes/FileOffset";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ota_upgrade_current_file_version_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade/Attributes/CurrentFileVersion", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OTAUpgrade/Attributes/CurrentFileVersion";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ota_upgrade_current_zig_bee_stack_version_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade/Attributes/CurrentZigBeeStackVersion", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OTAUpgrade/Attributes/CurrentZigBeeStackVersion";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ota_upgrade_downloaded_file_version_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade/Attributes/DownloadedFileVersion", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OTAUpgrade/Attributes/DownloadedFileVersion";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ota_upgrade_downloaded_zig_bee_stack_version_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade/Attributes/DownloadedZigBeeStackVersion", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OTAUpgrade/Attributes/DownloadedZigBeeStackVersion";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ota_upgrade_image_upgrade_status_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef OTA_UPGRADE_IMAGE_UPGRADE_STATUS_ENUM_NAME_AVAILABLE
  jsn["value"] = ota_upgrade_image_upgrade_status_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<OTAUpgradeImageUpgradeStatus>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade/Attributes/ImageUpgradeStatus", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OTAUpgrade/Attributes/ImageUpgradeStatus";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ota_upgrade_manufacturerid_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade/Attributes/ManufacturerID", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OTAUpgrade/Attributes/ManufacturerID";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ota_upgrade_image_typeid_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade/Attributes/ImageTypeID", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OTAUpgrade/Attributes/ImageTypeID";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ota_upgrade_minimum_block_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade/Attributes/MinimumBlockPeriod", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OTAUpgrade/Attributes/MinimumBlockPeriod";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ota_upgrade_image_stamp_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade/Attributes/ImageStamp", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OTAUpgrade/Attributes/ImageStamp";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ota_upgrade_upgrade_activation_policy_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef OTA_UPGRADE_UPGRADE_ACTIVATION_POLICY_ENUM_NAME_AVAILABLE
  jsn["value"] = ota_upgrade_upgrade_activation_policy_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<OTAUpgradeUpgradeActivationPolicy>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade/Attributes/UpgradeActivationPolicy", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OTAUpgrade/Attributes/UpgradeActivationPolicy";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ota_upgrade_upgrade_timeout_policy_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef OTA_UPGRADE_UPGRADE_TIMEOUT_POLICY_ENUM_NAME_AVAILABLE
  jsn["value"] = ota_upgrade_upgrade_timeout_policy_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<OTAUpgradeUpgradeTimeoutPolicy>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OTAUpgrade/Attributes/UpgradeTimeoutPolicy", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OTAUpgrade/Attributes/UpgradeTimeoutPolicy";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ota_upgrade_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_ota_upgrade_write_attributes_callback) {
    subscription_topic = base_topic + "OTAUpgrade/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ota_upgrade_WriteAttributes);
  }

  if(uic_mqtt_dotdot_ota_upgrade_force_read_attributes_callback) {
    subscription_topic = base_topic + "OTAUpgrade/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ota_upgrade_force_read_attributes);
  }
  if (uic_mqtt_dotdot_ota_upgrade_image_notify_callback) {
    subscription_topic = base_topic + "OTAUpgrade/Commands/ImageNotify";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ota_upgrade_image_notify);
  }
  if (uic_mqtt_dotdot_ota_upgrade_generated_image_notify_callback) {
    subscription_topic = base_topic + "OTAUpgrade/GeneratedCommands/ImageNotify";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_ota_upgrade_image_notify);
  }
  if (uic_mqtt_dotdot_ota_upgrade_query_next_image_request_callback) {
    subscription_topic = base_topic + "OTAUpgrade/Commands/QueryNextImageRequest";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ota_upgrade_query_next_image_request);
  }
  if (uic_mqtt_dotdot_ota_upgrade_generated_query_next_image_request_callback) {
    subscription_topic = base_topic + "OTAUpgrade/GeneratedCommands/QueryNextImageRequest";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_ota_upgrade_query_next_image_request);
  }
  if (uic_mqtt_dotdot_ota_upgrade_query_next_image_response_callback) {
    subscription_topic = base_topic + "OTAUpgrade/Commands/QueryNextImageResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ota_upgrade_query_next_image_response);
  }
  if (uic_mqtt_dotdot_ota_upgrade_generated_query_next_image_response_callback) {
    subscription_topic = base_topic + "OTAUpgrade/GeneratedCommands/QueryNextImageResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_ota_upgrade_query_next_image_response);
  }
  if (uic_mqtt_dotdot_ota_upgrade_image_block_request_callback) {
    subscription_topic = base_topic + "OTAUpgrade/Commands/ImageBlockRequest";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ota_upgrade_image_block_request);
  }
  if (uic_mqtt_dotdot_ota_upgrade_generated_image_block_request_callback) {
    subscription_topic = base_topic + "OTAUpgrade/GeneratedCommands/ImageBlockRequest";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_ota_upgrade_image_block_request);
  }
  if (uic_mqtt_dotdot_ota_upgrade_image_page_request_callback) {
    subscription_topic = base_topic + "OTAUpgrade/Commands/ImagePageRequest";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ota_upgrade_image_page_request);
  }
  if (uic_mqtt_dotdot_ota_upgrade_generated_image_page_request_callback) {
    subscription_topic = base_topic + "OTAUpgrade/GeneratedCommands/ImagePageRequest";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_ota_upgrade_image_page_request);
  }
  if (uic_mqtt_dotdot_ota_upgrade_image_block_response_callback) {
    subscription_topic = base_topic + "OTAUpgrade/Commands/ImageBlockResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ota_upgrade_image_block_response);
  }
  if (uic_mqtt_dotdot_ota_upgrade_generated_image_block_response_callback) {
    subscription_topic = base_topic + "OTAUpgrade/GeneratedCommands/ImageBlockResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_ota_upgrade_image_block_response);
  }
  if (uic_mqtt_dotdot_ota_upgrade_upgrade_end_request_callback) {
    subscription_topic = base_topic + "OTAUpgrade/Commands/UpgradeEndRequest";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ota_upgrade_upgrade_end_request);
  }
  if (uic_mqtt_dotdot_ota_upgrade_generated_upgrade_end_request_callback) {
    subscription_topic = base_topic + "OTAUpgrade/GeneratedCommands/UpgradeEndRequest";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_ota_upgrade_upgrade_end_request);
  }
  if (uic_mqtt_dotdot_ota_upgrade_upgrade_end_response_callback) {
    subscription_topic = base_topic + "OTAUpgrade/Commands/UpgradeEndResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ota_upgrade_upgrade_end_response);
  }
  if (uic_mqtt_dotdot_ota_upgrade_generated_upgrade_end_response_callback) {
    subscription_topic = base_topic + "OTAUpgrade/GeneratedCommands/UpgradeEndResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_ota_upgrade_upgrade_end_response);
  }
  if (uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_request_callback) {
    subscription_topic = base_topic + "OTAUpgrade/Commands/QueryDeviceSpecificFileRequest";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ota_upgrade_query_device_specific_file_request);
  }
  if (uic_mqtt_dotdot_ota_upgrade_generated_query_device_specific_file_request_callback) {
    subscription_topic = base_topic + "OTAUpgrade/GeneratedCommands/QueryDeviceSpecificFileRequest";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_ota_upgrade_query_device_specific_file_request);
  }
  if (uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_response_callback) {
    subscription_topic = base_topic + "OTAUpgrade/Commands/QueryDeviceSpecificFileResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ota_upgrade_query_device_specific_file_response);
  }
  if (uic_mqtt_dotdot_ota_upgrade_generated_query_device_specific_file_response_callback) {
    subscription_topic = base_topic + "OTAUpgrade/GeneratedCommands/QueryDeviceSpecificFileResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_ota_upgrade_query_device_specific_file_response);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_ota_upgrade_attributes_init();

  uic_mqtt_dotdot_by_group_ota_upgrade_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_poll_control_check_in_callback_t uic_mqtt_dotdot_poll_control_check_in_callback = nullptr;
static uic_mqtt_dotdot_poll_control_check_in_callback_t uic_mqtt_dotdot_poll_control_generated_check_in_callback = nullptr;
uic_mqtt_dotdot_poll_control_check_in_response_callback_t uic_mqtt_dotdot_poll_control_check_in_response_callback = nullptr;
static uic_mqtt_dotdot_poll_control_check_in_response_callback_t uic_mqtt_dotdot_poll_control_generated_check_in_response_callback = nullptr;
uic_mqtt_dotdot_poll_control_fast_poll_stop_callback_t uic_mqtt_dotdot_poll_control_fast_poll_stop_callback = nullptr;
static uic_mqtt_dotdot_poll_control_fast_poll_stop_callback_t uic_mqtt_dotdot_poll_control_generated_fast_poll_stop_callback = nullptr;
uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback_t uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback = nullptr;
static uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback_t uic_mqtt_dotdot_poll_control_generated_set_long_poll_interval_callback = nullptr;
uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback_t uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback = nullptr;
static uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback_t uic_mqtt_dotdot_poll_control_generated_set_short_poll_interval_callback = nullptr;
uic_mqtt_dotdot_poll_control_write_attributes_callback_t uic_mqtt_dotdot_poll_control_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_poll_control_force_read_attributes_callback_t uic_mqtt_dotdot_poll_control_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_poll_control_check_in_callback_set(const uic_mqtt_dotdot_poll_control_check_in_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_check_in_callback = callback;
}
void uic_mqtt_dotdot_poll_control_generated_check_in_callback_set(const uic_mqtt_dotdot_poll_control_check_in_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_generated_check_in_callback = callback;
}

void uic_mqtt_dotdot_poll_control_check_in_response_callback_set(const uic_mqtt_dotdot_poll_control_check_in_response_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_check_in_response_callback = callback;
}
void uic_mqtt_dotdot_poll_control_generated_check_in_response_callback_set(const uic_mqtt_dotdot_poll_control_check_in_response_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_generated_check_in_response_callback = callback;
}

void uic_mqtt_dotdot_poll_control_fast_poll_stop_callback_set(const uic_mqtt_dotdot_poll_control_fast_poll_stop_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_fast_poll_stop_callback = callback;
}
void uic_mqtt_dotdot_poll_control_generated_fast_poll_stop_callback_set(const uic_mqtt_dotdot_poll_control_fast_poll_stop_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_generated_fast_poll_stop_callback = callback;
}

void uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback_set(const uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback = callback;
}
void uic_mqtt_dotdot_poll_control_generated_set_long_poll_interval_callback_set(const uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_generated_set_long_poll_interval_callback = callback;
}

void uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback_set(const uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback = callback;
}
void uic_mqtt_dotdot_poll_control_generated_set_short_poll_interval_callback_set(const uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_generated_set_short_poll_interval_callback = callback;
}


void uic_mqtt_dotdot_set_poll_control_write_attributes_callback(
  const uic_mqtt_dotdot_poll_control_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_poll_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_poll_control_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/PollControl/Commands/CheckIn
void uic_mqtt_dotdot_on_poll_control_check_in(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_poll_control_check_in_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "CheckIn");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "CheckIn", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "CheckIn", "");
    return;
  }

  uic_mqtt_dotdot_poll_control_check_in_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/PollControl/GeneratedCommands/CheckIn
static void uic_mqtt_dotdot_on_generated_poll_control_check_in(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_poll_control_generated_check_in_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "CheckIn");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "CheckIn", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "CheckIn", "");
    return;
  }

  uic_mqtt_dotdot_poll_control_generated_check_in_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/PollControl/Commands/CheckInResponse
void uic_mqtt_dotdot_on_poll_control_check_in_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_poll_control_check_in_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  bool start_fast_polling = {};
  uint16_t fast_poll_timeout = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_poll_control_check_in_response(
      jsn,
      start_fast_polling,

      fast_poll_timeout
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "CheckInResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "CheckInResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "CheckInResponse", "");
    return;
  }

  uic_mqtt_dotdot_poll_control_check_in_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    start_fast_polling,

    fast_poll_timeout

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/PollControl/GeneratedCommands/CheckInResponse
static void uic_mqtt_dotdot_on_generated_poll_control_check_in_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_poll_control_generated_check_in_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  bool start_fast_polling;
  uint16_t fast_poll_timeout;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_poll_control_check_in_response(
      jsn,
      start_fast_polling,

      fast_poll_timeout
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "CheckInResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "CheckInResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "CheckInResponse", "");
    return;
  }

  uic_mqtt_dotdot_poll_control_generated_check_in_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    start_fast_polling,

    fast_poll_timeout

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/PollControl/Commands/FastPollStop
void uic_mqtt_dotdot_on_poll_control_fast_poll_stop(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_poll_control_fast_poll_stop_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "FastPollStop");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "FastPollStop", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "FastPollStop", "");
    return;
  }

  uic_mqtt_dotdot_poll_control_fast_poll_stop_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/PollControl/GeneratedCommands/FastPollStop
static void uic_mqtt_dotdot_on_generated_poll_control_fast_poll_stop(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_poll_control_generated_fast_poll_stop_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "FastPollStop");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "FastPollStop", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "FastPollStop", "");
    return;
  }

  uic_mqtt_dotdot_poll_control_generated_fast_poll_stop_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/PollControl/Commands/SetLongPollInterval
void uic_mqtt_dotdot_on_poll_control_set_long_poll_interval(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint32_t new_long_poll_interval = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_poll_control_set_long_poll_interval(
      jsn,
      new_long_poll_interval
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "SetLongPollInterval");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "SetLongPollInterval", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "SetLongPollInterval", "");
    return;
  }

  uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_long_poll_interval

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/PollControl/GeneratedCommands/SetLongPollInterval
static void uic_mqtt_dotdot_on_generated_poll_control_set_long_poll_interval(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_poll_control_generated_set_long_poll_interval_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint32_t new_long_poll_interval;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_poll_control_set_long_poll_interval(
      jsn,
      new_long_poll_interval
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "SetLongPollInterval");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "SetLongPollInterval", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "SetLongPollInterval", "");
    return;
  }

  uic_mqtt_dotdot_poll_control_generated_set_long_poll_interval_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_long_poll_interval

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/PollControl/Commands/SetShortPollInterval
void uic_mqtt_dotdot_on_poll_control_set_short_poll_interval(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t new_short_poll_interval = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_poll_control_set_short_poll_interval(
      jsn,
      new_short_poll_interval
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "SetShortPollInterval");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "SetShortPollInterval", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "SetShortPollInterval", "");
    return;
  }

  uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_short_poll_interval

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/PollControl/GeneratedCommands/SetShortPollInterval
static void uic_mqtt_dotdot_on_generated_poll_control_set_short_poll_interval(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_poll_control_generated_set_short_poll_interval_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t new_short_poll_interval;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_poll_control_set_short_poll_interval(
      jsn,
      new_short_poll_interval
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "SetShortPollInterval");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "SetShortPollInterval", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "SetShortPollInterval", "");
    return;
  }

  uic_mqtt_dotdot_poll_control_generated_set_short_poll_interval_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_short_poll_interval

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/PollControl/Commands/WriteAttributes
void uic_mqtt_dotdot_on_poll_control_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_poll_control_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_poll_control_state_t new_state = {};
  uic_mqtt_dotdot_poll_control_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_poll_control_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_poll_control_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_poll_control_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_poll_control_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_poll_control_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.check_in_interval = true;
        force_update.long_poll_interval = true;
        force_update.short_poll_interval = true;
        force_update.fast_poll_timeout = true;
        force_update.check_in_interval_min = true;
        force_update.long_poll_interval_min = true;
        force_update.fast_poll_timeout_max = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"CheckInInterval", &force_update.check_in_interval },
          {"LongPollInterval", &force_update.long_poll_interval },
          {"ShortPollInterval", &force_update.short_poll_interval },
          {"FastPollTimeout", &force_update.fast_poll_timeout },
          {"CheckInIntervalMin", &force_update.check_in_interval_min },
          {"LongPollIntervalMin", &force_update.long_poll_interval_min },
          {"FastPollTimeoutMax", &force_update.fast_poll_timeout_max },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_poll_control_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "PollControl/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_poll_control_check_in_interval_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl/Attributes/CheckInInterval", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PollControl/Attributes/CheckInInterval";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_poll_control_long_poll_interval_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl/Attributes/LongPollInterval", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PollControl/Attributes/LongPollInterval";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_poll_control_short_poll_interval_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl/Attributes/ShortPollInterval", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PollControl/Attributes/ShortPollInterval";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_poll_control_fast_poll_timeout_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl/Attributes/FastPollTimeout", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PollControl/Attributes/FastPollTimeout";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_poll_control_check_in_interval_min_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl/Attributes/CheckInIntervalMin", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PollControl/Attributes/CheckInIntervalMin";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_poll_control_long_poll_interval_min_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl/Attributes/LongPollIntervalMin", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PollControl/Attributes/LongPollIntervalMin";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_poll_control_fast_poll_timeout_max_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl/Attributes/FastPollTimeoutMax", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PollControl/Attributes/FastPollTimeoutMax";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_poll_control_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_poll_control_write_attributes_callback) {
    subscription_topic = base_topic + "PollControl/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_poll_control_WriteAttributes);
  }

  if(uic_mqtt_dotdot_poll_control_force_read_attributes_callback) {
    subscription_topic = base_topic + "PollControl/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_poll_control_force_read_attributes);
  }
  if (uic_mqtt_dotdot_poll_control_check_in_callback) {
    subscription_topic = base_topic + "PollControl/Commands/CheckIn";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_poll_control_check_in);
  }
  if (uic_mqtt_dotdot_poll_control_generated_check_in_callback) {
    subscription_topic = base_topic + "PollControl/GeneratedCommands/CheckIn";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_poll_control_check_in);
  }
  if (uic_mqtt_dotdot_poll_control_check_in_response_callback) {
    subscription_topic = base_topic + "PollControl/Commands/CheckInResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_poll_control_check_in_response);
  }
  if (uic_mqtt_dotdot_poll_control_generated_check_in_response_callback) {
    subscription_topic = base_topic + "PollControl/GeneratedCommands/CheckInResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_poll_control_check_in_response);
  }
  if (uic_mqtt_dotdot_poll_control_fast_poll_stop_callback) {
    subscription_topic = base_topic + "PollControl/Commands/FastPollStop";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_poll_control_fast_poll_stop);
  }
  if (uic_mqtt_dotdot_poll_control_generated_fast_poll_stop_callback) {
    subscription_topic = base_topic + "PollControl/GeneratedCommands/FastPollStop";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_poll_control_fast_poll_stop);
  }
  if (uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback) {
    subscription_topic = base_topic + "PollControl/Commands/SetLongPollInterval";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_poll_control_set_long_poll_interval);
  }
  if (uic_mqtt_dotdot_poll_control_generated_set_long_poll_interval_callback) {
    subscription_topic = base_topic + "PollControl/GeneratedCommands/SetLongPollInterval";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_poll_control_set_long_poll_interval);
  }
  if (uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback) {
    subscription_topic = base_topic + "PollControl/Commands/SetShortPollInterval";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_poll_control_set_short_poll_interval);
  }
  if (uic_mqtt_dotdot_poll_control_generated_set_short_poll_interval_callback) {
    subscription_topic = base_topic + "PollControl/GeneratedCommands/SetShortPollInterval";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_poll_control_set_short_poll_interval);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_poll_control_attributes_init();

  uic_mqtt_dotdot_by_group_poll_control_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_shade_configuration_write_attributes_callback_t uic_mqtt_dotdot_shade_configuration_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_shade_configuration_force_read_attributes_callback_t uic_mqtt_dotdot_shade_configuration_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_shade_configuration_write_attributes_callback(
  const uic_mqtt_dotdot_shade_configuration_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_shade_configuration_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_shade_configuration_force_read_attributes_callback(
  const uic_mqtt_dotdot_shade_configuration_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_shade_configuration_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/ShadeConfiguration/Commands/WriteAttributes
void uic_mqtt_dotdot_on_shade_configuration_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_shade_configuration_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_shade_configuration_state_t new_state = {};
  uic_mqtt_dotdot_shade_configuration_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_shade_configuration_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ShadeConfiguration", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ShadeConfiguration", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ShadeConfiguration", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_shade_configuration_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_shade_configuration_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_shade_configuration_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_shade_configuration_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.physical_closed_limit = true;
        force_update.motor_step_size = true;
        force_update.status = true;
        force_update.closed_limit = true;
        force_update.mode = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"PhysicalClosedLimit", &force_update.physical_closed_limit },
          {"MotorStepSize", &force_update.motor_step_size },
          {"Status", &force_update.status },
          {"ClosedLimit", &force_update.closed_limit },
          {"Mode", &force_update.mode },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_shade_configuration_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "ShadeConfiguration/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_shade_configuration_physical_closed_limit_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ShadeConfiguration/Attributes/PhysicalClosedLimit", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ShadeConfiguration/Attributes/PhysicalClosedLimit";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_shade_configuration_motor_step_size_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ShadeConfiguration/Attributes/MotorStepSize", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ShadeConfiguration/Attributes/MotorStepSize";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_shade_configuration_status_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ShadeConfigurationStatus.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ShadeConfiguration/Attributes/Status", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/ShadeConfiguration/Attributes/Status";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_shade_configuration_closed_limit_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ShadeConfiguration/Attributes/ClosedLimit", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ShadeConfiguration/Attributes/ClosedLimit";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_shade_configuration_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef SHADE_CONFIGURATION_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = shade_configuration_mode_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<ShadeConfigurationMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ShadeConfiguration/Attributes/Mode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ShadeConfiguration/Attributes/Mode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_shade_configuration_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_shade_configuration_write_attributes_callback) {
    subscription_topic = base_topic + "ShadeConfiguration/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_shade_configuration_WriteAttributes);
  }

  if(uic_mqtt_dotdot_shade_configuration_force_read_attributes_callback) {
    subscription_topic = base_topic + "ShadeConfiguration/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_shade_configuration_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_shade_configuration_attributes_init();

  uic_mqtt_dotdot_by_group_shade_configuration_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_door_lock_lock_door_callback_t uic_mqtt_dotdot_door_lock_lock_door_callback = nullptr;
static uic_mqtt_dotdot_door_lock_lock_door_callback_t uic_mqtt_dotdot_door_lock_generated_lock_door_callback = nullptr;
uic_mqtt_dotdot_door_lock_lock_door_response_callback_t uic_mqtt_dotdot_door_lock_lock_door_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_lock_door_response_callback_t uic_mqtt_dotdot_door_lock_generated_lock_door_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_unlock_door_callback_t uic_mqtt_dotdot_door_lock_unlock_door_callback = nullptr;
static uic_mqtt_dotdot_door_lock_unlock_door_callback_t uic_mqtt_dotdot_door_lock_generated_unlock_door_callback = nullptr;
uic_mqtt_dotdot_door_lock_unlock_door_response_callback_t uic_mqtt_dotdot_door_lock_unlock_door_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_unlock_door_response_callback_t uic_mqtt_dotdot_door_lock_generated_unlock_door_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_toggle_callback_t uic_mqtt_dotdot_door_lock_toggle_callback = nullptr;
static uic_mqtt_dotdot_door_lock_toggle_callback_t uic_mqtt_dotdot_door_lock_generated_toggle_callback = nullptr;
uic_mqtt_dotdot_door_lock_toggle_response_callback_t uic_mqtt_dotdot_door_lock_toggle_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_toggle_response_callback_t uic_mqtt_dotdot_door_lock_generated_toggle_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback_t uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback = nullptr;
static uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback_t uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_callback = nullptr;
uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback_t uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback_t uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_get_log_record_callback_t uic_mqtt_dotdot_door_lock_get_log_record_callback = nullptr;
static uic_mqtt_dotdot_door_lock_get_log_record_callback_t uic_mqtt_dotdot_door_lock_generated_get_log_record_callback = nullptr;
uic_mqtt_dotdot_door_lock_get_log_record_response_callback_t uic_mqtt_dotdot_door_lock_get_log_record_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_get_log_record_response_callback_t uic_mqtt_dotdot_door_lock_generated_get_log_record_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_setpin_code_callback_t uic_mqtt_dotdot_door_lock_setpin_code_callback = nullptr;
static uic_mqtt_dotdot_door_lock_setpin_code_callback_t uic_mqtt_dotdot_door_lock_generated_setpin_code_callback = nullptr;
uic_mqtt_dotdot_door_lock_setpin_code_response_callback_t uic_mqtt_dotdot_door_lock_setpin_code_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_setpin_code_response_callback_t uic_mqtt_dotdot_door_lock_generated_setpin_code_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_getpin_code_callback_t uic_mqtt_dotdot_door_lock_getpin_code_callback = nullptr;
static uic_mqtt_dotdot_door_lock_getpin_code_callback_t uic_mqtt_dotdot_door_lock_generated_getpin_code_callback = nullptr;
uic_mqtt_dotdot_door_lock_getpin_code_response_callback_t uic_mqtt_dotdot_door_lock_getpin_code_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_getpin_code_response_callback_t uic_mqtt_dotdot_door_lock_generated_getpin_code_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_clearpin_code_callback_t uic_mqtt_dotdot_door_lock_clearpin_code_callback = nullptr;
static uic_mqtt_dotdot_door_lock_clearpin_code_callback_t uic_mqtt_dotdot_door_lock_generated_clearpin_code_callback = nullptr;
uic_mqtt_dotdot_door_lock_clearpin_code_response_callback_t uic_mqtt_dotdot_door_lock_clearpin_code_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_clearpin_code_response_callback_t uic_mqtt_dotdot_door_lock_generated_clearpin_code_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_clear_allpin_codes_callback_t uic_mqtt_dotdot_door_lock_clear_allpin_codes_callback = nullptr;
static uic_mqtt_dotdot_door_lock_clear_allpin_codes_callback_t uic_mqtt_dotdot_door_lock_generated_clear_allpin_codes_callback = nullptr;
uic_mqtt_dotdot_door_lock_clear_allpin_codes_response_callback_t uic_mqtt_dotdot_door_lock_clear_allpin_codes_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_clear_allpin_codes_response_callback_t uic_mqtt_dotdot_door_lock_generated_clear_allpin_codes_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_set_user_status_callback_t uic_mqtt_dotdot_door_lock_set_user_status_callback = nullptr;
static uic_mqtt_dotdot_door_lock_set_user_status_callback_t uic_mqtt_dotdot_door_lock_generated_set_user_status_callback = nullptr;
uic_mqtt_dotdot_door_lock_set_user_status_response_callback_t uic_mqtt_dotdot_door_lock_set_user_status_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_set_user_status_response_callback_t uic_mqtt_dotdot_door_lock_generated_set_user_status_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_get_user_status_callback_t uic_mqtt_dotdot_door_lock_get_user_status_callback = nullptr;
static uic_mqtt_dotdot_door_lock_get_user_status_callback_t uic_mqtt_dotdot_door_lock_generated_get_user_status_callback = nullptr;
uic_mqtt_dotdot_door_lock_get_user_status_response_callback_t uic_mqtt_dotdot_door_lock_get_user_status_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_get_user_status_response_callback_t uic_mqtt_dotdot_door_lock_generated_get_user_status_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback_t uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback = nullptr;
static uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback_t uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_callback = nullptr;
uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback_t uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback_t uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback_t uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback = nullptr;
static uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback_t uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_callback = nullptr;
uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback_t uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback_t uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback_t uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback = nullptr;
static uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback_t uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_callback = nullptr;
uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback_t uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback_t uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback_t uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback = nullptr;
static uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback_t uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_callback = nullptr;
uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback_t uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback_t uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback_t uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback = nullptr;
static uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback_t uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_callback = nullptr;
uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback_t uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback_t uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback_t uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback = nullptr;
static uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback_t uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_callback = nullptr;
uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback_t uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback_t uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback_t uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback = nullptr;
static uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback_t uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_callback = nullptr;
uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback_t uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback_t uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback_t uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback = nullptr;
static uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback_t uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_callback = nullptr;
uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback_t uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback_t uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback_t uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback = nullptr;
static uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback_t uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_callback = nullptr;
uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback_t uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback_t uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_set_user_type_callback_t uic_mqtt_dotdot_door_lock_set_user_type_callback = nullptr;
static uic_mqtt_dotdot_door_lock_set_user_type_callback_t uic_mqtt_dotdot_door_lock_generated_set_user_type_callback = nullptr;
uic_mqtt_dotdot_door_lock_set_user_type_response_callback_t uic_mqtt_dotdot_door_lock_set_user_type_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_set_user_type_response_callback_t uic_mqtt_dotdot_door_lock_generated_set_user_type_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_get_user_type_callback_t uic_mqtt_dotdot_door_lock_get_user_type_callback = nullptr;
static uic_mqtt_dotdot_door_lock_get_user_type_callback_t uic_mqtt_dotdot_door_lock_generated_get_user_type_callback = nullptr;
uic_mqtt_dotdot_door_lock_get_user_type_response_callback_t uic_mqtt_dotdot_door_lock_get_user_type_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_get_user_type_response_callback_t uic_mqtt_dotdot_door_lock_generated_get_user_type_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_setrfid_code_callback_t uic_mqtt_dotdot_door_lock_setrfid_code_callback = nullptr;
static uic_mqtt_dotdot_door_lock_setrfid_code_callback_t uic_mqtt_dotdot_door_lock_generated_setrfid_code_callback = nullptr;
uic_mqtt_dotdot_door_lock_setrfid_code_response_callback_t uic_mqtt_dotdot_door_lock_setrfid_code_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_setrfid_code_response_callback_t uic_mqtt_dotdot_door_lock_generated_setrfid_code_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_getrfid_code_callback_t uic_mqtt_dotdot_door_lock_getrfid_code_callback = nullptr;
static uic_mqtt_dotdot_door_lock_getrfid_code_callback_t uic_mqtt_dotdot_door_lock_generated_getrfid_code_callback = nullptr;
uic_mqtt_dotdot_door_lock_getrfid_code_response_callback_t uic_mqtt_dotdot_door_lock_getrfid_code_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_getrfid_code_response_callback_t uic_mqtt_dotdot_door_lock_generated_getrfid_code_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_clearrfid_code_callback_t uic_mqtt_dotdot_door_lock_clearrfid_code_callback = nullptr;
static uic_mqtt_dotdot_door_lock_clearrfid_code_callback_t uic_mqtt_dotdot_door_lock_generated_clearrfid_code_callback = nullptr;
uic_mqtt_dotdot_door_lock_clearrfid_code_response_callback_t uic_mqtt_dotdot_door_lock_clearrfid_code_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_clearrfid_code_response_callback_t uic_mqtt_dotdot_door_lock_generated_clearrfid_code_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_clear_allrfid_codes_callback_t uic_mqtt_dotdot_door_lock_clear_allrfid_codes_callback = nullptr;
static uic_mqtt_dotdot_door_lock_clear_allrfid_codes_callback_t uic_mqtt_dotdot_door_lock_generated_clear_allrfid_codes_callback = nullptr;
uic_mqtt_dotdot_door_lock_clear_allrfid_codes_response_callback_t uic_mqtt_dotdot_door_lock_clear_allrfid_codes_response_callback = nullptr;
static uic_mqtt_dotdot_door_lock_clear_allrfid_codes_response_callback_t uic_mqtt_dotdot_door_lock_generated_clear_allrfid_codes_response_callback = nullptr;
uic_mqtt_dotdot_door_lock_operating_event_notification_callback_t uic_mqtt_dotdot_door_lock_operating_event_notification_callback = nullptr;
static uic_mqtt_dotdot_door_lock_operating_event_notification_callback_t uic_mqtt_dotdot_door_lock_generated_operating_event_notification_callback = nullptr;
uic_mqtt_dotdot_door_lock_programming_event_notification_callback_t uic_mqtt_dotdot_door_lock_programming_event_notification_callback = nullptr;
static uic_mqtt_dotdot_door_lock_programming_event_notification_callback_t uic_mqtt_dotdot_door_lock_generated_programming_event_notification_callback = nullptr;
uic_mqtt_dotdot_door_lock_write_attributes_callback_t uic_mqtt_dotdot_door_lock_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_door_lock_force_read_attributes_callback_t uic_mqtt_dotdot_door_lock_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_door_lock_lock_door_callback_set(const uic_mqtt_dotdot_door_lock_lock_door_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_lock_door_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_lock_door_callback_set(const uic_mqtt_dotdot_door_lock_lock_door_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_lock_door_callback = callback;
}

void uic_mqtt_dotdot_door_lock_lock_door_response_callback_set(const uic_mqtt_dotdot_door_lock_lock_door_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_lock_door_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_lock_door_response_callback_set(const uic_mqtt_dotdot_door_lock_lock_door_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_lock_door_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_unlock_door_callback_set(const uic_mqtt_dotdot_door_lock_unlock_door_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_unlock_door_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_unlock_door_callback_set(const uic_mqtt_dotdot_door_lock_unlock_door_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_unlock_door_callback = callback;
}

void uic_mqtt_dotdot_door_lock_unlock_door_response_callback_set(const uic_mqtt_dotdot_door_lock_unlock_door_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_unlock_door_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_unlock_door_response_callback_set(const uic_mqtt_dotdot_door_lock_unlock_door_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_unlock_door_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_toggle_callback_set(const uic_mqtt_dotdot_door_lock_toggle_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_toggle_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_toggle_callback_set(const uic_mqtt_dotdot_door_lock_toggle_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_toggle_callback = callback;
}

void uic_mqtt_dotdot_door_lock_toggle_response_callback_set(const uic_mqtt_dotdot_door_lock_toggle_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_toggle_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_toggle_response_callback_set(const uic_mqtt_dotdot_door_lock_toggle_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_toggle_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback_set(const uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_callback_set(const uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_callback = callback;
}

void uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback_set(const uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_response_callback_set(const uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_get_log_record_callback_set(const uic_mqtt_dotdot_door_lock_get_log_record_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_log_record_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_get_log_record_callback_set(const uic_mqtt_dotdot_door_lock_get_log_record_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_log_record_callback = callback;
}

void uic_mqtt_dotdot_door_lock_get_log_record_response_callback_set(const uic_mqtt_dotdot_door_lock_get_log_record_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_log_record_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_get_log_record_response_callback_set(const uic_mqtt_dotdot_door_lock_get_log_record_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_log_record_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_setpin_code_callback_set(const uic_mqtt_dotdot_door_lock_setpin_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_setpin_code_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_setpin_code_callback_set(const uic_mqtt_dotdot_door_lock_setpin_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_setpin_code_callback = callback;
}

void uic_mqtt_dotdot_door_lock_setpin_code_response_callback_set(const uic_mqtt_dotdot_door_lock_setpin_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_setpin_code_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_setpin_code_response_callback_set(const uic_mqtt_dotdot_door_lock_setpin_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_setpin_code_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_getpin_code_callback_set(const uic_mqtt_dotdot_door_lock_getpin_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_getpin_code_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_getpin_code_callback_set(const uic_mqtt_dotdot_door_lock_getpin_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_getpin_code_callback = callback;
}

void uic_mqtt_dotdot_door_lock_getpin_code_response_callback_set(const uic_mqtt_dotdot_door_lock_getpin_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_getpin_code_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_getpin_code_response_callback_set(const uic_mqtt_dotdot_door_lock_getpin_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_getpin_code_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_clearpin_code_callback_set(const uic_mqtt_dotdot_door_lock_clearpin_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clearpin_code_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_clearpin_code_callback_set(const uic_mqtt_dotdot_door_lock_clearpin_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clearpin_code_callback = callback;
}

void uic_mqtt_dotdot_door_lock_clearpin_code_response_callback_set(const uic_mqtt_dotdot_door_lock_clearpin_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clearpin_code_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_clearpin_code_response_callback_set(const uic_mqtt_dotdot_door_lock_clearpin_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clearpin_code_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_clear_allpin_codes_callback_set(const uic_mqtt_dotdot_door_lock_clear_allpin_codes_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_allpin_codes_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_clear_allpin_codes_callback_set(const uic_mqtt_dotdot_door_lock_clear_allpin_codes_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_allpin_codes_callback = callback;
}

void uic_mqtt_dotdot_door_lock_clear_allpin_codes_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_allpin_codes_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_allpin_codes_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_clear_allpin_codes_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_allpin_codes_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_allpin_codes_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_set_user_status_callback_set(const uic_mqtt_dotdot_door_lock_set_user_status_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_user_status_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_set_user_status_callback_set(const uic_mqtt_dotdot_door_lock_set_user_status_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_user_status_callback = callback;
}

void uic_mqtt_dotdot_door_lock_set_user_status_response_callback_set(const uic_mqtt_dotdot_door_lock_set_user_status_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_user_status_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_set_user_status_response_callback_set(const uic_mqtt_dotdot_door_lock_set_user_status_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_user_status_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_get_user_status_callback_set(const uic_mqtt_dotdot_door_lock_get_user_status_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_user_status_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_get_user_status_callback_set(const uic_mqtt_dotdot_door_lock_get_user_status_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_user_status_callback = callback;
}

void uic_mqtt_dotdot_door_lock_get_user_status_response_callback_set(const uic_mqtt_dotdot_door_lock_get_user_status_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_user_status_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_get_user_status_response_callback_set(const uic_mqtt_dotdot_door_lock_get_user_status_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_user_status_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_callback = callback;
}

void uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_callback = callback;
}

void uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_callback = callback;
}

void uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback_set(const uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_callback_set(const uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_callback = callback;
}

void uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback_set(const uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_callback_set(const uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_callback = callback;
}

void uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback_set(const uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_callback_set(const uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_callback = callback;
}

void uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_callback = callback;
}

void uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_callback = callback;
}

void uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_callback = callback;
}

void uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_set_user_type_callback_set(const uic_mqtt_dotdot_door_lock_set_user_type_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_user_type_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_set_user_type_callback_set(const uic_mqtt_dotdot_door_lock_set_user_type_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_user_type_callback = callback;
}

void uic_mqtt_dotdot_door_lock_set_user_type_response_callback_set(const uic_mqtt_dotdot_door_lock_set_user_type_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_user_type_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_set_user_type_response_callback_set(const uic_mqtt_dotdot_door_lock_set_user_type_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_user_type_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_get_user_type_callback_set(const uic_mqtt_dotdot_door_lock_get_user_type_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_user_type_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_get_user_type_callback_set(const uic_mqtt_dotdot_door_lock_get_user_type_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_user_type_callback = callback;
}

void uic_mqtt_dotdot_door_lock_get_user_type_response_callback_set(const uic_mqtt_dotdot_door_lock_get_user_type_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_user_type_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_get_user_type_response_callback_set(const uic_mqtt_dotdot_door_lock_get_user_type_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_user_type_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_setrfid_code_callback_set(const uic_mqtt_dotdot_door_lock_setrfid_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_setrfid_code_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_setrfid_code_callback_set(const uic_mqtt_dotdot_door_lock_setrfid_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_setrfid_code_callback = callback;
}

void uic_mqtt_dotdot_door_lock_setrfid_code_response_callback_set(const uic_mqtt_dotdot_door_lock_setrfid_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_setrfid_code_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_setrfid_code_response_callback_set(const uic_mqtt_dotdot_door_lock_setrfid_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_setrfid_code_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_getrfid_code_callback_set(const uic_mqtt_dotdot_door_lock_getrfid_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_getrfid_code_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_getrfid_code_callback_set(const uic_mqtt_dotdot_door_lock_getrfid_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_getrfid_code_callback = callback;
}

void uic_mqtt_dotdot_door_lock_getrfid_code_response_callback_set(const uic_mqtt_dotdot_door_lock_getrfid_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_getrfid_code_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_getrfid_code_response_callback_set(const uic_mqtt_dotdot_door_lock_getrfid_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_getrfid_code_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_clearrfid_code_callback_set(const uic_mqtt_dotdot_door_lock_clearrfid_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clearrfid_code_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_clearrfid_code_callback_set(const uic_mqtt_dotdot_door_lock_clearrfid_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clearrfid_code_callback = callback;
}

void uic_mqtt_dotdot_door_lock_clearrfid_code_response_callback_set(const uic_mqtt_dotdot_door_lock_clearrfid_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clearrfid_code_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_clearrfid_code_response_callback_set(const uic_mqtt_dotdot_door_lock_clearrfid_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clearrfid_code_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_clear_allrfid_codes_callback_set(const uic_mqtt_dotdot_door_lock_clear_allrfid_codes_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_allrfid_codes_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_clear_allrfid_codes_callback_set(const uic_mqtt_dotdot_door_lock_clear_allrfid_codes_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_allrfid_codes_callback = callback;
}

void uic_mqtt_dotdot_door_lock_clear_allrfid_codes_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_allrfid_codes_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_allrfid_codes_response_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_clear_allrfid_codes_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_allrfid_codes_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_allrfid_codes_response_callback = callback;
}

void uic_mqtt_dotdot_door_lock_operating_event_notification_callback_set(const uic_mqtt_dotdot_door_lock_operating_event_notification_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_operating_event_notification_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_operating_event_notification_callback_set(const uic_mqtt_dotdot_door_lock_operating_event_notification_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_operating_event_notification_callback = callback;
}

void uic_mqtt_dotdot_door_lock_programming_event_notification_callback_set(const uic_mqtt_dotdot_door_lock_programming_event_notification_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_programming_event_notification_callback = callback;
}
void uic_mqtt_dotdot_door_lock_generated_programming_event_notification_callback_set(const uic_mqtt_dotdot_door_lock_programming_event_notification_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_programming_event_notification_callback = callback;
}


void uic_mqtt_dotdot_set_door_lock_write_attributes_callback(
  const uic_mqtt_dotdot_door_lock_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_door_lock_force_read_attributes_callback(
  const uic_mqtt_dotdot_door_lock_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/LockDoor
void uic_mqtt_dotdot_on_door_lock_lock_door(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_lock_door_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* pin_orrfid_code = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_lock_door(
      jsn,
      pin_orrfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "LockDoor");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "LockDoor", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "LockDoor", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_lock_door_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    pin_orrfid_code

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/LockDoor
static void uic_mqtt_dotdot_on_generated_door_lock_lock_door(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_lock_door_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* pin_orrfid_code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_lock_door(
      jsn,
      pin_orrfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "LockDoor");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "LockDoor", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "LockDoor", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_lock_door_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    pin_orrfid_code

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/LockDoorResponse
void uic_mqtt_dotdot_on_door_lock_lock_door_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_lock_door_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_lock_door_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "LockDoorResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "LockDoorResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "LockDoorResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_lock_door_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/LockDoorResponse
static void uic_mqtt_dotdot_on_generated_door_lock_lock_door_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_lock_door_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_lock_door_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "LockDoorResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "LockDoorResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "LockDoorResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_lock_door_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/UnlockDoor
void uic_mqtt_dotdot_on_door_lock_unlock_door(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_unlock_door_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* pin_orrfid_code = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_unlock_door(
      jsn,
      pin_orrfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "UnlockDoor");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockDoor", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockDoor", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_unlock_door_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    pin_orrfid_code

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/UnlockDoor
static void uic_mqtt_dotdot_on_generated_door_lock_unlock_door(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_unlock_door_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* pin_orrfid_code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_unlock_door(
      jsn,
      pin_orrfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "UnlockDoor");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockDoor", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockDoor", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_unlock_door_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    pin_orrfid_code

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/UnlockDoorResponse
void uic_mqtt_dotdot_on_door_lock_unlock_door_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_unlock_door_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_unlock_door_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "UnlockDoorResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockDoorResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockDoorResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_unlock_door_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/UnlockDoorResponse
static void uic_mqtt_dotdot_on_generated_door_lock_unlock_door_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_unlock_door_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_unlock_door_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "UnlockDoorResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockDoorResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockDoorResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_unlock_door_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/Toggle
void uic_mqtt_dotdot_on_door_lock_toggle(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_toggle_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* pin_orrfid_code = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_toggle(
      jsn,
      pin_orrfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "Toggle");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "Toggle", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "Toggle", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_toggle_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    pin_orrfid_code

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/Toggle
static void uic_mqtt_dotdot_on_generated_door_lock_toggle(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_toggle_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* pin_orrfid_code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_toggle(
      jsn,
      pin_orrfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "Toggle");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "Toggle", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "Toggle", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_toggle_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    pin_orrfid_code

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ToggleResponse
void uic_mqtt_dotdot_on_door_lock_toggle_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_toggle_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_toggle_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ToggleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ToggleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ToggleResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_toggle_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ToggleResponse
static void uic_mqtt_dotdot_on_generated_door_lock_toggle_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_toggle_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_toggle_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ToggleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ToggleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ToggleResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_toggle_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/UnlockWithTimeout
void uic_mqtt_dotdot_on_door_lock_unlock_with_timeout(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t timeout_in_seconds = {};
  const char* pin_orrfid_code = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_unlock_with_timeout(
      jsn,
      timeout_in_seconds,

      pin_orrfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "UnlockWithTimeout");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockWithTimeout", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockWithTimeout", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    timeout_in_seconds,

    pin_orrfid_code

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/UnlockWithTimeout
static void uic_mqtt_dotdot_on_generated_door_lock_unlock_with_timeout(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t timeout_in_seconds;
  const char* pin_orrfid_code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_unlock_with_timeout(
      jsn,
      timeout_in_seconds,

      pin_orrfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "UnlockWithTimeout");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockWithTimeout", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockWithTimeout", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    timeout_in_seconds,

    pin_orrfid_code

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/UnlockWithTimeoutResponse
void uic_mqtt_dotdot_on_door_lock_unlock_with_timeout_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_unlock_with_timeout_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "UnlockWithTimeoutResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockWithTimeoutResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockWithTimeoutResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/UnlockWithTimeoutResponse
static void uic_mqtt_dotdot_on_generated_door_lock_unlock_with_timeout_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_unlock_with_timeout_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "UnlockWithTimeoutResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockWithTimeoutResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockWithTimeoutResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetLogRecord
void uic_mqtt_dotdot_on_door_lock_get_log_record(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_log_record_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t log_index = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_log_record(
      jsn,
      log_index
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetLogRecord");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetLogRecord", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetLogRecord", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_get_log_record_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    log_index

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetLogRecord
static void uic_mqtt_dotdot_on_generated_door_lock_get_log_record(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_log_record_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t log_index;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_log_record(
      jsn,
      log_index
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetLogRecord");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetLogRecord", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetLogRecord", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_get_log_record_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    log_index

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetLogRecordResponse
void uic_mqtt_dotdot_on_door_lock_get_log_record_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_log_record_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t log_entryid = {};
  uint32_t timestamp = {};
  GetLogRecordResponseEventType event_type = {};
  DrlkOperEventSource source_operation_event = {};
  uint8_t eventid_or_alarm_code = {};
  uint16_t userid = {};
  const char* pin = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_log_record_response(
      jsn,
      log_entryid,

      timestamp,

      event_type,

      source_operation_event,

      eventid_or_alarm_code,

      userid,

      pin
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetLogRecordResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetLogRecordResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetLogRecordResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_get_log_record_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    log_entryid,

    timestamp,

    event_type,

    source_operation_event,

    eventid_or_alarm_code,

    userid,

    pin

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetLogRecordResponse
static void uic_mqtt_dotdot_on_generated_door_lock_get_log_record_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_log_record_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t log_entryid;
  uint32_t timestamp;
  GetLogRecordResponseEventType event_type;
  DrlkOperEventSource source_operation_event;
  uint8_t eventid_or_alarm_code;
  uint16_t userid;
  const char* pin;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_log_record_response(
      jsn,
      log_entryid,

      timestamp,

      event_type,

      source_operation_event,

      eventid_or_alarm_code,

      userid,

      pin
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetLogRecordResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetLogRecordResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetLogRecordResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_get_log_record_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    log_entryid,

    timestamp,

    event_type,

    source_operation_event,

    eventid_or_alarm_code,

    userid,

    pin

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetPINCode
void uic_mqtt_dotdot_on_door_lock_setpin_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_setpin_code_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPINUserID userid = {};
  DrlkSettableUserStatus user_status = {};
  DrlkUserType user_type = {};
  const char* pin = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_setpin_code(
      jsn,
      userid,

      user_status,

      user_type,

      pin
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetPINCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetPINCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetPINCode", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_setpin_code_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid,

    user_status,

    user_type,

    pin

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetPINCode
static void uic_mqtt_dotdot_on_generated_door_lock_setpin_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_setpin_code_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPINUserID userid;
  DrlkSettableUserStatus user_status;
  DrlkUserType user_type;
  const char* pin;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_setpin_code(
      jsn,
      userid,

      user_status,

      user_type,

      pin
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetPINCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetPINCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetPINCode", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_setpin_code_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid,

    user_status,

    user_type,

    pin

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetPINCodeResponse
void uic_mqtt_dotdot_on_door_lock_setpin_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_setpin_code_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkSetCodeStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_setpin_code_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetPINCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetPINCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetPINCodeResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_setpin_code_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetPINCodeResponse
static void uic_mqtt_dotdot_on_generated_door_lock_setpin_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_setpin_code_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkSetCodeStatus status;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_setpin_code_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetPINCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetPINCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetPINCodeResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_setpin_code_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetPINCode
void uic_mqtt_dotdot_on_door_lock_getpin_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_getpin_code_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPINUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_getpin_code(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetPINCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetPINCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetPINCode", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_getpin_code_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetPINCode
static void uic_mqtt_dotdot_on_generated_door_lock_getpin_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_getpin_code_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPINUserID userid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_getpin_code(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetPINCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetPINCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetPINCode", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_getpin_code_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetPINCodeResponse
void uic_mqtt_dotdot_on_door_lock_getpin_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_getpin_code_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t userid = {};
  DrlkUserStatus user_status = {};
  DrlkUserType user_type = {};
  const char* code = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_getpin_code_response(
      jsn,
      userid,

      user_status,

      user_type,

      code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetPINCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetPINCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetPINCodeResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_getpin_code_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid,

    user_status,

    user_type,

    code

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetPINCodeResponse
static void uic_mqtt_dotdot_on_generated_door_lock_getpin_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_getpin_code_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t userid;
  DrlkUserStatus user_status;
  DrlkUserType user_type;
  const char* code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_getpin_code_response(
      jsn,
      userid,

      user_status,

      user_type,

      code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetPINCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetPINCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetPINCodeResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_getpin_code_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid,

    user_status,

    user_type,

    code

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearPINCode
void uic_mqtt_dotdot_on_door_lock_clearpin_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clearpin_code_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPINUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clearpin_code(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearPINCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearPINCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearPINCode", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_clearpin_code_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearPINCode
static void uic_mqtt_dotdot_on_generated_door_lock_clearpin_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clearpin_code_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPINUserID userid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clearpin_code(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearPINCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearPINCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearPINCode", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_clearpin_code_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearPINCodeResponse
void uic_mqtt_dotdot_on_door_lock_clearpin_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clearpin_code_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clearpin_code_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearPINCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearPINCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearPINCodeResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_clearpin_code_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearPINCodeResponse
static void uic_mqtt_dotdot_on_generated_door_lock_clearpin_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clearpin_code_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clearpin_code_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearPINCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearPINCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearPINCodeResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_clearpin_code_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearAllPINCodes
void uic_mqtt_dotdot_on_door_lock_clear_allpin_codes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_allpin_codes_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearAllPINCodes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllPINCodes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllPINCodes", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_clear_allpin_codes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearAllPINCodes
static void uic_mqtt_dotdot_on_generated_door_lock_clear_allpin_codes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_allpin_codes_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearAllPINCodes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllPINCodes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllPINCodes", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_clear_allpin_codes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearAllPINCodesResponse
void uic_mqtt_dotdot_on_door_lock_clear_allpin_codes_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_allpin_codes_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_allpin_codes_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearAllPINCodesResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllPINCodesResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllPINCodesResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_clear_allpin_codes_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearAllPINCodesResponse
static void uic_mqtt_dotdot_on_generated_door_lock_clear_allpin_codes_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_allpin_codes_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_allpin_codes_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearAllPINCodesResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllPINCodesResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllPINCodesResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_clear_allpin_codes_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetUserStatus
void uic_mqtt_dotdot_on_door_lock_set_user_status(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_user_status_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkTotalUserID userid = {};
  DrlkSettableUserStatus user_status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_user_status(
      jsn,
      userid,

      user_status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetUserStatus");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserStatus", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserStatus", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_set_user_status_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid,

    user_status

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetUserStatus
static void uic_mqtt_dotdot_on_generated_door_lock_set_user_status(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_user_status_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkTotalUserID userid;
  DrlkSettableUserStatus user_status;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_user_status(
      jsn,
      userid,

      user_status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetUserStatus");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserStatus", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserStatus", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_set_user_status_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid,

    user_status

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetUserStatusResponse
void uic_mqtt_dotdot_on_door_lock_set_user_status_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_user_status_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_user_status_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetUserStatusResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserStatusResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserStatusResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_set_user_status_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetUserStatusResponse
static void uic_mqtt_dotdot_on_generated_door_lock_set_user_status_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_user_status_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_user_status_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetUserStatusResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserStatusResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserStatusResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_set_user_status_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetUserStatus
void uic_mqtt_dotdot_on_door_lock_get_user_status(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_user_status_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkTotalUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_user_status(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUserStatus");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserStatus", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserStatus", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_get_user_status_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetUserStatus
static void uic_mqtt_dotdot_on_generated_door_lock_get_user_status(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_user_status_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkTotalUserID userid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_user_status(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUserStatus");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserStatus", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserStatus", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_get_user_status_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetUserStatusResponse
void uic_mqtt_dotdot_on_door_lock_get_user_status_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_user_status_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t userid = {};
  DrlkUserStatus user_status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_user_status_response(
      jsn,
      userid,

      user_status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUserStatusResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserStatusResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserStatusResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_get_user_status_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid,

    user_status

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetUserStatusResponse
static void uic_mqtt_dotdot_on_generated_door_lock_get_user_status_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_user_status_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t userid;
  DrlkUserStatus user_status;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_user_status_response(
      jsn,
      userid,

      user_status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUserStatusResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserStatusResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserStatusResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_get_user_status_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid,

    user_status

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetWeekdaySchedule
void uic_mqtt_dotdot_on_door_lock_set_weekday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkWeekDayScheduleID scheduleid = {};
  DrlkTotalUserID userid = {};
  uint8_t days_mask = {};
  uint8_t start_hour = {};
  uint8_t start_minute = {};
  uint8_t end_hour = {};
  uint8_t end_minute = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_weekday_schedule(
      jsn,
      scheduleid,

      userid,

      days_mask,

      start_hour,

      start_minute,

      end_hour,

      end_minute
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetWeekdaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetWeekdaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetWeekdaySchedule", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    scheduleid,

    userid,

    days_mask,

    start_hour,

    start_minute,

    end_hour,

    end_minute

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetWeekdaySchedule
static void uic_mqtt_dotdot_on_generated_door_lock_set_weekday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkWeekDayScheduleID scheduleid;
  DrlkTotalUserID userid;
  uint8_t days_mask;
  uint8_t start_hour;
  uint8_t start_minute;
  uint8_t end_hour;
  uint8_t end_minute;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_weekday_schedule(
      jsn,
      scheduleid,

      userid,

      days_mask,

      start_hour,

      start_minute,

      end_hour,

      end_minute
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetWeekdaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetWeekdaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetWeekdaySchedule", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    scheduleid,

    userid,

    days_mask,

    start_hour,

    start_minute,

    end_hour,

    end_minute

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetWeekdayScheduleResponse
void uic_mqtt_dotdot_on_door_lock_set_weekday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_weekday_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetWeekdayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetWeekdayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetWeekdayScheduleResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetWeekdayScheduleResponse
static void uic_mqtt_dotdot_on_generated_door_lock_set_weekday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_weekday_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetWeekdayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetWeekdayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetWeekdayScheduleResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetWeekdaySchedule
void uic_mqtt_dotdot_on_door_lock_get_weekday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkWeekDayScheduleID scheduleid = {};
  DrlkTotalUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_weekday_schedule(
      jsn,
      scheduleid,

      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetWeekdaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetWeekdaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetWeekdaySchedule", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    scheduleid,

    userid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetWeekdaySchedule
static void uic_mqtt_dotdot_on_generated_door_lock_get_weekday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkWeekDayScheduleID scheduleid;
  DrlkTotalUserID userid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_weekday_schedule(
      jsn,
      scheduleid,

      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetWeekdaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetWeekdaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetWeekdaySchedule", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    scheduleid,

    userid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetWeekdayScheduleResponse
void uic_mqtt_dotdot_on_door_lock_get_weekday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t scheduleid = {};
  uint16_t userid = {};
  zclStatus status = {};
  uint8_t days_mask = {};
  uint8_t start_hour = {};
  uint8_t start_minute = {};
  uint8_t end_hour = {};
  uint8_t end_minute = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_weekday_schedule_response(
      jsn,
      scheduleid,

      userid,

      status,

      days_mask,

      start_hour,

      start_minute,

      end_hour,

      end_minute
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetWeekdayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetWeekdayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetWeekdayScheduleResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    scheduleid,

    userid,

    status,

    days_mask,

    start_hour,

    start_minute,

    end_hour,

    end_minute

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetWeekdayScheduleResponse
static void uic_mqtt_dotdot_on_generated_door_lock_get_weekday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t scheduleid;
  uint16_t userid;
  zclStatus status;
  uint8_t days_mask;
  uint8_t start_hour;
  uint8_t start_minute;
  uint8_t end_hour;
  uint8_t end_minute;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_weekday_schedule_response(
      jsn,
      scheduleid,

      userid,

      status,

      days_mask,

      start_hour,

      start_minute,

      end_hour,

      end_minute
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetWeekdayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetWeekdayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetWeekdayScheduleResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    scheduleid,

    userid,

    status,

    days_mask,

    start_hour,

    start_minute,

    end_hour,

    end_minute

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearWeekdaySchedule
void uic_mqtt_dotdot_on_door_lock_clear_weekday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkWeekDayScheduleID scheduleid = {};
  DrlkTotalUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_weekday_schedule(
      jsn,
      scheduleid,

      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearWeekdaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearWeekdaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearWeekdaySchedule", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    scheduleid,

    userid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearWeekdaySchedule
static void uic_mqtt_dotdot_on_generated_door_lock_clear_weekday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkWeekDayScheduleID scheduleid;
  DrlkTotalUserID userid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_weekday_schedule(
      jsn,
      scheduleid,

      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearWeekdaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearWeekdaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearWeekdaySchedule", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    scheduleid,

    userid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearWeekdayScheduleResponse
void uic_mqtt_dotdot_on_door_lock_clear_weekday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_weekday_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearWeekdayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearWeekdayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearWeekdayScheduleResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearWeekdayScheduleResponse
static void uic_mqtt_dotdot_on_generated_door_lock_clear_weekday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_weekday_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearWeekdayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearWeekdayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearWeekdayScheduleResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetYearDaySchedule
void uic_mqtt_dotdot_on_door_lock_set_year_day_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkYearDayScheduleID scheduleid = {};
  DrlkTotalUserID userid = {};
  uint32_t local_start_time = {};
  uint32_t local_end_time = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_year_day_schedule(
      jsn,
      scheduleid,

      userid,

      local_start_time,

      local_end_time
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetYearDaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetYearDaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetYearDaySchedule", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    scheduleid,

    userid,

    local_start_time,

    local_end_time

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetYearDaySchedule
static void uic_mqtt_dotdot_on_generated_door_lock_set_year_day_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkYearDayScheduleID scheduleid;
  DrlkTotalUserID userid;
  uint32_t local_start_time;
  uint32_t local_end_time;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_year_day_schedule(
      jsn,
      scheduleid,

      userid,

      local_start_time,

      local_end_time
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetYearDaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetYearDaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetYearDaySchedule", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    scheduleid,

    userid,

    local_start_time,

    local_end_time

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetYearDayScheduleResponse
void uic_mqtt_dotdot_on_door_lock_set_year_day_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_year_day_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetYearDayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetYearDayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetYearDayScheduleResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetYearDayScheduleResponse
static void uic_mqtt_dotdot_on_generated_door_lock_set_year_day_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_year_day_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetYearDayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetYearDayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetYearDayScheduleResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetYearDaySchedule
void uic_mqtt_dotdot_on_door_lock_get_year_day_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkYearDayScheduleID scheduleid = {};
  DrlkTotalUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_year_day_schedule(
      jsn,
      scheduleid,

      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetYearDaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetYearDaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetYearDaySchedule", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    scheduleid,

    userid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetYearDaySchedule
static void uic_mqtt_dotdot_on_generated_door_lock_get_year_day_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkYearDayScheduleID scheduleid;
  DrlkTotalUserID userid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_year_day_schedule(
      jsn,
      scheduleid,

      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetYearDaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetYearDaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetYearDaySchedule", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    scheduleid,

    userid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetYearDayScheduleResponse
void uic_mqtt_dotdot_on_door_lock_get_year_day_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t scheduleid = {};
  uint16_t userid = {};
  zclStatus status = {};
  uint32_t local_start_time = {};
  uint32_t local_end_time = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_year_day_schedule_response(
      jsn,
      scheduleid,

      userid,

      status,

      local_start_time,

      local_end_time
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetYearDayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetYearDayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetYearDayScheduleResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    scheduleid,

    userid,

    status,

    local_start_time,

    local_end_time

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetYearDayScheduleResponse
static void uic_mqtt_dotdot_on_generated_door_lock_get_year_day_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t scheduleid;
  uint16_t userid;
  zclStatus status;
  uint32_t local_start_time;
  uint32_t local_end_time;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_year_day_schedule_response(
      jsn,
      scheduleid,

      userid,

      status,

      local_start_time,

      local_end_time
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetYearDayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetYearDayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetYearDayScheduleResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    scheduleid,

    userid,

    status,

    local_start_time,

    local_end_time

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearYearDaySchedule
void uic_mqtt_dotdot_on_door_lock_clear_year_day_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkYearDayScheduleID scheduleid = {};
  DrlkTotalUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_year_day_schedule(
      jsn,
      scheduleid,

      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearYearDaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearYearDaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearYearDaySchedule", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    scheduleid,

    userid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearYearDaySchedule
static void uic_mqtt_dotdot_on_generated_door_lock_clear_year_day_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkYearDayScheduleID scheduleid;
  DrlkTotalUserID userid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_year_day_schedule(
      jsn,
      scheduleid,

      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearYearDaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearYearDaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearYearDaySchedule", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    scheduleid,

    userid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearYearDayScheduleResponse
void uic_mqtt_dotdot_on_door_lock_clear_year_day_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_year_day_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearYearDayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearYearDayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearYearDayScheduleResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearYearDayScheduleResponse
static void uic_mqtt_dotdot_on_generated_door_lock_clear_year_day_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_year_day_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearYearDayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearYearDayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearYearDayScheduleResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetHolidaySchedule
void uic_mqtt_dotdot_on_door_lock_set_holiday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkHolidayScheduleID holiday_scheduleid = {};
  uint32_t local_start_time = {};
  uint32_t local_end_time = {};
  DrlkOperMode operating_mode_during_holiday = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_holiday_schedule(
      jsn,
      holiday_scheduleid,

      local_start_time,

      local_end_time,

      operating_mode_during_holiday
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetHolidaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetHolidaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetHolidaySchedule", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    holiday_scheduleid,

    local_start_time,

    local_end_time,

    operating_mode_during_holiday

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetHolidaySchedule
static void uic_mqtt_dotdot_on_generated_door_lock_set_holiday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkHolidayScheduleID holiday_scheduleid;
  uint32_t local_start_time;
  uint32_t local_end_time;
  DrlkOperMode operating_mode_during_holiday;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_holiday_schedule(
      jsn,
      holiday_scheduleid,

      local_start_time,

      local_end_time,

      operating_mode_during_holiday
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetHolidaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetHolidaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetHolidaySchedule", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    holiday_scheduleid,

    local_start_time,

    local_end_time,

    operating_mode_during_holiday

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetHolidayScheduleResponse
void uic_mqtt_dotdot_on_door_lock_set_holiday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_holiday_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetHolidayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetHolidayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetHolidayScheduleResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetHolidayScheduleResponse
static void uic_mqtt_dotdot_on_generated_door_lock_set_holiday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_holiday_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetHolidayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetHolidayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetHolidayScheduleResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetHolidaySchedule
void uic_mqtt_dotdot_on_door_lock_get_holiday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkHolidayScheduleID holiday_scheduleid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_holiday_schedule(
      jsn,
      holiday_scheduleid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetHolidaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetHolidaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetHolidaySchedule", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    holiday_scheduleid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetHolidaySchedule
static void uic_mqtt_dotdot_on_generated_door_lock_get_holiday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkHolidayScheduleID holiday_scheduleid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_holiday_schedule(
      jsn,
      holiday_scheduleid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetHolidaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetHolidaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetHolidaySchedule", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    holiday_scheduleid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetHolidayScheduleResponse
void uic_mqtt_dotdot_on_door_lock_get_holiday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t holiday_scheduleid = {};
  zclStatus status = {};
  uint32_t local_start_time = {};
  uint32_t local_end_time = {};
  DrlkOperMode operating_mode_during_holiday = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_holiday_schedule_response(
      jsn,
      holiday_scheduleid,

      status,

      local_start_time,

      local_end_time,

      operating_mode_during_holiday
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetHolidayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetHolidayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetHolidayScheduleResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    holiday_scheduleid,

    status,

    local_start_time,

    local_end_time,

    operating_mode_during_holiday

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetHolidayScheduleResponse
static void uic_mqtt_dotdot_on_generated_door_lock_get_holiday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t holiday_scheduleid;
  zclStatus status;
  uint32_t local_start_time;
  uint32_t local_end_time;
  DrlkOperMode operating_mode_during_holiday;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_holiday_schedule_response(
      jsn,
      holiday_scheduleid,

      status,

      local_start_time,

      local_end_time,

      operating_mode_during_holiday
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetHolidayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetHolidayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetHolidayScheduleResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    holiday_scheduleid,

    status,

    local_start_time,

    local_end_time,

    operating_mode_during_holiday

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearHolidaySchedule
void uic_mqtt_dotdot_on_door_lock_clear_holiday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkHolidayScheduleID holiday_scheduleid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_holiday_schedule(
      jsn,
      holiday_scheduleid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearHolidaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearHolidaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearHolidaySchedule", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    holiday_scheduleid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearHolidaySchedule
static void uic_mqtt_dotdot_on_generated_door_lock_clear_holiday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkHolidayScheduleID holiday_scheduleid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_holiday_schedule(
      jsn,
      holiday_scheduleid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearHolidaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearHolidaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearHolidaySchedule", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    holiday_scheduleid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearHolidayScheduleResponse
void uic_mqtt_dotdot_on_door_lock_clear_holiday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_holiday_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearHolidayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearHolidayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearHolidayScheduleResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearHolidayScheduleResponse
static void uic_mqtt_dotdot_on_generated_door_lock_clear_holiday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_holiday_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearHolidayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearHolidayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearHolidayScheduleResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetUserType
void uic_mqtt_dotdot_on_door_lock_set_user_type(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_user_type_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkTotalUserID userid = {};
  DrlkUserType user_type = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_user_type(
      jsn,
      userid,

      user_type
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetUserType");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserType", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserType", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_set_user_type_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid,

    user_type

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetUserType
static void uic_mqtt_dotdot_on_generated_door_lock_set_user_type(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_user_type_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkTotalUserID userid;
  DrlkUserType user_type;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_user_type(
      jsn,
      userid,

      user_type
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetUserType");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserType", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserType", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_set_user_type_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid,

    user_type

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetUserTypeResponse
void uic_mqtt_dotdot_on_door_lock_set_user_type_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_user_type_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_user_type_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetUserTypeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserTypeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserTypeResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_set_user_type_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetUserTypeResponse
static void uic_mqtt_dotdot_on_generated_door_lock_set_user_type_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_user_type_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_user_type_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetUserTypeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserTypeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserTypeResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_set_user_type_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetUserType
void uic_mqtt_dotdot_on_door_lock_get_user_type(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_user_type_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkTotalUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_user_type(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUserType");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserType", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserType", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_get_user_type_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetUserType
static void uic_mqtt_dotdot_on_generated_door_lock_get_user_type(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_user_type_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkTotalUserID userid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_user_type(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUserType");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserType", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserType", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_get_user_type_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetUserTypeResponse
void uic_mqtt_dotdot_on_door_lock_get_user_type_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_user_type_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t userid = {};
  DrlkUserType user_type = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_user_type_response(
      jsn,
      userid,

      user_type
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUserTypeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserTypeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserTypeResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_get_user_type_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid,

    user_type

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetUserTypeResponse
static void uic_mqtt_dotdot_on_generated_door_lock_get_user_type_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_user_type_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t userid;
  DrlkUserType user_type;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_user_type_response(
      jsn,
      userid,

      user_type
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUserTypeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserTypeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserTypeResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_get_user_type_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid,

    user_type

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetRFIDCode
void uic_mqtt_dotdot_on_door_lock_setrfid_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_setrfid_code_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkRFIDUserID userid = {};
  DrlkSettableUserStatus user_status = {};
  DrlkUserType user_type = {};
  const char* rfid_code = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_setrfid_code(
      jsn,
      userid,

      user_status,

      user_type,

      rfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetRFIDCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetRFIDCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetRFIDCode", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_setrfid_code_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid,

    user_status,

    user_type,

    rfid_code

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetRFIDCode
static void uic_mqtt_dotdot_on_generated_door_lock_setrfid_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_setrfid_code_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkRFIDUserID userid;
  DrlkSettableUserStatus user_status;
  DrlkUserType user_type;
  const char* rfid_code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_setrfid_code(
      jsn,
      userid,

      user_status,

      user_type,

      rfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetRFIDCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetRFIDCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetRFIDCode", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_setrfid_code_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid,

    user_status,

    user_type,

    rfid_code

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetRFIDCodeResponse
void uic_mqtt_dotdot_on_door_lock_setrfid_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_setrfid_code_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkSetCodeStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_setrfid_code_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetRFIDCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetRFIDCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetRFIDCodeResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_setrfid_code_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetRFIDCodeResponse
static void uic_mqtt_dotdot_on_generated_door_lock_setrfid_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_setrfid_code_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkSetCodeStatus status;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_setrfid_code_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetRFIDCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetRFIDCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetRFIDCodeResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_setrfid_code_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetRFIDCode
void uic_mqtt_dotdot_on_door_lock_getrfid_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_getrfid_code_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkRFIDUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_getrfid_code(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetRFIDCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetRFIDCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetRFIDCode", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_getrfid_code_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetRFIDCode
static void uic_mqtt_dotdot_on_generated_door_lock_getrfid_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_getrfid_code_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkRFIDUserID userid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_getrfid_code(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetRFIDCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetRFIDCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetRFIDCode", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_getrfid_code_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetRFIDCodeResponse
void uic_mqtt_dotdot_on_door_lock_getrfid_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_getrfid_code_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t userid = {};
  DrlkUserStatus user_status = {};
  DrlkUserType user_type = {};
  const char* rfid_code = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_getrfid_code_response(
      jsn,
      userid,

      user_status,

      user_type,

      rfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetRFIDCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetRFIDCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetRFIDCodeResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_getrfid_code_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid,

    user_status,

    user_type,

    rfid_code

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetRFIDCodeResponse
static void uic_mqtt_dotdot_on_generated_door_lock_getrfid_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_getrfid_code_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t userid;
  DrlkUserStatus user_status;
  DrlkUserType user_type;
  const char* rfid_code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_getrfid_code_response(
      jsn,
      userid,

      user_status,

      user_type,

      rfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetRFIDCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetRFIDCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetRFIDCodeResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_getrfid_code_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid,

    user_status,

    user_type,

    rfid_code

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearRFIDCode
void uic_mqtt_dotdot_on_door_lock_clearrfid_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clearrfid_code_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkRFIDUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clearrfid_code(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearRFIDCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearRFIDCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearRFIDCode", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_clearrfid_code_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearRFIDCode
static void uic_mqtt_dotdot_on_generated_door_lock_clearrfid_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clearrfid_code_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkRFIDUserID userid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clearrfid_code(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearRFIDCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearRFIDCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearRFIDCode", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_clearrfid_code_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    userid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearRFIDCodeResponse
void uic_mqtt_dotdot_on_door_lock_clearrfid_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clearrfid_code_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clearrfid_code_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearRFIDCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearRFIDCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearRFIDCodeResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_clearrfid_code_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearRFIDCodeResponse
static void uic_mqtt_dotdot_on_generated_door_lock_clearrfid_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clearrfid_code_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clearrfid_code_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearRFIDCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearRFIDCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearRFIDCodeResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_clearrfid_code_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearAllRFIDCodes
void uic_mqtt_dotdot_on_door_lock_clear_allrfid_codes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_allrfid_codes_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearAllRFIDCodes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllRFIDCodes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllRFIDCodes", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_clear_allrfid_codes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearAllRFIDCodes
static void uic_mqtt_dotdot_on_generated_door_lock_clear_allrfid_codes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_allrfid_codes_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearAllRFIDCodes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllRFIDCodes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllRFIDCodes", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_clear_allrfid_codes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearAllRFIDCodesResponse
void uic_mqtt_dotdot_on_door_lock_clear_allrfid_codes_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_allrfid_codes_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_allrfid_codes_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearAllRFIDCodesResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllRFIDCodesResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllRFIDCodesResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_clear_allrfid_codes_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearAllRFIDCodesResponse
static void uic_mqtt_dotdot_on_generated_door_lock_clear_allrfid_codes_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_allrfid_codes_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_allrfid_codes_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearAllRFIDCodesResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllRFIDCodesResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllRFIDCodesResponse", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_clear_allrfid_codes_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    status

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/OperatingEventNotification
void uic_mqtt_dotdot_on_door_lock_operating_event_notification(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_operating_event_notification_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkOperEventSource operation_event_source = {};
  OperatingEventNotificationOperationEventCode operation_event_code = {};
  uint16_t userid = {};
  const char* pin = {};
  uint32_t local_time = {};
  const char* data = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_operating_event_notification(
      jsn,
      operation_event_source,

      operation_event_code,

      userid,

      pin,

      local_time,

      data
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "OperatingEventNotification");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "OperatingEventNotification", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "OperatingEventNotification", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_operating_event_notification_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    operation_event_source,

    operation_event_code,

    userid,

    pin,

    local_time,

    data

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/OperatingEventNotification
static void uic_mqtt_dotdot_on_generated_door_lock_operating_event_notification(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_operating_event_notification_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkOperEventSource operation_event_source;
  OperatingEventNotificationOperationEventCode operation_event_code;
  uint16_t userid;
  const char* pin;
  uint32_t local_time;
  const char* data;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_operating_event_notification(
      jsn,
      operation_event_source,

      operation_event_code,

      userid,

      pin,

      local_time,

      data
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "OperatingEventNotification");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "OperatingEventNotification", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "OperatingEventNotification", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_operating_event_notification_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    operation_event_source,

    operation_event_code,

    userid,

    pin,

    local_time,

    data

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ProgrammingEventNotification
void uic_mqtt_dotdot_on_door_lock_programming_event_notification(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_programming_event_notification_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  ProgrammingEventNotificationProgramEventSource program_event_source = {};
  ProgrammingEventNotificationProgramEventCode program_event_code = {};
  uint16_t userid = {};
  const char* pin = {};
  DrlkUserType user_type = {};
  DrlkUserStatus user_status = {};
  uint32_t local_time = {};
  const char* data = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_programming_event_notification(
      jsn,
      program_event_source,

      program_event_code,

      userid,

      pin,

      user_type,

      user_status,

      local_time,

      data
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ProgrammingEventNotification");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ProgrammingEventNotification", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ProgrammingEventNotification", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_programming_event_notification_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    program_event_source,

    program_event_code,

    userid,

    pin,

    user_type,

    user_status,

    local_time,

    data

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ProgrammingEventNotification
static void uic_mqtt_dotdot_on_generated_door_lock_programming_event_notification(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_programming_event_notification_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  ProgrammingEventNotificationProgramEventSource program_event_source;
  ProgrammingEventNotificationProgramEventCode program_event_code;
  uint16_t userid;
  const char* pin;
  DrlkUserType user_type;
  DrlkUserStatus user_status;
  uint32_t local_time;
  const char* data;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_programming_event_notification(
      jsn,
      program_event_source,

      program_event_code,

      userid,

      pin,

      user_type,

      user_status,

      local_time,

      data
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ProgrammingEventNotification");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ProgrammingEventNotification", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ProgrammingEventNotification", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_generated_programming_event_notification_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    program_event_source,

    program_event_code,

    userid,

    pin,

    user_type,

    user_status,

    local_time,

    data

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/WriteAttributes
void uic_mqtt_dotdot_on_door_lock_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_door_lock_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_door_lock_state_t new_state = {};
  uic_mqtt_dotdot_door_lock_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_door_lock_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_door_lock_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_door_lock_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_door_lock_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_door_lock_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.lock_state = true;
        force_update.lock_type = true;
        force_update.actuator_enabled = true;
        force_update.door_state = true;
        force_update.door_open_events = true;
        force_update.door_closed_events = true;
        force_update.open_period = true;
        force_update.number_of_log_records_supported = true;
        force_update.number_of_total_users_supported = true;
        force_update.number_ofpin_users_supported = true;
        force_update.number_ofrfid_users_supported = true;
        force_update.number_of_week_day_schedules_supported_per_user = true;
        force_update.number_of_year_day_schedules_supported_per_user = true;
        force_update.number_of_holiday_schedules_supported = true;
        force_update.maxpin_code_length = true;
        force_update.minpin_code_length = true;
        force_update.maxrfid_code_length = true;
        force_update.minrfid_code_length = true;
        force_update.enable_logging = true;
        force_update.language = true;
        force_update.led_settings = true;
        force_update.auto_relock_time = true;
        force_update.sound_volume = true;
        force_update.operating_mode = true;
        force_update.supported_operating_modes = true;
        force_update.default_configuration_register = true;
        force_update.enable_local_programming = true;
        force_update.enable_one_touch_locking = true;
        force_update.enable_inside_statusled = true;
        force_update.enable_privacy_mode_button = true;
        force_update.wrong_code_entry_limit = true;
        force_update.user_code_temporary_disable_time = true;
        force_update.sendpin_over_the_air = true;
        force_update.requirepi_nforrf_operation = true;
        force_update.security_level = true;
        force_update.alarm_mask = true;
        force_update.keypad_operation_event_mask = true;
        force_update.rf_operation_event_mask = true;
        force_update.manual_operation_event_mask = true;
        force_update.rfid_operation_event_mask = true;
        force_update.keypad_programming_event_mask = true;
        force_update.rf_programming_event_mask = true;
        force_update.rfid_programming_event_mask = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"LockState", &force_update.lock_state },
          {"LockType", &force_update.lock_type },
          {"ActuatorEnabled", &force_update.actuator_enabled },
          {"DoorState", &force_update.door_state },
          {"DoorOpenEvents", &force_update.door_open_events },
          {"DoorClosedEvents", &force_update.door_closed_events },
          {"OpenPeriod", &force_update.open_period },
          {"NumberOfLogRecordsSupported", &force_update.number_of_log_records_supported },
          {"NumberOfTotalUsersSupported", &force_update.number_of_total_users_supported },
          {"NumberOfPINUsersSupported", &force_update.number_ofpin_users_supported },
          {"NumberOfRFIDUsersSupported", &force_update.number_ofrfid_users_supported },
          {"NumberOfWeekDaySchedulesSupportedPerUser", &force_update.number_of_week_day_schedules_supported_per_user },
          {"NumberOfYearDaySchedulesSupportedPerUser", &force_update.number_of_year_day_schedules_supported_per_user },
          {"NumberOfHolidaySchedulesSupported", &force_update.number_of_holiday_schedules_supported },
          {"MaxPINCodeLength", &force_update.maxpin_code_length },
          {"MinPINCodeLength", &force_update.minpin_code_length },
          {"MaxRFIDCodeLength", &force_update.maxrfid_code_length },
          {"MinRFIDCodeLength", &force_update.minrfid_code_length },
          {"EnableLogging", &force_update.enable_logging },
          {"Language", &force_update.language },
          {"LEDSettings", &force_update.led_settings },
          {"AutoRelockTime", &force_update.auto_relock_time },
          {"SoundVolume", &force_update.sound_volume },
          {"OperatingMode", &force_update.operating_mode },
          {"SupportedOperatingModes", &force_update.supported_operating_modes },
          {"DefaultConfigurationRegister", &force_update.default_configuration_register },
          {"EnableLocalProgramming", &force_update.enable_local_programming },
          {"EnableOneTouchLocking", &force_update.enable_one_touch_locking },
          {"EnableInsideStatusLED", &force_update.enable_inside_statusled },
          {"EnablePrivacyModeButton", &force_update.enable_privacy_mode_button },
          {"WrongCodeEntryLimit", &force_update.wrong_code_entry_limit },
          {"UserCodeTemporaryDisableTime", &force_update.user_code_temporary_disable_time },
          {"SendPINOverTheAir", &force_update.sendpin_over_the_air },
          {"RequirePINforRFOperation", &force_update.requirepi_nforrf_operation },
          {"SecurityLevel", &force_update.security_level },
          {"AlarmMask", &force_update.alarm_mask },
          {"KeypadOperationEventMask", &force_update.keypad_operation_event_mask },
          {"RFOperationEventMask", &force_update.rf_operation_event_mask },
          {"ManualOperationEventMask", &force_update.manual_operation_event_mask },
          {"RFIDOperationEventMask", &force_update.rfid_operation_event_mask },
          {"KeypadProgrammingEventMask", &force_update.keypad_programming_event_mask },
          {"RFProgrammingEventMask", &force_update.rf_programming_event_mask },
          {"RFIDProgrammingEventMask", &force_update.rfid_programming_event_mask },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_door_lock_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "DoorLock/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_door_lock_lock_state_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef DOOR_LOCK_LOCK_STATE_ENUM_NAME_AVAILABLE
  jsn["value"] = door_lock_lock_state_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<DoorLockLockState>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/LockState", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/LockState";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_lock_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef DOOR_LOCK_LOCK_TYPE_ENUM_NAME_AVAILABLE
  jsn["value"] = door_lock_lock_type_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<DoorLockLockType>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/LockType", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/LockType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_actuator_enabled_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/ActuatorEnabled", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/ActuatorEnabled";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_door_state_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef DOOR_LOCK_DOOR_STATE_ENUM_NAME_AVAILABLE
  jsn["value"] = door_lock_door_state_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<DoorLockDoorState>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/DoorState", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/DoorState";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_door_open_events_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/DoorOpenEvents", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/DoorOpenEvents";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_door_closed_events_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/DoorClosedEvents", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/DoorClosedEvents";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_open_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/OpenPeriod", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/OpenPeriod";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_number_of_log_records_supported_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/NumberOfLogRecordsSupported", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/NumberOfLogRecordsSupported";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_number_of_total_users_supported_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/NumberOfTotalUsersSupported", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/NumberOfTotalUsersSupported";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_number_ofpin_users_supported_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/NumberOfPINUsersSupported", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/NumberOfPINUsersSupported";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_number_ofrfid_users_supported_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/NumberOfRFIDUsersSupported", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/NumberOfRFIDUsersSupported";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_number_of_week_day_schedules_supported_per_user_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/NumberOfWeekDaySchedulesSupportedPerUser", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/NumberOfWeekDaySchedulesSupportedPerUser";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_number_of_year_day_schedules_supported_per_user_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/NumberOfYearDaySchedulesSupportedPerUser", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/NumberOfYearDaySchedulesSupportedPerUser";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_number_of_holiday_schedules_supported_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/NumberOfHolidaySchedulesSupported", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/NumberOfHolidaySchedulesSupported";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_maxpin_code_length_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/MaxPINCodeLength", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/MaxPINCodeLength";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_minpin_code_length_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/MinPINCodeLength", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/MinPINCodeLength";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_maxrfid_code_length_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/MaxRFIDCodeLength", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/MaxRFIDCodeLength";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_minrfid_code_length_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/MinRFIDCodeLength", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/MinRFIDCodeLength";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_enable_logging_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/EnableLogging", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/EnableLogging";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_language_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/Language", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/Language";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_led_settings_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/LEDSettings", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/LEDSettings";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_auto_relock_time_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/AutoRelockTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/AutoRelockTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_sound_volume_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/SoundVolume", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/SoundVolume";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_operating_mode_publish(
  const char *base_topic,
  DrlkOperMode value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef DOOR_LOCK_OPERATING_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = door_lock_operating_mode_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<DrlkOperMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/OperatingMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/OperatingMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_supported_operating_modes_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DoorLockSupportedOperatingModes.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/SupportedOperatingModes", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/SupportedOperatingModes";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_default_configuration_register_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DoorLockDefaultConfigurationRegister.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/DefaultConfigurationRegister", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/DefaultConfigurationRegister";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_enable_local_programming_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/EnableLocalProgramming", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/EnableLocalProgramming";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_enable_one_touch_locking_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/EnableOneTouchLocking", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/EnableOneTouchLocking";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_enable_inside_statusled_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/EnableInsideStatusLED", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/EnableInsideStatusLED";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_enable_privacy_mode_button_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/EnablePrivacyModeButton", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/EnablePrivacyModeButton";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_wrong_code_entry_limit_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/WrongCodeEntryLimit", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/WrongCodeEntryLimit";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_user_code_temporary_disable_time_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/UserCodeTemporaryDisableTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/UserCodeTemporaryDisableTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_sendpin_over_the_air_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/SendPINOverTheAir", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/SendPINOverTheAir";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_requirepi_nforrf_operation_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/RequirePINforRFOperation", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/RequirePINforRFOperation";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_security_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef DOOR_LOCK_SECURITY_LEVEL_ENUM_NAME_AVAILABLE
  jsn["value"] = door_lock_security_level_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<DoorLockSecurityLevel>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/SecurityLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/SecurityLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_alarm_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DoorLockAlarmMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/AlarmMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/AlarmMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_keypad_operation_event_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DoorLockKeypadOperationEventMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/KeypadOperationEventMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/KeypadOperationEventMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_rf_operation_event_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DoorLockRFOperationEventMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/RFOperationEventMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/RFOperationEventMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_manual_operation_event_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DoorLockManualOperationEventMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/ManualOperationEventMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/ManualOperationEventMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_rfid_operation_event_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DoorLockRFIDOperationEventMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/RFIDOperationEventMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/RFIDOperationEventMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_keypad_programming_event_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DoorLockKeypadProgrammingEventMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/KeypadProgrammingEventMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/KeypadProgrammingEventMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_rf_programming_event_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DoorLockRFProgrammingEventMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/RFProgrammingEventMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/RFProgrammingEventMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_door_lock_rfid_programming_event_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DoorLockRFIDProgrammingEventMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/RFIDProgrammingEventMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/RFIDProgrammingEventMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_door_lock_write_attributes_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_WriteAttributes);
  }

  if(uic_mqtt_dotdot_door_lock_force_read_attributes_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_force_read_attributes);
  }
  if (uic_mqtt_dotdot_door_lock_lock_door_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/LockDoor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_lock_door);
  }
  if (uic_mqtt_dotdot_door_lock_generated_lock_door_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/LockDoor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_lock_door);
  }
  if (uic_mqtt_dotdot_door_lock_lock_door_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/LockDoorResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_lock_door_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_lock_door_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/LockDoorResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_lock_door_response);
  }
  if (uic_mqtt_dotdot_door_lock_unlock_door_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/UnlockDoor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_unlock_door);
  }
  if (uic_mqtt_dotdot_door_lock_generated_unlock_door_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/UnlockDoor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_unlock_door);
  }
  if (uic_mqtt_dotdot_door_lock_unlock_door_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/UnlockDoorResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_unlock_door_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_unlock_door_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/UnlockDoorResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_unlock_door_response);
  }
  if (uic_mqtt_dotdot_door_lock_toggle_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/Toggle";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_toggle);
  }
  if (uic_mqtt_dotdot_door_lock_generated_toggle_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/Toggle";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_toggle);
  }
  if (uic_mqtt_dotdot_door_lock_toggle_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/ToggleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_toggle_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_toggle_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ToggleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_toggle_response);
  }
  if (uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/UnlockWithTimeout";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_unlock_with_timeout);
  }
  if (uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/UnlockWithTimeout";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_unlock_with_timeout);
  }
  if (uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/UnlockWithTimeoutResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_unlock_with_timeout_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/UnlockWithTimeoutResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_unlock_with_timeout_response);
  }
  if (uic_mqtt_dotdot_door_lock_get_log_record_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/GetLogRecord";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_log_record);
  }
  if (uic_mqtt_dotdot_door_lock_generated_get_log_record_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetLogRecord";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_log_record);
  }
  if (uic_mqtt_dotdot_door_lock_get_log_record_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/GetLogRecordResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_log_record_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_get_log_record_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetLogRecordResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_log_record_response);
  }
  if (uic_mqtt_dotdot_door_lock_setpin_code_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/SetPINCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_setpin_code);
  }
  if (uic_mqtt_dotdot_door_lock_generated_setpin_code_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetPINCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_setpin_code);
  }
  if (uic_mqtt_dotdot_door_lock_setpin_code_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/SetPINCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_setpin_code_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_setpin_code_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetPINCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_setpin_code_response);
  }
  if (uic_mqtt_dotdot_door_lock_getpin_code_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/GetPINCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_getpin_code);
  }
  if (uic_mqtt_dotdot_door_lock_generated_getpin_code_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetPINCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_getpin_code);
  }
  if (uic_mqtt_dotdot_door_lock_getpin_code_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/GetPINCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_getpin_code_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_getpin_code_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetPINCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_getpin_code_response);
  }
  if (uic_mqtt_dotdot_door_lock_clearpin_code_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearPINCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clearpin_code);
  }
  if (uic_mqtt_dotdot_door_lock_generated_clearpin_code_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearPINCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clearpin_code);
  }
  if (uic_mqtt_dotdot_door_lock_clearpin_code_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearPINCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clearpin_code_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_clearpin_code_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearPINCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clearpin_code_response);
  }
  if (uic_mqtt_dotdot_door_lock_clear_allpin_codes_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearAllPINCodes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_allpin_codes);
  }
  if (uic_mqtt_dotdot_door_lock_generated_clear_allpin_codes_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearAllPINCodes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_allpin_codes);
  }
  if (uic_mqtt_dotdot_door_lock_clear_allpin_codes_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearAllPINCodesResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_allpin_codes_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_clear_allpin_codes_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearAllPINCodesResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_allpin_codes_response);
  }
  if (uic_mqtt_dotdot_door_lock_set_user_status_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/SetUserStatus";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_user_status);
  }
  if (uic_mqtt_dotdot_door_lock_generated_set_user_status_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetUserStatus";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_user_status);
  }
  if (uic_mqtt_dotdot_door_lock_set_user_status_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/SetUserStatusResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_user_status_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_set_user_status_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetUserStatusResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_user_status_response);
  }
  if (uic_mqtt_dotdot_door_lock_get_user_status_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/GetUserStatus";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_user_status);
  }
  if (uic_mqtt_dotdot_door_lock_generated_get_user_status_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetUserStatus";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_user_status);
  }
  if (uic_mqtt_dotdot_door_lock_get_user_status_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/GetUserStatusResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_user_status_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_get_user_status_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetUserStatusResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_user_status_response);
  }
  if (uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/SetWeekdaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_weekday_schedule);
  }
  if (uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetWeekdaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_weekday_schedule);
  }
  if (uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/SetWeekdayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_weekday_schedule_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetWeekdayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_weekday_schedule_response);
  }
  if (uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/GetWeekdaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_weekday_schedule);
  }
  if (uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetWeekdaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_weekday_schedule);
  }
  if (uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/GetWeekdayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_weekday_schedule_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetWeekdayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_weekday_schedule_response);
  }
  if (uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearWeekdaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_weekday_schedule);
  }
  if (uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearWeekdaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_weekday_schedule);
  }
  if (uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearWeekdayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_weekday_schedule_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearWeekdayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_weekday_schedule_response);
  }
  if (uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/SetYearDaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_year_day_schedule);
  }
  if (uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetYearDaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_year_day_schedule);
  }
  if (uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/SetYearDayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_year_day_schedule_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetYearDayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_year_day_schedule_response);
  }
  if (uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/GetYearDaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_year_day_schedule);
  }
  if (uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetYearDaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_year_day_schedule);
  }
  if (uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/GetYearDayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_year_day_schedule_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetYearDayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_year_day_schedule_response);
  }
  if (uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearYearDaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_year_day_schedule);
  }
  if (uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearYearDaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_year_day_schedule);
  }
  if (uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearYearDayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_year_day_schedule_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearYearDayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_year_day_schedule_response);
  }
  if (uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/SetHolidaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_holiday_schedule);
  }
  if (uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetHolidaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_holiday_schedule);
  }
  if (uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/SetHolidayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_holiday_schedule_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetHolidayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_holiday_schedule_response);
  }
  if (uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/GetHolidaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_holiday_schedule);
  }
  if (uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetHolidaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_holiday_schedule);
  }
  if (uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/GetHolidayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_holiday_schedule_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetHolidayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_holiday_schedule_response);
  }
  if (uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearHolidaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_holiday_schedule);
  }
  if (uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearHolidaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_holiday_schedule);
  }
  if (uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearHolidayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_holiday_schedule_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearHolidayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_holiday_schedule_response);
  }
  if (uic_mqtt_dotdot_door_lock_set_user_type_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/SetUserType";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_user_type);
  }
  if (uic_mqtt_dotdot_door_lock_generated_set_user_type_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetUserType";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_user_type);
  }
  if (uic_mqtt_dotdot_door_lock_set_user_type_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/SetUserTypeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_user_type_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_set_user_type_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetUserTypeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_user_type_response);
  }
  if (uic_mqtt_dotdot_door_lock_get_user_type_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/GetUserType";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_user_type);
  }
  if (uic_mqtt_dotdot_door_lock_generated_get_user_type_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetUserType";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_user_type);
  }
  if (uic_mqtt_dotdot_door_lock_get_user_type_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/GetUserTypeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_user_type_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_get_user_type_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetUserTypeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_user_type_response);
  }
  if (uic_mqtt_dotdot_door_lock_setrfid_code_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/SetRFIDCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_setrfid_code);
  }
  if (uic_mqtt_dotdot_door_lock_generated_setrfid_code_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetRFIDCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_setrfid_code);
  }
  if (uic_mqtt_dotdot_door_lock_setrfid_code_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/SetRFIDCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_setrfid_code_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_setrfid_code_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetRFIDCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_setrfid_code_response);
  }
  if (uic_mqtt_dotdot_door_lock_getrfid_code_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/GetRFIDCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_getrfid_code);
  }
  if (uic_mqtt_dotdot_door_lock_generated_getrfid_code_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetRFIDCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_getrfid_code);
  }
  if (uic_mqtt_dotdot_door_lock_getrfid_code_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/GetRFIDCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_getrfid_code_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_getrfid_code_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetRFIDCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_getrfid_code_response);
  }
  if (uic_mqtt_dotdot_door_lock_clearrfid_code_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearRFIDCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clearrfid_code);
  }
  if (uic_mqtt_dotdot_door_lock_generated_clearrfid_code_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearRFIDCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clearrfid_code);
  }
  if (uic_mqtt_dotdot_door_lock_clearrfid_code_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearRFIDCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clearrfid_code_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_clearrfid_code_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearRFIDCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clearrfid_code_response);
  }
  if (uic_mqtt_dotdot_door_lock_clear_allrfid_codes_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearAllRFIDCodes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_allrfid_codes);
  }
  if (uic_mqtt_dotdot_door_lock_generated_clear_allrfid_codes_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearAllRFIDCodes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_allrfid_codes);
  }
  if (uic_mqtt_dotdot_door_lock_clear_allrfid_codes_response_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearAllRFIDCodesResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_allrfid_codes_response);
  }
  if (uic_mqtt_dotdot_door_lock_generated_clear_allrfid_codes_response_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearAllRFIDCodesResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_allrfid_codes_response);
  }
  if (uic_mqtt_dotdot_door_lock_operating_event_notification_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/OperatingEventNotification";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_operating_event_notification);
  }
  if (uic_mqtt_dotdot_door_lock_generated_operating_event_notification_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/OperatingEventNotification";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_operating_event_notification);
  }
  if (uic_mqtt_dotdot_door_lock_programming_event_notification_callback) {
    subscription_topic = base_topic + "DoorLock/Commands/ProgrammingEventNotification";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_programming_event_notification);
  }
  if (uic_mqtt_dotdot_door_lock_generated_programming_event_notification_callback) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ProgrammingEventNotification";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_programming_event_notification);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_door_lock_attributes_init();

  uic_mqtt_dotdot_by_group_door_lock_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_window_covering_up_or_open_callback_t uic_mqtt_dotdot_window_covering_up_or_open_callback = nullptr;
static uic_mqtt_dotdot_window_covering_up_or_open_callback_t uic_mqtt_dotdot_window_covering_generated_up_or_open_callback = nullptr;
uic_mqtt_dotdot_window_covering_down_or_close_callback_t uic_mqtt_dotdot_window_covering_down_or_close_callback = nullptr;
static uic_mqtt_dotdot_window_covering_down_or_close_callback_t uic_mqtt_dotdot_window_covering_generated_down_or_close_callback = nullptr;
uic_mqtt_dotdot_window_covering_stop_callback_t uic_mqtt_dotdot_window_covering_stop_callback = nullptr;
static uic_mqtt_dotdot_window_covering_stop_callback_t uic_mqtt_dotdot_window_covering_generated_stop_callback = nullptr;
uic_mqtt_dotdot_window_covering_go_to_lift_value_callback_t uic_mqtt_dotdot_window_covering_go_to_lift_value_callback = nullptr;
static uic_mqtt_dotdot_window_covering_go_to_lift_value_callback_t uic_mqtt_dotdot_window_covering_generated_go_to_lift_value_callback = nullptr;
uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback_t uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback = nullptr;
static uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback_t uic_mqtt_dotdot_window_covering_generated_go_to_lift_percentage_callback = nullptr;
uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback_t uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback = nullptr;
static uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback_t uic_mqtt_dotdot_window_covering_generated_go_to_tilt_value_callback = nullptr;
uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback_t uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback = nullptr;
static uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback_t uic_mqtt_dotdot_window_covering_generated_go_to_tilt_percentage_callback = nullptr;
uic_mqtt_dotdot_window_covering_write_attributes_callback_t uic_mqtt_dotdot_window_covering_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_window_covering_force_read_attributes_callback_t uic_mqtt_dotdot_window_covering_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_window_covering_up_or_open_callback_set(const uic_mqtt_dotdot_window_covering_up_or_open_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_up_or_open_callback = callback;
}
void uic_mqtt_dotdot_window_covering_generated_up_or_open_callback_set(const uic_mqtt_dotdot_window_covering_up_or_open_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_generated_up_or_open_callback = callback;
}

void uic_mqtt_dotdot_window_covering_down_or_close_callback_set(const uic_mqtt_dotdot_window_covering_down_or_close_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_down_or_close_callback = callback;
}
void uic_mqtt_dotdot_window_covering_generated_down_or_close_callback_set(const uic_mqtt_dotdot_window_covering_down_or_close_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_generated_down_or_close_callback = callback;
}

void uic_mqtt_dotdot_window_covering_stop_callback_set(const uic_mqtt_dotdot_window_covering_stop_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_stop_callback = callback;
}
void uic_mqtt_dotdot_window_covering_generated_stop_callback_set(const uic_mqtt_dotdot_window_covering_stop_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_generated_stop_callback = callback;
}

void uic_mqtt_dotdot_window_covering_go_to_lift_value_callback_set(const uic_mqtt_dotdot_window_covering_go_to_lift_value_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_go_to_lift_value_callback = callback;
}
void uic_mqtt_dotdot_window_covering_generated_go_to_lift_value_callback_set(const uic_mqtt_dotdot_window_covering_go_to_lift_value_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_generated_go_to_lift_value_callback = callback;
}

void uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback_set(const uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback = callback;
}
void uic_mqtt_dotdot_window_covering_generated_go_to_lift_percentage_callback_set(const uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_generated_go_to_lift_percentage_callback = callback;
}

void uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback_set(const uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback = callback;
}
void uic_mqtt_dotdot_window_covering_generated_go_to_tilt_value_callback_set(const uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_generated_go_to_tilt_value_callback = callback;
}

void uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback_set(const uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback = callback;
}
void uic_mqtt_dotdot_window_covering_generated_go_to_tilt_percentage_callback_set(const uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_generated_go_to_tilt_percentage_callback = callback;
}


void uic_mqtt_dotdot_set_window_covering_write_attributes_callback(
  const uic_mqtt_dotdot_window_covering_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_window_covering_force_read_attributes_callback(
  const uic_mqtt_dotdot_window_covering_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/Commands/UpOrOpen
void uic_mqtt_dotdot_on_window_covering_up_or_open(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_up_or_open_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "UpOrOpen");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "UpOrOpen", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "UpOrOpen", "");
    return;
  }

  uic_mqtt_dotdot_window_covering_up_or_open_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/GeneratedCommands/UpOrOpen
static void uic_mqtt_dotdot_on_generated_window_covering_up_or_open(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_generated_up_or_open_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "UpOrOpen");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "UpOrOpen", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "UpOrOpen", "");
    return;
  }

  uic_mqtt_dotdot_window_covering_generated_up_or_open_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/Commands/DownOrClose
void uic_mqtt_dotdot_on_window_covering_down_or_close(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_down_or_close_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "DownOrClose");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "DownOrClose", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "DownOrClose", "");
    return;
  }

  uic_mqtt_dotdot_window_covering_down_or_close_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/GeneratedCommands/DownOrClose
static void uic_mqtt_dotdot_on_generated_window_covering_down_or_close(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_generated_down_or_close_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "DownOrClose");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "DownOrClose", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "DownOrClose", "");
    return;
  }

  uic_mqtt_dotdot_window_covering_generated_down_or_close_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/Commands/Stop
void uic_mqtt_dotdot_on_window_covering_stop(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_stop_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "Stop");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "Stop", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "Stop", "");
    return;
  }

  uic_mqtt_dotdot_window_covering_stop_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/GeneratedCommands/Stop
static void uic_mqtt_dotdot_on_generated_window_covering_stop(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_generated_stop_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "Stop");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "Stop", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "Stop", "");
    return;
  }

  uic_mqtt_dotdot_window_covering_generated_stop_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/Commands/GoToLiftValue
void uic_mqtt_dotdot_on_window_covering_go_to_lift_value(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_go_to_lift_value_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t lift_value = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_window_covering_go_to_lift_value(
      jsn,
      lift_value
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "GoToLiftValue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToLiftValue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToLiftValue", "");
    return;
  }

  uic_mqtt_dotdot_window_covering_go_to_lift_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    lift_value

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/GeneratedCommands/GoToLiftValue
static void uic_mqtt_dotdot_on_generated_window_covering_go_to_lift_value(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_generated_go_to_lift_value_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t lift_value;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_window_covering_go_to_lift_value(
      jsn,
      lift_value
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "GoToLiftValue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToLiftValue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToLiftValue", "");
    return;
  }

  uic_mqtt_dotdot_window_covering_generated_go_to_lift_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    lift_value

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/Commands/GoToLiftPercentage
void uic_mqtt_dotdot_on_window_covering_go_to_lift_percentage(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t percentage_lift_value = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_window_covering_go_to_lift_percentage(
      jsn,
      percentage_lift_value
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "GoToLiftPercentage");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToLiftPercentage", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToLiftPercentage", "");
    return;
  }

  uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    percentage_lift_value

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/GeneratedCommands/GoToLiftPercentage
static void uic_mqtt_dotdot_on_generated_window_covering_go_to_lift_percentage(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_generated_go_to_lift_percentage_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t percentage_lift_value;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_window_covering_go_to_lift_percentage(
      jsn,
      percentage_lift_value
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "GoToLiftPercentage");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToLiftPercentage", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToLiftPercentage", "");
    return;
  }

  uic_mqtt_dotdot_window_covering_generated_go_to_lift_percentage_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    percentage_lift_value

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/Commands/GoToTiltValue
void uic_mqtt_dotdot_on_window_covering_go_to_tilt_value(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t tilt_value = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_window_covering_go_to_tilt_value(
      jsn,
      tilt_value
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "GoToTiltValue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToTiltValue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToTiltValue", "");
    return;
  }

  uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    tilt_value

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/GeneratedCommands/GoToTiltValue
static void uic_mqtt_dotdot_on_generated_window_covering_go_to_tilt_value(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_generated_go_to_tilt_value_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t tilt_value;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_window_covering_go_to_tilt_value(
      jsn,
      tilt_value
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "GoToTiltValue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToTiltValue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToTiltValue", "");
    return;
  }

  uic_mqtt_dotdot_window_covering_generated_go_to_tilt_value_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    tilt_value

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/Commands/GoToTiltPercentage
void uic_mqtt_dotdot_on_window_covering_go_to_tilt_percentage(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t percentage_tilt_value = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_window_covering_go_to_tilt_percentage(
      jsn,
      percentage_tilt_value
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "GoToTiltPercentage");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToTiltPercentage", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToTiltPercentage", "");
    return;
  }

  uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    percentage_tilt_value

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/GeneratedCommands/GoToTiltPercentage
static void uic_mqtt_dotdot_on_generated_window_covering_go_to_tilt_percentage(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_generated_go_to_tilt_percentage_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t percentage_tilt_value;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_window_covering_go_to_tilt_percentage(
      jsn,
      percentage_tilt_value
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "GoToTiltPercentage");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToTiltPercentage", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToTiltPercentage", "");
    return;
  }

  uic_mqtt_dotdot_window_covering_generated_go_to_tilt_percentage_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    percentage_tilt_value

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/Commands/WriteAttributes
void uic_mqtt_dotdot_on_window_covering_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_window_covering_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_window_covering_state_t new_state = {};
  uic_mqtt_dotdot_window_covering_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_window_covering_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_window_covering_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_window_covering_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_window_covering_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_window_covering_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.window_covering_type = true;
        force_update.physical_closed_limit_lift = true;
        force_update.physical_closed_limit_tilt = true;
        force_update.current_position_lift = true;
        force_update.current_position_tilt = true;
        force_update.number_of_actuations_lift = true;
        force_update.number_of_actuations_tilt = true;
        force_update.config_or_status = true;
        force_update.current_position_lift_percentage = true;
        force_update.current_position_tilt_percentage = true;
        force_update.installed_open_limit_lift = true;
        force_update.installed_closed_limit_lift = true;
        force_update.installed_open_limit_tilt = true;
        force_update.installed_closed_limit_tilt = true;
        force_update.velocity_lift = true;
        force_update.acceleration_time_lift = true;
        force_update.deceleration_time_lift = true;
        force_update.mode = true;
        force_update.intermediate_setpoints_lift = true;
        force_update.intermediate_setpoints_tilt = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"WindowCoveringType", &force_update.window_covering_type },
          {"PhysicalClosedLimitLift", &force_update.physical_closed_limit_lift },
          {"PhysicalClosedLimitTilt", &force_update.physical_closed_limit_tilt },
          {"CurrentPositionLift", &force_update.current_position_lift },
          {"CurrentPositionTilt", &force_update.current_position_tilt },
          {"NumberOfActuationsLift", &force_update.number_of_actuations_lift },
          {"NumberOfActuationsTilt", &force_update.number_of_actuations_tilt },
          {"ConfigOrStatus", &force_update.config_or_status },
          {"CurrentPositionLiftPercentage", &force_update.current_position_lift_percentage },
          {"CurrentPositionTiltPercentage", &force_update.current_position_tilt_percentage },
          {"InstalledOpenLimitLift", &force_update.installed_open_limit_lift },
          {"InstalledClosedLimitLift", &force_update.installed_closed_limit_lift },
          {"InstalledOpenLimitTilt", &force_update.installed_open_limit_tilt },
          {"InstalledClosedLimitTilt", &force_update.installed_closed_limit_tilt },
          {"VelocityLift", &force_update.velocity_lift },
          {"AccelerationTimeLift", &force_update.acceleration_time_lift },
          {"DecelerationTimeLift", &force_update.deceleration_time_lift },
          {"Mode", &force_update.mode },
          {"IntermediateSetpointsLift", &force_update.intermediate_setpoints_lift },
          {"IntermediateSetpointsTilt", &force_update.intermediate_setpoints_tilt },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_window_covering_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "WindowCovering/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_window_covering_window_covering_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef WINDOW_COVERING_WINDOW_COVERING_TYPE_ENUM_NAME_AVAILABLE
  jsn["value"] = window_covering_window_covering_type_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<WindowCoveringWindowCoveringType>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/WindowCoveringType", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/WindowCoveringType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_window_covering_physical_closed_limit_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/PhysicalClosedLimitLift", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/PhysicalClosedLimitLift";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_window_covering_physical_closed_limit_tilt_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/PhysicalClosedLimitTilt", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/PhysicalClosedLimitTilt";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_window_covering_current_position_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/CurrentPositionLift", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/CurrentPositionLift";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_window_covering_current_position_tilt_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/CurrentPositionTilt", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/CurrentPositionTilt";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_window_covering_number_of_actuations_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/NumberOfActuationsLift", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/NumberOfActuationsLift";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_window_covering_number_of_actuations_tilt_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/NumberOfActuationsTilt", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/NumberOfActuationsTilt";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_window_covering_config_or_status_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = WindowCoveringConfigOrStatus.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/ConfigOrStatus", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/ConfigOrStatus";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_window_covering_current_position_lift_percentage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/CurrentPositionLiftPercentage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/CurrentPositionLiftPercentage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_window_covering_current_position_tilt_percentage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/CurrentPositionTiltPercentage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/CurrentPositionTiltPercentage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_window_covering_installed_open_limit_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/InstalledOpenLimitLift", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/InstalledOpenLimitLift";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_window_covering_installed_closed_limit_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/InstalledClosedLimitLift", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/InstalledClosedLimitLift";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_window_covering_installed_open_limit_tilt_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/InstalledOpenLimitTilt", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/InstalledOpenLimitTilt";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_window_covering_installed_closed_limit_tilt_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/InstalledClosedLimitTilt", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/InstalledClosedLimitTilt";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_window_covering_velocity_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/VelocityLift", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/VelocityLift";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_window_covering_acceleration_time_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/AccelerationTimeLift", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/AccelerationTimeLift";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_window_covering_deceleration_time_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/DecelerationTimeLift", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/DecelerationTimeLift";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_window_covering_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = WindowCoveringMode.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/Mode", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/Mode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_window_covering_intermediate_setpoints_lift_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/IntermediateSetpointsLift", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/IntermediateSetpointsLift";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_window_covering_intermediate_setpoints_tilt_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/IntermediateSetpointsTilt", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/IntermediateSetpointsTilt";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_window_covering_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_window_covering_write_attributes_callback) {
    subscription_topic = base_topic + "WindowCovering/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_window_covering_WriteAttributes);
  }

  if(uic_mqtt_dotdot_window_covering_force_read_attributes_callback) {
    subscription_topic = base_topic + "WindowCovering/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_window_covering_force_read_attributes);
  }
  if (uic_mqtt_dotdot_window_covering_up_or_open_callback) {
    subscription_topic = base_topic + "WindowCovering/Commands/UpOrOpen";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_window_covering_up_or_open);
  }
  if (uic_mqtt_dotdot_window_covering_generated_up_or_open_callback) {
    subscription_topic = base_topic + "WindowCovering/GeneratedCommands/UpOrOpen";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_window_covering_up_or_open);
  }
  if (uic_mqtt_dotdot_window_covering_down_or_close_callback) {
    subscription_topic = base_topic + "WindowCovering/Commands/DownOrClose";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_window_covering_down_or_close);
  }
  if (uic_mqtt_dotdot_window_covering_generated_down_or_close_callback) {
    subscription_topic = base_topic + "WindowCovering/GeneratedCommands/DownOrClose";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_window_covering_down_or_close);
  }
  if (uic_mqtt_dotdot_window_covering_stop_callback) {
    subscription_topic = base_topic + "WindowCovering/Commands/Stop";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_window_covering_stop);
  }
  if (uic_mqtt_dotdot_window_covering_generated_stop_callback) {
    subscription_topic = base_topic + "WindowCovering/GeneratedCommands/Stop";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_window_covering_stop);
  }
  if (uic_mqtt_dotdot_window_covering_go_to_lift_value_callback) {
    subscription_topic = base_topic + "WindowCovering/Commands/GoToLiftValue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_window_covering_go_to_lift_value);
  }
  if (uic_mqtt_dotdot_window_covering_generated_go_to_lift_value_callback) {
    subscription_topic = base_topic + "WindowCovering/GeneratedCommands/GoToLiftValue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_window_covering_go_to_lift_value);
  }
  if (uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback) {
    subscription_topic = base_topic + "WindowCovering/Commands/GoToLiftPercentage";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_window_covering_go_to_lift_percentage);
  }
  if (uic_mqtt_dotdot_window_covering_generated_go_to_lift_percentage_callback) {
    subscription_topic = base_topic + "WindowCovering/GeneratedCommands/GoToLiftPercentage";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_window_covering_go_to_lift_percentage);
  }
  if (uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback) {
    subscription_topic = base_topic + "WindowCovering/Commands/GoToTiltValue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_window_covering_go_to_tilt_value);
  }
  if (uic_mqtt_dotdot_window_covering_generated_go_to_tilt_value_callback) {
    subscription_topic = base_topic + "WindowCovering/GeneratedCommands/GoToTiltValue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_window_covering_go_to_tilt_value);
  }
  if (uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback) {
    subscription_topic = base_topic + "WindowCovering/Commands/GoToTiltPercentage";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_window_covering_go_to_tilt_percentage);
  }
  if (uic_mqtt_dotdot_window_covering_generated_go_to_tilt_percentage_callback) {
    subscription_topic = base_topic + "WindowCovering/GeneratedCommands/GoToTiltPercentage";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_window_covering_go_to_tilt_percentage);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_window_covering_attributes_init();

  uic_mqtt_dotdot_by_group_window_covering_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_barrier_control_go_to_percent_callback_t uic_mqtt_dotdot_barrier_control_go_to_percent_callback = nullptr;
static uic_mqtt_dotdot_barrier_control_go_to_percent_callback_t uic_mqtt_dotdot_barrier_control_generated_go_to_percent_callback = nullptr;
uic_mqtt_dotdot_barrier_control_stop_callback_t uic_mqtt_dotdot_barrier_control_stop_callback = nullptr;
static uic_mqtt_dotdot_barrier_control_stop_callback_t uic_mqtt_dotdot_barrier_control_generated_stop_callback = nullptr;
uic_mqtt_dotdot_barrier_control_write_attributes_callback_t uic_mqtt_dotdot_barrier_control_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_barrier_control_force_read_attributes_callback_t uic_mqtt_dotdot_barrier_control_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_barrier_control_go_to_percent_callback_set(const uic_mqtt_dotdot_barrier_control_go_to_percent_callback_t callback)
{
  uic_mqtt_dotdot_barrier_control_go_to_percent_callback = callback;
}
void uic_mqtt_dotdot_barrier_control_generated_go_to_percent_callback_set(const uic_mqtt_dotdot_barrier_control_go_to_percent_callback_t callback)
{
  uic_mqtt_dotdot_barrier_control_generated_go_to_percent_callback = callback;
}

void uic_mqtt_dotdot_barrier_control_stop_callback_set(const uic_mqtt_dotdot_barrier_control_stop_callback_t callback)
{
  uic_mqtt_dotdot_barrier_control_stop_callback = callback;
}
void uic_mqtt_dotdot_barrier_control_generated_stop_callback_set(const uic_mqtt_dotdot_barrier_control_stop_callback_t callback)
{
  uic_mqtt_dotdot_barrier_control_generated_stop_callback = callback;
}


void uic_mqtt_dotdot_set_barrier_control_write_attributes_callback(
  const uic_mqtt_dotdot_barrier_control_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_barrier_control_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_barrier_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_barrier_control_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_barrier_control_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/BarrierControl/Commands/GoToPercent
void uic_mqtt_dotdot_on_barrier_control_go_to_percent(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_barrier_control_go_to_percent_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t percent_open = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_barrier_control_go_to_percent(
      jsn,
      percent_open
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "BarrierControl", "GoToPercent");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "GoToPercent", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "GoToPercent", "");
    return;
  }

  uic_mqtt_dotdot_barrier_control_go_to_percent_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    percent_open

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/BarrierControl/GeneratedCommands/GoToPercent
static void uic_mqtt_dotdot_on_generated_barrier_control_go_to_percent(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_barrier_control_generated_go_to_percent_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t percent_open;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_barrier_control_go_to_percent(
      jsn,
      percent_open
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "BarrierControl", "GoToPercent");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "GoToPercent", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "GoToPercent", "");
    return;
  }

  uic_mqtt_dotdot_barrier_control_generated_go_to_percent_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    percent_open

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/BarrierControl/Commands/Stop
void uic_mqtt_dotdot_on_barrier_control_stop(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_barrier_control_stop_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "BarrierControl", "Stop");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "Stop", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "Stop", "");
    return;
  }

  uic_mqtt_dotdot_barrier_control_stop_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/BarrierControl/GeneratedCommands/Stop
static void uic_mqtt_dotdot_on_generated_barrier_control_stop(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_barrier_control_generated_stop_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "BarrierControl", "Stop");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "Stop", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "Stop", "");
    return;
  }

  uic_mqtt_dotdot_barrier_control_generated_stop_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/BarrierControl/Commands/WriteAttributes
void uic_mqtt_dotdot_on_barrier_control_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_barrier_control_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_barrier_control_state_t new_state = {};
  uic_mqtt_dotdot_barrier_control_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_barrier_control_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "BarrierControl", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_barrier_control_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_barrier_control_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_barrier_control_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_barrier_control_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.moving_state = true;
        force_update.safety_status = true;
        force_update.capabilities = true;
        force_update.open_events = true;
        force_update.close_events = true;
        force_update.command_open_events = true;
        force_update.command_close_events = true;
        force_update.open_period = true;
        force_update.close_period = true;
        force_update.barrier_position = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"MovingState", &force_update.moving_state },
          {"SafetyStatus", &force_update.safety_status },
          {"Capabilities", &force_update.capabilities },
          {"OpenEvents", &force_update.open_events },
          {"CloseEvents", &force_update.close_events },
          {"CommandOpenEvents", &force_update.command_open_events },
          {"CommandCloseEvents", &force_update.command_close_events },
          {"OpenPeriod", &force_update.open_period },
          {"ClosePeriod", &force_update.close_period },
          {"BarrierPosition", &force_update.barrier_position },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_barrier_control_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "BarrierControl/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_barrier_control_moving_state_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef BARRIER_CONTROL_MOVING_STATE_ENUM_NAME_AVAILABLE
  jsn["value"] = barrier_control_moving_state_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<BarrierControlMovingState>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl/Attributes/MovingState", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BarrierControl/Attributes/MovingState";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_barrier_control_safety_status_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BarrierControlSafetyStatus.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl/Attributes/SafetyStatus", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/BarrierControl/Attributes/SafetyStatus";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_barrier_control_capabilities_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BarrierControlCapabilities.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl/Attributes/Capabilities", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/BarrierControl/Attributes/Capabilities";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_barrier_control_open_events_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl/Attributes/OpenEvents", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BarrierControl/Attributes/OpenEvents";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_barrier_control_close_events_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl/Attributes/CloseEvents", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BarrierControl/Attributes/CloseEvents";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_barrier_control_command_open_events_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl/Attributes/CommandOpenEvents", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BarrierControl/Attributes/CommandOpenEvents";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_barrier_control_command_close_events_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl/Attributes/CommandCloseEvents", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BarrierControl/Attributes/CommandCloseEvents";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_barrier_control_open_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl/Attributes/OpenPeriod", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BarrierControl/Attributes/OpenPeriod";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_barrier_control_close_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl/Attributes/ClosePeriod", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BarrierControl/Attributes/ClosePeriod";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_barrier_control_barrier_position_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl/Attributes/BarrierPosition", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BarrierControl/Attributes/BarrierPosition";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_barrier_control_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_barrier_control_write_attributes_callback) {
    subscription_topic = base_topic + "BarrierControl/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_barrier_control_WriteAttributes);
  }

  if(uic_mqtt_dotdot_barrier_control_force_read_attributes_callback) {
    subscription_topic = base_topic + "BarrierControl/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_barrier_control_force_read_attributes);
  }
  if (uic_mqtt_dotdot_barrier_control_go_to_percent_callback) {
    subscription_topic = base_topic + "BarrierControl/Commands/GoToPercent";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_barrier_control_go_to_percent);
  }
  if (uic_mqtt_dotdot_barrier_control_generated_go_to_percent_callback) {
    subscription_topic = base_topic + "BarrierControl/GeneratedCommands/GoToPercent";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_barrier_control_go_to_percent);
  }
  if (uic_mqtt_dotdot_barrier_control_stop_callback) {
    subscription_topic = base_topic + "BarrierControl/Commands/Stop";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_barrier_control_stop);
  }
  if (uic_mqtt_dotdot_barrier_control_generated_stop_callback) {
    subscription_topic = base_topic + "BarrierControl/GeneratedCommands/Stop";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_barrier_control_stop);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_barrier_control_attributes_init();

  uic_mqtt_dotdot_by_group_barrier_control_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback_t uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_callback_t uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_pump_configuration_and_control_write_attributes_callback(
  const uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_pump_configuration_and_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/PumpConfigurationAndControl/Commands/WriteAttributes
void uic_mqtt_dotdot_on_pump_configuration_and_control_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_state_t new_state = {};
  uic_mqtt_dotdot_pump_configuration_and_control_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_pump_configuration_and_control_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PumpConfigurationAndControl", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_pump_configuration_and_control_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_pump_configuration_and_control_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.max_pressure = true;
        force_update.max_speed = true;
        force_update.max_flow = true;
        force_update.min_const_pressure = true;
        force_update.max_const_pressure = true;
        force_update.min_comp_pressure = true;
        force_update.max_comp_pressure = true;
        force_update.min_const_speed = true;
        force_update.max_const_speed = true;
        force_update.min_const_flow = true;
        force_update.max_const_flow = true;
        force_update.min_const_temp = true;
        force_update.max_const_temp = true;
        force_update.pump_status = true;
        force_update.effective_operation_mode = true;
        force_update.effective_control_mode = true;
        force_update.capacity = true;
        force_update.speed = true;
        force_update.lifetime_running_hours = true;
        force_update.power = true;
        force_update.lifetime_energy_consumed = true;
        force_update.operation_mode = true;
        force_update.control_mode = true;
        force_update.alarm_mask = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"MaxPressure", &force_update.max_pressure },
          {"MaxSpeed", &force_update.max_speed },
          {"MaxFlow", &force_update.max_flow },
          {"MinConstPressure", &force_update.min_const_pressure },
          {"MaxConstPressure", &force_update.max_const_pressure },
          {"MinCompPressure", &force_update.min_comp_pressure },
          {"MaxCompPressure", &force_update.max_comp_pressure },
          {"MinConstSpeed", &force_update.min_const_speed },
          {"MaxConstSpeed", &force_update.max_const_speed },
          {"MinConstFlow", &force_update.min_const_flow },
          {"MaxConstFlow", &force_update.max_const_flow },
          {"MinConstTemp", &force_update.min_const_temp },
          {"MaxConstTemp", &force_update.max_const_temp },
          {"PumpStatus", &force_update.pump_status },
          {"EffectiveOperationMode", &force_update.effective_operation_mode },
          {"EffectiveControlMode", &force_update.effective_control_mode },
          {"Capacity", &force_update.capacity },
          {"Speed", &force_update.speed },
          {"LifetimeRunningHours", &force_update.lifetime_running_hours },
          {"Power", &force_update.power },
          {"LifetimeEnergyConsumed", &force_update.lifetime_energy_consumed },
          {"OperationMode", &force_update.operation_mode },
          {"ControlMode", &force_update.control_mode },
          {"AlarmMask", &force_update.alarm_mask },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "PumpConfigurationAndControl/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_pressure_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MaxPressure", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MaxPressure";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_speed_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MaxSpeed", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MaxSpeed";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_flow_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MaxFlow", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MaxFlow";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_min_const_pressure_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MinConstPressure", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MinConstPressure";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_const_pressure_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MaxConstPressure", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MaxConstPressure";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_min_comp_pressure_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MinCompPressure", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MinCompPressure";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_comp_pressure_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MaxCompPressure", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MaxCompPressure";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_min_const_speed_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MinConstSpeed", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MinConstSpeed";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_const_speed_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MaxConstSpeed", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MaxConstSpeed";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_min_const_flow_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MinConstFlow", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MinConstFlow";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_const_flow_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MaxConstFlow", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MaxConstFlow";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_min_const_temp_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MinConstTemp", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MinConstTemp";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_const_temp_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MaxConstTemp", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MaxConstTemp";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_pump_status_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = PumpConfigurationAndControlPumpStatus.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/PumpStatus", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/PumpStatus";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_effective_operation_mode_publish(
  const char *base_topic,
  PumpOperationMode value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_OPERATION_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = pump_configuration_and_control_effective_operation_mode_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<PumpOperationMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/EffectiveOperationMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/EffectiveOperationMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_effective_control_mode_publish(
  const char *base_topic,
  PumpControlMode value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_CONTROL_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = pump_configuration_and_control_effective_control_mode_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<PumpControlMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/EffectiveControlMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/EffectiveControlMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_capacity_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/Capacity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/Capacity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_speed_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/Speed", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/Speed";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_lifetime_running_hours_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/LifetimeRunningHours", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/LifetimeRunningHours";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_power_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/Power", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/Power";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_lifetime_energy_consumed_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/LifetimeEnergyConsumed", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/LifetimeEnergyConsumed";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_operation_mode_publish(
  const char *base_topic,
  PumpOperationMode value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef PUMP_CONFIGURATION_AND_CONTROL_OPERATION_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = pump_configuration_and_control_operation_mode_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<PumpOperationMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/OperationMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/OperationMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_control_mode_publish(
  const char *base_topic,
  PumpControlMode value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef PUMP_CONFIGURATION_AND_CONTROL_CONTROL_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = pump_configuration_and_control_control_mode_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<PumpControlMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/ControlMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/ControlMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_alarm_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = PumpConfigurationAndControlAlarmMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/AlarmMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/AlarmMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_pump_configuration_and_control_WriteAttributes);
  }

  if(uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_callback) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_pump_configuration_and_control_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_pump_configuration_and_control_attributes_init();

  uic_mqtt_dotdot_by_group_pump_configuration_and_control_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback_t uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback = nullptr;
static uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback_t uic_mqtt_dotdot_thermostat_generated_setpoint_raise_or_lower_callback = nullptr;
uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback_t uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback = nullptr;
static uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback_t uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_response_callback = nullptr;
uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback_t uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback = nullptr;
static uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback_t uic_mqtt_dotdot_thermostat_generated_set_weekly_schedule_callback = nullptr;
uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback_t uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback = nullptr;
static uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback_t uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_response_callback = nullptr;
uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback_t uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback = nullptr;
static uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback_t uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_callback = nullptr;
uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback_t uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback = nullptr;
static uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback_t uic_mqtt_dotdot_thermostat_generated_clear_weekly_schedule_callback = nullptr;
uic_mqtt_dotdot_thermostat_get_relay_status_log_callback_t uic_mqtt_dotdot_thermostat_get_relay_status_log_callback = nullptr;
static uic_mqtt_dotdot_thermostat_get_relay_status_log_callback_t uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_callback = nullptr;
uic_mqtt_dotdot_thermostat_write_attributes_callback_t uic_mqtt_dotdot_thermostat_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_thermostat_force_read_attributes_callback_t uic_mqtt_dotdot_thermostat_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback_set(const uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback = callback;
}
void uic_mqtt_dotdot_thermostat_generated_setpoint_raise_or_lower_callback_set(const uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_generated_setpoint_raise_or_lower_callback = callback;
}

void uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback_set(const uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback = callback;
}
void uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_response_callback_set(const uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_response_callback = callback;
}

void uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback_set(const uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback = callback;
}
void uic_mqtt_dotdot_thermostat_generated_set_weekly_schedule_callback_set(const uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_generated_set_weekly_schedule_callback = callback;
}

void uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback_set(const uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback = callback;
}
void uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_response_callback_set(const uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_response_callback = callback;
}

void uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback_set(const uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback = callback;
}
void uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_callback_set(const uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_callback = callback;
}

void uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback_set(const uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback = callback;
}
void uic_mqtt_dotdot_thermostat_generated_clear_weekly_schedule_callback_set(const uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_generated_clear_weekly_schedule_callback = callback;
}

void uic_mqtt_dotdot_thermostat_get_relay_status_log_callback_set(const uic_mqtt_dotdot_thermostat_get_relay_status_log_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_get_relay_status_log_callback = callback;
}
void uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_callback_set(const uic_mqtt_dotdot_thermostat_get_relay_status_log_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_callback = callback;
}


void uic_mqtt_dotdot_set_thermostat_write_attributes_callback(
  const uic_mqtt_dotdot_thermostat_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_thermostat_force_read_attributes_callback(
  const uic_mqtt_dotdot_thermostat_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/Commands/SetpointRaiseOrLower
void uic_mqtt_dotdot_on_thermostat_setpoint_raise_or_lower(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SetpointRaiseOrLowerMode mode = {};
  int8_t amount = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_thermostat_setpoint_raise_or_lower(
      jsn,
      mode,

      amount
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "SetpointRaiseOrLower");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "SetpointRaiseOrLower", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "SetpointRaiseOrLower", "");
    return;
  }

  uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    mode,

    amount

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/GeneratedCommands/SetpointRaiseOrLower
static void uic_mqtt_dotdot_on_generated_thermostat_setpoint_raise_or_lower(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_generated_setpoint_raise_or_lower_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SetpointRaiseOrLowerMode mode;
  int8_t amount;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_thermostat_setpoint_raise_or_lower(
      jsn,
      mode,

      amount
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "SetpointRaiseOrLower");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "SetpointRaiseOrLower", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "SetpointRaiseOrLower", "");
    return;
  }

  uic_mqtt_dotdot_thermostat_generated_setpoint_raise_or_lower_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    mode,

    amount

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/Commands/GetWeeklyScheduleResponse
void uic_mqtt_dotdot_on_thermostat_get_weekly_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t number_of_transitions = {};
  uint8_t day_of_week = {};
  uint8_t mode = {};
  std::vector<TransitionType> transitions;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_thermostat_get_weekly_schedule_response(
      jsn,
      number_of_transitions,

      day_of_week,

      mode,

      transitions
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "GetWeeklyScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetWeeklyScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetWeeklyScheduleResponse", "");
    return;
  }

  uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    number_of_transitions,

    day_of_week,

    mode,

    transitions.size(),
    transitions.data()

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/GeneratedCommands/GetWeeklyScheduleResponse
static void uic_mqtt_dotdot_on_generated_thermostat_get_weekly_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t number_of_transitions;
  uint8_t day_of_week;
  uint8_t mode;
  std::vector<TransitionType> transitions;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_thermostat_get_weekly_schedule_response(
      jsn,
      number_of_transitions,

      day_of_week,

      mode,

      transitions
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "GetWeeklyScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetWeeklyScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetWeeklyScheduleResponse", "");
    return;
  }

  uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    number_of_transitions,

    day_of_week,

    mode,

    transitions.size(),
    transitions.data()

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/Commands/SetWeeklySchedule
void uic_mqtt_dotdot_on_thermostat_set_weekly_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t number_of_transitions = {};
  uint8_t day_of_week = {};
  uint8_t mode = {};
  std::vector<TransitionType> transitions;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_thermostat_set_weekly_schedule(
      jsn,
      number_of_transitions,

      day_of_week,

      mode,

      transitions
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "SetWeeklySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "SetWeeklySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "SetWeeklySchedule", "");
    return;
  }

  uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    number_of_transitions,

    day_of_week,

    mode,

    transitions.size(),
    transitions.data()

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/GeneratedCommands/SetWeeklySchedule
static void uic_mqtt_dotdot_on_generated_thermostat_set_weekly_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_generated_set_weekly_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t number_of_transitions;
  uint8_t day_of_week;
  uint8_t mode;
  std::vector<TransitionType> transitions;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_thermostat_set_weekly_schedule(
      jsn,
      number_of_transitions,

      day_of_week,

      mode,

      transitions
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "SetWeeklySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "SetWeeklySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "SetWeeklySchedule", "");
    return;
  }

  uic_mqtt_dotdot_thermostat_generated_set_weekly_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    number_of_transitions,

    day_of_week,

    mode,

    transitions.size(),
    transitions.data()

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/Commands/GetRelayStatusLogResponse
void uic_mqtt_dotdot_on_thermostat_get_relay_status_log_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t time_of_day = {};
  uint8_t relay_status = {};
  int16_t local_temperature = {};
  uint8_t humidity_percentage = {};
  int16_t set_point = {};
  uint16_t unread_entries = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_thermostat_get_relay_status_log_response(
      jsn,
      time_of_day,

      relay_status,

      local_temperature,

      humidity_percentage,

      set_point,

      unread_entries
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "GetRelayStatusLogResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetRelayStatusLogResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetRelayStatusLogResponse", "");
    return;
  }

  uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    time_of_day,

    relay_status,

    local_temperature,

    humidity_percentage,

    set_point,

    unread_entries

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/GeneratedCommands/GetRelayStatusLogResponse
static void uic_mqtt_dotdot_on_generated_thermostat_get_relay_status_log_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t time_of_day;
  uint8_t relay_status;
  int16_t local_temperature;
  uint8_t humidity_percentage;
  int16_t set_point;
  uint16_t unread_entries;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_thermostat_get_relay_status_log_response(
      jsn,
      time_of_day,

      relay_status,

      local_temperature,

      humidity_percentage,

      set_point,

      unread_entries
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "GetRelayStatusLogResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetRelayStatusLogResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetRelayStatusLogResponse", "");
    return;
  }

  uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    time_of_day,

    relay_status,

    local_temperature,

    humidity_percentage,

    set_point,

    unread_entries

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/Commands/GetWeeklySchedule
void uic_mqtt_dotdot_on_thermostat_get_weekly_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t days_to_return = {};
  uint8_t mode_to_return = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_thermostat_get_weekly_schedule(
      jsn,
      days_to_return,

      mode_to_return
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "GetWeeklySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetWeeklySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetWeeklySchedule", "");
    return;
  }

  uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    days_to_return,

    mode_to_return

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/GeneratedCommands/GetWeeklySchedule
static void uic_mqtt_dotdot_on_generated_thermostat_get_weekly_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t days_to_return;
  uint8_t mode_to_return;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_thermostat_get_weekly_schedule(
      jsn,
      days_to_return,

      mode_to_return
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "GetWeeklySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetWeeklySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetWeeklySchedule", "");
    return;
  }

  uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    days_to_return,

    mode_to_return

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/Commands/ClearWeeklySchedule
void uic_mqtt_dotdot_on_thermostat_clear_weekly_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "ClearWeeklySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "ClearWeeklySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "ClearWeeklySchedule", "");
    return;
  }

  uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/GeneratedCommands/ClearWeeklySchedule
static void uic_mqtt_dotdot_on_generated_thermostat_clear_weekly_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_generated_clear_weekly_schedule_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "ClearWeeklySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "ClearWeeklySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "ClearWeeklySchedule", "");
    return;
  }

  uic_mqtt_dotdot_thermostat_generated_clear_weekly_schedule_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/Commands/GetRelayStatusLog
void uic_mqtt_dotdot_on_thermostat_get_relay_status_log(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_get_relay_status_log_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "GetRelayStatusLog");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetRelayStatusLog", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetRelayStatusLog", "");
    return;
  }

  uic_mqtt_dotdot_thermostat_get_relay_status_log_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/GeneratedCommands/GetRelayStatusLog
static void uic_mqtt_dotdot_on_generated_thermostat_get_relay_status_log(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "GetRelayStatusLog");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetRelayStatusLog", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetRelayStatusLog", "");
    return;
  }

  uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/Commands/WriteAttributes
void uic_mqtt_dotdot_on_thermostat_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_thermostat_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_thermostat_state_t new_state = {};
  uic_mqtt_dotdot_thermostat_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_thermostat_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_thermostat_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_thermostat_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_thermostat_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_thermostat_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.local_temperature = true;
        force_update.outdoor_temperature = true;
        force_update.occupancy = true;
        force_update.abs_min_heat_setpoint_limit = true;
        force_update.abs_max_heat_setpoint_limit = true;
        force_update.abs_min_cool_setpoint_limit = true;
        force_update.abs_max_cool_setpoint_limit = true;
        force_update.pi_cooling_demand = true;
        force_update.pi_heating_demand = true;
        force_update.hvac_system_type_configuration = true;
        force_update.local_temperature_calibration = true;
        force_update.occupied_cooling_setpoint = true;
        force_update.occupied_heating_setpoint = true;
        force_update.unoccupied_cooling_setpoint = true;
        force_update.unoccupied_heating_setpoint = true;
        force_update.min_heat_setpoint_limit = true;
        force_update.max_heat_setpoint_limit = true;
        force_update.min_cool_setpoint_limit = true;
        force_update.max_cool_setpoint_limit = true;
        force_update.min_setpoint_dead_band = true;
        force_update.remote_sensing = true;
        force_update.control_sequence_of_operation = true;
        force_update.system_mode = true;
        force_update.alarm_mask = true;
        force_update.thermostat_running_mode = true;
        force_update.start_of_week = true;
        force_update.number_of_weekly_transitions = true;
        force_update.number_of_daily_transitions = true;
        force_update.temperature_setpoint_hold = true;
        force_update.temperature_setpoint_hold_duration = true;
        force_update.thermostat_programming_operation_mode = true;
        force_update.thermostat_running_state = true;
        force_update.setpoint_change_source = true;
        force_update.setpoint_change_amount = true;
        force_update.setpoint_change_source_timestamp = true;
        force_update.occupied_setback = true;
        force_update.occupied_setback_min = true;
        force_update.occupied_setback_max = true;
        force_update.unoccupied_setback = true;
        force_update.unoccupied_setback_min = true;
        force_update.unoccupied_setback_max = true;
        force_update.emergency_heat_delta = true;
        force_update.ac_type = true;
        force_update.ac_capacity = true;
        force_update.ac_refrigerant_type = true;
        force_update.ac_compressor_type = true;
        force_update.ac_error_code = true;
        force_update.ac_louver_position = true;
        force_update.ac_coil_temperature = true;
        force_update.ac_capacity_format = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"LocalTemperature", &force_update.local_temperature },
          {"OutdoorTemperature", &force_update.outdoor_temperature },
          {"Occupancy", &force_update.occupancy },
          {"AbsMinHeatSetpointLimit", &force_update.abs_min_heat_setpoint_limit },
          {"AbsMaxHeatSetpointLimit", &force_update.abs_max_heat_setpoint_limit },
          {"AbsMinCoolSetpointLimit", &force_update.abs_min_cool_setpoint_limit },
          {"AbsMaxCoolSetpointLimit", &force_update.abs_max_cool_setpoint_limit },
          {"PICoolingDemand", &force_update.pi_cooling_demand },
          {"PIHeatingDemand", &force_update.pi_heating_demand },
          {"HVACSystemTypeConfiguration", &force_update.hvac_system_type_configuration },
          {"LocalTemperatureCalibration", &force_update.local_temperature_calibration },
          {"OccupiedCoolingSetpoint", &force_update.occupied_cooling_setpoint },
          {"OccupiedHeatingSetpoint", &force_update.occupied_heating_setpoint },
          {"UnoccupiedCoolingSetpoint", &force_update.unoccupied_cooling_setpoint },
          {"UnoccupiedHeatingSetpoint", &force_update.unoccupied_heating_setpoint },
          {"MinHeatSetpointLimit", &force_update.min_heat_setpoint_limit },
          {"MaxHeatSetpointLimit", &force_update.max_heat_setpoint_limit },
          {"MinCoolSetpointLimit", &force_update.min_cool_setpoint_limit },
          {"MaxCoolSetpointLimit", &force_update.max_cool_setpoint_limit },
          {"MinSetpointDeadBand", &force_update.min_setpoint_dead_band },
          {"RemoteSensing", &force_update.remote_sensing },
          {"ControlSequenceOfOperation", &force_update.control_sequence_of_operation },
          {"SystemMode", &force_update.system_mode },
          {"AlarmMask", &force_update.alarm_mask },
          {"ThermostatRunningMode", &force_update.thermostat_running_mode },
          {"StartOfWeek", &force_update.start_of_week },
          {"NumberOfWeeklyTransitions", &force_update.number_of_weekly_transitions },
          {"NumberOfDailyTransitions", &force_update.number_of_daily_transitions },
          {"TemperatureSetpointHold", &force_update.temperature_setpoint_hold },
          {"TemperatureSetpointHoldDuration", &force_update.temperature_setpoint_hold_duration },
          {"ThermostatProgrammingOperationMode", &force_update.thermostat_programming_operation_mode },
          {"ThermostatRunningState", &force_update.thermostat_running_state },
          {"SetpointChangeSource", &force_update.setpoint_change_source },
          {"SetpointChangeAmount", &force_update.setpoint_change_amount },
          {"SetpointChangeSourceTimestamp", &force_update.setpoint_change_source_timestamp },
          {"OccupiedSetback", &force_update.occupied_setback },
          {"OccupiedSetbackMin", &force_update.occupied_setback_min },
          {"OccupiedSetbackMax", &force_update.occupied_setback_max },
          {"UnoccupiedSetback", &force_update.unoccupied_setback },
          {"UnoccupiedSetbackMin", &force_update.unoccupied_setback_min },
          {"UnoccupiedSetbackMax", &force_update.unoccupied_setback_max },
          {"EmergencyHeatDelta", &force_update.emergency_heat_delta },
          {"ACType", &force_update.ac_type },
          {"ACCapacity", &force_update.ac_capacity },
          {"ACRefrigerantType", &force_update.ac_refrigerant_type },
          {"ACCompressorType", &force_update.ac_compressor_type },
          {"ACErrorCode", &force_update.ac_error_code },
          {"ACLouverPosition", &force_update.ac_louver_position },
          {"ACCoilTemperature", &force_update.ac_coil_temperature },
          {"ACCapacityFormat", &force_update.ac_capacity_format },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_thermostat_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "Thermostat/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_thermostat_local_temperature_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/LocalTemperature", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/LocalTemperature";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_outdoor_temperature_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/OutdoorTemperature", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/OutdoorTemperature";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_occupancy_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ThermostatOccupancy.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/Occupancy", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/Occupancy";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_abs_min_heat_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/AbsMinHeatSetpointLimit", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/AbsMinHeatSetpointLimit";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_abs_max_heat_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/AbsMaxHeatSetpointLimit", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/AbsMaxHeatSetpointLimit";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_abs_min_cool_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/AbsMinCoolSetpointLimit", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/AbsMinCoolSetpointLimit";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_abs_max_cool_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/AbsMaxCoolSetpointLimit", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/AbsMaxCoolSetpointLimit";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_pi_cooling_demand_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/PICoolingDemand", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/PICoolingDemand";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_pi_heating_demand_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/PIHeatingDemand", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/PIHeatingDemand";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_hvac_system_type_configuration_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ThermostatHVACSystemTypeConfiguration.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/HVACSystemTypeConfiguration", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/HVACSystemTypeConfiguration";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_local_temperature_calibration_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/LocalTemperatureCalibration", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/LocalTemperatureCalibration";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_occupied_cooling_setpoint_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/OccupiedCoolingSetpoint", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/OccupiedCoolingSetpoint";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_occupied_heating_setpoint_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/OccupiedHeatingSetpoint", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/OccupiedHeatingSetpoint";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_unoccupied_cooling_setpoint_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/UnoccupiedCoolingSetpoint", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/UnoccupiedCoolingSetpoint";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_unoccupied_heating_setpoint_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/UnoccupiedHeatingSetpoint", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/UnoccupiedHeatingSetpoint";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_min_heat_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/MinHeatSetpointLimit", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/MinHeatSetpointLimit";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_max_heat_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/MaxHeatSetpointLimit", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/MaxHeatSetpointLimit";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_min_cool_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/MinCoolSetpointLimit", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/MinCoolSetpointLimit";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_max_cool_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/MaxCoolSetpointLimit", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/MaxCoolSetpointLimit";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_min_setpoint_dead_band_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/MinSetpointDeadBand", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/MinSetpointDeadBand";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_remote_sensing_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ThermostatRemoteSensing.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/RemoteSensing", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/RemoteSensing";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_control_sequence_of_operation_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_CONTROL_SEQUENCE_OF_OPERATION_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_control_sequence_of_operation_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<ThermostatControlSequenceOfOperation>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ControlSequenceOfOperation", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ControlSequenceOfOperation";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_system_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_SYSTEM_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_system_mode_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<ThermostatSystemMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/SystemMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/SystemMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_alarm_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ThermostatAlarmMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/AlarmMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/AlarmMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_thermostat_running_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_THERMOSTAT_RUNNING_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_thermostat_running_mode_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<ThermostatThermostatRunningMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ThermostatRunningMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ThermostatRunningMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_start_of_week_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_START_OF_WEEK_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_start_of_week_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<ThermostatStartOfWeek>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/StartOfWeek", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/StartOfWeek";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_number_of_weekly_transitions_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/NumberOfWeeklyTransitions", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/NumberOfWeeklyTransitions";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_number_of_daily_transitions_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/NumberOfDailyTransitions", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/NumberOfDailyTransitions";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_temperature_setpoint_hold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_TEMPERATURE_SETPOINT_HOLD_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_temperature_setpoint_hold_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<ThermostatTemperatureSetpointHold>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/TemperatureSetpointHold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/TemperatureSetpointHold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_temperature_setpoint_hold_duration_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/TemperatureSetpointHoldDuration", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/TemperatureSetpointHoldDuration";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_thermostat_programming_operation_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ThermostatThermostatProgrammingOperationMode.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ThermostatProgrammingOperationMode", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ThermostatProgrammingOperationMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_thermostat_running_state_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ThermostatThermostatRunningState.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ThermostatRunningState", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ThermostatRunningState";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_setpoint_change_source_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_SETPOINT_CHANGE_SOURCE_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_setpoint_change_source_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<ThermostatSetpointChangeSource>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/SetpointChangeSource", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/SetpointChangeSource";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_setpoint_change_amount_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/SetpointChangeAmount", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/SetpointChangeAmount";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_setpoint_change_source_timestamp_publish(
  const char *base_topic,
  UTC value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/SetpointChangeSourceTimestamp", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/SetpointChangeSourceTimestamp";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_occupied_setback_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/OccupiedSetback", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/OccupiedSetback";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_occupied_setback_min_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/OccupiedSetbackMin", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/OccupiedSetbackMin";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_occupied_setback_max_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/OccupiedSetbackMax", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/OccupiedSetbackMax";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_unoccupied_setback_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/UnoccupiedSetback", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/UnoccupiedSetback";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_unoccupied_setback_min_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/UnoccupiedSetbackMin", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/UnoccupiedSetbackMin";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_unoccupied_setback_max_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/UnoccupiedSetbackMax", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/UnoccupiedSetbackMax";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_emergency_heat_delta_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/EmergencyHeatDelta", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/EmergencyHeatDelta";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_ac_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_AC_TYPE_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_ac_type_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<ThermostatACType>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ACType", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ACType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_ac_capacity_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ACCapacity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ACCapacity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_ac_refrigerant_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_AC_REFRIGERANT_TYPE_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_ac_refrigerant_type_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<ThermostatACRefrigerantType>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ACRefrigerantType", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ACRefrigerantType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_ac_compressor_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_AC_COMPRESSOR_TYPE_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_ac_compressor_type_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<ThermostatACCompressorType>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ACCompressorType", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ACCompressorType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_ac_error_code_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ThermostatACErrorCode.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ACErrorCode", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ACErrorCode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_ac_louver_position_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_AC_LOUVER_POSITION_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_ac_louver_position_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<ThermostatACLouverPosition>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ACLouverPosition", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ACLouverPosition";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_ac_coil_temperature_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ACCoilTemperature", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ACCoilTemperature";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_ac_capacity_format_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_AC_CAPACITY_FORMAT_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_ac_capacity_format_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<ThermostatACCapacityFormat>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ACCapacityFormat", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ACCapacityFormat";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_thermostat_write_attributes_callback) {
    subscription_topic = base_topic + "Thermostat/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_thermostat_WriteAttributes);
  }

  if(uic_mqtt_dotdot_thermostat_force_read_attributes_callback) {
    subscription_topic = base_topic + "Thermostat/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_thermostat_force_read_attributes);
  }
  if (uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback) {
    subscription_topic = base_topic + "Thermostat/Commands/SetpointRaiseOrLower";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_thermostat_setpoint_raise_or_lower);
  }
  if (uic_mqtt_dotdot_thermostat_generated_setpoint_raise_or_lower_callback) {
    subscription_topic = base_topic + "Thermostat/GeneratedCommands/SetpointRaiseOrLower";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_thermostat_setpoint_raise_or_lower);
  }
  if (uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback) {
    subscription_topic = base_topic + "Thermostat/Commands/GetWeeklyScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_thermostat_get_weekly_schedule_response);
  }
  if (uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_response_callback) {
    subscription_topic = base_topic + "Thermostat/GeneratedCommands/GetWeeklyScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_thermostat_get_weekly_schedule_response);
  }
  if (uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback) {
    subscription_topic = base_topic + "Thermostat/Commands/SetWeeklySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_thermostat_set_weekly_schedule);
  }
  if (uic_mqtt_dotdot_thermostat_generated_set_weekly_schedule_callback) {
    subscription_topic = base_topic + "Thermostat/GeneratedCommands/SetWeeklySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_thermostat_set_weekly_schedule);
  }
  if (uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback) {
    subscription_topic = base_topic + "Thermostat/Commands/GetRelayStatusLogResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_thermostat_get_relay_status_log_response);
  }
  if (uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_response_callback) {
    subscription_topic = base_topic + "Thermostat/GeneratedCommands/GetRelayStatusLogResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_thermostat_get_relay_status_log_response);
  }
  if (uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback) {
    subscription_topic = base_topic + "Thermostat/Commands/GetWeeklySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_thermostat_get_weekly_schedule);
  }
  if (uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_callback) {
    subscription_topic = base_topic + "Thermostat/GeneratedCommands/GetWeeklySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_thermostat_get_weekly_schedule);
  }
  if (uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback) {
    subscription_topic = base_topic + "Thermostat/Commands/ClearWeeklySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_thermostat_clear_weekly_schedule);
  }
  if (uic_mqtt_dotdot_thermostat_generated_clear_weekly_schedule_callback) {
    subscription_topic = base_topic + "Thermostat/GeneratedCommands/ClearWeeklySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_thermostat_clear_weekly_schedule);
  }
  if (uic_mqtt_dotdot_thermostat_get_relay_status_log_callback) {
    subscription_topic = base_topic + "Thermostat/Commands/GetRelayStatusLog";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_thermostat_get_relay_status_log);
  }
  if (uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_callback) {
    subscription_topic = base_topic + "Thermostat/GeneratedCommands/GetRelayStatusLog";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_thermostat_get_relay_status_log);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_thermostat_attributes_init();

  uic_mqtt_dotdot_by_group_thermostat_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_fan_control_write_attributes_callback_t uic_mqtt_dotdot_fan_control_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_fan_control_force_read_attributes_callback_t uic_mqtt_dotdot_fan_control_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_fan_control_write_attributes_callback(
  const uic_mqtt_dotdot_fan_control_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_fan_control_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_fan_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_fan_control_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_fan_control_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/FanControl/Commands/WriteAttributes
void uic_mqtt_dotdot_on_fan_control_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_fan_control_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_fan_control_state_t new_state = {};
  uic_mqtt_dotdot_fan_control_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_fan_control_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "FanControl", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FanControl", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FanControl", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_fan_control_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_fan_control_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_fan_control_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_fan_control_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.fan_mode = true;
        force_update.fan_mode_sequence = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"FanMode", &force_update.fan_mode },
          {"FanModeSequence", &force_update.fan_mode_sequence },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_fan_control_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "FanControl/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_fan_control_fan_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef FAN_CONTROL_FAN_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = fan_control_fan_mode_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<FanControlFanMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FanControl/Attributes/FanMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/FanControl/Attributes/FanMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_fan_control_fan_mode_sequence_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef FAN_CONTROL_FAN_MODE_SEQUENCE_ENUM_NAME_AVAILABLE
  jsn["value"] = fan_control_fan_mode_sequence_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<FanControlFanModeSequence>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FanControl/Attributes/FanModeSequence", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/FanControl/Attributes/FanModeSequence";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_fan_control_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_fan_control_write_attributes_callback) {
    subscription_topic = base_topic + "FanControl/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_fan_control_WriteAttributes);
  }

  if(uic_mqtt_dotdot_fan_control_force_read_attributes_callback) {
    subscription_topic = base_topic + "FanControl/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_fan_control_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_fan_control_attributes_init();

  uic_mqtt_dotdot_by_group_fan_control_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_dehumidification_control_write_attributes_callback_t uic_mqtt_dotdot_dehumidification_control_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_dehumidification_control_force_read_attributes_callback_t uic_mqtt_dotdot_dehumidification_control_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_dehumidification_control_write_attributes_callback(
  const uic_mqtt_dotdot_dehumidification_control_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_dehumidification_control_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_dehumidification_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_dehumidification_control_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_dehumidification_control_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/DehumidificationControl/Commands/WriteAttributes
void uic_mqtt_dotdot_on_dehumidification_control_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_dehumidification_control_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_dehumidification_control_state_t new_state = {};
  uic_mqtt_dotdot_dehumidification_control_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_dehumidification_control_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DehumidificationControl", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DehumidificationControl", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DehumidificationControl", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_dehumidification_control_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_dehumidification_control_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_dehumidification_control_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_dehumidification_control_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.relative_humidity = true;
        force_update.dehumidification_cooling = true;
        force_update.rh_dehumidification_setpoint = true;
        force_update.relative_humidity_mode = true;
        force_update.dehumidification_lockout = true;
        force_update.dehumidification_hysteresis = true;
        force_update.dehumidification_max_cool = true;
        force_update.relative_humidity_display = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"RelativeHumidity", &force_update.relative_humidity },
          {"DehumidificationCooling", &force_update.dehumidification_cooling },
          {"RHDehumidificationSetpoint", &force_update.rh_dehumidification_setpoint },
          {"RelativeHumidityMode", &force_update.relative_humidity_mode },
          {"DehumidificationLockout", &force_update.dehumidification_lockout },
          {"DehumidificationHysteresis", &force_update.dehumidification_hysteresis },
          {"DehumidificationMaxCool", &force_update.dehumidification_max_cool },
          {"RelativeHumidityDisplay", &force_update.relative_humidity_display },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_dehumidification_control_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "DehumidificationControl/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_dehumidification_control_relative_humidity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DehumidificationControl/Attributes/RelativeHumidity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DehumidificationControl/Attributes/RelativeHumidity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_dehumidification_control_dehumidification_cooling_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DehumidificationControl/Attributes/DehumidificationCooling", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DehumidificationControl/Attributes/DehumidificationCooling";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_dehumidification_control_rh_dehumidification_setpoint_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DehumidificationControl/Attributes/RHDehumidificationSetpoint", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DehumidificationControl/Attributes/RHDehumidificationSetpoint";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_dehumidification_control_relative_humidity_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = dehumidification_control_relative_humidity_mode_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<DehumidificationControlRelativeHumidityMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DehumidificationControl/Attributes/RelativeHumidityMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DehumidificationControl/Attributes/RelativeHumidityMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_dehumidification_control_dehumidification_lockout_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_LOCKOUT_ENUM_NAME_AVAILABLE
  jsn["value"] = dehumidification_control_dehumidification_lockout_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<DehumidificationControlDehumidificationLockout>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DehumidificationControl/Attributes/DehumidificationLockout", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DehumidificationControl/Attributes/DehumidificationLockout";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_dehumidification_control_dehumidification_hysteresis_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DehumidificationControl/Attributes/DehumidificationHysteresis", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DehumidificationControl/Attributes/DehumidificationHysteresis";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_dehumidification_control_dehumidification_max_cool_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DehumidificationControl/Attributes/DehumidificationMaxCool", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DehumidificationControl/Attributes/DehumidificationMaxCool";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_dehumidification_control_relative_humidity_display_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_DISPLAY_ENUM_NAME_AVAILABLE
  jsn["value"] = dehumidification_control_relative_humidity_display_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<DehumidificationControlRelativeHumidityDisplay>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DehumidificationControl/Attributes/RelativeHumidityDisplay", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DehumidificationControl/Attributes/RelativeHumidityDisplay";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_dehumidification_control_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_dehumidification_control_write_attributes_callback) {
    subscription_topic = base_topic + "DehumidificationControl/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_dehumidification_control_WriteAttributes);
  }

  if(uic_mqtt_dotdot_dehumidification_control_force_read_attributes_callback) {
    subscription_topic = base_topic + "DehumidificationControl/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_dehumidification_control_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_dehumidification_control_attributes_init();

  uic_mqtt_dotdot_by_group_dehumidification_control_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback_t uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_callback_t uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_thermostat_user_interface_configuration_write_attributes_callback(
  const uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_thermostat_user_interface_configuration_force_read_attributes_callback(
  const uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/ThermostatUserInterfaceConfiguration/Commands/WriteAttributes
void uic_mqtt_dotdot_on_thermostat_user_interface_configuration_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_thermostat_user_interface_configuration_state_t new_state = {};
  uic_mqtt_dotdot_thermostat_user_interface_configuration_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_thermostat_user_interface_configuration_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ThermostatUserInterfaceConfiguration", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ThermostatUserInterfaceConfiguration", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ThermostatUserInterfaceConfiguration", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_thermostat_user_interface_configuration_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_thermostat_user_interface_configuration_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.temperature_display_mode = true;
        force_update.keypad_lockout = true;
        force_update.schedule_programming_visibility = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"TemperatureDisplayMode", &force_update.temperature_display_mode },
          {"KeypadLockout", &force_update.keypad_lockout },
          {"ScheduleProgrammingVisibility", &force_update.schedule_programming_visibility },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "ThermostatUserInterfaceConfiguration/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_thermostat_user_interface_configuration_temperature_display_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_USER_INTERFACE_CONFIGURATION_TEMPERATURE_DISPLAY_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_user_interface_configuration_temperature_display_mode_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<ThermostatUserInterfaceConfigurationTemperatureDisplayMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ThermostatUserInterfaceConfiguration/Attributes/TemperatureDisplayMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ThermostatUserInterfaceConfiguration/Attributes/TemperatureDisplayMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_user_interface_configuration_keypad_lockout_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_USER_INTERFACE_CONFIGURATION_KEYPAD_LOCKOUT_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_user_interface_configuration_keypad_lockout_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<ThermostatUserInterfaceConfigurationKeypadLockout>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ThermostatUserInterfaceConfiguration/Attributes/KeypadLockout", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ThermostatUserInterfaceConfiguration/Attributes/KeypadLockout";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_thermostat_user_interface_configuration_schedule_programming_visibility_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_USER_INTERFACE_CONFIGURATION_SCHEDULE_PROGRAMMING_VISIBILITY_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_user_interface_configuration_schedule_programming_visibility_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<ThermostatUserInterfaceConfigurationScheduleProgrammingVisibility>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ThermostatUserInterfaceConfiguration/Attributes/ScheduleProgrammingVisibility", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ThermostatUserInterfaceConfiguration/Attributes/ScheduleProgrammingVisibility";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_user_interface_configuration_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback) {
    subscription_topic = base_topic + "ThermostatUserInterfaceConfiguration/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_thermostat_user_interface_configuration_WriteAttributes);
  }

  if(uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_callback) {
    subscription_topic = base_topic + "ThermostatUserInterfaceConfiguration/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_thermostat_user_interface_configuration_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_thermostat_user_interface_configuration_attributes_init();

  uic_mqtt_dotdot_by_group_thermostat_user_interface_configuration_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_color_control_move_to_hue_callback_t uic_mqtt_dotdot_color_control_move_to_hue_callback = nullptr;
static uic_mqtt_dotdot_color_control_move_to_hue_callback_t uic_mqtt_dotdot_color_control_generated_move_to_hue_callback = nullptr;
uic_mqtt_dotdot_color_control_move_hue_callback_t uic_mqtt_dotdot_color_control_move_hue_callback = nullptr;
static uic_mqtt_dotdot_color_control_move_hue_callback_t uic_mqtt_dotdot_color_control_generated_move_hue_callback = nullptr;
uic_mqtt_dotdot_color_control_step_hue_callback_t uic_mqtt_dotdot_color_control_step_hue_callback = nullptr;
static uic_mqtt_dotdot_color_control_step_hue_callback_t uic_mqtt_dotdot_color_control_generated_step_hue_callback = nullptr;
uic_mqtt_dotdot_color_control_move_to_saturation_callback_t uic_mqtt_dotdot_color_control_move_to_saturation_callback = nullptr;
static uic_mqtt_dotdot_color_control_move_to_saturation_callback_t uic_mqtt_dotdot_color_control_generated_move_to_saturation_callback = nullptr;
uic_mqtt_dotdot_color_control_move_saturation_callback_t uic_mqtt_dotdot_color_control_move_saturation_callback = nullptr;
static uic_mqtt_dotdot_color_control_move_saturation_callback_t uic_mqtt_dotdot_color_control_generated_move_saturation_callback = nullptr;
uic_mqtt_dotdot_color_control_step_saturation_callback_t uic_mqtt_dotdot_color_control_step_saturation_callback = nullptr;
static uic_mqtt_dotdot_color_control_step_saturation_callback_t uic_mqtt_dotdot_color_control_generated_step_saturation_callback = nullptr;
uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback_t uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback = nullptr;
static uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback_t uic_mqtt_dotdot_color_control_generated_move_to_hue_and_saturation_callback = nullptr;
uic_mqtt_dotdot_color_control_move_to_color_callback_t uic_mqtt_dotdot_color_control_move_to_color_callback = nullptr;
static uic_mqtt_dotdot_color_control_move_to_color_callback_t uic_mqtt_dotdot_color_control_generated_move_to_color_callback = nullptr;
uic_mqtt_dotdot_color_control_move_color_callback_t uic_mqtt_dotdot_color_control_move_color_callback = nullptr;
static uic_mqtt_dotdot_color_control_move_color_callback_t uic_mqtt_dotdot_color_control_generated_move_color_callback = nullptr;
uic_mqtt_dotdot_color_control_step_color_callback_t uic_mqtt_dotdot_color_control_step_color_callback = nullptr;
static uic_mqtt_dotdot_color_control_step_color_callback_t uic_mqtt_dotdot_color_control_generated_step_color_callback = nullptr;
uic_mqtt_dotdot_color_control_move_to_color_temperature_callback_t uic_mqtt_dotdot_color_control_move_to_color_temperature_callback = nullptr;
static uic_mqtt_dotdot_color_control_move_to_color_temperature_callback_t uic_mqtt_dotdot_color_control_generated_move_to_color_temperature_callback = nullptr;
uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback_t uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback = nullptr;
static uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback_t uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_callback = nullptr;
uic_mqtt_dotdot_color_control_enhanced_move_hue_callback_t uic_mqtt_dotdot_color_control_enhanced_move_hue_callback = nullptr;
static uic_mqtt_dotdot_color_control_enhanced_move_hue_callback_t uic_mqtt_dotdot_color_control_generated_enhanced_move_hue_callback = nullptr;
uic_mqtt_dotdot_color_control_enhanced_step_hue_callback_t uic_mqtt_dotdot_color_control_enhanced_step_hue_callback = nullptr;
static uic_mqtt_dotdot_color_control_enhanced_step_hue_callback_t uic_mqtt_dotdot_color_control_generated_enhanced_step_hue_callback = nullptr;
uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback_t uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback = nullptr;
static uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback_t uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_and_saturation_callback = nullptr;
uic_mqtt_dotdot_color_control_color_loop_set_callback_t uic_mqtt_dotdot_color_control_color_loop_set_callback = nullptr;
static uic_mqtt_dotdot_color_control_color_loop_set_callback_t uic_mqtt_dotdot_color_control_generated_color_loop_set_callback = nullptr;
uic_mqtt_dotdot_color_control_stop_move_step_callback_t uic_mqtt_dotdot_color_control_stop_move_step_callback = nullptr;
static uic_mqtt_dotdot_color_control_stop_move_step_callback_t uic_mqtt_dotdot_color_control_generated_stop_move_step_callback = nullptr;
uic_mqtt_dotdot_color_control_move_color_temperature_callback_t uic_mqtt_dotdot_color_control_move_color_temperature_callback = nullptr;
static uic_mqtt_dotdot_color_control_move_color_temperature_callback_t uic_mqtt_dotdot_color_control_generated_move_color_temperature_callback = nullptr;
uic_mqtt_dotdot_color_control_step_color_temperature_callback_t uic_mqtt_dotdot_color_control_step_color_temperature_callback = nullptr;
static uic_mqtt_dotdot_color_control_step_color_temperature_callback_t uic_mqtt_dotdot_color_control_generated_step_color_temperature_callback = nullptr;
uic_mqtt_dotdot_color_control_write_attributes_callback_t uic_mqtt_dotdot_color_control_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_color_control_force_read_attributes_callback_t uic_mqtt_dotdot_color_control_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_color_control_move_to_hue_callback_set(const uic_mqtt_dotdot_color_control_move_to_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_move_to_hue_callback = callback;
}
void uic_mqtt_dotdot_color_control_generated_move_to_hue_callback_set(const uic_mqtt_dotdot_color_control_move_to_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_move_to_hue_callback = callback;
}

void uic_mqtt_dotdot_color_control_move_hue_callback_set(const uic_mqtt_dotdot_color_control_move_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_move_hue_callback = callback;
}
void uic_mqtt_dotdot_color_control_generated_move_hue_callback_set(const uic_mqtt_dotdot_color_control_move_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_move_hue_callback = callback;
}

void uic_mqtt_dotdot_color_control_step_hue_callback_set(const uic_mqtt_dotdot_color_control_step_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_step_hue_callback = callback;
}
void uic_mqtt_dotdot_color_control_generated_step_hue_callback_set(const uic_mqtt_dotdot_color_control_step_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_step_hue_callback = callback;
}

void uic_mqtt_dotdot_color_control_move_to_saturation_callback_set(const uic_mqtt_dotdot_color_control_move_to_saturation_callback_t callback)
{
  uic_mqtt_dotdot_color_control_move_to_saturation_callback = callback;
}
void uic_mqtt_dotdot_color_control_generated_move_to_saturation_callback_set(const uic_mqtt_dotdot_color_control_move_to_saturation_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_move_to_saturation_callback = callback;
}

void uic_mqtt_dotdot_color_control_move_saturation_callback_set(const uic_mqtt_dotdot_color_control_move_saturation_callback_t callback)
{
  uic_mqtt_dotdot_color_control_move_saturation_callback = callback;
}
void uic_mqtt_dotdot_color_control_generated_move_saturation_callback_set(const uic_mqtt_dotdot_color_control_move_saturation_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_move_saturation_callback = callback;
}

void uic_mqtt_dotdot_color_control_step_saturation_callback_set(const uic_mqtt_dotdot_color_control_step_saturation_callback_t callback)
{
  uic_mqtt_dotdot_color_control_step_saturation_callback = callback;
}
void uic_mqtt_dotdot_color_control_generated_step_saturation_callback_set(const uic_mqtt_dotdot_color_control_step_saturation_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_step_saturation_callback = callback;
}

void uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback_set(const uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback_t callback)
{
  uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback = callback;
}
void uic_mqtt_dotdot_color_control_generated_move_to_hue_and_saturation_callback_set(const uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_move_to_hue_and_saturation_callback = callback;
}

void uic_mqtt_dotdot_color_control_move_to_color_callback_set(const uic_mqtt_dotdot_color_control_move_to_color_callback_t callback)
{
  uic_mqtt_dotdot_color_control_move_to_color_callback = callback;
}
void uic_mqtt_dotdot_color_control_generated_move_to_color_callback_set(const uic_mqtt_dotdot_color_control_move_to_color_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_move_to_color_callback = callback;
}

void uic_mqtt_dotdot_color_control_move_color_callback_set(const uic_mqtt_dotdot_color_control_move_color_callback_t callback)
{
  uic_mqtt_dotdot_color_control_move_color_callback = callback;
}
void uic_mqtt_dotdot_color_control_generated_move_color_callback_set(const uic_mqtt_dotdot_color_control_move_color_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_move_color_callback = callback;
}

void uic_mqtt_dotdot_color_control_step_color_callback_set(const uic_mqtt_dotdot_color_control_step_color_callback_t callback)
{
  uic_mqtt_dotdot_color_control_step_color_callback = callback;
}
void uic_mqtt_dotdot_color_control_generated_step_color_callback_set(const uic_mqtt_dotdot_color_control_step_color_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_step_color_callback = callback;
}

void uic_mqtt_dotdot_color_control_move_to_color_temperature_callback_set(const uic_mqtt_dotdot_color_control_move_to_color_temperature_callback_t callback)
{
  uic_mqtt_dotdot_color_control_move_to_color_temperature_callback = callback;
}
void uic_mqtt_dotdot_color_control_generated_move_to_color_temperature_callback_set(const uic_mqtt_dotdot_color_control_move_to_color_temperature_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_move_to_color_temperature_callback = callback;
}

void uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback_set(const uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback = callback;
}
void uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_callback_set(const uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_callback = callback;
}

void uic_mqtt_dotdot_color_control_enhanced_move_hue_callback_set(const uic_mqtt_dotdot_color_control_enhanced_move_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_enhanced_move_hue_callback = callback;
}
void uic_mqtt_dotdot_color_control_generated_enhanced_move_hue_callback_set(const uic_mqtt_dotdot_color_control_enhanced_move_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_enhanced_move_hue_callback = callback;
}

void uic_mqtt_dotdot_color_control_enhanced_step_hue_callback_set(const uic_mqtt_dotdot_color_control_enhanced_step_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_enhanced_step_hue_callback = callback;
}
void uic_mqtt_dotdot_color_control_generated_enhanced_step_hue_callback_set(const uic_mqtt_dotdot_color_control_enhanced_step_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_enhanced_step_hue_callback = callback;
}

void uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback_set(const uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback_t callback)
{
  uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback = callback;
}
void uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_and_saturation_callback_set(const uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_and_saturation_callback = callback;
}

void uic_mqtt_dotdot_color_control_color_loop_set_callback_set(const uic_mqtt_dotdot_color_control_color_loop_set_callback_t callback)
{
  uic_mqtt_dotdot_color_control_color_loop_set_callback = callback;
}
void uic_mqtt_dotdot_color_control_generated_color_loop_set_callback_set(const uic_mqtt_dotdot_color_control_color_loop_set_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_color_loop_set_callback = callback;
}

void uic_mqtt_dotdot_color_control_stop_move_step_callback_set(const uic_mqtt_dotdot_color_control_stop_move_step_callback_t callback)
{
  uic_mqtt_dotdot_color_control_stop_move_step_callback = callback;
}
void uic_mqtt_dotdot_color_control_generated_stop_move_step_callback_set(const uic_mqtt_dotdot_color_control_stop_move_step_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_stop_move_step_callback = callback;
}

void uic_mqtt_dotdot_color_control_move_color_temperature_callback_set(const uic_mqtt_dotdot_color_control_move_color_temperature_callback_t callback)
{
  uic_mqtt_dotdot_color_control_move_color_temperature_callback = callback;
}
void uic_mqtt_dotdot_color_control_generated_move_color_temperature_callback_set(const uic_mqtt_dotdot_color_control_move_color_temperature_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_move_color_temperature_callback = callback;
}

void uic_mqtt_dotdot_color_control_step_color_temperature_callback_set(const uic_mqtt_dotdot_color_control_step_color_temperature_callback_t callback)
{
  uic_mqtt_dotdot_color_control_step_color_temperature_callback = callback;
}
void uic_mqtt_dotdot_color_control_generated_step_color_temperature_callback_set(const uic_mqtt_dotdot_color_control_step_color_temperature_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_step_color_temperature_callback = callback;
}


void uic_mqtt_dotdot_set_color_control_write_attributes_callback(
  const uic_mqtt_dotdot_color_control_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_color_control_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_color_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_color_control_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_color_control_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/MoveToHue
void uic_mqtt_dotdot_on_color_control_move_to_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_move_to_hue_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t hue = {};
  CCDirection direction = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_to_hue(
      jsn,
      hue,

      direction,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToHue", "");
    return;
  }

  uic_mqtt_dotdot_color_control_move_to_hue_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    hue,

    direction,

    transition_time,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/MoveToHue
static void uic_mqtt_dotdot_on_generated_color_control_move_to_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_move_to_hue_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t hue;
  CCDirection direction;
  uint16_t transition_time;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_to_hue(
      jsn,
      hue,

      direction,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToHue", "");
    return;
  }

  uic_mqtt_dotdot_color_control_generated_move_to_hue_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    hue,

    direction,

    transition_time,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/MoveHue
void uic_mqtt_dotdot_on_color_control_move_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_move_hue_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCMoveMode move_mode = {};
  uint8_t rate = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_hue(
      jsn,
      move_mode,

      rate,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveHue", "");
    return;
  }

  uic_mqtt_dotdot_color_control_move_hue_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    move_mode,

    rate,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/MoveHue
static void uic_mqtt_dotdot_on_generated_color_control_move_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_move_hue_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCMoveMode move_mode;
  uint8_t rate;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_hue(
      jsn,
      move_mode,

      rate,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveHue", "");
    return;
  }

  uic_mqtt_dotdot_color_control_generated_move_hue_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    move_mode,

    rate,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/StepHue
void uic_mqtt_dotdot_on_color_control_step_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_step_hue_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCStepMode step_mode = {};
  uint8_t step_size = {};
  uint8_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_step_hue(
      jsn,
      step_mode,

      step_size,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StepHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepHue", "");
    return;
  }

  uic_mqtt_dotdot_color_control_step_hue_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    step_mode,

    step_size,

    transition_time,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/StepHue
static void uic_mqtt_dotdot_on_generated_color_control_step_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_step_hue_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCStepMode step_mode;
  uint8_t step_size;
  uint8_t transition_time;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_step_hue(
      jsn,
      step_mode,

      step_size,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StepHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepHue", "");
    return;
  }

  uic_mqtt_dotdot_color_control_generated_step_hue_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    step_mode,

    step_size,

    transition_time,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/MoveToSaturation
void uic_mqtt_dotdot_on_color_control_move_to_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_move_to_saturation_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t saturation = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_to_saturation(
      jsn,
      saturation,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToSaturation");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToSaturation", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToSaturation", "");
    return;
  }

  uic_mqtt_dotdot_color_control_move_to_saturation_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    saturation,

    transition_time,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/MoveToSaturation
static void uic_mqtt_dotdot_on_generated_color_control_move_to_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_move_to_saturation_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t saturation;
  uint16_t transition_time;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_to_saturation(
      jsn,
      saturation,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToSaturation");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToSaturation", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToSaturation", "");
    return;
  }

  uic_mqtt_dotdot_color_control_generated_move_to_saturation_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    saturation,

    transition_time,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/MoveSaturation
void uic_mqtt_dotdot_on_color_control_move_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_move_saturation_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCMoveMode move_mode = {};
  uint8_t rate = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_saturation(
      jsn,
      move_mode,

      rate,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveSaturation");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveSaturation", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveSaturation", "");
    return;
  }

  uic_mqtt_dotdot_color_control_move_saturation_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    move_mode,

    rate,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/MoveSaturation
static void uic_mqtt_dotdot_on_generated_color_control_move_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_move_saturation_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCMoveMode move_mode;
  uint8_t rate;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_saturation(
      jsn,
      move_mode,

      rate,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveSaturation");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveSaturation", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveSaturation", "");
    return;
  }

  uic_mqtt_dotdot_color_control_generated_move_saturation_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    move_mode,

    rate,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/StepSaturation
void uic_mqtt_dotdot_on_color_control_step_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_step_saturation_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCStepMode step_mode = {};
  uint8_t step_size = {};
  uint8_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_step_saturation(
      jsn,
      step_mode,

      step_size,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StepSaturation");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepSaturation", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepSaturation", "");
    return;
  }

  uic_mqtt_dotdot_color_control_step_saturation_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    step_mode,

    step_size,

    transition_time,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/StepSaturation
static void uic_mqtt_dotdot_on_generated_color_control_step_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_step_saturation_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCStepMode step_mode;
  uint8_t step_size;
  uint8_t transition_time;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_step_saturation(
      jsn,
      step_mode,

      step_size,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StepSaturation");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepSaturation", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepSaturation", "");
    return;
  }

  uic_mqtt_dotdot_color_control_generated_step_saturation_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    step_mode,

    step_size,

    transition_time,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/MoveToHueAndSaturation
void uic_mqtt_dotdot_on_color_control_move_to_hue_and_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t hue = {};
  uint8_t saturation = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_to_hue_and_saturation(
      jsn,
      hue,

      saturation,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToHueAndSaturation");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToHueAndSaturation", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToHueAndSaturation", "");
    return;
  }

  uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    hue,

    saturation,

    transition_time,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/MoveToHueAndSaturation
static void uic_mqtt_dotdot_on_generated_color_control_move_to_hue_and_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_move_to_hue_and_saturation_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t hue;
  uint8_t saturation;
  uint16_t transition_time;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_to_hue_and_saturation(
      jsn,
      hue,

      saturation,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToHueAndSaturation");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToHueAndSaturation", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToHueAndSaturation", "");
    return;
  }

  uic_mqtt_dotdot_color_control_generated_move_to_hue_and_saturation_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    hue,

    saturation,

    transition_time,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/MoveToColor
void uic_mqtt_dotdot_on_color_control_move_to_color(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_move_to_color_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t colorx = {};
  uint16_t colory = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_to_color(
      jsn,
      colorx,

      colory,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToColor");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToColor", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToColor", "");
    return;
  }

  uic_mqtt_dotdot_color_control_move_to_color_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    colorx,

    colory,

    transition_time,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/MoveToColor
static void uic_mqtt_dotdot_on_generated_color_control_move_to_color(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_move_to_color_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t colorx;
  uint16_t colory;
  uint16_t transition_time;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_to_color(
      jsn,
      colorx,

      colory,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToColor");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToColor", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToColor", "");
    return;
  }

  uic_mqtt_dotdot_color_control_generated_move_to_color_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    colorx,

    colory,

    transition_time,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/MoveColor
void uic_mqtt_dotdot_on_color_control_move_color(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_move_color_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  int16_t ratex = {};
  int16_t ratey = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_color(
      jsn,
      ratex,

      ratey,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveColor");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveColor", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveColor", "");
    return;
  }

  uic_mqtt_dotdot_color_control_move_color_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    ratex,

    ratey,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/MoveColor
static void uic_mqtt_dotdot_on_generated_color_control_move_color(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_move_color_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  int16_t ratex;
  int16_t ratey;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_color(
      jsn,
      ratex,

      ratey,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveColor");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveColor", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveColor", "");
    return;
  }

  uic_mqtt_dotdot_color_control_generated_move_color_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    ratex,

    ratey,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/StepColor
void uic_mqtt_dotdot_on_color_control_step_color(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_step_color_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  int16_t stepx = {};
  int16_t stepy = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_step_color(
      jsn,
      stepx,

      stepy,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StepColor");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepColor", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepColor", "");
    return;
  }

  uic_mqtt_dotdot_color_control_step_color_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    stepx,

    stepy,

    transition_time,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/StepColor
static void uic_mqtt_dotdot_on_generated_color_control_step_color(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_step_color_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  int16_t stepx;
  int16_t stepy;
  uint16_t transition_time;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_step_color(
      jsn,
      stepx,

      stepy,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StepColor");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepColor", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepColor", "");
    return;
  }

  uic_mqtt_dotdot_color_control_generated_step_color_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    stepx,

    stepy,

    transition_time,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/MoveToColorTemperature
void uic_mqtt_dotdot_on_color_control_move_to_color_temperature(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_move_to_color_temperature_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t color_temperature_mireds = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_to_color_temperature(
      jsn,
      color_temperature_mireds,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToColorTemperature");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToColorTemperature", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToColorTemperature", "");
    return;
  }

  uic_mqtt_dotdot_color_control_move_to_color_temperature_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    color_temperature_mireds,

    transition_time,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/MoveToColorTemperature
static void uic_mqtt_dotdot_on_generated_color_control_move_to_color_temperature(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_move_to_color_temperature_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t color_temperature_mireds;
  uint16_t transition_time;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_to_color_temperature(
      jsn,
      color_temperature_mireds,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToColorTemperature");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToColorTemperature", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToColorTemperature", "");
    return;
  }

  uic_mqtt_dotdot_color_control_generated_move_to_color_temperature_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    color_temperature_mireds,

    transition_time,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/EnhancedMoveToHue
void uic_mqtt_dotdot_on_color_control_enhanced_move_to_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t enhanced_hue = {};
  CCDirection direction = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_enhanced_move_to_hue(
      jsn,
      enhanced_hue,

      direction,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "EnhancedMoveToHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveToHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveToHue", "");
    return;
  }

  uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    enhanced_hue,

    direction,

    transition_time,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/EnhancedMoveToHue
static void uic_mqtt_dotdot_on_generated_color_control_enhanced_move_to_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t enhanced_hue;
  CCDirection direction;
  uint16_t transition_time;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_enhanced_move_to_hue(
      jsn,
      enhanced_hue,

      direction,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "EnhancedMoveToHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveToHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveToHue", "");
    return;
  }

  uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    enhanced_hue,

    direction,

    transition_time,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/EnhancedMoveHue
void uic_mqtt_dotdot_on_color_control_enhanced_move_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_enhanced_move_hue_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCMoveMode move_mode = {};
  uint16_t rate = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_enhanced_move_hue(
      jsn,
      move_mode,

      rate,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "EnhancedMoveHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveHue", "");
    return;
  }

  uic_mqtt_dotdot_color_control_enhanced_move_hue_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    move_mode,

    rate,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/EnhancedMoveHue
static void uic_mqtt_dotdot_on_generated_color_control_enhanced_move_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_enhanced_move_hue_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCMoveMode move_mode;
  uint16_t rate;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_enhanced_move_hue(
      jsn,
      move_mode,

      rate,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "EnhancedMoveHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveHue", "");
    return;
  }

  uic_mqtt_dotdot_color_control_generated_enhanced_move_hue_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    move_mode,

    rate,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/EnhancedStepHue
void uic_mqtt_dotdot_on_color_control_enhanced_step_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_enhanced_step_hue_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCStepMode step_mode = {};
  uint16_t step_size = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_enhanced_step_hue(
      jsn,
      step_mode,

      step_size,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "EnhancedStepHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedStepHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedStepHue", "");
    return;
  }

  uic_mqtt_dotdot_color_control_enhanced_step_hue_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    step_mode,

    step_size,

    transition_time,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/EnhancedStepHue
static void uic_mqtt_dotdot_on_generated_color_control_enhanced_step_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_enhanced_step_hue_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCStepMode step_mode;
  uint16_t step_size;
  uint16_t transition_time;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_enhanced_step_hue(
      jsn,
      step_mode,

      step_size,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "EnhancedStepHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedStepHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedStepHue", "");
    return;
  }

  uic_mqtt_dotdot_color_control_generated_enhanced_step_hue_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    step_mode,

    step_size,

    transition_time,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/EnhancedMoveToHueAndSaturation
void uic_mqtt_dotdot_on_color_control_enhanced_move_to_hue_and_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t enhanced_hue = {};
  uint8_t saturation = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_enhanced_move_to_hue_and_saturation(
      jsn,
      enhanced_hue,

      saturation,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "EnhancedMoveToHueAndSaturation");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveToHueAndSaturation", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveToHueAndSaturation", "");
    return;
  }

  uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    enhanced_hue,

    saturation,

    transition_time,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/EnhancedMoveToHueAndSaturation
static void uic_mqtt_dotdot_on_generated_color_control_enhanced_move_to_hue_and_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_and_saturation_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t enhanced_hue;
  uint8_t saturation;
  uint16_t transition_time;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_enhanced_move_to_hue_and_saturation(
      jsn,
      enhanced_hue,

      saturation,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "EnhancedMoveToHueAndSaturation");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveToHueAndSaturation", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveToHueAndSaturation", "");
    return;
  }

  uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_and_saturation_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    enhanced_hue,

    saturation,

    transition_time,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/ColorLoopSet
void uic_mqtt_dotdot_on_color_control_color_loop_set(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_color_loop_set_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t update_flags = {};
  ColorLoopSetAction action = {};
  CCColorLoopDirection direction = {};
  uint16_t time = {};
  uint16_t start_hue = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_color_loop_set(
      jsn,
      update_flags,

      action,

      direction,

      time,

      start_hue,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "ColorLoopSet");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "ColorLoopSet", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "ColorLoopSet", "");
    return;
  }

  uic_mqtt_dotdot_color_control_color_loop_set_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    update_flags,

    action,

    direction,

    time,

    start_hue,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/ColorLoopSet
static void uic_mqtt_dotdot_on_generated_color_control_color_loop_set(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_color_loop_set_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t update_flags;
  ColorLoopSetAction action;
  CCColorLoopDirection direction;
  uint16_t time;
  uint16_t start_hue;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_color_loop_set(
      jsn,
      update_flags,

      action,

      direction,

      time,

      start_hue,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "ColorLoopSet");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "ColorLoopSet", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "ColorLoopSet", "");
    return;
  }

  uic_mqtt_dotdot_color_control_generated_color_loop_set_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    update_flags,

    action,

    direction,

    time,

    start_hue,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/StopMoveStep
void uic_mqtt_dotdot_on_color_control_stop_move_step(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_stop_move_step_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_stop_move_step(
      jsn,
      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StopMoveStep");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StopMoveStep", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StopMoveStep", "");
    return;
  }

  uic_mqtt_dotdot_color_control_stop_move_step_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/StopMoveStep
static void uic_mqtt_dotdot_on_generated_color_control_stop_move_step(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_stop_move_step_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_stop_move_step(
      jsn,
      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StopMoveStep");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StopMoveStep", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StopMoveStep", "");
    return;
  }

  uic_mqtt_dotdot_color_control_generated_stop_move_step_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/MoveColorTemperature
void uic_mqtt_dotdot_on_color_control_move_color_temperature(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_move_color_temperature_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCMoveMode move_mode = {};
  uint16_t rate = {};
  CCMinMiredsField color_temperature_minimum_mireds = {};
  CCMaxMiredsField color_temperature_maximum_mireds = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_color_temperature(
      jsn,
      move_mode,

      rate,

      color_temperature_minimum_mireds,

      color_temperature_maximum_mireds,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveColorTemperature");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveColorTemperature", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveColorTemperature", "");
    return;
  }

  uic_mqtt_dotdot_color_control_move_color_temperature_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    move_mode,

    rate,

    color_temperature_minimum_mireds,

    color_temperature_maximum_mireds,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/MoveColorTemperature
static void uic_mqtt_dotdot_on_generated_color_control_move_color_temperature(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_move_color_temperature_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCMoveMode move_mode;
  uint16_t rate;
  CCMinMiredsField color_temperature_minimum_mireds;
  CCMaxMiredsField color_temperature_maximum_mireds;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_color_temperature(
      jsn,
      move_mode,

      rate,

      color_temperature_minimum_mireds,

      color_temperature_maximum_mireds,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveColorTemperature");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveColorTemperature", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveColorTemperature", "");
    return;
  }

  uic_mqtt_dotdot_color_control_generated_move_color_temperature_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    move_mode,

    rate,

    color_temperature_minimum_mireds,

    color_temperature_maximum_mireds,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/StepColorTemperature
void uic_mqtt_dotdot_on_color_control_step_color_temperature(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_step_color_temperature_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCStepMode step_mode = {};
  uint16_t step_size = {};
  uint16_t transition_time = {};
  CCMinMiredsField color_temperature_minimum_mireds = {};
  CCMaxMiredsField color_temperature_maximum_mireds = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_step_color_temperature(
      jsn,
      step_mode,

      step_size,

      transition_time,

      color_temperature_minimum_mireds,

      color_temperature_maximum_mireds,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StepColorTemperature");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepColorTemperature", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepColorTemperature", "");
    return;
  }

  uic_mqtt_dotdot_color_control_step_color_temperature_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    step_mode,

    step_size,

    transition_time,

    color_temperature_minimum_mireds,

    color_temperature_maximum_mireds,

    options_mask,

    options_override

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/StepColorTemperature
static void uic_mqtt_dotdot_on_generated_color_control_step_color_temperature(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_step_color_temperature_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCStepMode step_mode;
  uint16_t step_size;
  uint16_t transition_time;
  CCMinMiredsField color_temperature_minimum_mireds;
  CCMaxMiredsField color_temperature_maximum_mireds;
  uint8_t options_mask;
  uint8_t options_override;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_step_color_temperature(
      jsn,
      step_mode,

      step_size,

      transition_time,

      color_temperature_minimum_mireds,

      color_temperature_maximum_mireds,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StepColorTemperature");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepColorTemperature", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepColorTemperature", "");
    return;
  }

  uic_mqtt_dotdot_color_control_generated_step_color_temperature_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    step_mode,

    step_size,

    transition_time,

    color_temperature_minimum_mireds,

    color_temperature_maximum_mireds,

    options_mask,

    options_override

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/WriteAttributes
void uic_mqtt_dotdot_on_color_control_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_color_control_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_color_control_state_t new_state = {};
  uic_mqtt_dotdot_color_control_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_color_control_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_color_control_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_color_control_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_color_control_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_color_control_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.current_hue = true;
        force_update.current_saturation = true;
        force_update.remaining_time = true;
        force_update.currentx = true;
        force_update.currenty = true;
        force_update.drift_compensation = true;
        force_update.compensation_text = true;
        force_update.color_temperature_mireds = true;
        force_update.color_mode = true;
        force_update.options = true;
        force_update.number_of_primaries = true;
        force_update.primary1x = true;
        force_update.primary1y = true;
        force_update.primary1_intensity = true;
        force_update.primary2x = true;
        force_update.primary2y = true;
        force_update.primary2_intensity = true;
        force_update.primary3x = true;
        force_update.primary3y = true;
        force_update.primary3_intensity = true;
        force_update.primary4x = true;
        force_update.primary4y = true;
        force_update.primary4_intensity = true;
        force_update.primary5x = true;
        force_update.primary5y = true;
        force_update.primary5_intensity = true;
        force_update.primary6x = true;
        force_update.primary6y = true;
        force_update.primary6_intensity = true;
        force_update.white_pointx = true;
        force_update.white_pointy = true;
        force_update.color_pointrx = true;
        force_update.color_pointry = true;
        force_update.color_pointr_intensity = true;
        force_update.color_pointgx = true;
        force_update.color_pointgy = true;
        force_update.color_pointg_intensity = true;
        force_update.color_pointbx = true;
        force_update.color_pointby = true;
        force_update.color_pointb_intensity = true;
        force_update.enhanced_current_hue = true;
        force_update.enhanced_color_mode = true;
        force_update.color_loop_active = true;
        force_update.color_loop_direction = true;
        force_update.color_loop_time = true;
        force_update.color_loop_start_enhanced_hue = true;
        force_update.color_loop_stored_enhanced_hue = true;
        force_update.color_capabilities = true;
        force_update.color_temp_physical_min_mireds = true;
        force_update.color_temp_physical_max_mireds = true;
        force_update.couple_color_temp_to_level_min_mireds = true;
        force_update.start_up_color_temperature_mireds = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"CurrentHue", &force_update.current_hue },
          {"CurrentSaturation", &force_update.current_saturation },
          {"RemainingTime", &force_update.remaining_time },
          {"CurrentX", &force_update.currentx },
          {"CurrentY", &force_update.currenty },
          {"DriftCompensation", &force_update.drift_compensation },
          {"CompensationText", &force_update.compensation_text },
          {"ColorTemperatureMireds", &force_update.color_temperature_mireds },
          {"ColorMode", &force_update.color_mode },
          {"Options", &force_update.options },
          {"NumberOfPrimaries", &force_update.number_of_primaries },
          {"Primary1X", &force_update.primary1x },
          {"Primary1Y", &force_update.primary1y },
          {"Primary1Intensity", &force_update.primary1_intensity },
          {"Primary2X", &force_update.primary2x },
          {"Primary2Y", &force_update.primary2y },
          {"Primary2Intensity", &force_update.primary2_intensity },
          {"Primary3X", &force_update.primary3x },
          {"Primary3Y", &force_update.primary3y },
          {"Primary3Intensity", &force_update.primary3_intensity },
          {"Primary4X", &force_update.primary4x },
          {"Primary4Y", &force_update.primary4y },
          {"Primary4Intensity", &force_update.primary4_intensity },
          {"Primary5X", &force_update.primary5x },
          {"Primary5Y", &force_update.primary5y },
          {"Primary5Intensity", &force_update.primary5_intensity },
          {"Primary6X", &force_update.primary6x },
          {"Primary6Y", &force_update.primary6y },
          {"Primary6Intensity", &force_update.primary6_intensity },
          {"WhitePointX", &force_update.white_pointx },
          {"WhitePointY", &force_update.white_pointy },
          {"ColorPointRX", &force_update.color_pointrx },
          {"ColorPointRY", &force_update.color_pointry },
          {"ColorPointRIntensity", &force_update.color_pointr_intensity },
          {"ColorPointGX", &force_update.color_pointgx },
          {"ColorPointGY", &force_update.color_pointgy },
          {"ColorPointGIntensity", &force_update.color_pointg_intensity },
          {"ColorPointBX", &force_update.color_pointbx },
          {"ColorPointBY", &force_update.color_pointby },
          {"ColorPointBIntensity", &force_update.color_pointb_intensity },
          {"EnhancedCurrentHue", &force_update.enhanced_current_hue },
          {"EnhancedColorMode", &force_update.enhanced_color_mode },
          {"ColorLoopActive", &force_update.color_loop_active },
          {"ColorLoopDirection", &force_update.color_loop_direction },
          {"ColorLoopTime", &force_update.color_loop_time },
          {"ColorLoopStartEnhancedHue", &force_update.color_loop_start_enhanced_hue },
          {"ColorLoopStoredEnhancedHue", &force_update.color_loop_stored_enhanced_hue },
          {"ColorCapabilities", &force_update.color_capabilities },
          {"ColorTempPhysicalMinMireds", &force_update.color_temp_physical_min_mireds },
          {"ColorTempPhysicalMaxMireds", &force_update.color_temp_physical_max_mireds },
          {"CoupleColorTempToLevelMinMireds", &force_update.couple_color_temp_to_level_min_mireds },
          {"StartUpColorTemperatureMireds", &force_update.start_up_color_temperature_mireds },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_color_control_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "ColorControl/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_color_control_current_hue_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/CurrentHue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/CurrentHue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_current_saturation_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/CurrentSaturation", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/CurrentSaturation";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_remaining_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/RemainingTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/RemainingTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_currentx_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/CurrentX", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/CurrentX";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_currenty_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/CurrentY", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/CurrentY";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_drift_compensation_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef COLOR_CONTROL_DRIFT_COMPENSATION_ENUM_NAME_AVAILABLE
  jsn["value"] = color_control_drift_compensation_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<ColorControlDriftCompensation>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/DriftCompensation", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/DriftCompensation";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_compensation_text_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/CompensationText", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/CompensationText";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_color_temperature_mireds_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorTemperatureMireds", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorTemperatureMireds";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_color_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef COLOR_CONTROL_COLOR_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = color_control_color_mode_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<ColorControlColorMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_options_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = CCColorOptions.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Options", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Options";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_number_of_primaries_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/NumberOfPrimaries", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/NumberOfPrimaries";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_primary1x_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary1X", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary1X";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_primary1y_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary1Y", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary1Y";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_primary1_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary1Intensity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary1Intensity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_primary2x_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary2X", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary2X";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_primary2y_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary2Y", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary2Y";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_primary2_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary2Intensity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary2Intensity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_primary3x_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary3X", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary3X";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_primary3y_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary3Y", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary3Y";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_primary3_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary3Intensity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary3Intensity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_primary4x_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary4X", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary4X";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_primary4y_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary4Y", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary4Y";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_primary4_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary4Intensity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary4Intensity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_primary5x_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary5X", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary5X";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_primary5y_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary5Y", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary5Y";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_primary5_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary5Intensity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary5Intensity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_primary6x_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary6X", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary6X";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_primary6y_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary6Y", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary6Y";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_primary6_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary6Intensity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary6Intensity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_white_pointx_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/WhitePointX", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/WhitePointX";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_white_pointy_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/WhitePointY", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/WhitePointY";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_color_pointrx_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorPointRX", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorPointRX";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_color_pointry_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorPointRY", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorPointRY";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_color_pointr_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorPointRIntensity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorPointRIntensity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_color_pointgx_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorPointGX", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorPointGX";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_color_pointgy_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorPointGY", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorPointGY";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_color_pointg_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorPointGIntensity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorPointGIntensity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_color_pointbx_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorPointBX", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorPointBX";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_color_pointby_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorPointBY", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorPointBY";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_color_pointb_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorPointBIntensity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorPointBIntensity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_enhanced_current_hue_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/EnhancedCurrentHue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/EnhancedCurrentHue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_enhanced_color_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef COLOR_CONTROL_ENHANCED_COLOR_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = color_control_enhanced_color_mode_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<ColorControlEnhancedColorMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/EnhancedColorMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/EnhancedColorMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_color_loop_active_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorLoopActive", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorLoopActive";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_color_loop_direction_publish(
  const char *base_topic,
  CCColorLoopDirection value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef COLOR_CONTROL_COLOR_LOOP_DIRECTION_ENUM_NAME_AVAILABLE
  jsn["value"] = color_control_color_loop_direction_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<CCColorLoopDirection>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorLoopDirection", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorLoopDirection";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_color_loop_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorLoopTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorLoopTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_color_loop_start_enhanced_hue_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorLoopStartEnhancedHue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorLoopStartEnhancedHue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_color_loop_stored_enhanced_hue_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorLoopStoredEnhancedHue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorLoopStoredEnhancedHue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_color_capabilities_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ColorControlColorCapabilities.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorCapabilities", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorCapabilities";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_color_temp_physical_min_mireds_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorTempPhysicalMinMireds", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorTempPhysicalMinMireds";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_color_temp_physical_max_mireds_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorTempPhysicalMaxMireds", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorTempPhysicalMaxMireds";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_couple_color_temp_to_level_min_mireds_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/CoupleColorTempToLevelMinMireds", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/CoupleColorTempToLevelMinMireds";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_color_control_start_up_color_temperature_mireds_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/StartUpColorTemperatureMireds", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/StartUpColorTemperatureMireds";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_color_control_write_attributes_callback) {
    subscription_topic = base_topic + "ColorControl/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_WriteAttributes);
  }

  if(uic_mqtt_dotdot_color_control_force_read_attributes_callback) {
    subscription_topic = base_topic + "ColorControl/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_force_read_attributes);
  }
  if (uic_mqtt_dotdot_color_control_move_to_hue_callback) {
    subscription_topic = base_topic + "ColorControl/Commands/MoveToHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_move_to_hue);
  }
  if (uic_mqtt_dotdot_color_control_generated_move_to_hue_callback) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/MoveToHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_move_to_hue);
  }
  if (uic_mqtt_dotdot_color_control_move_hue_callback) {
    subscription_topic = base_topic + "ColorControl/Commands/MoveHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_move_hue);
  }
  if (uic_mqtt_dotdot_color_control_generated_move_hue_callback) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/MoveHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_move_hue);
  }
  if (uic_mqtt_dotdot_color_control_step_hue_callback) {
    subscription_topic = base_topic + "ColorControl/Commands/StepHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_step_hue);
  }
  if (uic_mqtt_dotdot_color_control_generated_step_hue_callback) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/StepHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_step_hue);
  }
  if (uic_mqtt_dotdot_color_control_move_to_saturation_callback) {
    subscription_topic = base_topic + "ColorControl/Commands/MoveToSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_move_to_saturation);
  }
  if (uic_mqtt_dotdot_color_control_generated_move_to_saturation_callback) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/MoveToSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_move_to_saturation);
  }
  if (uic_mqtt_dotdot_color_control_move_saturation_callback) {
    subscription_topic = base_topic + "ColorControl/Commands/MoveSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_move_saturation);
  }
  if (uic_mqtt_dotdot_color_control_generated_move_saturation_callback) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/MoveSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_move_saturation);
  }
  if (uic_mqtt_dotdot_color_control_step_saturation_callback) {
    subscription_topic = base_topic + "ColorControl/Commands/StepSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_step_saturation);
  }
  if (uic_mqtt_dotdot_color_control_generated_step_saturation_callback) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/StepSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_step_saturation);
  }
  if (uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback) {
    subscription_topic = base_topic + "ColorControl/Commands/MoveToHueAndSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_move_to_hue_and_saturation);
  }
  if (uic_mqtt_dotdot_color_control_generated_move_to_hue_and_saturation_callback) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/MoveToHueAndSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_move_to_hue_and_saturation);
  }
  if (uic_mqtt_dotdot_color_control_move_to_color_callback) {
    subscription_topic = base_topic + "ColorControl/Commands/MoveToColor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_move_to_color);
  }
  if (uic_mqtt_dotdot_color_control_generated_move_to_color_callback) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/MoveToColor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_move_to_color);
  }
  if (uic_mqtt_dotdot_color_control_move_color_callback) {
    subscription_topic = base_topic + "ColorControl/Commands/MoveColor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_move_color);
  }
  if (uic_mqtt_dotdot_color_control_generated_move_color_callback) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/MoveColor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_move_color);
  }
  if (uic_mqtt_dotdot_color_control_step_color_callback) {
    subscription_topic = base_topic + "ColorControl/Commands/StepColor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_step_color);
  }
  if (uic_mqtt_dotdot_color_control_generated_step_color_callback) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/StepColor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_step_color);
  }
  if (uic_mqtt_dotdot_color_control_move_to_color_temperature_callback) {
    subscription_topic = base_topic + "ColorControl/Commands/MoveToColorTemperature";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_move_to_color_temperature);
  }
  if (uic_mqtt_dotdot_color_control_generated_move_to_color_temperature_callback) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/MoveToColorTemperature";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_move_to_color_temperature);
  }
  if (uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback) {
    subscription_topic = base_topic + "ColorControl/Commands/EnhancedMoveToHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_enhanced_move_to_hue);
  }
  if (uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_callback) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/EnhancedMoveToHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_enhanced_move_to_hue);
  }
  if (uic_mqtt_dotdot_color_control_enhanced_move_hue_callback) {
    subscription_topic = base_topic + "ColorControl/Commands/EnhancedMoveHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_enhanced_move_hue);
  }
  if (uic_mqtt_dotdot_color_control_generated_enhanced_move_hue_callback) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/EnhancedMoveHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_enhanced_move_hue);
  }
  if (uic_mqtt_dotdot_color_control_enhanced_step_hue_callback) {
    subscription_topic = base_topic + "ColorControl/Commands/EnhancedStepHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_enhanced_step_hue);
  }
  if (uic_mqtt_dotdot_color_control_generated_enhanced_step_hue_callback) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/EnhancedStepHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_enhanced_step_hue);
  }
  if (uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback) {
    subscription_topic = base_topic + "ColorControl/Commands/EnhancedMoveToHueAndSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_enhanced_move_to_hue_and_saturation);
  }
  if (uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_and_saturation_callback) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/EnhancedMoveToHueAndSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_enhanced_move_to_hue_and_saturation);
  }
  if (uic_mqtt_dotdot_color_control_color_loop_set_callback) {
    subscription_topic = base_topic + "ColorControl/Commands/ColorLoopSet";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_color_loop_set);
  }
  if (uic_mqtt_dotdot_color_control_generated_color_loop_set_callback) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/ColorLoopSet";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_color_loop_set);
  }
  if (uic_mqtt_dotdot_color_control_stop_move_step_callback) {
    subscription_topic = base_topic + "ColorControl/Commands/StopMoveStep";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_stop_move_step);
  }
  if (uic_mqtt_dotdot_color_control_generated_stop_move_step_callback) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/StopMoveStep";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_stop_move_step);
  }
  if (uic_mqtt_dotdot_color_control_move_color_temperature_callback) {
    subscription_topic = base_topic + "ColorControl/Commands/MoveColorTemperature";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_move_color_temperature);
  }
  if (uic_mqtt_dotdot_color_control_generated_move_color_temperature_callback) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/MoveColorTemperature";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_move_color_temperature);
  }
  if (uic_mqtt_dotdot_color_control_step_color_temperature_callback) {
    subscription_topic = base_topic + "ColorControl/Commands/StepColorTemperature";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_step_color_temperature);
  }
  if (uic_mqtt_dotdot_color_control_generated_step_color_temperature_callback) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/StepColorTemperature";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_step_color_temperature);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_color_control_attributes_init();

  uic_mqtt_dotdot_by_group_color_control_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_ballast_configuration_write_attributes_callback_t uic_mqtt_dotdot_ballast_configuration_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_ballast_configuration_force_read_attributes_callback_t uic_mqtt_dotdot_ballast_configuration_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_ballast_configuration_write_attributes_callback(
  const uic_mqtt_dotdot_ballast_configuration_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_ballast_configuration_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_ballast_configuration_force_read_attributes_callback(
  const uic_mqtt_dotdot_ballast_configuration_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_ballast_configuration_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/BallastConfiguration/Commands/WriteAttributes
void uic_mqtt_dotdot_on_ballast_configuration_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_ballast_configuration_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_ballast_configuration_state_t new_state = {};
  uic_mqtt_dotdot_ballast_configuration_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_ballast_configuration_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "BallastConfiguration", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_ballast_configuration_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_ballast_configuration_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_ballast_configuration_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_ballast_configuration_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.physical_min_level = true;
        force_update.physical_max_level = true;
        force_update.ballast_status = true;
        force_update.min_level = true;
        force_update.max_level = true;
        force_update.power_on_level = true;
        force_update.power_on_fade_time = true;
        force_update.intrinsic_ballast_factor = true;
        force_update.ballast_factor_adjustment = true;
        force_update.lamp_quantity = true;
        force_update.lamp_type = true;
        force_update.lamp_manufacturer = true;
        force_update.lamp_rated_hours = true;
        force_update.lamp_burn_hours = true;
        force_update.lamp_alarm_mode = true;
        force_update.lamp_burn_hours_trip_point = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"PhysicalMinLevel", &force_update.physical_min_level },
          {"PhysicalMaxLevel", &force_update.physical_max_level },
          {"BallastStatus", &force_update.ballast_status },
          {"MinLevel", &force_update.min_level },
          {"MaxLevel", &force_update.max_level },
          {"PowerOnLevel", &force_update.power_on_level },
          {"PowerOnFadeTime", &force_update.power_on_fade_time },
          {"IntrinsicBallastFactor", &force_update.intrinsic_ballast_factor },
          {"BallastFactorAdjustment", &force_update.ballast_factor_adjustment },
          {"LampQuantity", &force_update.lamp_quantity },
          {"LampType", &force_update.lamp_type },
          {"LampManufacturer", &force_update.lamp_manufacturer },
          {"LampRatedHours", &force_update.lamp_rated_hours },
          {"LampBurnHours", &force_update.lamp_burn_hours },
          {"LampAlarmMode", &force_update.lamp_alarm_mode },
          {"LampBurnHoursTripPoint", &force_update.lamp_burn_hours_trip_point },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_ballast_configuration_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "BallastConfiguration/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_ballast_configuration_physical_min_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/PhysicalMinLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/PhysicalMinLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ballast_configuration_physical_max_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/PhysicalMaxLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/PhysicalMaxLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ballast_configuration_ballast_status_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BallastConfigurationBallastStatus.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/BallastStatus", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/BallastStatus";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ballast_configuration_min_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/MinLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/MinLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ballast_configuration_max_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/MaxLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/MaxLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ballast_configuration_power_on_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/PowerOnLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/PowerOnLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ballast_configuration_power_on_fade_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/PowerOnFadeTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/PowerOnFadeTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ballast_configuration_intrinsic_ballast_factor_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/IntrinsicBallastFactor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/IntrinsicBallastFactor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ballast_configuration_ballast_factor_adjustment_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/BallastFactorAdjustment", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/BallastFactorAdjustment";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_quantity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/LampQuantity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/LampQuantity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_type_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/LampType", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/LampType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_manufacturer_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/LampManufacturer", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/LampManufacturer";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_rated_hours_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/LampRatedHours", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/LampRatedHours";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_burn_hours_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/LampBurnHours", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/LampBurnHours";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_alarm_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BallastConfigurationLampAlarmMode.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/LampAlarmMode", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/LampAlarmMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_burn_hours_trip_point_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/LampBurnHoursTripPoint", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/LampBurnHoursTripPoint";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ballast_configuration_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_ballast_configuration_write_attributes_callback) {
    subscription_topic = base_topic + "BallastConfiguration/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ballast_configuration_WriteAttributes);
  }

  if(uic_mqtt_dotdot_ballast_configuration_force_read_attributes_callback) {
    subscription_topic = base_topic + "BallastConfiguration/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ballast_configuration_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_ballast_configuration_attributes_init();

  uic_mqtt_dotdot_by_group_ballast_configuration_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback_t uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_callback_t uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_illuminance_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_illuminance_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/IlluminanceMeasurement/Commands/WriteAttributes
void uic_mqtt_dotdot_on_illuminance_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_illuminance_measurement_state_t new_state = {};
  uic_mqtt_dotdot_illuminance_measurement_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_illuminance_measurement_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IlluminanceMeasurement", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceMeasurement", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceMeasurement", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_illuminance_measurement_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_illuminance_measurement_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.measured_value = true;
        force_update.min_measured_value = true;
        force_update.max_measured_value = true;
        force_update.tolerance = true;
        force_update.light_sensor_type = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"MeasuredValue", &force_update.measured_value },
          {"MinMeasuredValue", &force_update.min_measured_value },
          {"MaxMeasuredValue", &force_update.max_measured_value },
          {"Tolerance", &force_update.tolerance },
          {"LightSensorType", &force_update.light_sensor_type },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "IlluminanceMeasurement/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_illuminance_measurement_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceMeasurement/Attributes/MeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IlluminanceMeasurement/Attributes/MeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_illuminance_measurement_min_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceMeasurement/Attributes/MinMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IlluminanceMeasurement/Attributes/MinMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_illuminance_measurement_max_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceMeasurement/Attributes/MaxMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IlluminanceMeasurement/Attributes/MaxMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_illuminance_measurement_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceMeasurement/Attributes/Tolerance", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IlluminanceMeasurement/Attributes/Tolerance";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_illuminance_measurement_light_sensor_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef ILLUMINANCE_MEASUREMENT_LIGHT_SENSOR_TYPE_ENUM_NAME_AVAILABLE
  jsn["value"] = illuminance_measurement_light_sensor_type_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<IlluminanceMeasurementLightSensorType>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceMeasurement/Attributes/LightSensorType", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IlluminanceMeasurement/Attributes/LightSensorType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_illuminance_measurement_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback) {
    subscription_topic = base_topic + "IlluminanceMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_illuminance_measurement_WriteAttributes);
  }

  if(uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_callback) {
    subscription_topic = base_topic + "IlluminanceMeasurement/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_illuminance_measurement_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_illuminance_measurement_attributes_init();

  uic_mqtt_dotdot_by_group_illuminance_measurement_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback_t uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_callback_t uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_illuminance_level_sensing_write_attributes_callback(
  const uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_illuminance_level_sensing_force_read_attributes_callback(
  const uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/IlluminanceLevelSensing/Commands/WriteAttributes
void uic_mqtt_dotdot_on_illuminance_level_sensing_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_illuminance_level_sensing_state_t new_state = {};
  uic_mqtt_dotdot_illuminance_level_sensing_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_illuminance_level_sensing_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IlluminanceLevelSensing", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceLevelSensing", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceLevelSensing", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_illuminance_level_sensing_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_illuminance_level_sensing_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.level_status = true;
        force_update.light_sensor_type = true;
        force_update.illuminance_target_level = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"LevelStatus", &force_update.level_status },
          {"LightSensorType", &force_update.light_sensor_type },
          {"IlluminanceTargetLevel", &force_update.illuminance_target_level },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "IlluminanceLevelSensing/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_illuminance_level_sensing_level_status_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef ILLUMINANCE_LEVEL_SENSING_LEVEL_STATUS_ENUM_NAME_AVAILABLE
  jsn["value"] = illuminance_level_sensing_level_status_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<IlluminanceLevelSensingLevelStatus>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceLevelSensing/Attributes/LevelStatus", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IlluminanceLevelSensing/Attributes/LevelStatus";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_illuminance_level_sensing_light_sensor_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef ILLUMINANCE_LEVEL_SENSING_LIGHT_SENSOR_TYPE_ENUM_NAME_AVAILABLE
  jsn["value"] = illuminance_level_sensing_light_sensor_type_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<IlluminanceLevelSensingLightSensorType>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceLevelSensing/Attributes/LightSensorType", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IlluminanceLevelSensing/Attributes/LightSensorType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_illuminance_level_sensing_illuminance_target_level_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceLevelSensing/Attributes/IlluminanceTargetLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IlluminanceLevelSensing/Attributes/IlluminanceTargetLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_illuminance_level_sensing_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback) {
    subscription_topic = base_topic + "IlluminanceLevelSensing/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_illuminance_level_sensing_WriteAttributes);
  }

  if(uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_callback) {
    subscription_topic = base_topic + "IlluminanceLevelSensing/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_illuminance_level_sensing_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_illuminance_level_sensing_attributes_init();

  uic_mqtt_dotdot_by_group_illuminance_level_sensing_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_temperature_measurement_write_attributes_callback_t uic_mqtt_dotdot_temperature_measurement_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_temperature_measurement_force_read_attributes_callback_t uic_mqtt_dotdot_temperature_measurement_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_temperature_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_temperature_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_temperature_measurement_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_temperature_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_temperature_measurement_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_temperature_measurement_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/TemperatureMeasurement/Commands/WriteAttributes
void uic_mqtt_dotdot_on_temperature_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_temperature_measurement_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_temperature_measurement_state_t new_state = {};
  uic_mqtt_dotdot_temperature_measurement_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_temperature_measurement_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "TemperatureMeasurement", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "TemperatureMeasurement", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "TemperatureMeasurement", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_temperature_measurement_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_temperature_measurement_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_temperature_measurement_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_temperature_measurement_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.measured_value = true;
        force_update.min_measured_value = true;
        force_update.max_measured_value = true;
        force_update.tolerance = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"MeasuredValue", &force_update.measured_value },
          {"MinMeasuredValue", &force_update.min_measured_value },
          {"MaxMeasuredValue", &force_update.max_measured_value },
          {"Tolerance", &force_update.tolerance },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_temperature_measurement_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "TemperatureMeasurement/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_temperature_measurement_measured_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "TemperatureMeasurement/Attributes/MeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/TemperatureMeasurement/Attributes/MeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_temperature_measurement_min_measured_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "TemperatureMeasurement/Attributes/MinMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/TemperatureMeasurement/Attributes/MinMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_temperature_measurement_max_measured_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "TemperatureMeasurement/Attributes/MaxMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/TemperatureMeasurement/Attributes/MaxMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_temperature_measurement_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "TemperatureMeasurement/Attributes/Tolerance", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/TemperatureMeasurement/Attributes/Tolerance";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_temperature_measurement_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_temperature_measurement_write_attributes_callback) {
    subscription_topic = base_topic + "TemperatureMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_temperature_measurement_WriteAttributes);
  }

  if(uic_mqtt_dotdot_temperature_measurement_force_read_attributes_callback) {
    subscription_topic = base_topic + "TemperatureMeasurement/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_temperature_measurement_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_temperature_measurement_attributes_init();

  uic_mqtt_dotdot_by_group_temperature_measurement_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_pressure_measurement_write_attributes_callback_t uic_mqtt_dotdot_pressure_measurement_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_pressure_measurement_force_read_attributes_callback_t uic_mqtt_dotdot_pressure_measurement_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_pressure_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_pressure_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_pressure_measurement_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_pressure_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_pressure_measurement_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_pressure_measurement_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/PressureMeasurement/Commands/WriteAttributes
void uic_mqtt_dotdot_on_pressure_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_pressure_measurement_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_pressure_measurement_state_t new_state = {};
  uic_mqtt_dotdot_pressure_measurement_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_pressure_measurement_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PressureMeasurement", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_pressure_measurement_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_pressure_measurement_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_pressure_measurement_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_pressure_measurement_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.measured_value = true;
        force_update.min_measured_value = true;
        force_update.max_measured_value = true;
        force_update.tolerance = true;
        force_update.scaled_value = true;
        force_update.min_scaled_value = true;
        force_update.max_scaled_value = true;
        force_update.scaled_tolerance = true;
        force_update.scale = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"MeasuredValue", &force_update.measured_value },
          {"MinMeasuredValue", &force_update.min_measured_value },
          {"MaxMeasuredValue", &force_update.max_measured_value },
          {"Tolerance", &force_update.tolerance },
          {"ScaledValue", &force_update.scaled_value },
          {"MinScaledValue", &force_update.min_scaled_value },
          {"MaxScaledValue", &force_update.max_scaled_value },
          {"ScaledTolerance", &force_update.scaled_tolerance },
          {"Scale", &force_update.scale },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_pressure_measurement_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "PressureMeasurement/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_pressure_measurement_measured_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement/Attributes/MeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PressureMeasurement/Attributes/MeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pressure_measurement_min_measured_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement/Attributes/MinMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PressureMeasurement/Attributes/MinMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pressure_measurement_max_measured_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement/Attributes/MaxMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PressureMeasurement/Attributes/MaxMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pressure_measurement_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement/Attributes/Tolerance", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PressureMeasurement/Attributes/Tolerance";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pressure_measurement_scaled_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement/Attributes/ScaledValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PressureMeasurement/Attributes/ScaledValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pressure_measurement_min_scaled_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement/Attributes/MinScaledValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PressureMeasurement/Attributes/MinScaledValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pressure_measurement_max_scaled_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement/Attributes/MaxScaledValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PressureMeasurement/Attributes/MaxScaledValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pressure_measurement_scaled_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement/Attributes/ScaledTolerance", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PressureMeasurement/Attributes/ScaledTolerance";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_pressure_measurement_scale_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement/Attributes/Scale", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PressureMeasurement/Attributes/Scale";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pressure_measurement_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_pressure_measurement_write_attributes_callback) {
    subscription_topic = base_topic + "PressureMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_pressure_measurement_WriteAttributes);
  }

  if(uic_mqtt_dotdot_pressure_measurement_force_read_attributes_callback) {
    subscription_topic = base_topic + "PressureMeasurement/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_pressure_measurement_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_pressure_measurement_attributes_init();

  uic_mqtt_dotdot_by_group_pressure_measurement_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_flow_measurement_write_attributes_callback_t uic_mqtt_dotdot_flow_measurement_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_flow_measurement_force_read_attributes_callback_t uic_mqtt_dotdot_flow_measurement_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_flow_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_flow_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_flow_measurement_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_flow_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_flow_measurement_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_flow_measurement_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/FlowMeasurement/Commands/WriteAttributes
void uic_mqtt_dotdot_on_flow_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_flow_measurement_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_flow_measurement_state_t new_state = {};
  uic_mqtt_dotdot_flow_measurement_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_flow_measurement_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "FlowMeasurement", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FlowMeasurement", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FlowMeasurement", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_flow_measurement_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_flow_measurement_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_flow_measurement_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_flow_measurement_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.measured_value = true;
        force_update.min_measured_value = true;
        force_update.max_measured_value = true;
        force_update.tolerance = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"MeasuredValue", &force_update.measured_value },
          {"MinMeasuredValue", &force_update.min_measured_value },
          {"MaxMeasuredValue", &force_update.max_measured_value },
          {"Tolerance", &force_update.tolerance },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_flow_measurement_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "FlowMeasurement/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_flow_measurement_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FlowMeasurement/Attributes/MeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/FlowMeasurement/Attributes/MeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_flow_measurement_min_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FlowMeasurement/Attributes/MinMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/FlowMeasurement/Attributes/MinMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_flow_measurement_max_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FlowMeasurement/Attributes/MaxMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/FlowMeasurement/Attributes/MaxMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_flow_measurement_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FlowMeasurement/Attributes/Tolerance", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/FlowMeasurement/Attributes/Tolerance";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_flow_measurement_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_flow_measurement_write_attributes_callback) {
    subscription_topic = base_topic + "FlowMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_flow_measurement_WriteAttributes);
  }

  if(uic_mqtt_dotdot_flow_measurement_force_read_attributes_callback) {
    subscription_topic = base_topic + "FlowMeasurement/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_flow_measurement_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_flow_measurement_attributes_init();

  uic_mqtt_dotdot_by_group_flow_measurement_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_relativity_humidity_write_attributes_callback_t uic_mqtt_dotdot_relativity_humidity_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_relativity_humidity_force_read_attributes_callback_t uic_mqtt_dotdot_relativity_humidity_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_relativity_humidity_write_attributes_callback(
  const uic_mqtt_dotdot_relativity_humidity_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_relativity_humidity_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_relativity_humidity_force_read_attributes_callback(
  const uic_mqtt_dotdot_relativity_humidity_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_relativity_humidity_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/RelativityHumidity/Commands/WriteAttributes
void uic_mqtt_dotdot_on_relativity_humidity_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_relativity_humidity_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_relativity_humidity_state_t new_state = {};
  uic_mqtt_dotdot_relativity_humidity_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_relativity_humidity_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "RelativityHumidity", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "RelativityHumidity", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "RelativityHumidity", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_relativity_humidity_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_relativity_humidity_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_relativity_humidity_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_relativity_humidity_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.measured_value = true;
        force_update.min_measured_value = true;
        force_update.max_measured_value = true;
        force_update.tolerance = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"MeasuredValue", &force_update.measured_value },
          {"MinMeasuredValue", &force_update.min_measured_value },
          {"MaxMeasuredValue", &force_update.max_measured_value },
          {"Tolerance", &force_update.tolerance },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_relativity_humidity_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "RelativityHumidity/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_relativity_humidity_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "RelativityHumidity/Attributes/MeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/RelativityHumidity/Attributes/MeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_relativity_humidity_min_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "RelativityHumidity/Attributes/MinMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/RelativityHumidity/Attributes/MinMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_relativity_humidity_max_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "RelativityHumidity/Attributes/MaxMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/RelativityHumidity/Attributes/MaxMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_relativity_humidity_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "RelativityHumidity/Attributes/Tolerance", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/RelativityHumidity/Attributes/Tolerance";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_relativity_humidity_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_relativity_humidity_write_attributes_callback) {
    subscription_topic = base_topic + "RelativityHumidity/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_relativity_humidity_WriteAttributes);
  }

  if(uic_mqtt_dotdot_relativity_humidity_force_read_attributes_callback) {
    subscription_topic = base_topic + "RelativityHumidity/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_relativity_humidity_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_relativity_humidity_attributes_init();

  uic_mqtt_dotdot_by_group_relativity_humidity_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback_t uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_callback_t uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_occupancy_sensing_write_attributes_callback(
  const uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_occupancy_sensing_force_read_attributes_callback(
  const uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/OccupancySensing/Commands/WriteAttributes
void uic_mqtt_dotdot_on_occupancy_sensing_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_occupancy_sensing_state_t new_state = {};
  uic_mqtt_dotdot_occupancy_sensing_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_occupancy_sensing_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OccupancySensing", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_occupancy_sensing_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_occupancy_sensing_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.occupancy = true;
        force_update.occupancy_sensor_type = true;
        force_update.occupancy_sensor_type_bitmap = true;
        force_update.pir_occupied_to_unoccupied_delay = true;
        force_update.pir_unoccupied_to_occupied_delay = true;
        force_update.pir_unoccupied_to_occupied_threshold = true;
        force_update.ultrasonic_occupied_to_unoccupied_delay = true;
        force_update.ultrasonic_unoccupied_to_occupied_delay = true;
        force_update.ultrasonic_unoccupied_to_occupied_threshold = true;
        force_update.physical_contact_occupied_to_unoccupied_delay = true;
        force_update.physical_contact_unoccupied_to_occupied_delay = true;
        force_update.physical_contact_unoccupied_to_occupied_threshold = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"Occupancy", &force_update.occupancy },
          {"OccupancySensorType", &force_update.occupancy_sensor_type },
          {"OccupancySensorTypeBitmap", &force_update.occupancy_sensor_type_bitmap },
          {"PIROccupiedToUnoccupiedDelay", &force_update.pir_occupied_to_unoccupied_delay },
          {"PIRUnoccupiedToOccupiedDelay", &force_update.pir_unoccupied_to_occupied_delay },
          {"PIRUnoccupiedToOccupiedThreshold", &force_update.pir_unoccupied_to_occupied_threshold },
          {"UltrasonicOccupiedToUnoccupiedDelay", &force_update.ultrasonic_occupied_to_unoccupied_delay },
          {"UltrasonicUnoccupiedToOccupiedDelay", &force_update.ultrasonic_unoccupied_to_occupied_delay },
          {"UltrasonicUnoccupiedToOccupiedThreshold", &force_update.ultrasonic_unoccupied_to_occupied_threshold },
          {"PhysicalContactOccupiedToUnoccupiedDelay", &force_update.physical_contact_occupied_to_unoccupied_delay },
          {"PhysicalContactUnoccupiedToOccupiedDelay", &force_update.physical_contact_unoccupied_to_occupied_delay },
          {"PhysicalContactUnoccupiedToOccupiedThreshold", &force_update.physical_contact_unoccupied_to_occupied_threshold },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "OccupancySensing/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_occupancy_sensing_occupancy_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = OccupancySensingOccupancy.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/Occupancy", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/Occupancy";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_occupancy_sensing_occupancy_sensor_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE_ENUM_NAME_AVAILABLE
  jsn["value"] = occupancy_sensing_occupancy_sensor_type_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<OccupancySensingOccupancySensorType>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/OccupancySensorType", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/OccupancySensorType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_occupancy_sensing_occupancy_sensor_type_bitmap_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = OccupancySensingOccupancySensorTypeBitmap.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/OccupancySensorTypeBitmap", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/OccupancySensorTypeBitmap";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_occupancy_sensing_pir_occupied_to_unoccupied_delay_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/PIROccupiedToUnoccupiedDelay", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/PIROccupiedToUnoccupiedDelay";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_occupancy_sensing_pir_unoccupied_to_occupied_delay_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/PIRUnoccupiedToOccupiedDelay", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/PIRUnoccupiedToOccupiedDelay";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_occupancy_sensing_pir_unoccupied_to_occupied_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/PIRUnoccupiedToOccupiedThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/PIRUnoccupiedToOccupiedThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_occupancy_sensing_ultrasonic_occupied_to_unoccupied_delay_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/UltrasonicOccupiedToUnoccupiedDelay", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/UltrasonicOccupiedToUnoccupiedDelay";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_occupancy_sensing_ultrasonic_unoccupied_to_occupied_delay_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/UltrasonicUnoccupiedToOccupiedDelay", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/UltrasonicUnoccupiedToOccupiedDelay";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_occupancy_sensing_ultrasonic_unoccupied_to_occupied_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/UltrasonicUnoccupiedToOccupiedThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/UltrasonicUnoccupiedToOccupiedThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_occupancy_sensing_physical_contact_occupied_to_unoccupied_delay_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/PhysicalContactOccupiedToUnoccupiedDelay", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/PhysicalContactOccupiedToUnoccupiedDelay";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_occupancy_sensing_physical_contact_unoccupied_to_occupied_delay_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/PhysicalContactUnoccupiedToOccupiedDelay", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/PhysicalContactUnoccupiedToOccupiedDelay";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_occupancy_sensing_physical_contact_unoccupied_to_occupied_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/PhysicalContactUnoccupiedToOccupiedThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/PhysicalContactUnoccupiedToOccupiedThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_occupancy_sensing_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback) {
    subscription_topic = base_topic + "OccupancySensing/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_occupancy_sensing_WriteAttributes);
  }

  if(uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_callback) {
    subscription_topic = base_topic + "OccupancySensing/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_occupancy_sensing_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_occupancy_sensing_attributes_init();

  uic_mqtt_dotdot_by_group_occupancy_sensing_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_ph_measurement_write_attributes_callback_t uic_mqtt_dotdot_ph_measurement_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_ph_measurement_force_read_attributes_callback_t uic_mqtt_dotdot_ph_measurement_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_ph_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_ph_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_ph_measurement_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_ph_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_ph_measurement_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_ph_measurement_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/PhMeasurement/Commands/WriteAttributes
void uic_mqtt_dotdot_on_ph_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_ph_measurement_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_ph_measurement_state_t new_state = {};
  uic_mqtt_dotdot_ph_measurement_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_ph_measurement_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PhMeasurement", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PhMeasurement", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PhMeasurement", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_ph_measurement_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_ph_measurement_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_ph_measurement_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_ph_measurement_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.measured_value = true;
        force_update.min_measured_value = true;
        force_update.max_measured_value = true;
        force_update.tolerance = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"MeasuredValue", &force_update.measured_value },
          {"MinMeasuredValue", &force_update.min_measured_value },
          {"MaxMeasuredValue", &force_update.max_measured_value },
          {"Tolerance", &force_update.tolerance },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_ph_measurement_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "PhMeasurement/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_ph_measurement_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PhMeasurement/Attributes/MeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PhMeasurement/Attributes/MeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ph_measurement_min_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PhMeasurement/Attributes/MinMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PhMeasurement/Attributes/MinMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ph_measurement_max_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PhMeasurement/Attributes/MaxMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PhMeasurement/Attributes/MaxMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ph_measurement_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PhMeasurement/Attributes/Tolerance", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PhMeasurement/Attributes/Tolerance";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ph_measurement_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_ph_measurement_write_attributes_callback) {
    subscription_topic = base_topic + "PhMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ph_measurement_WriteAttributes);
  }

  if(uic_mqtt_dotdot_ph_measurement_force_read_attributes_callback) {
    subscription_topic = base_topic + "PhMeasurement/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ph_measurement_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_ph_measurement_attributes_init();

  uic_mqtt_dotdot_by_group_ph_measurement_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback_t uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_callback_t uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_electrical_conductivity_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_electrical_conductivity_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/ElectricalConductivityMeasurement/Commands/WriteAttributes
void uic_mqtt_dotdot_on_electrical_conductivity_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_electrical_conductivity_measurement_state_t new_state = {};
  uic_mqtt_dotdot_electrical_conductivity_measurement_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_electrical_conductivity_measurement_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalConductivityMeasurement", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalConductivityMeasurement", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalConductivityMeasurement", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_electrical_conductivity_measurement_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_electrical_conductivity_measurement_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.measured_value = true;
        force_update.min_measured_value = true;
        force_update.max_measured_value = true;
        force_update.tolerance = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"MeasuredValue", &force_update.measured_value },
          {"MinMeasuredValue", &force_update.min_measured_value },
          {"MaxMeasuredValue", &force_update.max_measured_value },
          {"Tolerance", &force_update.tolerance },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "ElectricalConductivityMeasurement/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_electrical_conductivity_measurement_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalConductivityMeasurement/Attributes/MeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalConductivityMeasurement/Attributes/MeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_conductivity_measurement_min_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalConductivityMeasurement/Attributes/MinMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalConductivityMeasurement/Attributes/MinMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_conductivity_measurement_max_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalConductivityMeasurement/Attributes/MaxMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalConductivityMeasurement/Attributes/MaxMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_conductivity_measurement_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalConductivityMeasurement/Attributes/Tolerance", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalConductivityMeasurement/Attributes/Tolerance";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_conductivity_measurement_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback) {
    subscription_topic = base_topic + "ElectricalConductivityMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_electrical_conductivity_measurement_WriteAttributes);
  }

  if(uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_callback) {
    subscription_topic = base_topic + "ElectricalConductivityMeasurement/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_electrical_conductivity_measurement_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_electrical_conductivity_measurement_attributes_init();

  uic_mqtt_dotdot_by_group_electrical_conductivity_measurement_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback_t uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_callback_t uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_wind_speed_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_wind_speed_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/WindSpeedMeasurement/Commands/WriteAttributes
void uic_mqtt_dotdot_on_wind_speed_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_wind_speed_measurement_state_t new_state = {};
  uic_mqtt_dotdot_wind_speed_measurement_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_wind_speed_measurement_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindSpeedMeasurement", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindSpeedMeasurement", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindSpeedMeasurement", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_wind_speed_measurement_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_wind_speed_measurement_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.measured_value = true;
        force_update.min_measured_value = true;
        force_update.max_measured_value = true;
        force_update.tolerance = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"MeasuredValue", &force_update.measured_value },
          {"MinMeasuredValue", &force_update.min_measured_value },
          {"MaxMeasuredValue", &force_update.max_measured_value },
          {"Tolerance", &force_update.tolerance },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "WindSpeedMeasurement/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_wind_speed_measurement_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindSpeedMeasurement/Attributes/MeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindSpeedMeasurement/Attributes/MeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_wind_speed_measurement_min_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindSpeedMeasurement/Attributes/MinMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindSpeedMeasurement/Attributes/MinMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_wind_speed_measurement_max_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindSpeedMeasurement/Attributes/MaxMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindSpeedMeasurement/Attributes/MaxMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_wind_speed_measurement_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindSpeedMeasurement/Attributes/Tolerance", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindSpeedMeasurement/Attributes/Tolerance";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_wind_speed_measurement_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback) {
    subscription_topic = base_topic + "WindSpeedMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_wind_speed_measurement_WriteAttributes);
  }

  if(uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_callback) {
    subscription_topic = base_topic + "WindSpeedMeasurement/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_wind_speed_measurement_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_wind_speed_measurement_attributes_init();

  uic_mqtt_dotdot_by_group_wind_speed_measurement_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback_t uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_callback_t uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_carbon_monoxide_write_attributes_callback(
  const uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_carbon_monoxide_force_read_attributes_callback(
  const uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/CarbonMonoxide/Commands/WriteAttributes
void uic_mqtt_dotdot_on_carbon_monoxide_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_carbon_monoxide_state_t new_state = {};
  uic_mqtt_dotdot_carbon_monoxide_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_carbon_monoxide_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "CarbonMonoxide", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "CarbonMonoxide", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "CarbonMonoxide", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_carbon_monoxide_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_carbon_monoxide_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.measured_value = true;
        force_update.min_measured_value = true;
        force_update.max_measured_value = true;
        force_update.tolerance = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"MeasuredValue", &force_update.measured_value },
          {"MinMeasuredValue", &force_update.min_measured_value },
          {"MaxMeasuredValue", &force_update.max_measured_value },
          {"Tolerance", &force_update.tolerance },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "CarbonMonoxide/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_carbon_monoxide_measured_value_publish(
  const char *base_topic,
  float value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "CarbonMonoxide/Attributes/MeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/CarbonMonoxide/Attributes/MeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_carbon_monoxide_min_measured_value_publish(
  const char *base_topic,
  float value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "CarbonMonoxide/Attributes/MinMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/CarbonMonoxide/Attributes/MinMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_carbon_monoxide_max_measured_value_publish(
  const char *base_topic,
  float value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "CarbonMonoxide/Attributes/MaxMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/CarbonMonoxide/Attributes/MaxMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_carbon_monoxide_tolerance_publish(
  const char *base_topic,
  float value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "CarbonMonoxide/Attributes/Tolerance", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/CarbonMonoxide/Attributes/Tolerance";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_carbon_monoxide_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback) {
    subscription_topic = base_topic + "CarbonMonoxide/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_carbon_monoxide_WriteAttributes);
  }

  if(uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_callback) {
    subscription_topic = base_topic + "CarbonMonoxide/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_carbon_monoxide_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_carbon_monoxide_attributes_init();

  uic_mqtt_dotdot_by_group_carbon_monoxide_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback_t uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback = nullptr;
static uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback_t uic_mqtt_dotdot_ias_zone_generated_zone_enroll_response_callback = nullptr;
uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback_t uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback = nullptr;
static uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback_t uic_mqtt_dotdot_ias_zone_generated_zone_status_change_notification_callback = nullptr;
uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback_t uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback = nullptr;
static uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback_t uic_mqtt_dotdot_ias_zone_generated_initiate_normal_operation_mode_callback = nullptr;
uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback_t uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback = nullptr;
static uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback_t uic_mqtt_dotdot_ias_zone_generated_zone_enroll_request_callback = nullptr;
uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback_t uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback = nullptr;
static uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback_t uic_mqtt_dotdot_ias_zone_generated_initiate_test_mode_callback = nullptr;
uic_mqtt_dotdot_ias_zone_write_attributes_callback_t uic_mqtt_dotdot_ias_zone_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_ias_zone_force_read_attributes_callback_t uic_mqtt_dotdot_ias_zone_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback_set(const uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback = callback;
}
void uic_mqtt_dotdot_ias_zone_generated_zone_enroll_response_callback_set(const uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_generated_zone_enroll_response_callback = callback;
}

void uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback_set(const uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback = callback;
}
void uic_mqtt_dotdot_ias_zone_generated_zone_status_change_notification_callback_set(const uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_generated_zone_status_change_notification_callback = callback;
}

void uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback_set(const uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback = callback;
}
void uic_mqtt_dotdot_ias_zone_generated_initiate_normal_operation_mode_callback_set(const uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_generated_initiate_normal_operation_mode_callback = callback;
}

void uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback_set(const uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback = callback;
}
void uic_mqtt_dotdot_ias_zone_generated_zone_enroll_request_callback_set(const uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_generated_zone_enroll_request_callback = callback;
}

void uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback_set(const uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback = callback;
}
void uic_mqtt_dotdot_ias_zone_generated_initiate_test_mode_callback_set(const uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_generated_initiate_test_mode_callback = callback;
}


void uic_mqtt_dotdot_set_ias_zone_write_attributes_callback(
  const uic_mqtt_dotdot_ias_zone_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_ias_zone_force_read_attributes_callback(
  const uic_mqtt_dotdot_ias_zone_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/IASZone/Commands/ZoneEnrollResponse
void uic_mqtt_dotdot_on_ias_zone_zone_enroll_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  ZoneEnrollResponseEnrollResponseCode enroll_response_code = {};
  uint8_t zoneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ias_zone_zone_enroll_response(
      jsn,
      enroll_response_code,

      zoneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "ZoneEnrollResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneEnrollResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneEnrollResponse", "");
    return;
  }

  uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    enroll_response_code,

    zoneid

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/IASZone/GeneratedCommands/ZoneEnrollResponse
static void uic_mqtt_dotdot_on_generated_ias_zone_zone_enroll_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ias_zone_generated_zone_enroll_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  ZoneEnrollResponseEnrollResponseCode enroll_response_code;
  uint8_t zoneid;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ias_zone_zone_enroll_response(
      jsn,
      enroll_response_code,

      zoneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "ZoneEnrollResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneEnrollResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneEnrollResponse", "");
    return;
  }

  uic_mqtt_dotdot_ias_zone_generated_zone_enroll_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    enroll_response_code,

    zoneid

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/IASZone/Commands/ZoneStatusChangeNotification
void uic_mqtt_dotdot_on_ias_zone_zone_status_change_notification(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t zone_status = {};
  uint8_t extended_status = {};
  uint8_t zoneid = {};
  uint16_t delay = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ias_zone_zone_status_change_notification(
      jsn,
      zone_status,

      extended_status,

      zoneid,

      delay
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "ZoneStatusChangeNotification");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneStatusChangeNotification", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneStatusChangeNotification", "");
    return;
  }

  uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    zone_status,

    extended_status,

    zoneid,

    delay

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/IASZone/GeneratedCommands/ZoneStatusChangeNotification
static void uic_mqtt_dotdot_on_generated_ias_zone_zone_status_change_notification(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ias_zone_generated_zone_status_change_notification_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t zone_status;
  uint8_t extended_status;
  uint8_t zoneid;
  uint16_t delay;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ias_zone_zone_status_change_notification(
      jsn,
      zone_status,

      extended_status,

      zoneid,

      delay
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "ZoneStatusChangeNotification");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneStatusChangeNotification", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneStatusChangeNotification", "");
    return;
  }

  uic_mqtt_dotdot_ias_zone_generated_zone_status_change_notification_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    zone_status,

    extended_status,

    zoneid,

    delay

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/IASZone/Commands/InitiateNormalOperationMode
void uic_mqtt_dotdot_on_ias_zone_initiate_normal_operation_mode(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "InitiateNormalOperationMode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "InitiateNormalOperationMode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "InitiateNormalOperationMode", "");
    return;
  }

  uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/IASZone/GeneratedCommands/InitiateNormalOperationMode
static void uic_mqtt_dotdot_on_generated_ias_zone_initiate_normal_operation_mode(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ias_zone_generated_initiate_normal_operation_mode_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "InitiateNormalOperationMode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "InitiateNormalOperationMode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "InitiateNormalOperationMode", "");
    return;
  }

  uic_mqtt_dotdot_ias_zone_generated_initiate_normal_operation_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/IASZone/Commands/ZoneEnrollRequest
void uic_mqtt_dotdot_on_ias_zone_zone_enroll_request(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  IasZoneType zone_type = {};
  uint16_t manufacturer_code = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ias_zone_zone_enroll_request(
      jsn,
      zone_type,

      manufacturer_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "ZoneEnrollRequest");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneEnrollRequest", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneEnrollRequest", "");
    return;
  }

  uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    zone_type,

    manufacturer_code

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/IASZone/GeneratedCommands/ZoneEnrollRequest
static void uic_mqtt_dotdot_on_generated_ias_zone_zone_enroll_request(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ias_zone_generated_zone_enroll_request_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  IasZoneType zone_type;
  uint16_t manufacturer_code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ias_zone_zone_enroll_request(
      jsn,
      zone_type,

      manufacturer_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "ZoneEnrollRequest");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneEnrollRequest", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneEnrollRequest", "");
    return;
  }

  uic_mqtt_dotdot_ias_zone_generated_zone_enroll_request_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    zone_type,

    manufacturer_code

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/IASZone/Commands/InitiateTestMode
void uic_mqtt_dotdot_on_ias_zone_initiate_test_mode(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t test_mode_duration = {};
  uint8_t current_zone_sensitivity_level = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ias_zone_initiate_test_mode(
      jsn,
      test_mode_duration,

      current_zone_sensitivity_level
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "InitiateTestMode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "InitiateTestMode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "InitiateTestMode", "");
    return;
  }

  uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    test_mode_duration,

    current_zone_sensitivity_level

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/IASZone/GeneratedCommands/InitiateTestMode
static void uic_mqtt_dotdot_on_generated_ias_zone_initiate_test_mode(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ias_zone_generated_initiate_test_mode_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t test_mode_duration;
  uint8_t current_zone_sensitivity_level;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ias_zone_initiate_test_mode(
      jsn,
      test_mode_duration,

      current_zone_sensitivity_level
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "InitiateTestMode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "InitiateTestMode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "InitiateTestMode", "");
    return;
  }

  uic_mqtt_dotdot_ias_zone_generated_initiate_test_mode_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    test_mode_duration,

    current_zone_sensitivity_level

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/IASZone/Commands/WriteAttributes
void uic_mqtt_dotdot_on_ias_zone_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_ias_zone_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_ias_zone_state_t new_state = {};
  uic_mqtt_dotdot_ias_zone_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_ias_zone_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_ias_zone_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_ias_zone_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_ias_zone_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_ias_zone_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.zone_state = true;
        force_update.zone_type = true;
        force_update.zone_status = true;
        force_update.iascie_address = true;
        force_update.zoneid = true;
        force_update.number_of_zone_sensitivity_levels_supported = true;
        force_update.current_zone_sensitivity_level = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"ZoneState", &force_update.zone_state },
          {"ZoneType", &force_update.zone_type },
          {"ZoneStatus", &force_update.zone_status },
          {"IASCIEAddress", &force_update.iascie_address },
          {"ZoneID", &force_update.zoneid },
          {"NumberOfZoneSensitivityLevelsSupported", &force_update.number_of_zone_sensitivity_levels_supported },
          {"CurrentZoneSensitivityLevel", &force_update.current_zone_sensitivity_level },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_ias_zone_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "IASZone/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_ias_zone_zone_state_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef IAS_ZONE_ZONE_STATE_ENUM_NAME_AVAILABLE
  jsn["value"] = ias_zone_zone_state_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<IASZoneZoneState>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone/Attributes/ZoneState", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IASZone/Attributes/ZoneState";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ias_zone_zone_type_publish(
  const char *base_topic,
  IasZoneType value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef IAS_ZONE_ZONE_TYPE_ENUM_NAME_AVAILABLE
  jsn["value"] = ias_zone_zone_type_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<IasZoneType>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone/Attributes/ZoneType", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IASZone/Attributes/ZoneType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ias_zone_zone_status_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = IasZoneStatus.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone/Attributes/ZoneStatus", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/IASZone/Attributes/ZoneStatus";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ias_zone_iascie_address_publish(
  const char *base_topic,
  EUI64 value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone/Attributes/IASCIEAddress", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IASZone/Attributes/IASCIEAddress";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ias_zone_zoneid_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone/Attributes/ZoneID", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IASZone/Attributes/ZoneID";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ias_zone_number_of_zone_sensitivity_levels_supported_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone/Attributes/NumberOfZoneSensitivityLevelsSupported", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IASZone/Attributes/NumberOfZoneSensitivityLevelsSupported";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_ias_zone_current_zone_sensitivity_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone/Attributes/CurrentZoneSensitivityLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IASZone/Attributes/CurrentZoneSensitivityLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ias_zone_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_ias_zone_write_attributes_callback) {
    subscription_topic = base_topic + "IASZone/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ias_zone_WriteAttributes);
  }

  if(uic_mqtt_dotdot_ias_zone_force_read_attributes_callback) {
    subscription_topic = base_topic + "IASZone/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ias_zone_force_read_attributes);
  }
  if (uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback) {
    subscription_topic = base_topic + "IASZone/Commands/ZoneEnrollResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ias_zone_zone_enroll_response);
  }
  if (uic_mqtt_dotdot_ias_zone_generated_zone_enroll_response_callback) {
    subscription_topic = base_topic + "IASZone/GeneratedCommands/ZoneEnrollResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_ias_zone_zone_enroll_response);
  }
  if (uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback) {
    subscription_topic = base_topic + "IASZone/Commands/ZoneStatusChangeNotification";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ias_zone_zone_status_change_notification);
  }
  if (uic_mqtt_dotdot_ias_zone_generated_zone_status_change_notification_callback) {
    subscription_topic = base_topic + "IASZone/GeneratedCommands/ZoneStatusChangeNotification";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_ias_zone_zone_status_change_notification);
  }
  if (uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback) {
    subscription_topic = base_topic + "IASZone/Commands/InitiateNormalOperationMode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ias_zone_initiate_normal_operation_mode);
  }
  if (uic_mqtt_dotdot_ias_zone_generated_initiate_normal_operation_mode_callback) {
    subscription_topic = base_topic + "IASZone/GeneratedCommands/InitiateNormalOperationMode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_ias_zone_initiate_normal_operation_mode);
  }
  if (uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback) {
    subscription_topic = base_topic + "IASZone/Commands/ZoneEnrollRequest";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ias_zone_zone_enroll_request);
  }
  if (uic_mqtt_dotdot_ias_zone_generated_zone_enroll_request_callback) {
    subscription_topic = base_topic + "IASZone/GeneratedCommands/ZoneEnrollRequest";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_ias_zone_zone_enroll_request);
  }
  if (uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback) {
    subscription_topic = base_topic + "IASZone/Commands/InitiateTestMode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ias_zone_initiate_test_mode);
  }
  if (uic_mqtt_dotdot_ias_zone_generated_initiate_test_mode_callback) {
    subscription_topic = base_topic + "IASZone/GeneratedCommands/InitiateTestMode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_ias_zone_initiate_test_mode);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_ias_zone_attributes_init();

  uic_mqtt_dotdot_by_group_ias_zone_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_iaswd_start_warning_callback_t uic_mqtt_dotdot_iaswd_start_warning_callback = nullptr;
static uic_mqtt_dotdot_iaswd_start_warning_callback_t uic_mqtt_dotdot_iaswd_generated_start_warning_callback = nullptr;
uic_mqtt_dotdot_iaswd_squawk_callback_t uic_mqtt_dotdot_iaswd_squawk_callback = nullptr;
static uic_mqtt_dotdot_iaswd_squawk_callback_t uic_mqtt_dotdot_iaswd_generated_squawk_callback = nullptr;
uic_mqtt_dotdot_iaswd_write_attributes_callback_t uic_mqtt_dotdot_iaswd_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_iaswd_force_read_attributes_callback_t uic_mqtt_dotdot_iaswd_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_iaswd_start_warning_callback_set(const uic_mqtt_dotdot_iaswd_start_warning_callback_t callback)
{
  uic_mqtt_dotdot_iaswd_start_warning_callback = callback;
}
void uic_mqtt_dotdot_iaswd_generated_start_warning_callback_set(const uic_mqtt_dotdot_iaswd_start_warning_callback_t callback)
{
  uic_mqtt_dotdot_iaswd_generated_start_warning_callback = callback;
}

void uic_mqtt_dotdot_iaswd_squawk_callback_set(const uic_mqtt_dotdot_iaswd_squawk_callback_t callback)
{
  uic_mqtt_dotdot_iaswd_squawk_callback = callback;
}
void uic_mqtt_dotdot_iaswd_generated_squawk_callback_set(const uic_mqtt_dotdot_iaswd_squawk_callback_t callback)
{
  uic_mqtt_dotdot_iaswd_generated_squawk_callback = callback;
}


void uic_mqtt_dotdot_set_iaswd_write_attributes_callback(
  const uic_mqtt_dotdot_iaswd_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_iaswd_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_iaswd_force_read_attributes_callback(
  const uic_mqtt_dotdot_iaswd_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_iaswd_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/IASWD/Commands/StartWarning
void uic_mqtt_dotdot_on_iaswd_start_warning(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_iaswd_start_warning_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t siren_configuration = {};
  uint16_t warning_duration = {};
  uint8_t strobe_duty_cycle = {};
  IaswdLevel strobe_level = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_iaswd_start_warning(
      jsn,
      siren_configuration,

      warning_duration,

      strobe_duty_cycle,

      strobe_level
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASWD", "StartWarning");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "StartWarning", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "StartWarning", "");
    return;
  }

  uic_mqtt_dotdot_iaswd_start_warning_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    siren_configuration,

    warning_duration,

    strobe_duty_cycle,

    strobe_level

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/IASWD/GeneratedCommands/StartWarning
static void uic_mqtt_dotdot_on_generated_iaswd_start_warning(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_iaswd_generated_start_warning_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t siren_configuration;
  uint16_t warning_duration;
  uint8_t strobe_duty_cycle;
  IaswdLevel strobe_level;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_iaswd_start_warning(
      jsn,
      siren_configuration,

      warning_duration,

      strobe_duty_cycle,

      strobe_level
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASWD", "StartWarning");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "StartWarning", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "StartWarning", "");
    return;
  }

  uic_mqtt_dotdot_iaswd_generated_start_warning_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    siren_configuration,

    warning_duration,

    strobe_duty_cycle,

    strobe_level

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/IASWD/Commands/Squawk
void uic_mqtt_dotdot_on_iaswd_squawk(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_iaswd_squawk_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t squawk_configuration = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_iaswd_squawk(
      jsn,
      squawk_configuration
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASWD", "Squawk");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "Squawk", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "Squawk", "");
    return;
  }

  uic_mqtt_dotdot_iaswd_squawk_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    squawk_configuration

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/IASWD/GeneratedCommands/Squawk
static void uic_mqtt_dotdot_on_generated_iaswd_squawk(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_iaswd_generated_squawk_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t squawk_configuration;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_iaswd_squawk(
      jsn,
      squawk_configuration
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASWD", "Squawk");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "Squawk", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "Squawk", "");
    return;
  }

  uic_mqtt_dotdot_iaswd_generated_squawk_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    squawk_configuration

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/IASWD/Commands/WriteAttributes
void uic_mqtt_dotdot_on_iaswd_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_iaswd_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_iaswd_state_t new_state = {};
  uic_mqtt_dotdot_iaswd_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_iaswd_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASWD", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_iaswd_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_iaswd_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_iaswd_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_iaswd_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.max_duration = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"MaxDuration", &force_update.max_duration },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_iaswd_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "IASWD/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_iaswd_max_duration_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD/Attributes/MaxDuration", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IASWD/Attributes/MaxDuration";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_iaswd_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_iaswd_write_attributes_callback) {
    subscription_topic = base_topic + "IASWD/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_iaswd_WriteAttributes);
  }

  if(uic_mqtt_dotdot_iaswd_force_read_attributes_callback) {
    subscription_topic = base_topic + "IASWD/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_iaswd_force_read_attributes);
  }
  if (uic_mqtt_dotdot_iaswd_start_warning_callback) {
    subscription_topic = base_topic + "IASWD/Commands/StartWarning";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_iaswd_start_warning);
  }
  if (uic_mqtt_dotdot_iaswd_generated_start_warning_callback) {
    subscription_topic = base_topic + "IASWD/GeneratedCommands/StartWarning";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_iaswd_start_warning);
  }
  if (uic_mqtt_dotdot_iaswd_squawk_callback) {
    subscription_topic = base_topic + "IASWD/Commands/Squawk";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_iaswd_squawk);
  }
  if (uic_mqtt_dotdot_iaswd_generated_squawk_callback) {
    subscription_topic = base_topic + "IASWD/GeneratedCommands/Squawk";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_iaswd_squawk);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_iaswd_attributes_init();

  uic_mqtt_dotdot_by_group_iaswd_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_metering_write_attributes_callback_t uic_mqtt_dotdot_metering_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_metering_force_read_attributes_callback_t uic_mqtt_dotdot_metering_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_metering_write_attributes_callback(
  const uic_mqtt_dotdot_metering_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_metering_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_metering_force_read_attributes_callback(
  const uic_mqtt_dotdot_metering_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_metering_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/Metering/Commands/WriteAttributes
void uic_mqtt_dotdot_on_metering_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_metering_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_metering_state_t new_state = {};
  uic_mqtt_dotdot_metering_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_metering_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Metering", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_metering_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_metering_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_metering_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_metering_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.current_summation_delivered = true;
        force_update.current_summation_received = true;
        force_update.current_max_demand_delivered = true;
        force_update.current_max_demand_received = true;
        force_update.power_factor = true;
        force_update.reading_snap_shot_time = true;
        force_update.current_max_demand_delivered_time = true;
        force_update.current_max_demand_received_time = true;
        force_update.default_update_period = true;
        force_update.supply_status = true;
        force_update.current_inlet_energy_carrier_summation = true;
        force_update.current_outlet_energy_carrier_summation = true;
        force_update.inlet_temperature = true;
        force_update.outlet_temperature = true;
        force_update.unitof_measure = true;
        force_update.multiplier = true;
        force_update.divisor = true;
        force_update.summation_formatting = true;
        force_update.demand_formatting = true;
        force_update.historical_consumption_formatting = true;
        force_update.metering_device_type = true;
        force_update.energy_carrier_unit_of_measure = true;
        force_update.energy_carrier_summation_formatting = true;
        force_update.energy_carrier_demand_formatting = true;
        force_update.temperature_unit_of_measure = true;
        force_update.temperature_formatting = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"CurrentSummationDelivered", &force_update.current_summation_delivered },
          {"CurrentSummationReceived", &force_update.current_summation_received },
          {"CurrentMaxDemandDelivered", &force_update.current_max_demand_delivered },
          {"CurrentMaxDemandReceived", &force_update.current_max_demand_received },
          {"PowerFactor", &force_update.power_factor },
          {"ReadingSnapShotTime", &force_update.reading_snap_shot_time },
          {"CurrentMaxDemandDeliveredTime", &force_update.current_max_demand_delivered_time },
          {"CurrentMaxDemandReceivedTime", &force_update.current_max_demand_received_time },
          {"DefaultUpdatePeriod", &force_update.default_update_period },
          {"SupplyStatus", &force_update.supply_status },
          {"CurrentInletEnergyCarrierSummation", &force_update.current_inlet_energy_carrier_summation },
          {"CurrentOutletEnergyCarrierSummation", &force_update.current_outlet_energy_carrier_summation },
          {"InletTemperature", &force_update.inlet_temperature },
          {"OutletTemperature", &force_update.outlet_temperature },
          {"UnitofMeasure", &force_update.unitof_measure },
          {"Multiplier", &force_update.multiplier },
          {"Divisor", &force_update.divisor },
          {"SummationFormatting", &force_update.summation_formatting },
          {"DemandFormatting", &force_update.demand_formatting },
          {"HistoricalConsumptionFormatting", &force_update.historical_consumption_formatting },
          {"MeteringDeviceType", &force_update.metering_device_type },
          {"EnergyCarrierUnitOfMeasure", &force_update.energy_carrier_unit_of_measure },
          {"EnergyCarrierSummationFormatting", &force_update.energy_carrier_summation_formatting },
          {"EnergyCarrierDemandFormatting", &force_update.energy_carrier_demand_formatting },
          {"TemperatureUnitOfMeasure", &force_update.temperature_unit_of_measure },
          {"TemperatureFormatting", &force_update.temperature_formatting },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_metering_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "Metering/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_metering_current_summation_delivered_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/CurrentSummationDelivered", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/CurrentSummationDelivered";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_current_summation_received_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/CurrentSummationReceived", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/CurrentSummationReceived";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_current_max_demand_delivered_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/CurrentMaxDemandDelivered", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/CurrentMaxDemandDelivered";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_current_max_demand_received_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/CurrentMaxDemandReceived", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/CurrentMaxDemandReceived";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_power_factor_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/PowerFactor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/PowerFactor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_reading_snap_shot_time_publish(
  const char *base_topic,
  UTC value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/ReadingSnapShotTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/ReadingSnapShotTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_current_max_demand_delivered_time_publish(
  const char *base_topic,
  UTC value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/CurrentMaxDemandDeliveredTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/CurrentMaxDemandDeliveredTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_current_max_demand_received_time_publish(
  const char *base_topic,
  UTC value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/CurrentMaxDemandReceivedTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/CurrentMaxDemandReceivedTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_default_update_period_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/DefaultUpdatePeriod", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/DefaultUpdatePeriod";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_supply_status_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef METERING_SUPPLY_STATUS_ENUM_NAME_AVAILABLE
  jsn["value"] = metering_supply_status_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<MeteringSupplyStatus>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/SupplyStatus", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/SupplyStatus";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_current_inlet_energy_carrier_summation_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/CurrentInletEnergyCarrierSummation", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/CurrentInletEnergyCarrierSummation";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_current_outlet_energy_carrier_summation_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/CurrentOutletEnergyCarrierSummation", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/CurrentOutletEnergyCarrierSummation";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_inlet_temperature_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/InletTemperature", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/InletTemperature";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_outlet_temperature_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/OutletTemperature", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/OutletTemperature";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_unitof_measure_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef METERING_UNITOF_MEASURE_ENUM_NAME_AVAILABLE
  jsn["value"] = metering_unitof_measure_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<MeteringUnitofMeasure>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/UnitofMeasure", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/UnitofMeasure";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_multiplier_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/Multiplier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/Multiplier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_divisor_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/Divisor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/Divisor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_summation_formatting_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = MeteringSummationFormatting.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/SummationFormatting", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Metering/Attributes/SummationFormatting";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_demand_formatting_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = MeteringDemandFormatting.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/DemandFormatting", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Metering/Attributes/DemandFormatting";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_historical_consumption_formatting_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = MeteringHistoricalConsumptionFormatting.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/HistoricalConsumptionFormatting", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Metering/Attributes/HistoricalConsumptionFormatting";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_metering_device_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef METERING_METERING_DEVICE_TYPE_ENUM_NAME_AVAILABLE
  jsn["value"] = metering_metering_device_type_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<MeteringMeteringDeviceType>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/MeteringDeviceType", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/MeteringDeviceType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_energy_carrier_unit_of_measure_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef METERING_ENERGY_CARRIER_UNIT_OF_MEASURE_ENUM_NAME_AVAILABLE
  jsn["value"] = metering_energy_carrier_unit_of_measure_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<MeteringEnergyCarrierUnitOfMeasure>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/EnergyCarrierUnitOfMeasure", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/EnergyCarrierUnitOfMeasure";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_energy_carrier_summation_formatting_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = MeteringEnergyCarrierSummationFormatting.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/EnergyCarrierSummationFormatting", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Metering/Attributes/EnergyCarrierSummationFormatting";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_energy_carrier_demand_formatting_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = MeteringEnergyCarrierDemandFormatting.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/EnergyCarrierDemandFormatting", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Metering/Attributes/EnergyCarrierDemandFormatting";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_temperature_unit_of_measure_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef METERING_TEMPERATURE_UNIT_OF_MEASURE_ENUM_NAME_AVAILABLE
  jsn["value"] = metering_temperature_unit_of_measure_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<MeteringTemperatureUnitOfMeasure>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/TemperatureUnitOfMeasure", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/TemperatureUnitOfMeasure";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_metering_temperature_formatting_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = MeteringTemperatureFormatting.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/TemperatureFormatting", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Metering/Attributes/TemperatureFormatting";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_metering_write_attributes_callback) {
    subscription_topic = base_topic + "Metering/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_metering_WriteAttributes);
  }

  if(uic_mqtt_dotdot_metering_force_read_attributes_callback) {
    subscription_topic = base_topic + "Metering/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_metering_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_metering_attributes_init();

  uic_mqtt_dotdot_by_group_metering_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback_t uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback_t uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_response_callback = nullptr;
uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback_t uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback_t uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_callback = nullptr;
uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback_t uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback_t uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_response_callback = nullptr;
uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback_t uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback_t uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_callback = nullptr;
uic_mqtt_dotdot_electrical_measurement_write_attributes_callback_t uic_mqtt_dotdot_electrical_measurement_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_electrical_measurement_force_read_attributes_callback_t uic_mqtt_dotdot_electrical_measurement_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback_set(const uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_response_callback_set(const uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_response_callback = callback;
}

void uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback_set(const uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_callback_set(const uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_callback = callback;
}

void uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback_set(const uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_response_callback_set(const uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_response_callback = callback;
}

void uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback_set(const uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback = callback;
}
void uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_callback_set(const uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_callback = callback;
}


void uic_mqtt_dotdot_set_electrical_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_electrical_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_electrical_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_electrical_measurement_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/ElectricalMeasurement/Commands/GetProfileInfoResponse
void uic_mqtt_dotdot_on_electrical_measurement_get_profile_info_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t profile_count = {};
  ProfileIntervalPeriod profile_interval_period = {};
  uint8_t max_number_of_intervals = {};
  std::vector<uint16_t> list_of_attributes;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_electrical_measurement_get_profile_info_response(
      jsn,
      profile_count,

      profile_interval_period,

      max_number_of_intervals,

      list_of_attributes
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalMeasurement", "GetProfileInfoResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetProfileInfoResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetProfileInfoResponse", "");
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    profile_count,

    profile_interval_period,

    max_number_of_intervals,

    list_of_attributes.size(),
    list_of_attributes.data()

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ElectricalMeasurement/GeneratedCommands/GetProfileInfoResponse
static void uic_mqtt_dotdot_on_generated_electrical_measurement_get_profile_info_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t profile_count;
  ProfileIntervalPeriod profile_interval_period;
  uint8_t max_number_of_intervals;
  std::vector<uint16_t> list_of_attributes;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_electrical_measurement_get_profile_info_response(
      jsn,
      profile_count,

      profile_interval_period,

      max_number_of_intervals,

      list_of_attributes
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalMeasurement", "GetProfileInfoResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetProfileInfoResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetProfileInfoResponse", "");
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    profile_count,

    profile_interval_period,

    max_number_of_intervals,

    list_of_attributes.size(),
    list_of_attributes.data()

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ElectricalMeasurement/Commands/GetProfileInfo
void uic_mqtt_dotdot_on_electrical_measurement_get_profile_info(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalMeasurement", "GetProfileInfo");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetProfileInfo", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetProfileInfo", "");
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ElectricalMeasurement/GeneratedCommands/GetProfileInfo
static void uic_mqtt_dotdot_on_generated_electrical_measurement_get_profile_info(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalMeasurement", "GetProfileInfo");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetProfileInfo", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetProfileInfo", "");
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ElectricalMeasurement/Commands/GetMeasurementProfileResponse
void uic_mqtt_dotdot_on_electrical_measurement_get_measurement_profile_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  UTC start_time = {};
  GetMeasurementProfileResponseStatus status = {};
  ProfileIntervalPeriod profile_interval_period = {};
  uint8_t number_of_intervals_delivered = {};
  uint16_t attribute_id = {};
  std::vector<uint8_t> intervals;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_electrical_measurement_get_measurement_profile_response(
      jsn,
      start_time,

      status,

      profile_interval_period,

      number_of_intervals_delivered,

      attribute_id,

      intervals
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalMeasurement", "GetMeasurementProfileResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetMeasurementProfileResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetMeasurementProfileResponse", "");
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    start_time,

    status,

    profile_interval_period,

    number_of_intervals_delivered,

    attribute_id,

    intervals.size(),
    intervals.data()

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ElectricalMeasurement/GeneratedCommands/GetMeasurementProfileResponse
static void uic_mqtt_dotdot_on_generated_electrical_measurement_get_measurement_profile_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_response_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  UTC start_time;
  GetMeasurementProfileResponseStatus status;
  ProfileIntervalPeriod profile_interval_period;
  uint8_t number_of_intervals_delivered;
  uint16_t attribute_id;
  std::vector<uint8_t> intervals;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_electrical_measurement_get_measurement_profile_response(
      jsn,
      start_time,

      status,

      profile_interval_period,

      number_of_intervals_delivered,

      attribute_id,

      intervals
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalMeasurement", "GetMeasurementProfileResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetMeasurementProfileResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetMeasurementProfileResponse", "");
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_response_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    start_time,

    status,

    profile_interval_period,

    number_of_intervals_delivered,

    attribute_id,

    intervals.size(),
    intervals.data()

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ElectricalMeasurement/Commands/GetMeasurementProfile
void uic_mqtt_dotdot_on_electrical_measurement_get_measurement_profile(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t attributeid = {};
  UTC start_time = {};
  uint8_t number_of_intervals = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_electrical_measurement_get_measurement_profile(
      jsn,
      attributeid,

      start_time,

      number_of_intervals
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalMeasurement", "GetMeasurementProfile");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetMeasurementProfile", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetMeasurementProfile", "");
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    attributeid,

    start_time,

    number_of_intervals

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ElectricalMeasurement/GeneratedCommands/GetMeasurementProfile
static void uic_mqtt_dotdot_on_generated_electrical_measurement_get_measurement_profile(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t attributeid;
  UTC start_time;
  uint8_t number_of_intervals;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_electrical_measurement_get_measurement_profile(
      jsn,
      attributeid,

      start_time,

      number_of_intervals
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalMeasurement", "GetMeasurementProfile");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetMeasurementProfile", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetMeasurementProfile", "");
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    attributeid,

    start_time,

    number_of_intervals

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ElectricalMeasurement/Commands/WriteAttributes
void uic_mqtt_dotdot_on_electrical_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_electrical_measurement_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_state_t new_state = {};
  uic_mqtt_dotdot_electrical_measurement_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_electrical_measurement_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalMeasurement", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_electrical_measurement_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_electrical_measurement_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_electrical_measurement_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.measurement_type = true;
        force_update.dc_voltage = true;
        force_update.dc_voltage_min = true;
        force_update.dc_voltage_max = true;
        force_update.dc_current = true;
        force_update.dc_current_min = true;
        force_update.dc_current_max = true;
        force_update.dc_power = true;
        force_update.dc_power_min = true;
        force_update.dc_power_max = true;
        force_update.dc_voltage_multiplier = true;
        force_update.dc_voltage_divisor = true;
        force_update.dc_current_multiplier = true;
        force_update.dc_current_divisor = true;
        force_update.dc_power_multiplier = true;
        force_update.dc_power_divisor = true;
        force_update.ac_frequency = true;
        force_update.ac_frequency_min = true;
        force_update.ac_frequency_max = true;
        force_update.neutral_current = true;
        force_update.total_active_power = true;
        force_update.total_reactive_power = true;
        force_update.total_apparent_power = true;
        force_update.measured1st_harmonic_current = true;
        force_update.measured3rd_harmonic_current = true;
        force_update.measured5th_harmonic_current = true;
        force_update.measured7th_harmonic_current = true;
        force_update.measured9th_harmonic_current = true;
        force_update.measured11th_harmonic_current = true;
        force_update.measured_phase1st_harmonic_current = true;
        force_update.measured_phase3rd_harmonic_current = true;
        force_update.measured_phase5th_harmonic_current = true;
        force_update.measured_phase7th_harmonic_current = true;
        force_update.measured_phase9th_harmonic_current = true;
        force_update.measured_phase11th_harmonic_current = true;
        force_update.ac_frequency_multiplier = true;
        force_update.ac_frequency_divisor = true;
        force_update.power_multiplier = true;
        force_update.power_divisor = true;
        force_update.harmonic_current_multiplier = true;
        force_update.phase_harmonic_current_multiplier = true;
        force_update.line_current = true;
        force_update.active_current = true;
        force_update.reactive_current = true;
        force_update.rms_voltage = true;
        force_update.rms_voltage_min = true;
        force_update.rms_voltage_max = true;
        force_update.rms_current = true;
        force_update.rms_current_min = true;
        force_update.rms_current_max = true;
        force_update.active_power = true;
        force_update.active_power_min = true;
        force_update.active_power_max = true;
        force_update.reactive_power = true;
        force_update.apparent_power = true;
        force_update.power_factor = true;
        force_update.averagerms_voltage_measurement_period = true;
        force_update.averagerms_over_voltage_counter = true;
        force_update.averagerms_under_voltage_counter = true;
        force_update.rms_extreme_over_voltage_period = true;
        force_update.rms_extreme_under_voltage_period = true;
        force_update.rms_voltage_sag_period = true;
        force_update.rms_voltage_swell_period = true;
        force_update.ac_voltage_multiplier = true;
        force_update.ac_voltage_divisor = true;
        force_update.ac_current_multiplier = true;
        force_update.ac_current_divisor = true;
        force_update.ac_power_multiplier = true;
        force_update.ac_power_divisor = true;
        force_update.dc_overload_alarms_mask = true;
        force_update.dc_voltage_overload = true;
        force_update.dc_current_overload = true;
        force_update.ac_alarms_mask = true;
        force_update.ac_voltage_overload = true;
        force_update.ac_current_overload = true;
        force_update.ac_active_power_overload = true;
        force_update.ac_reactive_power_overload = true;
        force_update.averagerms_over_voltage = true;
        force_update.averagerms_under_voltage = true;
        force_update.rms_extreme_over_voltage = true;
        force_update.rms_extreme_under_voltage = true;
        force_update.rms_voltage_sag = true;
        force_update.rms_voltage_swell = true;
        force_update.line_current_phb = true;
        force_update.active_current_phb = true;
        force_update.reactive_current_phb = true;
        force_update.rms_voltage_phb = true;
        force_update.rms_voltage_min_phb = true;
        force_update.rms_voltage_max_phb = true;
        force_update.rms_current_phb = true;
        force_update.rms_current_min_phb = true;
        force_update.rms_current_max_phb = true;
        force_update.active_power_phb = true;
        force_update.active_power_min_phb = true;
        force_update.active_power_max_phb = true;
        force_update.reactive_power_phb = true;
        force_update.apparent_power_phb = true;
        force_update.power_factor_phb = true;
        force_update.averagerms_voltage_measurement_period_phb = true;
        force_update.averagerms_over_voltage_counter_phb = true;
        force_update.averagerms_under_voltage_counter_phb = true;
        force_update.rms_extreme_over_voltage_period_phb = true;
        force_update.rms_extreme_under_voltage_period_phb = true;
        force_update.rms_voltage_sag_period_phb = true;
        force_update.rms_voltage_swell_period_phb = true;
        force_update.line_current_phc = true;
        force_update.active_current_phc = true;
        force_update.reactive_current_phc = true;
        force_update.rms_voltage_phc = true;
        force_update.rms_voltage_min_phc = true;
        force_update.rms_voltage_max_phc = true;
        force_update.rms_current_phc = true;
        force_update.rms_current_min_phc = true;
        force_update.rms_current_max_phc = true;
        force_update.active_power_phc = true;
        force_update.active_power_min_phc = true;
        force_update.active_power_max_phc = true;
        force_update.reactive_power_phc = true;
        force_update.apparent_power_phc = true;
        force_update.power_factor_phc = true;
        force_update.averagerms_voltage_measurement_period_phc = true;
        force_update.averagerms_over_voltage_counter_phc = true;
        force_update.averagerms_under_voltage_counter_phc = true;
        force_update.rms_extreme_over_voltage_period_phc = true;
        force_update.rms_extreme_under_voltage_period_phc = true;
        force_update.rms_voltage_sag_period_phc = true;
        force_update.rms_voltage_swell_period_phc = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"MeasurementType", &force_update.measurement_type },
          {"DCVoltage", &force_update.dc_voltage },
          {"DCVoltageMin", &force_update.dc_voltage_min },
          {"DCVoltageMax", &force_update.dc_voltage_max },
          {"DCCurrent", &force_update.dc_current },
          {"DCCurrentMin", &force_update.dc_current_min },
          {"DCCurrentMax", &force_update.dc_current_max },
          {"DCPower", &force_update.dc_power },
          {"DCPowerMin", &force_update.dc_power_min },
          {"DCPowerMax", &force_update.dc_power_max },
          {"DCVoltageMultiplier", &force_update.dc_voltage_multiplier },
          {"DCVoltageDivisor", &force_update.dc_voltage_divisor },
          {"DCCurrentMultiplier", &force_update.dc_current_multiplier },
          {"DCCurrentDivisor", &force_update.dc_current_divisor },
          {"DCPowerMultiplier", &force_update.dc_power_multiplier },
          {"DCPowerDivisor", &force_update.dc_power_divisor },
          {"ACFrequency", &force_update.ac_frequency },
          {"ACFrequencyMin", &force_update.ac_frequency_min },
          {"ACFrequencyMax", &force_update.ac_frequency_max },
          {"NeutralCurrent", &force_update.neutral_current },
          {"TotalActivePower", &force_update.total_active_power },
          {"TotalReactivePower", &force_update.total_reactive_power },
          {"TotalApparentPower", &force_update.total_apparent_power },
          {"Measured1stHarmonicCurrent", &force_update.measured1st_harmonic_current },
          {"Measured3rdHarmonicCurrent", &force_update.measured3rd_harmonic_current },
          {"Measured5thHarmonicCurrent", &force_update.measured5th_harmonic_current },
          {"Measured7thHarmonicCurrent", &force_update.measured7th_harmonic_current },
          {"Measured9thHarmonicCurrent", &force_update.measured9th_harmonic_current },
          {"Measured11thHarmonicCurrent", &force_update.measured11th_harmonic_current },
          {"MeasuredPhase1stHarmonicCurrent", &force_update.measured_phase1st_harmonic_current },
          {"MeasuredPhase3rdHarmonicCurrent", &force_update.measured_phase3rd_harmonic_current },
          {"MeasuredPhase5thHarmonicCurrent", &force_update.measured_phase5th_harmonic_current },
          {"MeasuredPhase7thHarmonicCurrent", &force_update.measured_phase7th_harmonic_current },
          {"MeasuredPhase9thHarmonicCurrent", &force_update.measured_phase9th_harmonic_current },
          {"MeasuredPhase11thHarmonicCurrent", &force_update.measured_phase11th_harmonic_current },
          {"ACFrequencyMultiplier", &force_update.ac_frequency_multiplier },
          {"ACFrequencyDivisor", &force_update.ac_frequency_divisor },
          {"PowerMultiplier", &force_update.power_multiplier },
          {"PowerDivisor", &force_update.power_divisor },
          {"HarmonicCurrentMultiplier", &force_update.harmonic_current_multiplier },
          {"PhaseHarmonicCurrentMultiplier", &force_update.phase_harmonic_current_multiplier },
          {"LineCurrent", &force_update.line_current },
          {"ActiveCurrent", &force_update.active_current },
          {"ReactiveCurrent", &force_update.reactive_current },
          {"RMSVoltage", &force_update.rms_voltage },
          {"RMSVoltageMin", &force_update.rms_voltage_min },
          {"RMSVoltageMax", &force_update.rms_voltage_max },
          {"RMSCurrent", &force_update.rms_current },
          {"RMSCurrentMin", &force_update.rms_current_min },
          {"RMSCurrentMax", &force_update.rms_current_max },
          {"ActivePower", &force_update.active_power },
          {"ActivePowerMin", &force_update.active_power_min },
          {"ActivePowerMax", &force_update.active_power_max },
          {"ReactivePower", &force_update.reactive_power },
          {"ApparentPower", &force_update.apparent_power },
          {"PowerFactor", &force_update.power_factor },
          {"AverageRMSVoltageMeasurementPeriod", &force_update.averagerms_voltage_measurement_period },
          {"AverageRMSOverVoltageCounter", &force_update.averagerms_over_voltage_counter },
          {"AverageRMSUnderVoltageCounter", &force_update.averagerms_under_voltage_counter },
          {"RMSExtremeOverVoltagePeriod", &force_update.rms_extreme_over_voltage_period },
          {"RMSExtremeUnderVoltagePeriod", &force_update.rms_extreme_under_voltage_period },
          {"RMSVoltageSagPeriod", &force_update.rms_voltage_sag_period },
          {"RMSVoltageSwellPeriod", &force_update.rms_voltage_swell_period },
          {"ACVoltageMultiplier", &force_update.ac_voltage_multiplier },
          {"ACVoltageDivisor", &force_update.ac_voltage_divisor },
          {"ACCurrentMultiplier", &force_update.ac_current_multiplier },
          {"ACCurrentDivisor", &force_update.ac_current_divisor },
          {"ACPowerMultiplier", &force_update.ac_power_multiplier },
          {"ACPowerDivisor", &force_update.ac_power_divisor },
          {"DCOverloadAlarmsMask", &force_update.dc_overload_alarms_mask },
          {"DCVoltageOverload", &force_update.dc_voltage_overload },
          {"DCCurrentOverload", &force_update.dc_current_overload },
          {"ACAlarmsMask", &force_update.ac_alarms_mask },
          {"ACVoltageOverload", &force_update.ac_voltage_overload },
          {"ACCurrentOverload", &force_update.ac_current_overload },
          {"ACActivePowerOverload", &force_update.ac_active_power_overload },
          {"ACReactivePowerOverload", &force_update.ac_reactive_power_overload },
          {"AverageRMSOverVoltage", &force_update.averagerms_over_voltage },
          {"AverageRMSUnderVoltage", &force_update.averagerms_under_voltage },
          {"RMSExtremeOverVoltage", &force_update.rms_extreme_over_voltage },
          {"RMSExtremeUnderVoltage", &force_update.rms_extreme_under_voltage },
          {"RMSVoltageSag", &force_update.rms_voltage_sag },
          {"RMSVoltageSwell", &force_update.rms_voltage_swell },
          {"LineCurrentPhB", &force_update.line_current_phb },
          {"ActiveCurrentPhB", &force_update.active_current_phb },
          {"ReactiveCurrentPhB", &force_update.reactive_current_phb },
          {"RMSVoltagePhB", &force_update.rms_voltage_phb },
          {"RMSVoltageMinPhB", &force_update.rms_voltage_min_phb },
          {"RMSVoltageMaxPhB", &force_update.rms_voltage_max_phb },
          {"RMSCurrentPhB", &force_update.rms_current_phb },
          {"RMSCurrentMinPhB", &force_update.rms_current_min_phb },
          {"RMSCurrentMaxPhB", &force_update.rms_current_max_phb },
          {"ActivePowerPhB", &force_update.active_power_phb },
          {"ActivePowerMinPhB", &force_update.active_power_min_phb },
          {"ActivePowerMaxPhB", &force_update.active_power_max_phb },
          {"ReactivePowerPhB", &force_update.reactive_power_phb },
          {"ApparentPowerPhB", &force_update.apparent_power_phb },
          {"PowerFactorPhB", &force_update.power_factor_phb },
          {"AverageRMSVoltageMeasurementPeriodPhB", &force_update.averagerms_voltage_measurement_period_phb },
          {"AverageRMSOverVoltageCounterPhB", &force_update.averagerms_over_voltage_counter_phb },
          {"AverageRMSUnderVoltageCounterPhB", &force_update.averagerms_under_voltage_counter_phb },
          {"RMSExtremeOverVoltagePeriodPhB", &force_update.rms_extreme_over_voltage_period_phb },
          {"RMSExtremeUnderVoltagePeriodPhB", &force_update.rms_extreme_under_voltage_period_phb },
          {"RMSVoltageSagPeriodPhB", &force_update.rms_voltage_sag_period_phb },
          {"RMSVoltageSwellPeriodPhB", &force_update.rms_voltage_swell_period_phb },
          {"LineCurrentPhC", &force_update.line_current_phc },
          {"ActiveCurrentPhC", &force_update.active_current_phc },
          {"ReactiveCurrentPhC", &force_update.reactive_current_phc },
          {"RMSVoltagePhC", &force_update.rms_voltage_phc },
          {"RMSVoltageMinPhC", &force_update.rms_voltage_min_phc },
          {"RMSVoltageMaxPhC", &force_update.rms_voltage_max_phc },
          {"RMSCurrentPhC", &force_update.rms_current_phc },
          {"RMSCurrentMinPhC", &force_update.rms_current_min_phc },
          {"RMSCurrentMaxPhC", &force_update.rms_current_max_phc },
          {"ActivePowerPhC", &force_update.active_power_phc },
          {"ActivePowerMinPhC", &force_update.active_power_min_phc },
          {"ActivePowerMaxPhC", &force_update.active_power_max_phc },
          {"ReactivePowerPhC", &force_update.reactive_power_phc },
          {"ApparentPowerPhC", &force_update.apparent_power_phc },
          {"PowerFactorPhC", &force_update.power_factor_phc },
          {"AverageRMSVoltageMeasurementPeriodPhC", &force_update.averagerms_voltage_measurement_period_phc },
          {"AverageRMSOverVoltageCounterPhC", &force_update.averagerms_over_voltage_counter_phc },
          {"AverageRMSUnderVoltageCounterPhC", &force_update.averagerms_under_voltage_counter_phc },
          {"RMSExtremeOverVoltagePeriodPhC", &force_update.rms_extreme_over_voltage_period_phc },
          {"RMSExtremeUnderVoltagePeriodPhC", &force_update.rms_extreme_under_voltage_period_phc },
          {"RMSVoltageSagPeriodPhC", &force_update.rms_voltage_sag_period_phc },
          {"RMSVoltageSwellPeriodPhC", &force_update.rms_voltage_swell_period_phc },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_electrical_measurement_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "ElectricalMeasurement/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_measurement_type_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ElectricalMeasurementMeasurementType.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/MeasurementType", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/MeasurementType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCVoltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCVoltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_min_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCVoltageMin", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCVoltageMin";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_max_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCVoltageMax", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCVoltageMax";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_min_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCCurrentMin", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCCurrentMin";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_max_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCCurrentMax", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCCurrentMax";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_power_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCPower", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCPower";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_power_min_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCPowerMin", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCPowerMin";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_power_max_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCPowerMax", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCPowerMax";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_multiplier_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCVoltageMultiplier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCVoltageMultiplier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_divisor_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCVoltageDivisor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCVoltageDivisor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_multiplier_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCCurrentMultiplier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCCurrentMultiplier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_divisor_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCCurrentDivisor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCCurrentDivisor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_power_multiplier_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCPowerMultiplier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCPowerMultiplier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_power_divisor_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCPowerDivisor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCPowerDivisor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_frequency_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACFrequency", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACFrequency";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_frequency_min_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACFrequencyMin", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACFrequencyMin";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_frequency_max_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACFrequencyMax", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACFrequencyMax";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_neutral_current_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/NeutralCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/NeutralCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_total_active_power_publish(
  const char *base_topic,
  int32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/TotalActivePower", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/TotalActivePower";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_total_reactive_power_publish(
  const char *base_topic,
  int32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/TotalReactivePower", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/TotalReactivePower";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_total_apparent_power_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/TotalApparentPower", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/TotalApparentPower";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured1st_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/Measured1stHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/Measured1stHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured3rd_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/Measured3rdHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/Measured3rdHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured5th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/Measured5thHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/Measured5thHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured7th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/Measured7thHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/Measured7thHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured9th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/Measured9thHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/Measured9thHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured11th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/Measured11thHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/Measured11thHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase1st_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/MeasuredPhase1stHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/MeasuredPhase1stHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase3rd_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/MeasuredPhase3rdHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/MeasuredPhase3rdHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase5th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/MeasuredPhase5thHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/MeasuredPhase5thHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase7th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/MeasuredPhase7thHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/MeasuredPhase7thHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase9th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/MeasuredPhase9thHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/MeasuredPhase9thHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase11th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/MeasuredPhase11thHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/MeasuredPhase11thHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_frequency_multiplier_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACFrequencyMultiplier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACFrequencyMultiplier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_frequency_divisor_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACFrequencyDivisor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACFrequencyDivisor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_power_multiplier_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/PowerMultiplier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/PowerMultiplier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_power_divisor_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/PowerDivisor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/PowerDivisor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_harmonic_current_multiplier_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/HarmonicCurrentMultiplier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/HarmonicCurrentMultiplier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_phase_harmonic_current_multiplier_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/PhaseHarmonicCurrentMultiplier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/PhaseHarmonicCurrentMultiplier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_line_current_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/LineCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/LineCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActiveCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActiveCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ReactiveCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ReactiveCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageMin", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageMin";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageMax", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageMax";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_min_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSCurrentMin", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSCurrentMin";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_max_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSCurrentMax", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSCurrentMax";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActivePower", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActivePower";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_min_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActivePowerMin", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActivePowerMin";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_max_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActivePowerMax", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActivePowerMax";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_power_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ReactivePower", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ReactivePower";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_apparent_power_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ApparentPower", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ApparentPower";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_power_factor_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/PowerFactor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/PowerFactor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_averagerms_voltage_measurement_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/AverageRMSVoltageMeasurementPeriod", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/AverageRMSVoltageMeasurementPeriod";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_averagerms_over_voltage_counter_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/AverageRMSOverVoltageCounter", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/AverageRMSOverVoltageCounter";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_averagerms_under_voltage_counter_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/AverageRMSUnderVoltageCounter", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/AverageRMSUnderVoltageCounter";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSExtremeOverVoltagePeriod", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSExtremeOverVoltagePeriod";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSExtremeUnderVoltagePeriod", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSExtremeUnderVoltagePeriod";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageSagPeriod", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageSagPeriod";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageSwellPeriod", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageSwellPeriod";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_voltage_multiplier_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACVoltageMultiplier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACVoltageMultiplier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_voltage_divisor_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACVoltageDivisor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACVoltageDivisor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_current_multiplier_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACCurrentMultiplier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACCurrentMultiplier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_current_divisor_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACCurrentDivisor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACCurrentDivisor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_power_multiplier_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACPowerMultiplier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACPowerMultiplier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_power_divisor_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACPowerDivisor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACPowerDivisor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_overload_alarms_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ElectricalMeasurementDCOverloadAlarmsMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCOverloadAlarmsMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCOverloadAlarmsMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_overload_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCVoltageOverload", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCVoltageOverload";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_overload_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCCurrentOverload", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCCurrentOverload";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_alarms_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ElectricalMeasurementACAlarmsMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACAlarmsMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACAlarmsMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_voltage_overload_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACVoltageOverload", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACVoltageOverload";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_current_overload_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACCurrentOverload", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACCurrentOverload";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_active_power_overload_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACActivePowerOverload", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACActivePowerOverload";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_reactive_power_overload_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACReactivePowerOverload", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACReactivePowerOverload";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_averagerms_over_voltage_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/AverageRMSOverVoltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/AverageRMSOverVoltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_averagerms_under_voltage_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/AverageRMSUnderVoltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/AverageRMSUnderVoltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSExtremeOverVoltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSExtremeOverVoltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSExtremeUnderVoltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSExtremeUnderVoltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageSag", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageSag";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageSwell", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageSwell";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_line_current_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/LineCurrentPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/LineCurrentPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_current_phb_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActiveCurrentPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActiveCurrentPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_current_phb_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ReactiveCurrentPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ReactiveCurrentPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltagePhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltagePhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageMinPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageMinPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageMaxPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageMaxPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSCurrentPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSCurrentPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_min_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSCurrentMinPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSCurrentMinPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_max_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSCurrentMaxPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSCurrentMaxPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_phb_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActivePowerPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActivePowerPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_min_phb_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActivePowerMinPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActivePowerMinPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_max_phb_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActivePowerMaxPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActivePowerMaxPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_power_phb_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ReactivePowerPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ReactivePowerPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_apparent_power_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ApparentPowerPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ApparentPowerPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_power_factor_phb_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/PowerFactorPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/PowerFactorPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_averagerms_voltage_measurement_period_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/AverageRMSVoltageMeasurementPeriodPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/AverageRMSVoltageMeasurementPeriodPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_averagerms_over_voltage_counter_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/AverageRMSOverVoltageCounterPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/AverageRMSOverVoltageCounterPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_averagerms_under_voltage_counter_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/AverageRMSUnderVoltageCounterPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/AverageRMSUnderVoltageCounterPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSExtremeOverVoltagePeriodPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSExtremeOverVoltagePeriodPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSExtremeUnderVoltagePeriodPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSExtremeUnderVoltagePeriodPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageSagPeriodPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageSagPeriodPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageSwellPeriodPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageSwellPeriodPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_line_current_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/LineCurrentPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/LineCurrentPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_current_phc_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActiveCurrentPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActiveCurrentPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_current_phc_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ReactiveCurrentPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ReactiveCurrentPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltagePhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltagePhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageMinPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageMinPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageMaxPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageMaxPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSCurrentPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSCurrentPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_min_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSCurrentMinPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSCurrentMinPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_max_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSCurrentMaxPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSCurrentMaxPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_phc_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActivePowerPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActivePowerPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_min_phc_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActivePowerMinPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActivePowerMinPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_max_phc_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActivePowerMaxPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActivePowerMaxPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_power_phc_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ReactivePowerPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ReactivePowerPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_apparent_power_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ApparentPowerPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ApparentPowerPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_power_factor_phc_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/PowerFactorPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/PowerFactorPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_averagerms_voltage_measurement_period_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/AverageRMSVoltageMeasurementPeriodPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/AverageRMSVoltageMeasurementPeriodPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_averagerms_over_voltage_counter_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/AverageRMSOverVoltageCounterPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/AverageRMSOverVoltageCounterPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_averagerms_under_voltage_counter_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/AverageRMSUnderVoltageCounterPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/AverageRMSUnderVoltageCounterPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSExtremeOverVoltagePeriodPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSExtremeOverVoltagePeriodPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSExtremeUnderVoltagePeriodPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSExtremeUnderVoltagePeriodPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageSagPeriodPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageSagPeriodPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageSwellPeriodPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageSwellPeriodPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_electrical_measurement_write_attributes_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_electrical_measurement_WriteAttributes);
  }

  if(uic_mqtt_dotdot_electrical_measurement_force_read_attributes_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_electrical_measurement_force_read_attributes);
  }
  if (uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Commands/GetProfileInfoResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_electrical_measurement_get_profile_info_response);
  }
  if (uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_response_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/GeneratedCommands/GetProfileInfoResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_electrical_measurement_get_profile_info_response);
  }
  if (uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Commands/GetProfileInfo";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_electrical_measurement_get_profile_info);
  }
  if (uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/GeneratedCommands/GetProfileInfo";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_electrical_measurement_get_profile_info);
  }
  if (uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Commands/GetMeasurementProfileResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_electrical_measurement_get_measurement_profile_response);
  }
  if (uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_response_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/GeneratedCommands/GetMeasurementProfileResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_electrical_measurement_get_measurement_profile_response);
  }
  if (uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/Commands/GetMeasurementProfile";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_electrical_measurement_get_measurement_profile);
  }
  if (uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_callback) {
    subscription_topic = base_topic + "ElectricalMeasurement/GeneratedCommands/GetMeasurementProfile";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_electrical_measurement_get_measurement_profile);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_electrical_measurement_attributes_init();

  uic_mqtt_dotdot_by_group_electrical_measurement_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_diagnostics_write_attributes_callback_t uic_mqtt_dotdot_diagnostics_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_diagnostics_force_read_attributes_callback_t uic_mqtt_dotdot_diagnostics_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_diagnostics_write_attributes_callback(
  const uic_mqtt_dotdot_diagnostics_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_diagnostics_force_read_attributes_callback(
  const uic_mqtt_dotdot_diagnostics_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/Diagnostics/Commands/WriteAttributes
void uic_mqtt_dotdot_on_diagnostics_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_diagnostics_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_diagnostics_state_t new_state = {};
  uic_mqtt_dotdot_diagnostics_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_diagnostics_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Diagnostics", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_diagnostics_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_diagnostics_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_diagnostics_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_diagnostics_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.number_of_resets = true;
        force_update.persistent_memory_writes = true;
        force_update.mac_rx_bcast = true;
        force_update.mac_tx_bcast = true;
        force_update.mac_rx_ucast = true;
        force_update.mac_tx_ucast = true;
        force_update.mac_tx_ucast_retry = true;
        force_update.mac_tx_ucast_fail = true;
        force_update.aps_rx_bcast = true;
        force_update.aps_tx_bcast = true;
        force_update.aps_rx_ucast = true;
        force_update.aps_tx_ucast_success = true;
        force_update.aps_tx_ucast_retry = true;
        force_update.aps_tx_ucast_fail = true;
        force_update.route_disc_initiated = true;
        force_update.neighbor_added = true;
        force_update.neighbor_removed = true;
        force_update.neighbor_stale = true;
        force_update.join_indication = true;
        force_update.child_moved = true;
        force_update.nwkfc_failure = true;
        force_update.apsfc_failure = true;
        force_update.aps_unauthorized_key = true;
        force_update.nwk_decrypt_failures = true;
        force_update.aps_decrypt_failures = true;
        force_update.packet_buffer_allocate_failures = true;
        force_update.relayed_ucast = true;
        force_update.phy_tomac_queue_limit_reached = true;
        force_update.packet_validate_drop_count = true;
        force_update.averagemac_retry_peraps_message_sent = true;
        force_update.last_messagelqi = true;
        force_update.last_messagerssi = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"NumberOfResets", &force_update.number_of_resets },
          {"PersistentMemoryWrites", &force_update.persistent_memory_writes },
          {"MacRxBcast", &force_update.mac_rx_bcast },
          {"MacTxBcast", &force_update.mac_tx_bcast },
          {"MacRxUcast", &force_update.mac_rx_ucast },
          {"MacTxUcast", &force_update.mac_tx_ucast },
          {"MacTxUcastRetry", &force_update.mac_tx_ucast_retry },
          {"MacTxUcastFail", &force_update.mac_tx_ucast_fail },
          {"APSRxBcast", &force_update.aps_rx_bcast },
          {"APSTxBcast", &force_update.aps_tx_bcast },
          {"APSRxUcast", &force_update.aps_rx_ucast },
          {"APSTxUcastSuccess", &force_update.aps_tx_ucast_success },
          {"APSTxUcastRetry", &force_update.aps_tx_ucast_retry },
          {"APSTxUcastFail", &force_update.aps_tx_ucast_fail },
          {"RouteDiscInitiated", &force_update.route_disc_initiated },
          {"NeighborAdded", &force_update.neighbor_added },
          {"NeighborRemoved", &force_update.neighbor_removed },
          {"NeighborStale", &force_update.neighbor_stale },
          {"JoinIndication", &force_update.join_indication },
          {"ChildMoved", &force_update.child_moved },
          {"NWKFCFailure", &force_update.nwkfc_failure },
          {"APSFCFailure", &force_update.apsfc_failure },
          {"APSUnauthorizedKey", &force_update.aps_unauthorized_key },
          {"NWKDecryptFailures", &force_update.nwk_decrypt_failures },
          {"APSDecryptFailures", &force_update.aps_decrypt_failures },
          {"PacketBufferAllocateFailures", &force_update.packet_buffer_allocate_failures },
          {"RelayedUcast", &force_update.relayed_ucast },
          {"PHYToMACQueueLimitReached", &force_update.phy_tomac_queue_limit_reached },
          {"PacketValidateDropCount", &force_update.packet_validate_drop_count },
          {"AverageMACRetryPerAPSMessageSent", &force_update.averagemac_retry_peraps_message_sent },
          {"LastMessageLQI", &force_update.last_messagelqi },
          {"LastMessageRSSI", &force_update.last_messagerssi },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_diagnostics_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "Diagnostics/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_diagnostics_number_of_resets_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/NumberOfResets", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/NumberOfResets";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_persistent_memory_writes_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/PersistentMemoryWrites", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/PersistentMemoryWrites";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_mac_rx_bcast_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/MacRxBcast", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/MacRxBcast";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_mac_tx_bcast_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/MacTxBcast", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/MacTxBcast";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_mac_rx_ucast_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/MacRxUcast", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/MacRxUcast";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_mac_tx_ucast_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/MacTxUcast", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/MacTxUcast";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_mac_tx_ucast_retry_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/MacTxUcastRetry", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/MacTxUcastRetry";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_mac_tx_ucast_fail_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/MacTxUcastFail", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/MacTxUcastFail";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_aps_rx_bcast_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/APSRxBcast", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/APSRxBcast";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_aps_tx_bcast_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/APSTxBcast", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/APSTxBcast";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_aps_rx_ucast_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/APSRxUcast", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/APSRxUcast";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_aps_tx_ucast_success_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/APSTxUcastSuccess", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/APSTxUcastSuccess";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_aps_tx_ucast_retry_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/APSTxUcastRetry", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/APSTxUcastRetry";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_aps_tx_ucast_fail_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/APSTxUcastFail", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/APSTxUcastFail";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_route_disc_initiated_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/RouteDiscInitiated", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/RouteDiscInitiated";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_neighbor_added_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/NeighborAdded", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/NeighborAdded";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_neighbor_removed_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/NeighborRemoved", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/NeighborRemoved";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_neighbor_stale_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/NeighborStale", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/NeighborStale";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_join_indication_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/JoinIndication", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/JoinIndication";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_child_moved_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/ChildMoved", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/ChildMoved";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_nwkfc_failure_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/NWKFCFailure", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/NWKFCFailure";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_apsfc_failure_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/APSFCFailure", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/APSFCFailure";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_aps_unauthorized_key_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/APSUnauthorizedKey", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/APSUnauthorizedKey";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_nwk_decrypt_failures_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/NWKDecryptFailures", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/NWKDecryptFailures";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_aps_decrypt_failures_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/APSDecryptFailures", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/APSDecryptFailures";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_packet_buffer_allocate_failures_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/PacketBufferAllocateFailures", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/PacketBufferAllocateFailures";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_relayed_ucast_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/RelayedUcast", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/RelayedUcast";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_phy_tomac_queue_limit_reached_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/PHYToMACQueueLimitReached", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/PHYToMACQueueLimitReached";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_packet_validate_drop_count_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/PacketValidateDropCount", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/PacketValidateDropCount";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_averagemac_retry_peraps_message_sent_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/AverageMACRetryPerAPSMessageSent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/AverageMACRetryPerAPSMessageSent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_last_messagelqi_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/LastMessageLQI", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/LastMessageLQI";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_diagnostics_last_messagerssi_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/LastMessageRSSI", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/LastMessageRSSI";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_diagnostics_write_attributes_callback) {
    subscription_topic = base_topic + "Diagnostics/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_diagnostics_WriteAttributes);
  }

  if(uic_mqtt_dotdot_diagnostics_force_read_attributes_callback) {
    subscription_topic = base_topic + "Diagnostics/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_diagnostics_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_diagnostics_attributes_init();

  uic_mqtt_dotdot_by_group_diagnostics_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback_t uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback = nullptr;
static uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback_t uic_mqtt_dotdot_protocol_controller_rf_telemetry_generated_tx_report_callback = nullptr;
uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_callback_t uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_protocol_controller_rf_telemetry_force_read_attributes_callback_t uic_mqtt_dotdot_protocol_controller_rf_telemetry_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback_set(const uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback_t callback)
{
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback = callback;
}
void uic_mqtt_dotdot_protocol_controller_rf_telemetry_generated_tx_report_callback_set(const uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback_t callback)
{
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_generated_tx_report_callback = callback;
}


void uic_mqtt_dotdot_set_protocol_controller_rf_telemetry_write_attributes_callback(
  const uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_protocol_controller_rf_telemetry_force_read_attributes_callback(
  const uic_mqtt_dotdot_protocol_controller_rf_telemetry_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/ProtocolController-RFTelemetry/Commands/TxReport
void uic_mqtt_dotdot_on_protocol_controller_rf_telemetry_tx_report(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* sourceunid = {};
  const char* destinationunid = {};
  bool transmission_successful = {};
  uint16_t transmission_time_ms = {};
  int8_t tx_powerd_bm = {};
  uint8_t tx_channel = {};
  uint8_t routing_attempts = {};
  bool route_changed = {};
  TxReportTransmissionSpeed transmission_speed = {};
  int8_t measured_noise_floord_bm = {};
  std::vector<const char*> last_route_repeaters;
  std::vector<int8_t> incomingrssi_repeaters;
  int8_t ackrssi = {};
  uint8_t ack_channel = {};
  const char* last_route_failed_link_functionalunid = {};
  const char* last_route_failed_link_non_functionalunid = {};
  int8_t destination_ack_tx_powerd_bm = {};
  int8_t destination_ack_measuredrssi = {};
  int8_t destination_ack_measured_noise_floor = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_protocol_controller_rf_telemetry_tx_report(
      jsn,
      sourceunid,

      destinationunid,

      transmission_successful,

      transmission_time_ms,

      tx_powerd_bm,

      tx_channel,

      routing_attempts,

      route_changed,

      transmission_speed,

      measured_noise_floord_bm,

      last_route_repeaters,

      incomingrssi_repeaters,

      ackrssi,

      ack_channel,

      last_route_failed_link_functionalunid,

      last_route_failed_link_non_functionalunid,

      destination_ack_tx_powerd_bm,

      destination_ack_measuredrssi,

      destination_ack_measured_noise_floor
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ProtocolController-RFTelemetry", "TxReport");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-RFTelemetry", "TxReport", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-RFTelemetry", "TxReport", "");
    return;
  }

  uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    sourceunid,

    destinationunid,

    transmission_successful,

    transmission_time_ms,

    tx_powerd_bm,

    tx_channel,

    routing_attempts,

    route_changed,

    transmission_speed,

    measured_noise_floord_bm,

    last_route_repeaters.size(),
    last_route_repeaters.data(),

    incomingrssi_repeaters.size(),
    incomingrssi_repeaters.data(),

    ackrssi,

    ack_channel,

    last_route_failed_link_functionalunid,

    last_route_failed_link_non_functionalunid,

    destination_ack_tx_powerd_bm,

    destination_ack_measuredrssi,

    destination_ack_measured_noise_floor

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ProtocolController-RFTelemetry/GeneratedCommands/TxReport
static void uic_mqtt_dotdot_on_generated_protocol_controller_rf_telemetry_tx_report(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_protocol_controller_rf_telemetry_generated_tx_report_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* sourceunid;
  const char* destinationunid;
  bool transmission_successful;
  uint16_t transmission_time_ms;
  int8_t tx_powerd_bm;
  uint8_t tx_channel;
  uint8_t routing_attempts;
  bool route_changed;
  TxReportTransmissionSpeed transmission_speed;
  int8_t measured_noise_floord_bm;
  std::vector<const char*> last_route_repeaters;
  std::vector<int8_t> incomingrssi_repeaters;
  int8_t ackrssi;
  uint8_t ack_channel;
  const char* last_route_failed_link_functionalunid;
  const char* last_route_failed_link_non_functionalunid;
  int8_t destination_ack_tx_powerd_bm;
  int8_t destination_ack_measuredrssi;
  int8_t destination_ack_measured_noise_floor;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_protocol_controller_rf_telemetry_tx_report(
      jsn,
      sourceunid,

      destinationunid,

      transmission_successful,

      transmission_time_ms,

      tx_powerd_bm,

      tx_channel,

      routing_attempts,

      route_changed,

      transmission_speed,

      measured_noise_floord_bm,

      last_route_repeaters,

      incomingrssi_repeaters,

      ackrssi,

      ack_channel,

      last_route_failed_link_functionalunid,

      last_route_failed_link_non_functionalunid,

      destination_ack_tx_powerd_bm,

      destination_ack_measuredrssi,

      destination_ack_measured_noise_floor
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ProtocolController-RFTelemetry", "TxReport");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-RFTelemetry", "TxReport", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-RFTelemetry", "TxReport", "");
    return;
  }

  uic_mqtt_dotdot_protocol_controller_rf_telemetry_generated_tx_report_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    sourceunid,

    destinationunid,

    transmission_successful,

    transmission_time_ms,

    tx_powerd_bm,

    tx_channel,

    routing_attempts,

    route_changed,

    transmission_speed,

    measured_noise_floord_bm,

    last_route_repeaters.size(),
    last_route_repeaters.data(),

    incomingrssi_repeaters.size(),
    incomingrssi_repeaters.data(),

    ackrssi,

    ack_channel,

    last_route_failed_link_functionalunid,

    last_route_failed_link_non_functionalunid,

    destination_ack_tx_powerd_bm,

    destination_ack_measuredrssi,

    destination_ack_measured_noise_floor

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ProtocolController-RFTelemetry/Commands/WriteAttributes
void uic_mqtt_dotdot_on_protocol_controller_rf_telemetry_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_protocol_controller_rf_telemetry_state_t new_state = {};
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_protocol_controller_rf_telemetry_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ProtocolController-RFTelemetry", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-RFTelemetry", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-RFTelemetry", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_protocol_controller_rf_telemetry_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_protocol_controller_rf_telemetry_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_protocol_controller_rf_telemetry_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.tx_report_enabled = true;
        force_update.pti_enabled = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"TxReportEnabled", &force_update.tx_report_enabled },
          {"PTIEnabled", &force_update.pti_enabled },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_protocol_controller_rf_telemetry_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "ProtocolController-RFTelemetry/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_enabled_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController/RFTelemetry/Attributes/TxReportEnabled", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ProtocolController/RFTelemetry/Attributes/TxReportEnabled";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_protocol_controller_rf_telemetry_pti_enabled_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController/RFTelemetry/Attributes/PTIEnabled", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ProtocolController/RFTelemetry/Attributes/PTIEnabled";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_protocol_controller_rf_telemetry_init()
{
  std::string base_topic = "ucl/by-unid/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_callback) {
    subscription_topic = base_topic + "ProtocolController/RFTelemetry/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_protocol_controller_rf_telemetry_WriteAttributes);
  }

  if(uic_mqtt_dotdot_protocol_controller_rf_telemetry_force_read_attributes_callback) {
    subscription_topic = base_topic + "ProtocolController/RFTelemetry/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_protocol_controller_rf_telemetry_force_read_attributes);
  }
  if (uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback) {
    subscription_topic = base_topic + "ProtocolController/RFTelemetry/Commands/TxReport";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_protocol_controller_rf_telemetry_tx_report);
  }
  if (uic_mqtt_dotdot_protocol_controller_rf_telemetry_generated_tx_report_callback) {
    subscription_topic = base_topic + "ProtocolController/RFTelemetry/GeneratedCommands/TxReport";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_protocol_controller_rf_telemetry_tx_report);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_attributes_init();


  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_state_remove_callback_t uic_mqtt_dotdot_state_remove_callback = nullptr;
static uic_mqtt_dotdot_state_remove_callback_t uic_mqtt_dotdot_state_generated_remove_callback = nullptr;
uic_mqtt_dotdot_state_remove_offline_callback_t uic_mqtt_dotdot_state_remove_offline_callback = nullptr;
static uic_mqtt_dotdot_state_remove_offline_callback_t uic_mqtt_dotdot_state_generated_remove_offline_callback = nullptr;
uic_mqtt_dotdot_state_discover_neighbors_callback_t uic_mqtt_dotdot_state_discover_neighbors_callback = nullptr;
static uic_mqtt_dotdot_state_discover_neighbors_callback_t uic_mqtt_dotdot_state_generated_discover_neighbors_callback = nullptr;
uic_mqtt_dotdot_state_interview_callback_t uic_mqtt_dotdot_state_interview_callback = nullptr;
static uic_mqtt_dotdot_state_interview_callback_t uic_mqtt_dotdot_state_generated_interview_callback = nullptr;
uic_mqtt_dotdot_state_write_attributes_callback_t uic_mqtt_dotdot_state_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_state_force_read_attributes_callback_t uic_mqtt_dotdot_state_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_state_remove_callback_set(const uic_mqtt_dotdot_state_remove_callback_t callback)
{
  uic_mqtt_dotdot_state_remove_callback = callback;
}
void uic_mqtt_dotdot_state_generated_remove_callback_set(const uic_mqtt_dotdot_state_remove_callback_t callback)
{
  uic_mqtt_dotdot_state_generated_remove_callback = callback;
}

void uic_mqtt_dotdot_state_remove_offline_callback_set(const uic_mqtt_dotdot_state_remove_offline_callback_t callback)
{
  uic_mqtt_dotdot_state_remove_offline_callback = callback;
}
void uic_mqtt_dotdot_state_generated_remove_offline_callback_set(const uic_mqtt_dotdot_state_remove_offline_callback_t callback)
{
  uic_mqtt_dotdot_state_generated_remove_offline_callback = callback;
}

void uic_mqtt_dotdot_state_discover_neighbors_callback_set(const uic_mqtt_dotdot_state_discover_neighbors_callback_t callback)
{
  uic_mqtt_dotdot_state_discover_neighbors_callback = callback;
}
void uic_mqtt_dotdot_state_generated_discover_neighbors_callback_set(const uic_mqtt_dotdot_state_discover_neighbors_callback_t callback)
{
  uic_mqtt_dotdot_state_generated_discover_neighbors_callback = callback;
}

void uic_mqtt_dotdot_state_interview_callback_set(const uic_mqtt_dotdot_state_interview_callback_t callback)
{
  uic_mqtt_dotdot_state_interview_callback = callback;
}
void uic_mqtt_dotdot_state_generated_interview_callback_set(const uic_mqtt_dotdot_state_interview_callback_t callback)
{
  uic_mqtt_dotdot_state_generated_interview_callback = callback;
}


void uic_mqtt_dotdot_set_state_write_attributes_callback(
  const uic_mqtt_dotdot_state_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_state_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_state_force_read_attributes_callback(
  const uic_mqtt_dotdot_state_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_state_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/State/Commands/Remove
void uic_mqtt_dotdot_on_state_remove(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_state_remove_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "State", "Remove");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "Remove", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "Remove", "");
    return;
  }

  uic_mqtt_dotdot_state_remove_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/State/GeneratedCommands/Remove
static void uic_mqtt_dotdot_on_generated_state_remove(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_state_generated_remove_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "State", "Remove");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "Remove", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "Remove", "");
    return;
  }

  uic_mqtt_dotdot_state_generated_remove_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/State/Commands/RemoveOffline
void uic_mqtt_dotdot_on_state_remove_offline(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_state_remove_offline_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "State", "RemoveOffline");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "RemoveOffline", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "RemoveOffline", "");
    return;
  }

  uic_mqtt_dotdot_state_remove_offline_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/State/GeneratedCommands/RemoveOffline
static void uic_mqtt_dotdot_on_generated_state_remove_offline(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_state_generated_remove_offline_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "State", "RemoveOffline");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "RemoveOffline", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "RemoveOffline", "");
    return;
  }

  uic_mqtt_dotdot_state_generated_remove_offline_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/State/Commands/DiscoverNeighbors
void uic_mqtt_dotdot_on_state_discover_neighbors(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_state_discover_neighbors_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "State", "DiscoverNeighbors");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "DiscoverNeighbors", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "DiscoverNeighbors", "");
    return;
  }

  uic_mqtt_dotdot_state_discover_neighbors_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/State/GeneratedCommands/DiscoverNeighbors
static void uic_mqtt_dotdot_on_generated_state_discover_neighbors(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_state_generated_discover_neighbors_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "State", "DiscoverNeighbors");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "DiscoverNeighbors", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "DiscoverNeighbors", "");
    return;
  }

  uic_mqtt_dotdot_state_generated_discover_neighbors_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/State/Commands/Interview
void uic_mqtt_dotdot_on_state_interview(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_state_interview_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "State", "Interview");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "Interview", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "Interview", "");
    return;
  }

  uic_mqtt_dotdot_state_interview_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/State/GeneratedCommands/Interview
static void uic_mqtt_dotdot_on_generated_state_interview(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_state_generated_interview_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "State", "Interview");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "Interview", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "Interview", "");
    return;
  }

  uic_mqtt_dotdot_state_generated_interview_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/State/Commands/WriteAttributes
void uic_mqtt_dotdot_on_state_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_state_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_state_state_t new_state = {};
  uic_mqtt_dotdot_state_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_state_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "State", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_state_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_state_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_state_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_state_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.endpoint_id_list = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"EndpointIdList", &force_update.endpoint_id_list },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_state_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "State/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_state_endpoint_id_list_publish(
  const char *base_topic,
  size_t value_count,
  const uint8_t* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    jsn["value"].push_back(value[i]);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State/Attributes/EndpointIdList", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/State/Attributes/EndpointIdList";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_state_init()
{
  std::string base_topic = "ucl/by-unid/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_state_write_attributes_callback) {
    subscription_topic = base_topic + "State/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_state_WriteAttributes);
  }

  if(uic_mqtt_dotdot_state_force_read_attributes_callback) {
    subscription_topic = base_topic + "State/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_state_force_read_attributes);
  }
  if (uic_mqtt_dotdot_state_remove_callback) {
    subscription_topic = base_topic + "State/Commands/Remove";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_state_remove);
  }
  if (uic_mqtt_dotdot_state_generated_remove_callback) {
    subscription_topic = base_topic + "State/GeneratedCommands/Remove";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_state_remove);
  }
  if (uic_mqtt_dotdot_state_remove_offline_callback) {
    subscription_topic = base_topic + "State/Commands/RemoveOffline";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_state_remove_offline);
  }
  if (uic_mqtt_dotdot_state_generated_remove_offline_callback) {
    subscription_topic = base_topic + "State/GeneratedCommands/RemoveOffline";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_state_remove_offline);
  }
  if (uic_mqtt_dotdot_state_discover_neighbors_callback) {
    subscription_topic = base_topic + "State/Commands/DiscoverNeighbors";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_state_discover_neighbors);
  }
  if (uic_mqtt_dotdot_state_generated_discover_neighbors_callback) {
    subscription_topic = base_topic + "State/GeneratedCommands/DiscoverNeighbors";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_state_discover_neighbors);
  }
  if (uic_mqtt_dotdot_state_interview_callback) {
    subscription_topic = base_topic + "State/Commands/Interview";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_state_interview);
  }
  if (uic_mqtt_dotdot_state_generated_interview_callback) {
    subscription_topic = base_topic + "State/GeneratedCommands/Interview";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_state_interview);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_state_attributes_init();


  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_binding_bind_callback_t uic_mqtt_dotdot_binding_bind_callback = nullptr;
static uic_mqtt_dotdot_binding_bind_callback_t uic_mqtt_dotdot_binding_generated_bind_callback = nullptr;
uic_mqtt_dotdot_binding_unbind_callback_t uic_mqtt_dotdot_binding_unbind_callback = nullptr;
static uic_mqtt_dotdot_binding_unbind_callback_t uic_mqtt_dotdot_binding_generated_unbind_callback = nullptr;
uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback_t uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback = nullptr;
static uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback_t uic_mqtt_dotdot_binding_generated_bind_to_protocol_controller_callback = nullptr;
uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback_t uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback = nullptr;
static uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback_t uic_mqtt_dotdot_binding_generated_unbind_from_protocol_controller_callback = nullptr;
uic_mqtt_dotdot_binding_write_attributes_callback_t uic_mqtt_dotdot_binding_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_binding_force_read_attributes_callback_t uic_mqtt_dotdot_binding_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_binding_bind_callback_set(const uic_mqtt_dotdot_binding_bind_callback_t callback)
{
  uic_mqtt_dotdot_binding_bind_callback = callback;
}
void uic_mqtt_dotdot_binding_generated_bind_callback_set(const uic_mqtt_dotdot_binding_bind_callback_t callback)
{
  uic_mqtt_dotdot_binding_generated_bind_callback = callback;
}

void uic_mqtt_dotdot_binding_unbind_callback_set(const uic_mqtt_dotdot_binding_unbind_callback_t callback)
{
  uic_mqtt_dotdot_binding_unbind_callback = callback;
}
void uic_mqtt_dotdot_binding_generated_unbind_callback_set(const uic_mqtt_dotdot_binding_unbind_callback_t callback)
{
  uic_mqtt_dotdot_binding_generated_unbind_callback = callback;
}

void uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback_set(const uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback_t callback)
{
  uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback = callback;
}
void uic_mqtt_dotdot_binding_generated_bind_to_protocol_controller_callback_set(const uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback_t callback)
{
  uic_mqtt_dotdot_binding_generated_bind_to_protocol_controller_callback = callback;
}

void uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback_set(const uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback_t callback)
{
  uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback = callback;
}
void uic_mqtt_dotdot_binding_generated_unbind_from_protocol_controller_callback_set(const uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback_t callback)
{
  uic_mqtt_dotdot_binding_generated_unbind_from_protocol_controller_callback = callback;
}


void uic_mqtt_dotdot_set_binding_write_attributes_callback(
  const uic_mqtt_dotdot_binding_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_binding_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_binding_force_read_attributes_callback(
  const uic_mqtt_dotdot_binding_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_binding_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/Binding/Commands/Bind
void uic_mqtt_dotdot_on_binding_bind(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_binding_bind_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* cluster_name = {};
  const char* destination_unid = {};
  uint8_t destination_ep = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_binding_bind(
      jsn,
      cluster_name,

      destination_unid,

      destination_ep
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Binding", "Bind");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "Bind", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "Bind", "");
    return;
  }

  uic_mqtt_dotdot_binding_bind_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    cluster_name,

    destination_unid,

    destination_ep

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Binding/GeneratedCommands/Bind
static void uic_mqtt_dotdot_on_generated_binding_bind(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_binding_generated_bind_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* cluster_name;
  const char* destination_unid;
  uint8_t destination_ep;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_binding_bind(
      jsn,
      cluster_name,

      destination_unid,

      destination_ep
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Binding", "Bind");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "Bind", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "Bind", "");
    return;
  }

  uic_mqtt_dotdot_binding_generated_bind_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    cluster_name,

    destination_unid,

    destination_ep

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Binding/Commands/Unbind
void uic_mqtt_dotdot_on_binding_unbind(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_binding_unbind_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* cluster_name = {};
  const char* destination_unid = {};
  uint8_t destination_ep = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_binding_unbind(
      jsn,
      cluster_name,

      destination_unid,

      destination_ep
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Binding", "Unbind");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "Unbind", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "Unbind", "");
    return;
  }

  uic_mqtt_dotdot_binding_unbind_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    cluster_name,

    destination_unid,

    destination_ep

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Binding/GeneratedCommands/Unbind
static void uic_mqtt_dotdot_on_generated_binding_unbind(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_binding_generated_unbind_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* cluster_name;
  const char* destination_unid;
  uint8_t destination_ep;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_binding_unbind(
      jsn,
      cluster_name,

      destination_unid,

      destination_ep
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Binding", "Unbind");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "Unbind", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "Unbind", "");
    return;
  }

  uic_mqtt_dotdot_binding_generated_unbind_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    cluster_name,

    destination_unid,

    destination_ep

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Binding/Commands/BindToProtocolController
void uic_mqtt_dotdot_on_binding_bind_to_protocol_controller(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* cluster_name = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_binding_bind_to_protocol_controller(
      jsn,
      cluster_name
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Binding", "BindToProtocolController");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "BindToProtocolController", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "BindToProtocolController", "");
    return;
  }

  uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    cluster_name

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Binding/GeneratedCommands/BindToProtocolController
static void uic_mqtt_dotdot_on_generated_binding_bind_to_protocol_controller(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_binding_generated_bind_to_protocol_controller_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* cluster_name;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_binding_bind_to_protocol_controller(
      jsn,
      cluster_name
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Binding", "BindToProtocolController");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "BindToProtocolController", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "BindToProtocolController", "");
    return;
  }

  uic_mqtt_dotdot_binding_generated_bind_to_protocol_controller_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    cluster_name

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Binding/Commands/UnbindFromProtocolController
void uic_mqtt_dotdot_on_binding_unbind_from_protocol_controller(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* cluster_name = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_binding_unbind_from_protocol_controller(
      jsn,
      cluster_name
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Binding", "UnbindFromProtocolController");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "UnbindFromProtocolController", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "UnbindFromProtocolController", "");
    return;
  }

  uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    cluster_name

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/Binding/GeneratedCommands/UnbindFromProtocolController
static void uic_mqtt_dotdot_on_generated_binding_unbind_from_protocol_controller(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_binding_generated_unbind_from_protocol_controller_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* cluster_name;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_binding_unbind_from_protocol_controller(
      jsn,
      cluster_name
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Binding", "UnbindFromProtocolController");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "UnbindFromProtocolController", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "UnbindFromProtocolController", "");
    return;
  }

  uic_mqtt_dotdot_binding_generated_unbind_from_protocol_controller_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    cluster_name

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/Binding/Commands/WriteAttributes
void uic_mqtt_dotdot_on_binding_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_binding_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_binding_state_t new_state = {};
  uic_mqtt_dotdot_binding_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_binding_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Binding", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_binding_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_binding_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_binding_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_binding_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.binding_table_full = true;
        force_update.bindable_cluster_list = true;
        force_update.binding_table = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"BindingTableFull", &force_update.binding_table_full },
          {"BindableClusterList", &force_update.bindable_cluster_list },
          {"BindingTable", &force_update.binding_table },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_binding_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "Binding/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_binding_binding_table_full_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding/Attributes/BindingTableFull", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Binding/Attributes/BindingTableFull";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_binding_bindable_cluster_list_publish(
  const char *base_topic,
  size_t value_count,
  const char** value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // String type
    jsn["value"].push_back(std::string(value[i]));
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding/Attributes/BindableClusterList", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Binding/Attributes/BindableClusterList";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_binding_binding_table_publish(
  const char *base_topic,
  size_t value_count,
  const BindingObject* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // Struct type
    nlohmann::json json_object = nlohmann::json::object();
    json_object["ClusterName"] = value[i].ClusterName;
    json_object["DestinationUnid"] = value[i].DestinationUnid;
    json_object["DestinationEp"] = value[i].DestinationEp;
    jsn["value"].push_back(json_object);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding/Attributes/BindingTable", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Binding/Attributes/BindingTable";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_binding_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_binding_write_attributes_callback) {
    subscription_topic = base_topic + "Binding/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_binding_WriteAttributes);
  }

  if(uic_mqtt_dotdot_binding_force_read_attributes_callback) {
    subscription_topic = base_topic + "Binding/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_binding_force_read_attributes);
  }
  if (uic_mqtt_dotdot_binding_bind_callback) {
    subscription_topic = base_topic + "Binding/Commands/Bind";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_binding_bind);
  }
  if (uic_mqtt_dotdot_binding_generated_bind_callback) {
    subscription_topic = base_topic + "Binding/GeneratedCommands/Bind";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_binding_bind);
  }
  if (uic_mqtt_dotdot_binding_unbind_callback) {
    subscription_topic = base_topic + "Binding/Commands/Unbind";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_binding_unbind);
  }
  if (uic_mqtt_dotdot_binding_generated_unbind_callback) {
    subscription_topic = base_topic + "Binding/GeneratedCommands/Unbind";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_binding_unbind);
  }
  if (uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback) {
    subscription_topic = base_topic + "Binding/Commands/BindToProtocolController";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_binding_bind_to_protocol_controller);
  }
  if (uic_mqtt_dotdot_binding_generated_bind_to_protocol_controller_callback) {
    subscription_topic = base_topic + "Binding/GeneratedCommands/BindToProtocolController";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_binding_bind_to_protocol_controller);
  }
  if (uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback) {
    subscription_topic = base_topic + "Binding/Commands/UnbindFromProtocolController";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_binding_unbind_from_protocol_controller);
  }
  if (uic_mqtt_dotdot_binding_generated_unbind_from_protocol_controller_callback) {
    subscription_topic = base_topic + "Binding/GeneratedCommands/UnbindFromProtocolController";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_binding_unbind_from_protocol_controller);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_binding_attributes_init();

  uic_mqtt_dotdot_by_group_binding_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_system_metrics_write_attributes_callback_t uic_mqtt_dotdot_system_metrics_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_system_metrics_force_read_attributes_callback_t uic_mqtt_dotdot_system_metrics_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_system_metrics_write_attributes_callback(
  const uic_mqtt_dotdot_system_metrics_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_system_metrics_force_read_attributes_callback(
  const uic_mqtt_dotdot_system_metrics_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/SystemMetrics/Commands/WriteAttributes
void uic_mqtt_dotdot_on_system_metrics_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_system_metrics_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_system_metrics_state_t new_state = {};
  uic_mqtt_dotdot_system_metrics_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_system_metrics_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "SystemMetrics", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_system_metrics_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_system_metrics_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_system_metrics_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_system_metrics_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.reporting_interval_seconds = true;
        force_update.cpu_usage_percent = true;
        force_update.cpu_frequencym_hz = true;
        force_update.cpu_average_usage_percent = true;
        force_update.cpu_min_usage_percent = true;
        force_update.cpu_max_usage_percent = true;
        force_update.ram_totalmb = true;
        force_update.ram_freemb = true;
        force_update.ram_availablemb = true;
        force_update.swap_memory_totalmb = true;
        force_update.swap_memory_usedmb = true;
        force_update.virtual_memory_totalmb = true;
        force_update.virtual_memory_usedmb = true;
        force_update.disks_usage = true;
        force_update.disks_counters = true;
        force_update.network_interfaces_data = true;
        force_update.wireless_network_interfaces_data = true;
        force_update.hostname = true;
        force_update.fqdn = true;
        force_update.uptime_minutes = true;
        force_update.current_temperature_celcius = true;
        force_update.average_temperature_celcius = true;
        force_update.min_temperature_celcius = true;
        force_update.max_temperature_celcius = true;
        force_update.power_plugged = true;
        force_update.battery_percentage = true;
        force_update.system_interrupts = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"ReportingIntervalSeconds", &force_update.reporting_interval_seconds },
          {"CPUUsagePercent", &force_update.cpu_usage_percent },
          {"CPUFrequencyMHz", &force_update.cpu_frequencym_hz },
          {"CPUAverageUsagePercent", &force_update.cpu_average_usage_percent },
          {"CPUMinUsagePercent", &force_update.cpu_min_usage_percent },
          {"CPUMaxUsagePercent", &force_update.cpu_max_usage_percent },
          {"RAMTotalMB", &force_update.ram_totalmb },
          {"RAMFreeMB", &force_update.ram_freemb },
          {"RAMAvailableMB", &force_update.ram_availablemb },
          {"SWAPMemoryTotalMB", &force_update.swap_memory_totalmb },
          {"SWAPMemoryUsedMB", &force_update.swap_memory_usedmb },
          {"VirtualMemoryTotalMB", &force_update.virtual_memory_totalmb },
          {"VirtualMemoryUsedMB", &force_update.virtual_memory_usedmb },
          {"DisksUsage", &force_update.disks_usage },
          {"DisksCounters", &force_update.disks_counters },
          {"NetworkInterfacesData", &force_update.network_interfaces_data },
          {"WirelessNetworkInterfacesData", &force_update.wireless_network_interfaces_data },
          {"Hostname", &force_update.hostname },
          {"FQDN", &force_update.fqdn },
          {"UptimeMinutes", &force_update.uptime_minutes },
          {"CurrentTemperatureCelcius", &force_update.current_temperature_celcius },
          {"AverageTemperatureCelcius", &force_update.average_temperature_celcius },
          {"MinTemperatureCelcius", &force_update.min_temperature_celcius },
          {"MaxTemperatureCelcius", &force_update.max_temperature_celcius },
          {"PowerPlugged", &force_update.power_plugged },
          {"BatteryPercentage", &force_update.battery_percentage },
          {"SystemInterrupts", &force_update.system_interrupts },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_system_metrics_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "SystemMetrics/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_system_metrics_reporting_interval_seconds_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/ReportingIntervalSeconds", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/ReportingIntervalSeconds";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_cpu_usage_percent_publish(
  const char *base_topic,
  size_t value_count,
  const double* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    jsn["value"].push_back(value[i]);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/CPUUsagePercent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/CPUUsagePercent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_cpu_frequencym_hz_publish(
  const char *base_topic,
  size_t value_count,
  const double* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    jsn["value"].push_back(value[i]);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/CPUFrequencyMHz", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/CPUFrequencyMHz";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_cpu_average_usage_percent_publish(
  const char *base_topic,
  size_t value_count,
  const double* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    jsn["value"].push_back(value[i]);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/CPUAverageUsagePercent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/CPUAverageUsagePercent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_cpu_min_usage_percent_publish(
  const char *base_topic,
  size_t value_count,
  const double* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    jsn["value"].push_back(value[i]);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/CPUMinUsagePercent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/CPUMinUsagePercent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_cpu_max_usage_percent_publish(
  const char *base_topic,
  size_t value_count,
  const double* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    jsn["value"].push_back(value[i]);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/CPUMaxUsagePercent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/CPUMaxUsagePercent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_ram_totalmb_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/RAMTotalMB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/RAMTotalMB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_ram_freemb_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/RAMFreeMB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/RAMFreeMB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_ram_availablemb_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/RAMAvailableMB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/RAMAvailableMB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_swap_memory_totalmb_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/SWAPMemoryTotalMB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/SWAPMemoryTotalMB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_swap_memory_usedmb_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/SWAPMemoryUsedMB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/SWAPMemoryUsedMB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_virtual_memory_totalmb_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/VirtualMemoryTotalMB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/VirtualMemoryTotalMB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_virtual_memory_usedmb_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/VirtualMemoryUsedMB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/VirtualMemoryUsedMB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_disks_usage_publish(
  const char *base_topic,
  size_t value_count,
  const DiskUsageData* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // Struct type
    nlohmann::json json_object = nlohmann::json::object();
    json_object["UUID"] = value[i].UUID;
    json_object["UsagePercent"] = value[i].UsagePercent;
    json_object["FreeSpaceMB"] = value[i].FreeSpaceMB;
    jsn["value"].push_back(json_object);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/DisksUsage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/DisksUsage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_disks_counters_publish(
  const char *base_topic,
  size_t value_count,
  const DiskIOCounters* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // Struct type
    nlohmann::json json_object = nlohmann::json::object();
    json_object["UUID"] = value[i].UUID;
    json_object["ReadCount"] = value[i].ReadCount;
    json_object["WriteCount"] = value[i].WriteCount;
    json_object["ReadBytes"] = value[i].ReadBytes;
    json_object["WriteBytes"] = value[i].WriteBytes;
    jsn["value"].push_back(json_object);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/DisksCounters", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/DisksCounters";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_network_interfaces_data_publish(
  const char *base_topic,
  size_t value_count,
  const NetworkInterfaceData* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // Struct type
    nlohmann::json json_object = nlohmann::json::object();
    json_object["InterfaceName"] = value[i].InterfaceName;
    json_object["BytesSent"] = value[i].BytesSent;
    json_object["BytesReceived"] = value[i].BytesReceived;
    json_object["PacketsSent"] = value[i].PacketsSent;
    json_object["PacketsReceived"] = value[i].PacketsReceived;
    json_object["ErrorsIn"] = value[i].ErrorsIn;
    json_object["ErrorsOut"] = value[i].ErrorsOut;
    json_object["DropIn"] = value[i].DropIn;
    json_object["DropOut"] = value[i].DropOut;
    jsn["value"].push_back(json_object);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/NetworkInterfacesData", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/NetworkInterfacesData";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_wireless_network_interfaces_data_publish(
  const char *base_topic,
  size_t value_count,
  const WirelessNetworkInterfaceData* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // Struct type
    nlohmann::json json_object = nlohmann::json::object();
    json_object["InterfaceName"] = value[i].InterfaceName;
    json_object["SignalStrengthdBm"] = value[i].SignalStrengthdBm;
    jsn["value"].push_back(json_object);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/WirelessNetworkInterfacesData", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/WirelessNetworkInterfacesData";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_hostname_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/Hostname", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/Hostname";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_fqdn_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/FQDN", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/FQDN";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_uptime_minutes_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/UptimeMinutes", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/UptimeMinutes";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_current_temperature_celcius_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/CurrentTemperatureCelcius", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/CurrentTemperatureCelcius";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_average_temperature_celcius_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/AverageTemperatureCelcius", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/AverageTemperatureCelcius";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_min_temperature_celcius_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/MinTemperatureCelcius", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/MinTemperatureCelcius";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_max_temperature_celcius_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/MaxTemperatureCelcius", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/MaxTemperatureCelcius";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_power_plugged_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/PowerPlugged", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/PowerPlugged";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_battery_percentage_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/BatteryPercentage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/BatteryPercentage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_system_metrics_system_interrupts_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/SystemInterrupts", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/SystemInterrupts";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_init()
{
  std::string base_topic = "ucl/by-unid/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_system_metrics_write_attributes_callback) {
    subscription_topic = base_topic + "SystemMetrics/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_system_metrics_WriteAttributes);
  }

  if(uic_mqtt_dotdot_system_metrics_force_read_attributes_callback) {
    subscription_topic = base_topic + "SystemMetrics/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_system_metrics_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_system_metrics_attributes_init();


  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_application_monitoring_log_entry_callback_t uic_mqtt_dotdot_application_monitoring_log_entry_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_log_entry_callback_t uic_mqtt_dotdot_application_monitoring_generated_log_entry_callback = nullptr;
uic_mqtt_dotdot_application_monitoring_write_attributes_callback_t uic_mqtt_dotdot_application_monitoring_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_application_monitoring_force_read_attributes_callback_t uic_mqtt_dotdot_application_monitoring_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_application_monitoring_log_entry_callback_set(const uic_mqtt_dotdot_application_monitoring_log_entry_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_log_entry_callback = callback;
}
void uic_mqtt_dotdot_application_monitoring_generated_log_entry_callback_set(const uic_mqtt_dotdot_application_monitoring_log_entry_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_generated_log_entry_callback = callback;
}


void uic_mqtt_dotdot_set_application_monitoring_write_attributes_callback(
  const uic_mqtt_dotdot_application_monitoring_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_application_monitoring_force_read_attributes_callback(
  const uic_mqtt_dotdot_application_monitoring_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/ApplicationMonitoring/Commands/LogEntry
void uic_mqtt_dotdot_on_application_monitoring_log_entry(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_application_monitoring_log_entry_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* timestamp = {};
  LoggingLevelEnum log_level = {};
  const char* log_tag = {};
  const char* log_message = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_application_monitoring_log_entry(
      jsn,
      timestamp,

      log_level,

      log_tag,

      log_message
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ApplicationMonitoring", "LogEntry");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring", "LogEntry", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring", "LogEntry", "");
    return;
  }

  uic_mqtt_dotdot_application_monitoring_log_entry_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    timestamp,

    log_level,

    log_tag,

    log_message

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ApplicationMonitoring/GeneratedCommands/LogEntry
static void uic_mqtt_dotdot_on_generated_application_monitoring_log_entry(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_application_monitoring_generated_log_entry_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* timestamp;
  LoggingLevelEnum log_level;
  const char* log_tag;
  const char* log_message;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_application_monitoring_log_entry(
      jsn,
      timestamp,

      log_level,

      log_tag,

      log_message
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ApplicationMonitoring", "LogEntry");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring", "LogEntry", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring", "LogEntry", "");
    return;
  }

  uic_mqtt_dotdot_application_monitoring_generated_log_entry_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    timestamp,

    log_level,

    log_tag,

    log_message

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ApplicationMonitoring/Commands/WriteAttributes
void uic_mqtt_dotdot_on_application_monitoring_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_application_monitoring_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_state_t new_state = {};
  uic_mqtt_dotdot_application_monitoring_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_application_monitoring_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ApplicationMonitoring", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_application_monitoring_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_application_monitoring_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_application_monitoring_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_application_monitoring_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.application_name = true;
        force_update.application_version = true;
        force_update.application_connected = true;
        force_update.applicationmqtt_topics = true;
        force_update.uptime_minutes = true;
        force_update.process_id = true;
        force_update.hostname = true;
        force_update.fqdn = true;
        force_update.mqtt_logging_enabled = true;
        force_update.mqtt_logging_level = true;
        force_update.mqtt_statistics_reporting_interval_seconds = true;
        force_update.mqtt_messages_sent = true;
        force_update.mqtt_messages_received = true;
        force_update.mqtt_subscription_count = true;
        force_update.mqtt_average_delivery_time_seconds = true;
        force_update.mqtt_min_delivery_time_seconds = true;
        force_update.mqtt_max_delivery_time_seconds = true;
        force_update.application_statistics_reporting_interval_seconds = true;
        force_update.applicationcpu_usage_percent = true;
        force_update.applicationcpu_average_usage_percent = true;
        force_update.applicationcpu_min_usage_percent = true;
        force_update.applicationcpu_max_usage_percent = true;
        force_update.applicationram_usagemb = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"ApplicationName", &force_update.application_name },
          {"ApplicationVersion", &force_update.application_version },
          {"ApplicationConnected", &force_update.application_connected },
          {"ApplicationMQTTTopics", &force_update.applicationmqtt_topics },
          {"UptimeMinutes", &force_update.uptime_minutes },
          {"ProcessId", &force_update.process_id },
          {"Hostname", &force_update.hostname },
          {"FQDN", &force_update.fqdn },
          {"MQTTLoggingEnabled", &force_update.mqtt_logging_enabled },
          {"MQTTLoggingLevel", &force_update.mqtt_logging_level },
          {"MQTTStatisticsReportingIntervalSeconds", &force_update.mqtt_statistics_reporting_interval_seconds },
          {"MQTTMessagesSent", &force_update.mqtt_messages_sent },
          {"MQTTMessagesReceived", &force_update.mqtt_messages_received },
          {"MQTTSubscriptionCount", &force_update.mqtt_subscription_count },
          {"MQTTAverageDeliveryTimeSeconds", &force_update.mqtt_average_delivery_time_seconds },
          {"MQTTMinDeliveryTimeSeconds", &force_update.mqtt_min_delivery_time_seconds },
          {"MQTTMaxDeliveryTimeSeconds", &force_update.mqtt_max_delivery_time_seconds },
          {"ApplicationStatisticsReportingIntervalSeconds", &force_update.application_statistics_reporting_interval_seconds },
          {"ApplicationCPUUsagePercent", &force_update.applicationcpu_usage_percent },
          {"ApplicationCPUAverageUsagePercent", &force_update.applicationcpu_average_usage_percent },
          {"ApplicationCPUMinUsagePercent", &force_update.applicationcpu_min_usage_percent },
          {"ApplicationCPUMaxUsagePercent", &force_update.applicationcpu_max_usage_percent },
          {"ApplicationRAMUsageMB", &force_update.applicationram_usagemb },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_application_monitoring_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "ApplicationMonitoring/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_application_monitoring_application_name_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/ApplicationName", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ApplicationName";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_application_monitoring_application_version_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/ApplicationVersion", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ApplicationVersion";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_application_monitoring_application_connected_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/ApplicationConnected", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ApplicationConnected";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_application_monitoring_applicationmqtt_topics_publish(
  const char *base_topic,
  size_t value_count,
  const char** value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // String type
    jsn["value"].push_back(std::string(value[i]));
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/ApplicationMQTTTopics", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ApplicationMQTTTopics";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_application_monitoring_uptime_minutes_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/UptimeMinutes", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/UptimeMinutes";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_application_monitoring_process_id_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/ProcessId", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ProcessId";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_application_monitoring_hostname_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/Hostname", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/Hostname";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_application_monitoring_fqdn_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/FQDN", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/FQDN";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_logging_enabled_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/MQTTLoggingEnabled", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/MQTTLoggingEnabled";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_logging_level_publish(
  const char *base_topic,
  LoggingLevelEnum value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef APPLICATION_MONITORING_MQTT_LOGGING_LEVEL_ENUM_NAME_AVAILABLE
  jsn["value"] = application_monitoring_mqtt_logging_level_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<LoggingLevelEnum>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/MQTTLoggingLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/MQTTLoggingLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_statistics_reporting_interval_seconds_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/MQTTStatisticsReportingIntervalSeconds", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/MQTTStatisticsReportingIntervalSeconds";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_messages_sent_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/MQTTMessagesSent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/MQTTMessagesSent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_messages_received_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/MQTTMessagesReceived", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/MQTTMessagesReceived";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_subscription_count_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/MQTTSubscriptionCount", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/MQTTSubscriptionCount";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_average_delivery_time_seconds_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/MQTTAverageDeliveryTimeSeconds", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/MQTTAverageDeliveryTimeSeconds";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_min_delivery_time_seconds_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/MQTTMinDeliveryTimeSeconds", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/MQTTMinDeliveryTimeSeconds";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_max_delivery_time_seconds_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/MQTTMaxDeliveryTimeSeconds", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/MQTTMaxDeliveryTimeSeconds";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_application_monitoring_application_statistics_reporting_interval_seconds_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/ApplicationStatisticsReportingIntervalSeconds", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ApplicationStatisticsReportingIntervalSeconds";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_application_monitoring_applicationcpu_usage_percent_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/ApplicationCPUUsagePercent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ApplicationCPUUsagePercent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_application_monitoring_applicationcpu_average_usage_percent_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/ApplicationCPUAverageUsagePercent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ApplicationCPUAverageUsagePercent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_application_monitoring_applicationcpu_min_usage_percent_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/ApplicationCPUMinUsagePercent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ApplicationCPUMinUsagePercent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_application_monitoring_applicationcpu_max_usage_percent_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/ApplicationCPUMaxUsagePercent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ApplicationCPUMaxUsagePercent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_application_monitoring_applicationram_usagemb_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/ApplicationRAMUsageMB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ApplicationRAMUsageMB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_init()
{
  std::string base_topic = "ucl/by-unid/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_application_monitoring_write_attributes_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_application_monitoring_WriteAttributes);
  }

  if(uic_mqtt_dotdot_application_monitoring_force_read_attributes_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_application_monitoring_force_read_attributes);
  }
  if (uic_mqtt_dotdot_application_monitoring_log_entry_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/Commands/LogEntry";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_application_monitoring_log_entry);
  }
  if (uic_mqtt_dotdot_application_monitoring_generated_log_entry_callback) {
    subscription_topic = base_topic + "ApplicationMonitoring/GeneratedCommands/LogEntry";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_application_monitoring_log_entry);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_application_monitoring_attributes_init();


  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_name_and_location_write_attributes_callback_t uic_mqtt_dotdot_name_and_location_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_name_and_location_force_read_attributes_callback_t uic_mqtt_dotdot_name_and_location_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_name_and_location_write_attributes_callback(
  const uic_mqtt_dotdot_name_and_location_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_name_and_location_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_name_and_location_force_read_attributes_callback(
  const uic_mqtt_dotdot_name_and_location_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_name_and_location_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/NameAndLocation/Commands/WriteAttributes
void uic_mqtt_dotdot_on_name_and_location_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_name_and_location_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_name_and_location_state_t new_state = {};
  uic_mqtt_dotdot_name_and_location_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_name_and_location_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "NameAndLocation", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "NameAndLocation", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "NameAndLocation", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_name_and_location_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_name_and_location_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_name_and_location_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_name_and_location_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.name = true;
        force_update.location = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"Name", &force_update.name },
          {"Location", &force_update.location },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_name_and_location_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "NameAndLocation/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_name_and_location_name_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "NameAndLocation/Attributes/Name", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/NameAndLocation/Attributes/Name";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_name_and_location_location_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "NameAndLocation/Attributes/Location", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/NameAndLocation/Attributes/Location";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_name_and_location_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_name_and_location_write_attributes_callback) {
    subscription_topic = base_topic + "NameAndLocation/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_name_and_location_WriteAttributes);
  }

  if(uic_mqtt_dotdot_name_and_location_force_read_attributes_callback) {
    subscription_topic = base_topic + "NameAndLocation/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_name_and_location_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_name_and_location_attributes_init();

  uic_mqtt_dotdot_by_group_name_and_location_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback_t uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback = nullptr;
static uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback_t uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_callback = nullptr;
uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback_t uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback = nullptr;
static uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback_t uic_mqtt_dotdot_configuration_parameters_generated_default_reset_all_parameters_callback = nullptr;
uic_mqtt_dotdot_configuration_parameters_set_parameter_callback_t uic_mqtt_dotdot_configuration_parameters_set_parameter_callback = nullptr;
static uic_mqtt_dotdot_configuration_parameters_set_parameter_callback_t uic_mqtt_dotdot_configuration_parameters_generated_set_parameter_callback = nullptr;
uic_mqtt_dotdot_configuration_parameters_write_attributes_callback_t uic_mqtt_dotdot_configuration_parameters_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_configuration_parameters_force_read_attributes_callback_t uic_mqtt_dotdot_configuration_parameters_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback_set(const uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback_t callback)
{
  uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback = callback;
}
void uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_callback_set(const uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback_t callback)
{
  uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_callback = callback;
}

void uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback_set(const uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback_t callback)
{
  uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback = callback;
}
void uic_mqtt_dotdot_configuration_parameters_generated_default_reset_all_parameters_callback_set(const uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback_t callback)
{
  uic_mqtt_dotdot_configuration_parameters_generated_default_reset_all_parameters_callback = callback;
}

void uic_mqtt_dotdot_configuration_parameters_set_parameter_callback_set(const uic_mqtt_dotdot_configuration_parameters_set_parameter_callback_t callback)
{
  uic_mqtt_dotdot_configuration_parameters_set_parameter_callback = callback;
}
void uic_mqtt_dotdot_configuration_parameters_generated_set_parameter_callback_set(const uic_mqtt_dotdot_configuration_parameters_set_parameter_callback_t callback)
{
  uic_mqtt_dotdot_configuration_parameters_generated_set_parameter_callback = callback;
}


void uic_mqtt_dotdot_set_configuration_parameters_write_attributes_callback(
  const uic_mqtt_dotdot_configuration_parameters_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_configuration_parameters_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_configuration_parameters_force_read_attributes_callback(
  const uic_mqtt_dotdot_configuration_parameters_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_configuration_parameters_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/ConfigurationParameters/Commands/DiscoverParameter
void uic_mqtt_dotdot_on_configuration_parameters_discover_parameter(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t parameter_id = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_configuration_parameters_discover_parameter(
      jsn,
      parameter_id
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ConfigurationParameters", "DiscoverParameter");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DiscoverParameter", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DiscoverParameter", "");
    return;
  }

  uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    parameter_id

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ConfigurationParameters/GeneratedCommands/DiscoverParameter
static void uic_mqtt_dotdot_on_generated_configuration_parameters_discover_parameter(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t parameter_id;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_configuration_parameters_discover_parameter(
      jsn,
      parameter_id
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ConfigurationParameters", "DiscoverParameter");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DiscoverParameter", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DiscoverParameter", "");
    return;
  }

  uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    parameter_id

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ConfigurationParameters/Commands/DefaultResetAllParameters
void uic_mqtt_dotdot_on_configuration_parameters_default_reset_all_parameters(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ConfigurationParameters", "DefaultResetAllParameters");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DefaultResetAllParameters", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DefaultResetAllParameters", "");
    return;
  }

  uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ConfigurationParameters/GeneratedCommands/DefaultResetAllParameters
static void uic_mqtt_dotdot_on_generated_configuration_parameters_default_reset_all_parameters(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_configuration_parameters_generated_default_reset_all_parameters_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ConfigurationParameters", "DefaultResetAllParameters");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DefaultResetAllParameters", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DefaultResetAllParameters", "");
    return;
  }

  uic_mqtt_dotdot_configuration_parameters_generated_default_reset_all_parameters_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ConfigurationParameters/Commands/SetParameter
void uic_mqtt_dotdot_on_configuration_parameters_set_parameter(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_configuration_parameters_set_parameter_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t parameter_id = {};
  int64_t value = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_configuration_parameters_set_parameter(
      jsn,
      parameter_id,

      value
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ConfigurationParameters", "SetParameter");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "SetParameter", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "SetParameter", "");
    return;
  }

  uic_mqtt_dotdot_configuration_parameters_set_parameter_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    parameter_id,

    value

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ConfigurationParameters/GeneratedCommands/SetParameter
static void uic_mqtt_dotdot_on_generated_configuration_parameters_set_parameter(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_configuration_parameters_generated_set_parameter_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t parameter_id;
  int64_t value;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_configuration_parameters_set_parameter(
      jsn,
      parameter_id,

      value
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ConfigurationParameters", "SetParameter");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "SetParameter", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "SetParameter", "");
    return;
  }

  uic_mqtt_dotdot_configuration_parameters_generated_set_parameter_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    parameter_id,

    value

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ConfigurationParameters/Commands/WriteAttributes
void uic_mqtt_dotdot_on_configuration_parameters_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_configuration_parameters_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_configuration_parameters_state_t new_state = {};
  uic_mqtt_dotdot_configuration_parameters_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_configuration_parameters_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ConfigurationParameters", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_configuration_parameters_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_configuration_parameters_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_configuration_parameters_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_configuration_parameters_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.configuration_parameters = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"ConfigurationParameters", &force_update.configuration_parameters },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_configuration_parameters_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "ConfigurationParameters/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_configuration_parameters_configuration_parameters_publish(
  const char *base_topic,
  size_t value_count,
  const ConfigurationParameter* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // Struct type
    nlohmann::json json_object = nlohmann::json::object();
    json_object["ParameterId"] = value[i].ParameterId;
    json_object["Value"] = value[i].Value;
    json_object["Name"] = value[i].Name;
    json_object["Info"] = value[i].Info;
    json_object["MinimumValue"] = value[i].MinimumValue;
    json_object["MaximumValue"] = value[i].MaximumValue;
    json_object["DefaultValue"] = value[i].DefaultValue;
    json_object["DisplayFormat"] = value[i].DisplayFormat;
    json_object["ReadOnly"] = value[i].ReadOnly;
    json_object["Advanced"] = value[i].Advanced;
    json_object["AlteringCapabilities"] = value[i].AlteringCapabilities;
    jsn["value"].push_back(json_object);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters/Attributes/ConfigurationParameters", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ConfigurationParameters/Attributes/ConfigurationParameters";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_configuration_parameters_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_configuration_parameters_write_attributes_callback) {
    subscription_topic = base_topic + "ConfigurationParameters/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_configuration_parameters_WriteAttributes);
  }

  if(uic_mqtt_dotdot_configuration_parameters_force_read_attributes_callback) {
    subscription_topic = base_topic + "ConfigurationParameters/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_configuration_parameters_force_read_attributes);
  }
  if (uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback) {
    subscription_topic = base_topic + "ConfigurationParameters/Commands/DiscoverParameter";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_configuration_parameters_discover_parameter);
  }
  if (uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_callback) {
    subscription_topic = base_topic + "ConfigurationParameters/GeneratedCommands/DiscoverParameter";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_configuration_parameters_discover_parameter);
  }
  if (uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback) {
    subscription_topic = base_topic + "ConfigurationParameters/Commands/DefaultResetAllParameters";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_configuration_parameters_default_reset_all_parameters);
  }
  if (uic_mqtt_dotdot_configuration_parameters_generated_default_reset_all_parameters_callback) {
    subscription_topic = base_topic + "ConfigurationParameters/GeneratedCommands/DefaultResetAllParameters";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_configuration_parameters_default_reset_all_parameters);
  }
  if (uic_mqtt_dotdot_configuration_parameters_set_parameter_callback) {
    subscription_topic = base_topic + "ConfigurationParameters/Commands/SetParameter";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_configuration_parameters_set_parameter);
  }
  if (uic_mqtt_dotdot_configuration_parameters_generated_set_parameter_callback) {
    subscription_topic = base_topic + "ConfigurationParameters/GeneratedCommands/SetParameter";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_configuration_parameters_set_parameter);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_configuration_parameters_attributes_init();

  uic_mqtt_dotdot_by_group_configuration_parameters_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_aox_locator_iq_report_callback_t uic_mqtt_dotdot_aox_locator_iq_report_callback = nullptr;
static uic_mqtt_dotdot_aox_locator_iq_report_callback_t uic_mqtt_dotdot_aox_locator_generated_iq_report_callback = nullptr;
uic_mqtt_dotdot_aox_locator_angle_report_callback_t uic_mqtt_dotdot_aox_locator_angle_report_callback = nullptr;
static uic_mqtt_dotdot_aox_locator_angle_report_callback_t uic_mqtt_dotdot_aox_locator_generated_angle_report_callback = nullptr;
uic_mqtt_dotdot_aox_locator_angle_correction_callback_t uic_mqtt_dotdot_aox_locator_angle_correction_callback = nullptr;
static uic_mqtt_dotdot_aox_locator_angle_correction_callback_t uic_mqtt_dotdot_aox_locator_generated_angle_correction_callback = nullptr;
uic_mqtt_dotdot_aox_locator_write_attributes_callback_t uic_mqtt_dotdot_aox_locator_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_aox_locator_force_read_attributes_callback_t uic_mqtt_dotdot_aox_locator_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_aox_locator_iq_report_callback_set(const uic_mqtt_dotdot_aox_locator_iq_report_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_iq_report_callback = callback;
}
void uic_mqtt_dotdot_aox_locator_generated_iq_report_callback_set(const uic_mqtt_dotdot_aox_locator_iq_report_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_generated_iq_report_callback = callback;
}

void uic_mqtt_dotdot_aox_locator_angle_report_callback_set(const uic_mqtt_dotdot_aox_locator_angle_report_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_angle_report_callback = callback;
}
void uic_mqtt_dotdot_aox_locator_generated_angle_report_callback_set(const uic_mqtt_dotdot_aox_locator_angle_report_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_generated_angle_report_callback = callback;
}

void uic_mqtt_dotdot_aox_locator_angle_correction_callback_set(const uic_mqtt_dotdot_aox_locator_angle_correction_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_angle_correction_callback = callback;
}
void uic_mqtt_dotdot_aox_locator_generated_angle_correction_callback_set(const uic_mqtt_dotdot_aox_locator_angle_correction_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_generated_angle_correction_callback = callback;
}


void uic_mqtt_dotdot_set_aox_locator_write_attributes_callback(
  const uic_mqtt_dotdot_aox_locator_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_aox_locator_force_read_attributes_callback(
  const uic_mqtt_dotdot_aox_locator_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/AoXLocator/Commands/IQReport
void uic_mqtt_dotdot_on_aox_locator_iq_report(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_aox_locator_iq_report_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* tag_unid = {};
  uint8_t channel = {};
  int8_t rssi = {};
  std::vector<int8_t> samples;
  int32_t sequence = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_aox_locator_iq_report(
      jsn,
      tag_unid,

      channel,

      rssi,

      samples,

      sequence
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "AoXLocator", "IQReport");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "IQReport", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "IQReport", "");
    return;
  }

  uic_mqtt_dotdot_aox_locator_iq_report_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    tag_unid,

    channel,

    rssi,

    samples.size(),
    samples.data(),

    sequence

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/AoXLocator/GeneratedCommands/IQReport
static void uic_mqtt_dotdot_on_generated_aox_locator_iq_report(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_aox_locator_generated_iq_report_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* tag_unid;
  uint8_t channel;
  int8_t rssi;
  std::vector<int8_t> samples;
  int32_t sequence;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_aox_locator_iq_report(
      jsn,
      tag_unid,

      channel,

      rssi,

      samples,

      sequence
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "AoXLocator", "IQReport");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "IQReport", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "IQReport", "");
    return;
  }

  uic_mqtt_dotdot_aox_locator_generated_iq_report_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    tag_unid,

    channel,

    rssi,

    samples.size(),
    samples.data(),

    sequence

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/AoXLocator/Commands/AngleReport
void uic_mqtt_dotdot_on_aox_locator_angle_report(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_aox_locator_angle_report_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* tag_unid = {};
  SphericalCoordinates direction = {};
  SphericalCoordinates deviation = {};
  int32_t sequence = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_aox_locator_angle_report(
      jsn,
      tag_unid,

      direction,

      deviation,

      sequence
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "AoXLocator", "AngleReport");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "AngleReport", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "AngleReport", "");
    return;
  }

  uic_mqtt_dotdot_aox_locator_angle_report_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    tag_unid,

    direction,

    deviation,

    sequence

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/AoXLocator/GeneratedCommands/AngleReport
static void uic_mqtt_dotdot_on_generated_aox_locator_angle_report(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_aox_locator_generated_angle_report_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* tag_unid;
  SphericalCoordinates direction;
  SphericalCoordinates deviation;
  int32_t sequence;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_aox_locator_angle_report(
      jsn,
      tag_unid,

      direction,

      deviation,

      sequence
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "AoXLocator", "AngleReport");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "AngleReport", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "AngleReport", "");
    return;
  }

  uic_mqtt_dotdot_aox_locator_generated_angle_report_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    tag_unid,

    direction,

    deviation,

    sequence

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/AoXLocator/Commands/AngleCorrection
void uic_mqtt_dotdot_on_aox_locator_angle_correction(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_aox_locator_angle_correction_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* tag_unid = {};
  SphericalCoordinates direction = {};
  SphericalCoordinates deviation = {};
  int32_t sequence = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_aox_locator_angle_correction(
      jsn,
      tag_unid,

      direction,

      deviation,

      sequence
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "AoXLocator", "AngleCorrection");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "AngleCorrection", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "AngleCorrection", "");
    return;
  }

  uic_mqtt_dotdot_aox_locator_angle_correction_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    tag_unid,

    direction,

    deviation,

    sequence

  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/AoXLocator/GeneratedCommands/AngleCorrection
static void uic_mqtt_dotdot_on_generated_aox_locator_angle_correction(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_aox_locator_generated_angle_correction_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  const char* tag_unid;
  SphericalCoordinates direction;
  SphericalCoordinates deviation;
  int32_t sequence;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_aox_locator_angle_correction(
      jsn,
      tag_unid,

      direction,

      deviation,

      sequence
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "AoXLocator", "AngleCorrection");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "AngleCorrection", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "AngleCorrection", "");
    return;
  }

  uic_mqtt_dotdot_aox_locator_generated_angle_correction_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    tag_unid,

    direction,

    deviation,

    sequence

  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/AoXLocator/Commands/WriteAttributes
void uic_mqtt_dotdot_on_aox_locator_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_aox_locator_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_aox_locator_state_t new_state = {};
  uic_mqtt_dotdot_aox_locator_updated_state_t new_updated_state = {};

  std::vector<MinMaxPair> azimuth_mask;

  std::vector<MinMaxPair> elevation_mask;

  std::vector<const char*> allow_list;

  std::vector<int8_t> antenna_array;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_aox_locator_write_attributes(
      jsn,
      new_state,
      new_updated_state,
      azimuth_mask,
      elevation_mask,
      allow_list,
      antenna_array
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "AoXLocator", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_aox_locator_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_aox_locator_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_aox_locator_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_aox_locator_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.reporting_mode = true;
        force_update.position_and_orientation_valid = true;
        force_update.position_and_orientation = true;
        force_update.azimuth_mask = true;
        force_update.elevation_mask = true;
        force_update.allow_list = true;
        force_update.aox_mode = true;
        force_update.antenna_mode = true;
        force_update.antenna_array = true;
        force_update.period_samples = true;
        force_update.angle_filtering = true;
        force_update.angle_filtering_weight = true;
        force_update.angle_correction_timeout = true;
        force_update.angle_correction_delay = true;
        force_update.cte_mode = true;
        force_update.cte_sampling_interval = true;
        force_update.cte_length = true;
        force_update.slot_duration = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"ReportingMode", &force_update.reporting_mode },
          {"PositionAndOrientationValid", &force_update.position_and_orientation_valid },
          {"PositionAndOrientation", &force_update.position_and_orientation },
          {"AzimuthMask", &force_update.azimuth_mask },
          {"ElevationMask", &force_update.elevation_mask },
          {"AllowList", &force_update.allow_list },
          {"AoXMode", &force_update.aox_mode },
          {"AntennaMode", &force_update.antenna_mode },
          {"AntennaArray", &force_update.antenna_array },
          {"PeriodSamples", &force_update.period_samples },
          {"AngleFiltering", &force_update.angle_filtering },
          {"AngleFilteringWeight", &force_update.angle_filtering_weight },
          {"AngleCorrectionTimeout", &force_update.angle_correction_timeout },
          {"AngleCorrectionDelay", &force_update.angle_correction_delay },
          {"CTEMode", &force_update.cte_mode },
          {"CTESamplingInterval", &force_update.cte_sampling_interval },
          {"CTELength", &force_update.cte_length },
          {"SlotDuration", &force_update.slot_duration },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_aox_locator_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "AoXLocator/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_aox_locator_reporting_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef AOX_LOCATOR_REPORTING_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = aox_locator_reporting_mode_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<AoXLocatorReportingMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/ReportingMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/ReportingMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_aox_locator_position_and_orientation_valid_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/PositionAndOrientationValid", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/PositionAndOrientationValid";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_aox_locator_position_and_orientation_publish(
  const char *base_topic,
  CoordinateAndOrientation value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json json_object = nlohmann::json::object();
   json_object["CoordinateX"] = value.CoordinateX;
   json_object["CoordinateY"] = value.CoordinateY;
   json_object["CoordinateZ"] = value.CoordinateZ;
   json_object["OrientationX"] = value.OrientationX;
   json_object["OrientationY"] = value.OrientationY;
   json_object["OrientationZ"] = value.OrientationZ;
  jsn["value"]= json_object;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/PositionAndOrientation", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/PositionAndOrientation";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_aox_locator_azimuth_mask_publish(
  const char *base_topic,
  size_t value_count,
  const MinMaxPair* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // Struct type
    nlohmann::json json_object = nlohmann::json::object();
    json_object["Min"] = value[i].Min;
    json_object["Max"] = value[i].Max;
    jsn["value"].push_back(json_object);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/AzimuthMask", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/AzimuthMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_aox_locator_elevation_mask_publish(
  const char *base_topic,
  size_t value_count,
  const MinMaxPair* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // Struct type
    nlohmann::json json_object = nlohmann::json::object();
    json_object["Min"] = value[i].Min;
    json_object["Max"] = value[i].Max;
    jsn["value"].push_back(json_object);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/ElevationMask", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/ElevationMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_aox_locator_allow_list_publish(
  const char *base_topic,
  size_t value_count,
  const char** value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // String type
    jsn["value"].push_back(std::string(value[i]));
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/AllowList", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/AllowList";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_aox_locator_aox_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef AOX_LOCATOR_AOX_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = aox_locator_aox_mode_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<AoXLocatorAoXMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/AoXMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/AoXMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_aox_locator_antenna_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef AOX_LOCATOR_ANTENNA_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = aox_locator_antenna_mode_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<AoXLocatorAntennaMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/AntennaMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/AntennaMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_aox_locator_antenna_array_publish(
  const char *base_topic,
  size_t value_count,
  const int8_t* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    jsn["value"].push_back(value[i]);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/AntennaArray", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/AntennaArray";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_aox_locator_period_samples_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/PeriodSamples", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/PeriodSamples";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_aox_locator_angle_filtering_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/AngleFiltering", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/AngleFiltering";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_aox_locator_angle_filtering_weight_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/AngleFilteringWeight", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/AngleFilteringWeight";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_aox_locator_angle_correction_timeout_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/AngleCorrectionTimeout", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/AngleCorrectionTimeout";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_aox_locator_angle_correction_delay_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/AngleCorrectionDelay", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/AngleCorrectionDelay";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_aox_locator_cte_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef AOX_LOCATOR_CTE_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = aox_locator_cte_mode_get_enum_value_name((uint32_t)value);
  #else
  jsn["value"] = static_cast<AoXLocatorCTEMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/CTEMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/CTEMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_aox_locator_cte_sampling_interval_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/CTESamplingInterval", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/CTESamplingInterval";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_aox_locator_cte_length_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/CTELength", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/CTELength";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}
sl_status_t uic_mqtt_dotdot_aox_locator_slot_duration_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = value;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/SlotDuration", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/SlotDuration";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_aox_locator_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_aox_locator_write_attributes_callback) {
    subscription_topic = base_topic + "AoXLocator/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_aox_locator_WriteAttributes);
  }

  if(uic_mqtt_dotdot_aox_locator_force_read_attributes_callback) {
    subscription_topic = base_topic + "AoXLocator/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_aox_locator_force_read_attributes);
  }
  if (uic_mqtt_dotdot_aox_locator_iq_report_callback) {
    subscription_topic = base_topic + "AoXLocator/Commands/IQReport";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_aox_locator_iq_report);
  }
  if (uic_mqtt_dotdot_aox_locator_generated_iq_report_callback) {
    subscription_topic = base_topic + "AoXLocator/GeneratedCommands/IQReport";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_aox_locator_iq_report);
  }
  if (uic_mqtt_dotdot_aox_locator_angle_report_callback) {
    subscription_topic = base_topic + "AoXLocator/Commands/AngleReport";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_aox_locator_angle_report);
  }
  if (uic_mqtt_dotdot_aox_locator_generated_angle_report_callback) {
    subscription_topic = base_topic + "AoXLocator/GeneratedCommands/AngleReport";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_aox_locator_angle_report);
  }
  if (uic_mqtt_dotdot_aox_locator_angle_correction_callback) {
    subscription_topic = base_topic + "AoXLocator/Commands/AngleCorrection";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_aox_locator_angle_correction);
  }
  if (uic_mqtt_dotdot_aox_locator_generated_angle_correction_callback) {
    subscription_topic = base_topic + "AoXLocator/GeneratedCommands/AngleCorrection";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_aox_locator_angle_correction);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_aox_locator_attributes_init();

  uic_mqtt_dotdot_by_group_aox_locator_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback_t uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_aox_position_estimation_force_read_attributes_callback_t uic_mqtt_dotdot_aox_position_estimation_force_read_attributes_callback = nullptr;

// Callbacks setters

void uic_mqtt_dotdot_set_aox_position_estimation_write_attributes_callback(
  const uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_aox_position_estimation_force_read_attributes_callback(
  const uic_mqtt_dotdot_aox_position_estimation_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_aox_position_estimation_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/AoXPositionEstimation/Commands/WriteAttributes
void uic_mqtt_dotdot_on_aox_position_estimation_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_aox_position_estimation_state_t new_state = {};
  uic_mqtt_dotdot_aox_position_estimation_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_aox_position_estimation_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "AoXPositionEstimation", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXPositionEstimation", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXPositionEstimation", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_aox_position_estimation_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_aox_position_estimation_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_aox_position_estimation_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.position = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"Position", &force_update.position },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_aox_position_estimation_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "AoXPositionEstimation/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_aox_position_estimation_position_publish(
  const char *base_topic,
  EstimatedPosition value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json json_object = nlohmann::json::object();
   json_object["ApplicationId"] = value.ApplicationId;
   json_object["X"] = value.X;
   json_object["Y"] = value.Y;
   json_object["Z"] = value.Z;
   json_object["DeviationX"] = value.DeviationX;
   json_object["DeviationY"] = value.DeviationY;
   json_object["DeviationZ"] = value.DeviationZ;
   json_object["Sequence"] = value.Sequence;
  jsn["value"]= json_object;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXPositionEstimation/Attributes/Position", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXPositionEstimation/Attributes/Position";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_aox_position_estimation_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback) {
    subscription_topic = base_topic + "AoXPositionEstimation/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_aox_position_estimation_WriteAttributes);
  }

  if(uic_mqtt_dotdot_aox_position_estimation_force_read_attributes_callback) {
    subscription_topic = base_topic + "AoXPositionEstimation/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_aox_position_estimation_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_aox_position_estimation_attributes_init();

  uic_mqtt_dotdot_by_group_aox_position_estimation_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
uic_mqtt_dotdot_protocol_controller_network_management_write_callback_t uic_mqtt_dotdot_protocol_controller_network_management_write_callback = nullptr;
static uic_mqtt_dotdot_protocol_controller_network_management_write_callback_t uic_mqtt_dotdot_protocol_controller_network_management_generated_write_callback = nullptr;
uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_callback_t uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_callback = nullptr;
static uic_mqtt_dotdot_protocol_controller_network_management_force_read_attributes_callback_t uic_mqtt_dotdot_protocol_controller_network_management_force_read_attributes_callback = nullptr;

// Callbacks setters
void uic_mqtt_dotdot_protocol_controller_network_management_write_callback_set(const uic_mqtt_dotdot_protocol_controller_network_management_write_callback_t callback)
{
  uic_mqtt_dotdot_protocol_controller_network_management_write_callback = callback;
}
void uic_mqtt_dotdot_protocol_controller_network_management_generated_write_callback_set(const uic_mqtt_dotdot_protocol_controller_network_management_write_callback_t callback)
{
  uic_mqtt_dotdot_protocol_controller_network_management_generated_write_callback = callback;
}


void uic_mqtt_dotdot_set_protocol_controller_network_management_write_attributes_callback(
  const uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_callback = callback;
}

void uic_mqtt_dotdot_set_protocol_controller_network_management_force_read_attributes_callback(
  const uic_mqtt_dotdot_protocol_controller_network_management_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_protocol_controller_network_management_force_read_attributes_callback = callback;
}


// Callback function for incoming publications on ucl/by-unid/+/+/ProtocolController-NetworkManagement/Commands/Write
void uic_mqtt_dotdot_on_protocol_controller_network_management_write(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_protocol_controller_network_management_write_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ProtocolController-NetworkManagement", "Write");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-NetworkManagement", "Write", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-NetworkManagement", "Write", "");
    return;
  }

  uic_mqtt_dotdot_protocol_controller_network_management_write_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}

// Callback function for incoming publications on ucl/by-unid/+/+/ProtocolController-NetworkManagement/GeneratedCommands/Write
static void uic_mqtt_dotdot_on_generated_protocol_controller_network_management_write(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_protocol_controller_network_management_generated_write_callback == nullptr)) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ProtocolController-NetworkManagement", "Write");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-NetworkManagement", "Write", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-NetworkManagement", "Write", "");
    return;
  }

  uic_mqtt_dotdot_protocol_controller_network_management_generated_write_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
  );

}


// Callback function for incoming publications on ucl/by-unid/+/+/ProtocolController-NetworkManagement/Commands/WriteAttributes
void uic_mqtt_dotdot_on_protocol_controller_network_management_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_callback == nullptr) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_protocol_controller_network_management_state_t new_state = {};
  uic_mqtt_dotdot_protocol_controller_network_management_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_protocol_controller_network_management_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ProtocolController-NetworkManagement", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-NetworkManagement", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-NetworkManagement", "WriteAttributes", "");
    return;
  }

  uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_callback(
    static_cast<dotdot_unid_t>(unid.c_str()),
    endpoint,
    UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
    new_state,
    new_updated_state
  );

}

static void uic_mqtt_dotdot_on_protocol_controller_network_management_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if (message_length == 0) {
    return;
  } else if ( uic_mqtt_dotdot_protocol_controller_network_management_force_read_attributes_callback ) {

    if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
      sl_log_debug(LOG_TAG,
                  "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                  topic);
      return;
    }

    try {
      uic_mqtt_dotdot_protocol_controller_network_management_updated_state_t force_update = {0};
      bool trigger_handler = false;

      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
      std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

      // Assume all attributes to be read on empty array received
      if (attributes.size() == 0) {
        force_update.network_management_state = true;
        trigger_handler = true;
      } else {
        std::unordered_map<std::string, bool *> supported_attrs = {
          {"NetworkManagementState", &force_update.network_management_state },
        };

        for (auto& attribute : attributes) {
          auto found_attr = supported_attrs.find(attribute);
          if (found_attr != supported_attrs.end()) {
            *(found_attr->second) = true;
            trigger_handler = true;
          }
        }
      }

      if (trigger_handler == true) {
        uic_mqtt_dotdot_protocol_controller_network_management_force_read_attributes_callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    } catch (...) {
      sl_log_debug(LOG_TAG, "ProtocolController-NetworkManagement/Commands/ForceReadAttributes: Unable to parse JSON payload");
      return;
    }
  }
}

sl_status_t uic_mqtt_dotdot_protocol_controller_network_management_network_management_state_publish(
  const char *base_topic,
  NetworkManagementState value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json json_object = nlohmann::json::object();
   json_object["State"] = value.State;
   json_object["SupportedStateList"] = value.SupportedStateList;
   json_object["StateParameters"] = value.StateParameters;
   json_object["RequestedStateParameters"] = value.RequestedStateParameters;
  jsn["value"]= json_object;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController/NetworkManagement/Attributes/NetworkManagementState", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ProtocolController/NetworkManagement/Attributes/NetworkManagementState";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_protocol_controller_network_management_init()
{
  std::string base_topic = "ucl/by-unid/+/";

  std::string subscription_topic;
  if(uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_callback) {
    subscription_topic = base_topic + "ProtocolController/NetworkManagement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_protocol_controller_network_management_WriteAttributes);
  }

  if(uic_mqtt_dotdot_protocol_controller_network_management_force_read_attributes_callback) {
    subscription_topic = base_topic + "ProtocolController/NetworkManagement/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_protocol_controller_network_management_force_read_attributes);
  }
  if (uic_mqtt_dotdot_protocol_controller_network_management_write_callback) {
    subscription_topic = base_topic + "ProtocolController/NetworkManagement/Commands/Write";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_protocol_controller_network_management_write);
  }
  if (uic_mqtt_dotdot_protocol_controller_network_management_generated_write_callback) {
    subscription_topic = base_topic + "ProtocolController/NetworkManagement/GeneratedCommands/Write";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_protocol_controller_network_management_write);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_protocol_controller_network_management_attributes_init();


  return SL_STATUS_OK;
}


sl_status_t uic_mqtt_dotdot_init() {

  sl_status_t status_flag = SL_STATUS_OK;

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_basic_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_power_configuration_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_device_temperature_configuration_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_identify_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_groups_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_scenes_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_on_off_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_level_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_alarms_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_time_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_ota_upgrade_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_poll_control_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_shade_configuration_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_door_lock_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_window_covering_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_barrier_control_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_pump_configuration_and_control_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_thermostat_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_fan_control_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_dehumidification_control_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_thermostat_user_interface_configuration_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_color_control_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_ballast_configuration_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_illuminance_measurement_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_illuminance_level_sensing_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_temperature_measurement_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_pressure_measurement_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_flow_measurement_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_relativity_humidity_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_occupancy_sensing_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_ph_measurement_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_electrical_conductivity_measurement_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_wind_speed_measurement_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_carbon_monoxide_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_ias_zone_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_iaswd_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_metering_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_electrical_measurement_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_diagnostics_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_protocol_controller_rf_telemetry_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_state_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_binding_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_system_metrics_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_application_monitoring_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_name_and_location_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_configuration_parameters_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_aox_locator_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_aox_position_estimation_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_protocol_controller_network_management_init();
  }


  return status_flag;
}

// Publish all supported dotdot cluster commands per each endpoints.
// Here is the steps what this API does:
// - For each dotdot cluster
// - -  For each dotdot cluster command
// - - - Invoke the callback to ask if that particular unid/ep supports the command
// - - - - add or not the command in supported command list based on the return value of the command handler callback
// - - - end
// - - - publish the list of supported commands
//- - end
//-  end
void uic_mqtt_dotdot_publish_supported_commands(
  dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint)
{
  std::stringstream ss;
  bool first_command;
  // Basic cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback) {


      if ( uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ResetToFactoryDefaults")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_basic_write_attributes_callback) {
      uic_mqtt_dotdot_basic_state_t basic_new_state = {};
      uic_mqtt_dotdot_basic_updated_state_t basic_new_updated_state = {};

      if(uic_mqtt_dotdot_basic_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            basic_new_state,
            basic_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_basic_force_read_attributes_callback) {
      uic_mqtt_dotdot_basic_updated_state_t basic_force_update = {0};

      if(uic_mqtt_dotdot_basic_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            basic_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/Basic/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/Basic/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // PowerConfiguration cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_power_configuration_write_attributes_callback) {
      uic_mqtt_dotdot_power_configuration_state_t power_configuration_new_state = {};
      uic_mqtt_dotdot_power_configuration_updated_state_t power_configuration_new_updated_state = {};

      if(uic_mqtt_dotdot_power_configuration_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            power_configuration_new_state,
            power_configuration_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_power_configuration_force_read_attributes_callback) {
      uic_mqtt_dotdot_power_configuration_updated_state_t power_configuration_force_update = {0};

      if(uic_mqtt_dotdot_power_configuration_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            power_configuration_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/PowerConfiguration/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/PowerConfiguration/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // DeviceTemperatureConfiguration cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback) {
      uic_mqtt_dotdot_device_temperature_configuration_state_t device_temperature_configuration_new_state = {};
      uic_mqtt_dotdot_device_temperature_configuration_updated_state_t device_temperature_configuration_new_updated_state = {};

      if(uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            device_temperature_configuration_new_state,
            device_temperature_configuration_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_callback) {
      uic_mqtt_dotdot_device_temperature_configuration_updated_state_t device_temperature_configuration_force_update = {0};

      if(uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            device_temperature_configuration_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/DeviceTemperatureConfiguration/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/DeviceTemperatureConfiguration/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // Identify cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_identify_identify_callback) {
        uint16_t identify_time_value;
        memset(&identify_time_value, 0x00, sizeof(identify_time_value));
      

      if ( uic_mqtt_dotdot_identify_identify_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              identify_time_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("Identify")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_identify_identify_query_response_callback) {
        uint16_t timeout_value;
        memset(&timeout_value, 0x00, sizeof(timeout_value));
      

      if ( uic_mqtt_dotdot_identify_identify_query_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              timeout_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("IdentifyQueryResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_identify_identify_query_callback) {


      if ( uic_mqtt_dotdot_identify_identify_query_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("IdentifyQuery")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_identify_trigger_effect_callback) {
        TriggerEffectEffectIdentifier effect_identifier_value;
        memset(&effect_identifier_value, 0x00, sizeof(effect_identifier_value));
              TriggerEffectEffectVariant effect_variant_value;
        memset(&effect_variant_value, 0x00, sizeof(effect_variant_value));
      

      if ( uic_mqtt_dotdot_identify_trigger_effect_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              effect_identifier_value,

              effect_variant_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("TriggerEffect")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_identify_write_attributes_callback) {
      uic_mqtt_dotdot_identify_state_t identify_new_state = {};
      uic_mqtt_dotdot_identify_updated_state_t identify_new_updated_state = {};

      if(uic_mqtt_dotdot_identify_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            identify_new_state,
            identify_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_identify_force_read_attributes_callback) {
      uic_mqtt_dotdot_identify_updated_state_t identify_force_update = {0};

      if(uic_mqtt_dotdot_identify_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            identify_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/Identify/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/Identify/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // Groups cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_groups_add_group_callback) {
        uint16_t group_id_value;
        memset(&group_id_value, 0x00, sizeof(group_id_value));
              const char* group_name_value;
        memset(&group_name_value, 0x00, sizeof(group_name_value));
      

      if ( uic_mqtt_dotdot_groups_add_group_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              group_id_value,

              group_name_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("AddGroup")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_groups_add_group_response_callback) {
        uint8_t status_value;
        memset(&status_value, 0x00, sizeof(status_value));
              uint16_t group_id_value;
        memset(&group_id_value, 0x00, sizeof(group_id_value));
      

      if ( uic_mqtt_dotdot_groups_add_group_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value,

              group_id_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("AddGroupResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_groups_view_group_callback) {
        uint16_t group_id_value;
        memset(&group_id_value, 0x00, sizeof(group_id_value));
      

      if ( uic_mqtt_dotdot_groups_view_group_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              group_id_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ViewGroup")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_groups_view_group_response_callback) {
        uint8_t status_value;
        memset(&status_value, 0x00, sizeof(status_value));
              uint16_t group_id_value;
        memset(&group_id_value, 0x00, sizeof(group_id_value));
              const char* group_name_value;
        memset(&group_name_value, 0x00, sizeof(group_name_value));
      

      if ( uic_mqtt_dotdot_groups_view_group_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value,

              group_id_value,

              group_name_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ViewGroupResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_groups_get_group_membership_callback) {


      if ( uic_mqtt_dotdot_groups_get_group_membership_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              0,
              nullptr

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetGroupMembership")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_groups_get_group_membership_response_callback) {
        uint8_t capacity_value;
        memset(&capacity_value, 0x00, sizeof(capacity_value));
      

      if ( uic_mqtt_dotdot_groups_get_group_membership_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              capacity_value,

              0,
              nullptr

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetGroupMembershipResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_groups_remove_group_callback) {
        uint16_t group_id_value;
        memset(&group_id_value, 0x00, sizeof(group_id_value));
      

      if ( uic_mqtt_dotdot_groups_remove_group_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              group_id_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("RemoveGroup")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_groups_remove_group_response_callback) {
        uint8_t status_value;
        memset(&status_value, 0x00, sizeof(status_value));
              uint16_t group_id_value;
        memset(&group_id_value, 0x00, sizeof(group_id_value));
      

      if ( uic_mqtt_dotdot_groups_remove_group_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value,

              group_id_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("RemoveGroupResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_groups_remove_all_groups_callback) {


      if ( uic_mqtt_dotdot_groups_remove_all_groups_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("RemoveAllGroups")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_groups_add_group_if_identifying_callback) {
        uint16_t group_id_value;
        memset(&group_id_value, 0x00, sizeof(group_id_value));
              const char* group_name_value;
        memset(&group_name_value, 0x00, sizeof(group_name_value));
      

      if ( uic_mqtt_dotdot_groups_add_group_if_identifying_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              group_id_value,

              group_name_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("AddGroupIfIdentifying")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_groups_write_attributes_callback) {
      uic_mqtt_dotdot_groups_state_t groups_new_state = {};
      uic_mqtt_dotdot_groups_updated_state_t groups_new_updated_state = {};

      if(uic_mqtt_dotdot_groups_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            groups_new_state,
            groups_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_groups_force_read_attributes_callback) {
      uic_mqtt_dotdot_groups_updated_state_t groups_force_update = {0};

      if(uic_mqtt_dotdot_groups_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            groups_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/Groups/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/Groups/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // Scenes cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_scenes_add_scene_callback) {
        SGroupId groupid_value;
        memset(&groupid_value, 0x00, sizeof(groupid_value));
              uint8_t sceneid_value;
        memset(&sceneid_value, 0x00, sizeof(sceneid_value));
              uint16_t transition_time_value;
        memset(&transition_time_value, 0x00, sizeof(transition_time_value));
              SSceneName scene_name_value;
        memset(&scene_name_value, 0x00, sizeof(scene_name_value));
      

      if ( uic_mqtt_dotdot_scenes_add_scene_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              groupid_value,

              sceneid_value,

              transition_time_value,

              scene_name_value,

              0,
              nullptr

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("AddScene")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_scenes_add_scene_response_callback) {
        zclStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
              SGroupId groupid_value;
        memset(&groupid_value, 0x00, sizeof(groupid_value));
              uint8_t sceneid_value;
        memset(&sceneid_value, 0x00, sizeof(sceneid_value));
      

      if ( uic_mqtt_dotdot_scenes_add_scene_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value,

              groupid_value,

              sceneid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("AddSceneResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_scenes_view_scene_callback) {
        SGroupId groupid_value;
        memset(&groupid_value, 0x00, sizeof(groupid_value));
              uint8_t sceneid_value;
        memset(&sceneid_value, 0x00, sizeof(sceneid_value));
      

      if ( uic_mqtt_dotdot_scenes_view_scene_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              groupid_value,

              sceneid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ViewScene")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_scenes_view_scene_response_callback) {
        zclStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
              SGroupId groupid_value;
        memset(&groupid_value, 0x00, sizeof(groupid_value));
              uint8_t sceneid_value;
        memset(&sceneid_value, 0x00, sizeof(sceneid_value));
              uint16_t transition_time_value;
        memset(&transition_time_value, 0x00, sizeof(transition_time_value));
              SSceneName scene_name_value;
        memset(&scene_name_value, 0x00, sizeof(scene_name_value));
      

      if ( uic_mqtt_dotdot_scenes_view_scene_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value,

              groupid_value,

              sceneid_value,

              transition_time_value,

              scene_name_value,

              0,
              nullptr

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ViewSceneResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_scenes_remove_scene_callback) {
        SGroupId groupid_value;
        memset(&groupid_value, 0x00, sizeof(groupid_value));
              uint8_t sceneid_value;
        memset(&sceneid_value, 0x00, sizeof(sceneid_value));
      

      if ( uic_mqtt_dotdot_scenes_remove_scene_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              groupid_value,

              sceneid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("RemoveScene")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_scenes_remove_scene_response_callback) {
        zclStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
              SGroupId groupid_value;
        memset(&groupid_value, 0x00, sizeof(groupid_value));
              uint8_t sceneid_value;
        memset(&sceneid_value, 0x00, sizeof(sceneid_value));
      

      if ( uic_mqtt_dotdot_scenes_remove_scene_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value,

              groupid_value,

              sceneid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("RemoveSceneResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_scenes_remove_all_scenes_callback) {
        SGroupId groupid_value;
        memset(&groupid_value, 0x00, sizeof(groupid_value));
      

      if ( uic_mqtt_dotdot_scenes_remove_all_scenes_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              groupid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("RemoveAllScenes")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback) {
        zclStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
              SGroupId groupid_value;
        memset(&groupid_value, 0x00, sizeof(groupid_value));
      

      if ( uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value,

              groupid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("RemoveAllScenesResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_scenes_store_scene_callback) {
        SGroupId groupid_value;
        memset(&groupid_value, 0x00, sizeof(groupid_value));
              uint8_t sceneid_value;
        memset(&sceneid_value, 0x00, sizeof(sceneid_value));
      

      if ( uic_mqtt_dotdot_scenes_store_scene_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              groupid_value,

              sceneid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("StoreScene")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_scenes_store_scene_response_callback) {
        zclStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
              SGroupId groupid_value;
        memset(&groupid_value, 0x00, sizeof(groupid_value));
              uint8_t sceneid_value;
        memset(&sceneid_value, 0x00, sizeof(sceneid_value));
      

      if ( uic_mqtt_dotdot_scenes_store_scene_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value,

              groupid_value,

              sceneid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("StoreSceneResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_scenes_recall_scene_callback) {
        SGroupId groupid_value;
        memset(&groupid_value, 0x00, sizeof(groupid_value));
              uint8_t sceneid_value;
        memset(&sceneid_value, 0x00, sizeof(sceneid_value));
              uint16_t transition_time_value;
        memset(&transition_time_value, 0x00, sizeof(transition_time_value));
      

      if ( uic_mqtt_dotdot_scenes_recall_scene_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              groupid_value,

              sceneid_value,

              transition_time_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("RecallScene")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_scenes_get_scene_membership_callback) {
        SGroupId groupid_value;
        memset(&groupid_value, 0x00, sizeof(groupid_value));
      

      if ( uic_mqtt_dotdot_scenes_get_scene_membership_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              groupid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetSceneMembership")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_scenes_get_scene_membership_response_callback) {
        zclStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
              uint8_t capacity_value;
        memset(&capacity_value, 0x00, sizeof(capacity_value));
              SGroupId groupid_value;
        memset(&groupid_value, 0x00, sizeof(groupid_value));
      

      if ( uic_mqtt_dotdot_scenes_get_scene_membership_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value,

              capacity_value,

              groupid_value,

              0,
              nullptr

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetSceneMembershipResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_scenes_enhanced_add_scene_callback) {
        SGroupId groupid_value;
        memset(&groupid_value, 0x00, sizeof(groupid_value));
              uint8_t sceneid_value;
        memset(&sceneid_value, 0x00, sizeof(sceneid_value));
              uint16_t transition_time_value;
        memset(&transition_time_value, 0x00, sizeof(transition_time_value));
              SSceneName scene_name_value;
        memset(&scene_name_value, 0x00, sizeof(scene_name_value));
      

      if ( uic_mqtt_dotdot_scenes_enhanced_add_scene_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              groupid_value,

              sceneid_value,

              transition_time_value,

              scene_name_value,

              0,
              nullptr

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("EnhancedAddScene")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback) {
        zclStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
              SGroupId groupid_value;
        memset(&groupid_value, 0x00, sizeof(groupid_value));
              uint8_t sceneid_value;
        memset(&sceneid_value, 0x00, sizeof(sceneid_value));
      

      if ( uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value,

              groupid_value,

              sceneid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("EnhancedAddSceneResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_scenes_enhanced_view_scene_callback) {
        SGroupId groupid_value;
        memset(&groupid_value, 0x00, sizeof(groupid_value));
              uint8_t sceneid_value;
        memset(&sceneid_value, 0x00, sizeof(sceneid_value));
      

      if ( uic_mqtt_dotdot_scenes_enhanced_view_scene_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              groupid_value,

              sceneid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("EnhancedViewScene")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback) {
        zclStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
              SGroupId groupid_value;
        memset(&groupid_value, 0x00, sizeof(groupid_value));
              uint8_t sceneid_value;
        memset(&sceneid_value, 0x00, sizeof(sceneid_value));
              uint16_t transition_time_value;
        memset(&transition_time_value, 0x00, sizeof(transition_time_value));
              SSceneName scene_name_value;
        memset(&scene_name_value, 0x00, sizeof(scene_name_value));
      

      if ( uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value,

              groupid_value,

              sceneid_value,

              transition_time_value,

              scene_name_value,

              0,
              nullptr

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("EnhancedViewSceneResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_scenes_copy_scene_callback) {
        uint8_t mode_value;
        memset(&mode_value, 0x00, sizeof(mode_value));
              SGroupId group_identifier_from_value;
        memset(&group_identifier_from_value, 0x00, sizeof(group_identifier_from_value));
              uint8_t scene_identifier_from_value;
        memset(&scene_identifier_from_value, 0x00, sizeof(scene_identifier_from_value));
              SGroupId group_identifier_to_value;
        memset(&group_identifier_to_value, 0x00, sizeof(group_identifier_to_value));
              uint8_t scene_identifier_to_value;
        memset(&scene_identifier_to_value, 0x00, sizeof(scene_identifier_to_value));
      

      if ( uic_mqtt_dotdot_scenes_copy_scene_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              mode_value,

              group_identifier_from_value,

              scene_identifier_from_value,

              group_identifier_to_value,

              scene_identifier_to_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("CopyScene")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_scenes_copy_scene_response_callback) {
        zclStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
              SGroupId group_identifier_from_value;
        memset(&group_identifier_from_value, 0x00, sizeof(group_identifier_from_value));
              uint8_t scene_identifier_from_value;
        memset(&scene_identifier_from_value, 0x00, sizeof(scene_identifier_from_value));
      

      if ( uic_mqtt_dotdot_scenes_copy_scene_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value,

              group_identifier_from_value,

              scene_identifier_from_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("CopySceneResponse")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_scenes_write_attributes_callback) {
      uic_mqtt_dotdot_scenes_state_t scenes_new_state = {};
      uic_mqtt_dotdot_scenes_updated_state_t scenes_new_updated_state = {};

      if(uic_mqtt_dotdot_scenes_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            scenes_new_state,
            scenes_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_scenes_force_read_attributes_callback) {
      uic_mqtt_dotdot_scenes_updated_state_t scenes_force_update = {0};

      if(uic_mqtt_dotdot_scenes_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            scenes_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/Scenes/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/Scenes/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // OnOff cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_on_off_off_callback) {


      if ( uic_mqtt_dotdot_on_off_off_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("Off")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_on_off_on_callback) {


      if ( uic_mqtt_dotdot_on_off_on_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("On")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_on_off_toggle_callback) {


      if ( uic_mqtt_dotdot_on_off_toggle_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("Toggle")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_on_off_off_with_effect_callback) {
        OffWithEffectEffectIdentifier effect_identifier_value;
        memset(&effect_identifier_value, 0x00, sizeof(effect_identifier_value));
              uint8_t effect_variant_value;
        memset(&effect_variant_value, 0x00, sizeof(effect_variant_value));
      

      if ( uic_mqtt_dotdot_on_off_off_with_effect_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              effect_identifier_value,

              effect_variant_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("OffWithEffect")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback) {


      if ( uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("OnWithRecallGlobalScene")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_on_off_on_with_timed_off_callback) {
        uint8_t on_off_control_value;
        memset(&on_off_control_value, 0x00, sizeof(on_off_control_value));
              uint16_t on_time_value;
        memset(&on_time_value, 0x00, sizeof(on_time_value));
              uint16_t off_wait_time_value;
        memset(&off_wait_time_value, 0x00, sizeof(off_wait_time_value));
      

      if ( uic_mqtt_dotdot_on_off_on_with_timed_off_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              on_off_control_value,

              on_time_value,

              off_wait_time_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("OnWithTimedOff")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_on_off_write_attributes_callback) {
      uic_mqtt_dotdot_on_off_state_t on_off_new_state = {};
      uic_mqtt_dotdot_on_off_updated_state_t on_off_new_updated_state = {};

      if(uic_mqtt_dotdot_on_off_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            on_off_new_state,
            on_off_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_on_off_force_read_attributes_callback) {
      uic_mqtt_dotdot_on_off_updated_state_t on_off_force_update = {0};

      if(uic_mqtt_dotdot_on_off_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            on_off_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/OnOff/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/OnOff/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // Level cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_level_move_to_level_callback) {
        uint8_t level_value;
        memset(&level_value, 0x00, sizeof(level_value));
              uint16_t transition_time_value;
        memset(&transition_time_value, 0x00, sizeof(transition_time_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_level_move_to_level_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              level_value,

              transition_time_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("MoveToLevel")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_level_move_callback) {
        MoveStepMode move_mode_value;
        memset(&move_mode_value, 0x00, sizeof(move_mode_value));
              uint8_t rate_value;
        memset(&rate_value, 0x00, sizeof(rate_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_level_move_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              move_mode_value,

              rate_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("Move")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_level_step_callback) {
        MoveStepMode step_mode_value;
        memset(&step_mode_value, 0x00, sizeof(step_mode_value));
              uint8_t step_size_value;
        memset(&step_size_value, 0x00, sizeof(step_size_value));
              uint16_t transition_time_value;
        memset(&transition_time_value, 0x00, sizeof(transition_time_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_level_step_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              step_mode_value,

              step_size_value,

              transition_time_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("Step")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_level_stop_callback) {
        uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_level_stop_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("Stop")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_level_move_to_level_with_on_off_callback) {
        uint8_t level_value;
        memset(&level_value, 0x00, sizeof(level_value));
              uint16_t transition_time_value;
        memset(&transition_time_value, 0x00, sizeof(transition_time_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_level_move_to_level_with_on_off_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              level_value,

              transition_time_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("MoveToLevelWithOnOff")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_level_move_with_on_off_callback) {
        MoveStepMode move_mode_value;
        memset(&move_mode_value, 0x00, sizeof(move_mode_value));
              uint8_t rate_value;
        memset(&rate_value, 0x00, sizeof(rate_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_level_move_with_on_off_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              move_mode_value,

              rate_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("MoveWithOnOff")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_level_step_with_on_off_callback) {
        MoveStepMode step_mode_value;
        memset(&step_mode_value, 0x00, sizeof(step_mode_value));
              uint8_t step_size_value;
        memset(&step_size_value, 0x00, sizeof(step_size_value));
              uint16_t transition_time_value;
        memset(&transition_time_value, 0x00, sizeof(transition_time_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_level_step_with_on_off_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              step_mode_value,

              step_size_value,

              transition_time_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("StepWithOnOff")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_level_stop_with_on_off_callback) {
        uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_level_stop_with_on_off_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("StopWithOnOff")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_level_move_to_closest_frequency_callback) {
        uint16_t frequency_value;
        memset(&frequency_value, 0x00, sizeof(frequency_value));
      

      if ( uic_mqtt_dotdot_level_move_to_closest_frequency_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              frequency_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("MoveToClosestFrequency")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_level_write_attributes_callback) {
      uic_mqtt_dotdot_level_state_t level_new_state = {};
      uic_mqtt_dotdot_level_updated_state_t level_new_updated_state = {};

      if(uic_mqtt_dotdot_level_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            level_new_state,
            level_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_level_force_read_attributes_callback) {
      uic_mqtt_dotdot_level_updated_state_t level_force_update = {0};

      if(uic_mqtt_dotdot_level_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            level_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/Level/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/Level/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // Alarms cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_alarms_reset_alarm_callback) {
        uint8_t alarm_code_value;
        memset(&alarm_code_value, 0x00, sizeof(alarm_code_value));
              clusterId cluster_identifier_value;
        memset(&cluster_identifier_value, 0x00, sizeof(cluster_identifier_value));
      

      if ( uic_mqtt_dotdot_alarms_reset_alarm_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              alarm_code_value,

              cluster_identifier_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ResetAlarm")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_alarms_alarm_callback) {
        uint8_t alarm_code_value;
        memset(&alarm_code_value, 0x00, sizeof(alarm_code_value));
              clusterId cluster_identifier_value;
        memset(&cluster_identifier_value, 0x00, sizeof(cluster_identifier_value));
      

      if ( uic_mqtt_dotdot_alarms_alarm_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              alarm_code_value,

              cluster_identifier_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("Alarm")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_alarms_reset_all_alarms_callback) {


      if ( uic_mqtt_dotdot_alarms_reset_all_alarms_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ResetAllAlarms")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_alarms_get_alarm_response_callback) {
        zclStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
              uint8_t alarm_code_value;
        memset(&alarm_code_value, 0x00, sizeof(alarm_code_value));
              clusterId cluster_identifier_value;
        memset(&cluster_identifier_value, 0x00, sizeof(cluster_identifier_value));
              uint32_t time_stamp_value;
        memset(&time_stamp_value, 0x00, sizeof(time_stamp_value));
      

      if ( uic_mqtt_dotdot_alarms_get_alarm_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value,

              alarm_code_value,

              cluster_identifier_value,

              time_stamp_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetAlarmResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_alarms_get_alarm_callback) {


      if ( uic_mqtt_dotdot_alarms_get_alarm_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetAlarm")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_alarms_reset_alarm_log_callback) {


      if ( uic_mqtt_dotdot_alarms_reset_alarm_log_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ResetAlarmLog")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_alarms_write_attributes_callback) {
      uic_mqtt_dotdot_alarms_state_t alarms_new_state = {};
      uic_mqtt_dotdot_alarms_updated_state_t alarms_new_updated_state = {};

      if(uic_mqtt_dotdot_alarms_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            alarms_new_state,
            alarms_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_alarms_force_read_attributes_callback) {
      uic_mqtt_dotdot_alarms_updated_state_t alarms_force_update = {0};

      if(uic_mqtt_dotdot_alarms_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            alarms_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/Alarms/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/Alarms/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // Time cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_time_write_attributes_callback) {
      uic_mqtt_dotdot_time_state_t time_new_state = {};
      uic_mqtt_dotdot_time_updated_state_t time_new_updated_state = {};

      if(uic_mqtt_dotdot_time_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            time_new_state,
            time_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_time_force_read_attributes_callback) {
      uic_mqtt_dotdot_time_updated_state_t time_force_update = {0};

      if(uic_mqtt_dotdot_time_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            time_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/Time/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/Time/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // Commissioning cluster
  // OTAUpgrade cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_ota_upgrade_image_notify_callback) {
        ImageNotifyPayloadType payload_type_value;
        memset(&payload_type_value, 0x00, sizeof(payload_type_value));
              uint8_t query_jitter_value;
        memset(&query_jitter_value, 0x00, sizeof(query_jitter_value));
              uint16_t manufacturer_code_value;
        memset(&manufacturer_code_value, 0x00, sizeof(manufacturer_code_value));
              uint16_t image_type_value;
        memset(&image_type_value, 0x00, sizeof(image_type_value));
              uint32_t new_file_version_value;
        memset(&new_file_version_value, 0x00, sizeof(new_file_version_value));
      

      if ( uic_mqtt_dotdot_ota_upgrade_image_notify_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              payload_type_value,

              query_jitter_value,

              manufacturer_code_value,

              image_type_value,

              new_file_version_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ImageNotify")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_ota_upgrade_query_next_image_request_callback) {
        uint8_t field_control_value;
        memset(&field_control_value, 0x00, sizeof(field_control_value));
              uint16_t manufacturer_code_value;
        memset(&manufacturer_code_value, 0x00, sizeof(manufacturer_code_value));
              OTAImageType image_type_value;
        memset(&image_type_value, 0x00, sizeof(image_type_value));
              uint32_t current_file_version_value;
        memset(&current_file_version_value, 0x00, sizeof(current_file_version_value));
              uint16_t hardware_version_value;
        memset(&hardware_version_value, 0x00, sizeof(hardware_version_value));
      

      if ( uic_mqtt_dotdot_ota_upgrade_query_next_image_request_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              field_control_value,

              manufacturer_code_value,

              image_type_value,

              current_file_version_value,

              hardware_version_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("QueryNextImageRequest")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_ota_upgrade_query_next_image_response_callback) {
        zclStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
              uint16_t manufacturer_code_value;
        memset(&manufacturer_code_value, 0x00, sizeof(manufacturer_code_value));
              OTAImageType image_type_value;
        memset(&image_type_value, 0x00, sizeof(image_type_value));
              uint32_t file_version_value;
        memset(&file_version_value, 0x00, sizeof(file_version_value));
              uint32_t image_size_value;
        memset(&image_size_value, 0x00, sizeof(image_size_value));
      

      if ( uic_mqtt_dotdot_ota_upgrade_query_next_image_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value,

              manufacturer_code_value,

              image_type_value,

              file_version_value,

              image_size_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("QueryNextImageResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_ota_upgrade_image_block_request_callback) {
        uint8_t field_control_value;
        memset(&field_control_value, 0x00, sizeof(field_control_value));
              uint16_t manufacturer_code_value;
        memset(&manufacturer_code_value, 0x00, sizeof(manufacturer_code_value));
              OTAImageType image_type_value;
        memset(&image_type_value, 0x00, sizeof(image_type_value));
              uint32_t file_version_value;
        memset(&file_version_value, 0x00, sizeof(file_version_value));
              uint32_t file_offset_value;
        memset(&file_offset_value, 0x00, sizeof(file_offset_value));
              uint8_t maximum_data_size_value;
        memset(&maximum_data_size_value, 0x00, sizeof(maximum_data_size_value));
              EUI64 request_node_address_value;
        memset(&request_node_address_value, 0x00, sizeof(request_node_address_value));
              uint16_t minimum_block_period_value;
        memset(&minimum_block_period_value, 0x00, sizeof(minimum_block_period_value));
      

      if ( uic_mqtt_dotdot_ota_upgrade_image_block_request_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              field_control_value,

              manufacturer_code_value,

              image_type_value,

              file_version_value,

              file_offset_value,

              maximum_data_size_value,

              request_node_address_value,

              minimum_block_period_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ImageBlockRequest")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_ota_upgrade_image_page_request_callback) {
        uint8_t field_control_value;
        memset(&field_control_value, 0x00, sizeof(field_control_value));
              uint16_t manufacturer_code_value;
        memset(&manufacturer_code_value, 0x00, sizeof(manufacturer_code_value));
              OTAImageType image_type_value;
        memset(&image_type_value, 0x00, sizeof(image_type_value));
              uint32_t file_version_value;
        memset(&file_version_value, 0x00, sizeof(file_version_value));
              uint32_t file_offset_value;
        memset(&file_offset_value, 0x00, sizeof(file_offset_value));
              uint8_t maximum_data_size_value;
        memset(&maximum_data_size_value, 0x00, sizeof(maximum_data_size_value));
              uint16_t page_size_value;
        memset(&page_size_value, 0x00, sizeof(page_size_value));
              uint16_t response_spacing_value;
        memset(&response_spacing_value, 0x00, sizeof(response_spacing_value));
              EUI64 request_node_address_value;
        memset(&request_node_address_value, 0x00, sizeof(request_node_address_value));
      

      if ( uic_mqtt_dotdot_ota_upgrade_image_page_request_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              field_control_value,

              manufacturer_code_value,

              image_type_value,

              file_version_value,

              file_offset_value,

              maximum_data_size_value,

              page_size_value,

              response_spacing_value,

              request_node_address_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ImagePageRequest")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_ota_upgrade_image_block_response_callback) {
        zclStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
              uint16_t manufacturer_code_value;
        memset(&manufacturer_code_value, 0x00, sizeof(manufacturer_code_value));
              OTAImageType image_type_value;
        memset(&image_type_value, 0x00, sizeof(image_type_value));
              uint32_t file_version_value;
        memset(&file_version_value, 0x00, sizeof(file_version_value));
              uint32_t file_offset_value;
        memset(&file_offset_value, 0x00, sizeof(file_offset_value));
              const char* image_data_value;
        memset(&image_data_value, 0x00, sizeof(image_data_value));
              uint32_t current_time_value;
        memset(&current_time_value, 0x00, sizeof(current_time_value));
              uint32_t request_time_value;
        memset(&request_time_value, 0x00, sizeof(request_time_value));
              uint16_t minimum_block_period_value;
        memset(&minimum_block_period_value, 0x00, sizeof(minimum_block_period_value));
      

      if ( uic_mqtt_dotdot_ota_upgrade_image_block_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value,

              manufacturer_code_value,

              image_type_value,

              file_version_value,

              file_offset_value,

              image_data_value,

              current_time_value,

              request_time_value,

              minimum_block_period_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ImageBlockResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_ota_upgrade_upgrade_end_request_callback) {
        zclStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
              uint16_t manufacturer_code_value;
        memset(&manufacturer_code_value, 0x00, sizeof(manufacturer_code_value));
              OTAImageType image_type_value;
        memset(&image_type_value, 0x00, sizeof(image_type_value));
              uint32_t file_version_value;
        memset(&file_version_value, 0x00, sizeof(file_version_value));
      

      if ( uic_mqtt_dotdot_ota_upgrade_upgrade_end_request_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value,

              manufacturer_code_value,

              image_type_value,

              file_version_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("UpgradeEndRequest")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_ota_upgrade_upgrade_end_response_callback) {
        uint16_t manufacturer_code_value;
        memset(&manufacturer_code_value, 0x00, sizeof(manufacturer_code_value));
              OTAImageType image_type_value;
        memset(&image_type_value, 0x00, sizeof(image_type_value));
              uint32_t file_version_value;
        memset(&file_version_value, 0x00, sizeof(file_version_value));
              UTC current_time_value;
        memset(&current_time_value, 0x00, sizeof(current_time_value));
              UTC upgrade_time_value;
        memset(&upgrade_time_value, 0x00, sizeof(upgrade_time_value));
      

      if ( uic_mqtt_dotdot_ota_upgrade_upgrade_end_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              manufacturer_code_value,

              image_type_value,

              file_version_value,

              current_time_value,

              upgrade_time_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("UpgradeEndResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_request_callback) {
        EUI64 request_node_address_value;
        memset(&request_node_address_value, 0x00, sizeof(request_node_address_value));
              uint16_t manufacturer_code_value;
        memset(&manufacturer_code_value, 0x00, sizeof(manufacturer_code_value));
              OTADeviceSpecificImageType image_type_value;
        memset(&image_type_value, 0x00, sizeof(image_type_value));
              uint32_t file_version_value;
        memset(&file_version_value, 0x00, sizeof(file_version_value));
              uint16_t current_zigbee_stack_version_value;
        memset(&current_zigbee_stack_version_value, 0x00, sizeof(current_zigbee_stack_version_value));
      

      if ( uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_request_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              request_node_address_value,

              manufacturer_code_value,

              image_type_value,

              file_version_value,

              current_zigbee_stack_version_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("QueryDeviceSpecificFileRequest")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_response_callback) {
        zclStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
              uint16_t manufacturer_code_value;
        memset(&manufacturer_code_value, 0x00, sizeof(manufacturer_code_value));
              OTADeviceSpecificImageType image_type_value;
        memset(&image_type_value, 0x00, sizeof(image_type_value));
              uint32_t file_version_value;
        memset(&file_version_value, 0x00, sizeof(file_version_value));
              uint32_t image_size_value;
        memset(&image_size_value, 0x00, sizeof(image_size_value));
      

      if ( uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value,

              manufacturer_code_value,

              image_type_value,

              file_version_value,

              image_size_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("QueryDeviceSpecificFileResponse")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_ota_upgrade_write_attributes_callback) {
      uic_mqtt_dotdot_ota_upgrade_state_t ota_upgrade_new_state = {};
      uic_mqtt_dotdot_ota_upgrade_updated_state_t ota_upgrade_new_updated_state = {};

      if(uic_mqtt_dotdot_ota_upgrade_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            ota_upgrade_new_state,
            ota_upgrade_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_ota_upgrade_force_read_attributes_callback) {
      uic_mqtt_dotdot_ota_upgrade_updated_state_t ota_upgrade_force_update = {0};

      if(uic_mqtt_dotdot_ota_upgrade_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            ota_upgrade_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/OTAUpgrade/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/OTAUpgrade/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // PollControl cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_poll_control_check_in_callback) {


      if ( uic_mqtt_dotdot_poll_control_check_in_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("CheckIn")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_poll_control_check_in_response_callback) {
        bool start_fast_polling_value;
        memset(&start_fast_polling_value, 0x00, sizeof(start_fast_polling_value));
              uint16_t fast_poll_timeout_value;
        memset(&fast_poll_timeout_value, 0x00, sizeof(fast_poll_timeout_value));
      

      if ( uic_mqtt_dotdot_poll_control_check_in_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              start_fast_polling_value,

              fast_poll_timeout_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("CheckInResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_poll_control_fast_poll_stop_callback) {


      if ( uic_mqtt_dotdot_poll_control_fast_poll_stop_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("FastPollStop")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback) {
        uint32_t new_long_poll_interval_value;
        memset(&new_long_poll_interval_value, 0x00, sizeof(new_long_poll_interval_value));
      

      if ( uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              new_long_poll_interval_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("SetLongPollInterval")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback) {
        uint16_t new_short_poll_interval_value;
        memset(&new_short_poll_interval_value, 0x00, sizeof(new_short_poll_interval_value));
      

      if ( uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              new_short_poll_interval_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("SetShortPollInterval")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_poll_control_write_attributes_callback) {
      uic_mqtt_dotdot_poll_control_state_t poll_control_new_state = {};
      uic_mqtt_dotdot_poll_control_updated_state_t poll_control_new_updated_state = {};

      if(uic_mqtt_dotdot_poll_control_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            poll_control_new_state,
            poll_control_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_poll_control_force_read_attributes_callback) {
      uic_mqtt_dotdot_poll_control_updated_state_t poll_control_force_update = {0};

      if(uic_mqtt_dotdot_poll_control_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            poll_control_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/PollControl/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/PollControl/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // ShadeConfiguration cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_shade_configuration_write_attributes_callback) {
      uic_mqtt_dotdot_shade_configuration_state_t shade_configuration_new_state = {};
      uic_mqtt_dotdot_shade_configuration_updated_state_t shade_configuration_new_updated_state = {};

      if(uic_mqtt_dotdot_shade_configuration_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            shade_configuration_new_state,
            shade_configuration_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_shade_configuration_force_read_attributes_callback) {
      uic_mqtt_dotdot_shade_configuration_updated_state_t shade_configuration_force_update = {0};

      if(uic_mqtt_dotdot_shade_configuration_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            shade_configuration_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/ShadeConfiguration/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/ShadeConfiguration/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // DoorLock cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_lock_door_callback) {
        const char* pin_orrfid_code_value;
        memset(&pin_orrfid_code_value, 0x00, sizeof(pin_orrfid_code_value));
      

      if ( uic_mqtt_dotdot_door_lock_lock_door_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              pin_orrfid_code_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("LockDoor")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_lock_door_response_callback) {
        zclStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
      

      if ( uic_mqtt_dotdot_door_lock_lock_door_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("LockDoorResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_unlock_door_callback) {
        const char* pin_orrfid_code_value;
        memset(&pin_orrfid_code_value, 0x00, sizeof(pin_orrfid_code_value));
      

      if ( uic_mqtt_dotdot_door_lock_unlock_door_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              pin_orrfid_code_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("UnlockDoor")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_unlock_door_response_callback) {
        zclStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
      

      if ( uic_mqtt_dotdot_door_lock_unlock_door_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("UnlockDoorResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_toggle_callback) {
        const char* pin_orrfid_code_value;
        memset(&pin_orrfid_code_value, 0x00, sizeof(pin_orrfid_code_value));
      

      if ( uic_mqtt_dotdot_door_lock_toggle_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              pin_orrfid_code_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("Toggle")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_toggle_response_callback) {
        zclStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
      

      if ( uic_mqtt_dotdot_door_lock_toggle_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ToggleResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback) {
        uint16_t timeout_in_seconds_value;
        memset(&timeout_in_seconds_value, 0x00, sizeof(timeout_in_seconds_value));
              const char* pin_orrfid_code_value;
        memset(&pin_orrfid_code_value, 0x00, sizeof(pin_orrfid_code_value));
      

      if ( uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              timeout_in_seconds_value,

              pin_orrfid_code_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("UnlockWithTimeout")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback) {
        zclStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
      

      if ( uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("UnlockWithTimeoutResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_get_log_record_callback) {
        uint16_t log_index_value;
        memset(&log_index_value, 0x00, sizeof(log_index_value));
      

      if ( uic_mqtt_dotdot_door_lock_get_log_record_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              log_index_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetLogRecord")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_get_log_record_response_callback) {
        uint16_t log_entryid_value;
        memset(&log_entryid_value, 0x00, sizeof(log_entryid_value));
              uint32_t timestamp_value;
        memset(&timestamp_value, 0x00, sizeof(timestamp_value));
              GetLogRecordResponseEventType event_type_value;
        memset(&event_type_value, 0x00, sizeof(event_type_value));
              DrlkOperEventSource source_operation_event_value;
        memset(&source_operation_event_value, 0x00, sizeof(source_operation_event_value));
              uint8_t eventid_or_alarm_code_value;
        memset(&eventid_or_alarm_code_value, 0x00, sizeof(eventid_or_alarm_code_value));
              uint16_t userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
              const char* pin_value;
        memset(&pin_value, 0x00, sizeof(pin_value));
      

      if ( uic_mqtt_dotdot_door_lock_get_log_record_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              log_entryid_value,

              timestamp_value,

              event_type_value,

              source_operation_event_value,

              eventid_or_alarm_code_value,

              userid_value,

              pin_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetLogRecordResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_setpin_code_callback) {
        DrlkPINUserID userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
              DrlkSettableUserStatus user_status_value;
        memset(&user_status_value, 0x00, sizeof(user_status_value));
              DrlkUserType user_type_value;
        memset(&user_type_value, 0x00, sizeof(user_type_value));
              const char* pin_value;
        memset(&pin_value, 0x00, sizeof(pin_value));
      

      if ( uic_mqtt_dotdot_door_lock_setpin_code_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              userid_value,

              user_status_value,

              user_type_value,

              pin_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("SetPINCode")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_setpin_code_response_callback) {
        DrlkSetCodeStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
      

      if ( uic_mqtt_dotdot_door_lock_setpin_code_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("SetPINCodeResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_getpin_code_callback) {
        DrlkPINUserID userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
      

      if ( uic_mqtt_dotdot_door_lock_getpin_code_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              userid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetPINCode")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_getpin_code_response_callback) {
        uint16_t userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
              DrlkUserStatus user_status_value;
        memset(&user_status_value, 0x00, sizeof(user_status_value));
              DrlkUserType user_type_value;
        memset(&user_type_value, 0x00, sizeof(user_type_value));
              const char* code_value;
        memset(&code_value, 0x00, sizeof(code_value));
      

      if ( uic_mqtt_dotdot_door_lock_getpin_code_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              userid_value,

              user_status_value,

              user_type_value,

              code_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetPINCodeResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_clearpin_code_callback) {
        DrlkPINUserID userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
      

      if ( uic_mqtt_dotdot_door_lock_clearpin_code_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              userid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ClearPINCode")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_clearpin_code_response_callback) {
        DrlkPassFailStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
      

      if ( uic_mqtt_dotdot_door_lock_clearpin_code_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ClearPINCodeResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_clear_allpin_codes_callback) {


      if ( uic_mqtt_dotdot_door_lock_clear_allpin_codes_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ClearAllPINCodes")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_clear_allpin_codes_response_callback) {
        DrlkPassFailStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
      

      if ( uic_mqtt_dotdot_door_lock_clear_allpin_codes_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ClearAllPINCodesResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_set_user_status_callback) {
        DrlkTotalUserID userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
              DrlkSettableUserStatus user_status_value;
        memset(&user_status_value, 0x00, sizeof(user_status_value));
      

      if ( uic_mqtt_dotdot_door_lock_set_user_status_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              userid_value,

              user_status_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("SetUserStatus")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_set_user_status_response_callback) {
        DrlkPassFailStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
      

      if ( uic_mqtt_dotdot_door_lock_set_user_status_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("SetUserStatusResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_get_user_status_callback) {
        DrlkTotalUserID userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
      

      if ( uic_mqtt_dotdot_door_lock_get_user_status_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              userid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetUserStatus")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_get_user_status_response_callback) {
        uint16_t userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
              DrlkUserStatus user_status_value;
        memset(&user_status_value, 0x00, sizeof(user_status_value));
      

      if ( uic_mqtt_dotdot_door_lock_get_user_status_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              userid_value,

              user_status_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetUserStatusResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback) {
        DrlkWeekDayScheduleID scheduleid_value;
        memset(&scheduleid_value, 0x00, sizeof(scheduleid_value));
              DrlkTotalUserID userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
              uint8_t days_mask_value;
        memset(&days_mask_value, 0x00, sizeof(days_mask_value));
              uint8_t start_hour_value;
        memset(&start_hour_value, 0x00, sizeof(start_hour_value));
              uint8_t start_minute_value;
        memset(&start_minute_value, 0x00, sizeof(start_minute_value));
              uint8_t end_hour_value;
        memset(&end_hour_value, 0x00, sizeof(end_hour_value));
              uint8_t end_minute_value;
        memset(&end_minute_value, 0x00, sizeof(end_minute_value));
      

      if ( uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              scheduleid_value,

              userid_value,

              days_mask_value,

              start_hour_value,

              start_minute_value,

              end_hour_value,

              end_minute_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("SetWeekdaySchedule")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback) {
        DrlkPassFailStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
      

      if ( uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("SetWeekdayScheduleResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback) {
        DrlkWeekDayScheduleID scheduleid_value;
        memset(&scheduleid_value, 0x00, sizeof(scheduleid_value));
              DrlkTotalUserID userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
      

      if ( uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              scheduleid_value,

              userid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetWeekdaySchedule")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback) {
        uint8_t scheduleid_value;
        memset(&scheduleid_value, 0x00, sizeof(scheduleid_value));
              uint16_t userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
              zclStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
              uint8_t days_mask_value;
        memset(&days_mask_value, 0x00, sizeof(days_mask_value));
              uint8_t start_hour_value;
        memset(&start_hour_value, 0x00, sizeof(start_hour_value));
              uint8_t start_minute_value;
        memset(&start_minute_value, 0x00, sizeof(start_minute_value));
              uint8_t end_hour_value;
        memset(&end_hour_value, 0x00, sizeof(end_hour_value));
              uint8_t end_minute_value;
        memset(&end_minute_value, 0x00, sizeof(end_minute_value));
      

      if ( uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              scheduleid_value,

              userid_value,

              status_value,

              days_mask_value,

              start_hour_value,

              start_minute_value,

              end_hour_value,

              end_minute_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetWeekdayScheduleResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback) {
        DrlkWeekDayScheduleID scheduleid_value;
        memset(&scheduleid_value, 0x00, sizeof(scheduleid_value));
              DrlkTotalUserID userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
      

      if ( uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              scheduleid_value,

              userid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ClearWeekdaySchedule")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback) {
        DrlkPassFailStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
      

      if ( uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ClearWeekdayScheduleResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback) {
        DrlkYearDayScheduleID scheduleid_value;
        memset(&scheduleid_value, 0x00, sizeof(scheduleid_value));
              DrlkTotalUserID userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
              uint32_t local_start_time_value;
        memset(&local_start_time_value, 0x00, sizeof(local_start_time_value));
              uint32_t local_end_time_value;
        memset(&local_end_time_value, 0x00, sizeof(local_end_time_value));
      

      if ( uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              scheduleid_value,

              userid_value,

              local_start_time_value,

              local_end_time_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("SetYearDaySchedule")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback) {
        DrlkPassFailStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
      

      if ( uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("SetYearDayScheduleResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback) {
        DrlkYearDayScheduleID scheduleid_value;
        memset(&scheduleid_value, 0x00, sizeof(scheduleid_value));
              DrlkTotalUserID userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
      

      if ( uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              scheduleid_value,

              userid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetYearDaySchedule")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback) {
        uint8_t scheduleid_value;
        memset(&scheduleid_value, 0x00, sizeof(scheduleid_value));
              uint16_t userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
              zclStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
              uint32_t local_start_time_value;
        memset(&local_start_time_value, 0x00, sizeof(local_start_time_value));
              uint32_t local_end_time_value;
        memset(&local_end_time_value, 0x00, sizeof(local_end_time_value));
      

      if ( uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              scheduleid_value,

              userid_value,

              status_value,

              local_start_time_value,

              local_end_time_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetYearDayScheduleResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback) {
        DrlkYearDayScheduleID scheduleid_value;
        memset(&scheduleid_value, 0x00, sizeof(scheduleid_value));
              DrlkTotalUserID userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
      

      if ( uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              scheduleid_value,

              userid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ClearYearDaySchedule")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback) {
        DrlkPassFailStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
      

      if ( uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ClearYearDayScheduleResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback) {
        DrlkHolidayScheduleID holiday_scheduleid_value;
        memset(&holiday_scheduleid_value, 0x00, sizeof(holiday_scheduleid_value));
              uint32_t local_start_time_value;
        memset(&local_start_time_value, 0x00, sizeof(local_start_time_value));
              uint32_t local_end_time_value;
        memset(&local_end_time_value, 0x00, sizeof(local_end_time_value));
              DrlkOperMode operating_mode_during_holiday_value;
        memset(&operating_mode_during_holiday_value, 0x00, sizeof(operating_mode_during_holiday_value));
      

      if ( uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              holiday_scheduleid_value,

              local_start_time_value,

              local_end_time_value,

              operating_mode_during_holiday_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("SetHolidaySchedule")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback) {
        DrlkPassFailStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
      

      if ( uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("SetHolidayScheduleResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback) {
        DrlkHolidayScheduleID holiday_scheduleid_value;
        memset(&holiday_scheduleid_value, 0x00, sizeof(holiday_scheduleid_value));
      

      if ( uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              holiday_scheduleid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetHolidaySchedule")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback) {
        uint8_t holiday_scheduleid_value;
        memset(&holiday_scheduleid_value, 0x00, sizeof(holiday_scheduleid_value));
              zclStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
              uint32_t local_start_time_value;
        memset(&local_start_time_value, 0x00, sizeof(local_start_time_value));
              uint32_t local_end_time_value;
        memset(&local_end_time_value, 0x00, sizeof(local_end_time_value));
              DrlkOperMode operating_mode_during_holiday_value;
        memset(&operating_mode_during_holiday_value, 0x00, sizeof(operating_mode_during_holiday_value));
      

      if ( uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              holiday_scheduleid_value,

              status_value,

              local_start_time_value,

              local_end_time_value,

              operating_mode_during_holiday_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetHolidayScheduleResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback) {
        DrlkHolidayScheduleID holiday_scheduleid_value;
        memset(&holiday_scheduleid_value, 0x00, sizeof(holiday_scheduleid_value));
      

      if ( uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              holiday_scheduleid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ClearHolidaySchedule")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback) {
        DrlkPassFailStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
      

      if ( uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ClearHolidayScheduleResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_set_user_type_callback) {
        DrlkTotalUserID userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
              DrlkUserType user_type_value;
        memset(&user_type_value, 0x00, sizeof(user_type_value));
      

      if ( uic_mqtt_dotdot_door_lock_set_user_type_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              userid_value,

              user_type_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("SetUserType")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_set_user_type_response_callback) {
        DrlkPassFailStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
      

      if ( uic_mqtt_dotdot_door_lock_set_user_type_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("SetUserTypeResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_get_user_type_callback) {
        DrlkTotalUserID userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
      

      if ( uic_mqtt_dotdot_door_lock_get_user_type_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              userid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetUserType")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_get_user_type_response_callback) {
        uint16_t userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
              DrlkUserType user_type_value;
        memset(&user_type_value, 0x00, sizeof(user_type_value));
      

      if ( uic_mqtt_dotdot_door_lock_get_user_type_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              userid_value,

              user_type_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetUserTypeResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_setrfid_code_callback) {
        DrlkRFIDUserID userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
              DrlkSettableUserStatus user_status_value;
        memset(&user_status_value, 0x00, sizeof(user_status_value));
              DrlkUserType user_type_value;
        memset(&user_type_value, 0x00, sizeof(user_type_value));
              const char* rfid_code_value;
        memset(&rfid_code_value, 0x00, sizeof(rfid_code_value));
      

      if ( uic_mqtt_dotdot_door_lock_setrfid_code_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              userid_value,

              user_status_value,

              user_type_value,

              rfid_code_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("SetRFIDCode")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_setrfid_code_response_callback) {
        DrlkSetCodeStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
      

      if ( uic_mqtt_dotdot_door_lock_setrfid_code_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("SetRFIDCodeResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_getrfid_code_callback) {
        DrlkRFIDUserID userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
      

      if ( uic_mqtt_dotdot_door_lock_getrfid_code_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              userid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetRFIDCode")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_getrfid_code_response_callback) {
        uint16_t userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
              DrlkUserStatus user_status_value;
        memset(&user_status_value, 0x00, sizeof(user_status_value));
              DrlkUserType user_type_value;
        memset(&user_type_value, 0x00, sizeof(user_type_value));
              const char* rfid_code_value;
        memset(&rfid_code_value, 0x00, sizeof(rfid_code_value));
      

      if ( uic_mqtt_dotdot_door_lock_getrfid_code_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              userid_value,

              user_status_value,

              user_type_value,

              rfid_code_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetRFIDCodeResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_clearrfid_code_callback) {
        DrlkRFIDUserID userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
      

      if ( uic_mqtt_dotdot_door_lock_clearrfid_code_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              userid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ClearRFIDCode")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_clearrfid_code_response_callback) {
        DrlkPassFailStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
      

      if ( uic_mqtt_dotdot_door_lock_clearrfid_code_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ClearRFIDCodeResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_clear_allrfid_codes_callback) {


      if ( uic_mqtt_dotdot_door_lock_clear_allrfid_codes_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ClearAllRFIDCodes")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_clear_allrfid_codes_response_callback) {
        DrlkPassFailStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
      

      if ( uic_mqtt_dotdot_door_lock_clear_allrfid_codes_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              status_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ClearAllRFIDCodesResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_operating_event_notification_callback) {
        DrlkOperEventSource operation_event_source_value;
        memset(&operation_event_source_value, 0x00, sizeof(operation_event_source_value));
              OperatingEventNotificationOperationEventCode operation_event_code_value;
        memset(&operation_event_code_value, 0x00, sizeof(operation_event_code_value));
              uint16_t userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
              const char* pin_value;
        memset(&pin_value, 0x00, sizeof(pin_value));
              uint32_t local_time_value;
        memset(&local_time_value, 0x00, sizeof(local_time_value));
              const char* data_value;
        memset(&data_value, 0x00, sizeof(data_value));
      

      if ( uic_mqtt_dotdot_door_lock_operating_event_notification_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              operation_event_source_value,

              operation_event_code_value,

              userid_value,

              pin_value,

              local_time_value,

              data_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("OperatingEventNotification")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_door_lock_programming_event_notification_callback) {
        ProgrammingEventNotificationProgramEventSource program_event_source_value;
        memset(&program_event_source_value, 0x00, sizeof(program_event_source_value));
              ProgrammingEventNotificationProgramEventCode program_event_code_value;
        memset(&program_event_code_value, 0x00, sizeof(program_event_code_value));
              uint16_t userid_value;
        memset(&userid_value, 0x00, sizeof(userid_value));
              const char* pin_value;
        memset(&pin_value, 0x00, sizeof(pin_value));
              DrlkUserType user_type_value;
        memset(&user_type_value, 0x00, sizeof(user_type_value));
              DrlkUserStatus user_status_value;
        memset(&user_status_value, 0x00, sizeof(user_status_value));
              uint32_t local_time_value;
        memset(&local_time_value, 0x00, sizeof(local_time_value));
              const char* data_value;
        memset(&data_value, 0x00, sizeof(data_value));
      

      if ( uic_mqtt_dotdot_door_lock_programming_event_notification_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              program_event_source_value,

              program_event_code_value,

              userid_value,

              pin_value,

              user_type_value,

              user_status_value,

              local_time_value,

              data_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ProgrammingEventNotification")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_door_lock_write_attributes_callback) {
      uic_mqtt_dotdot_door_lock_state_t door_lock_new_state = {};
      uic_mqtt_dotdot_door_lock_updated_state_t door_lock_new_updated_state = {};

      if(uic_mqtt_dotdot_door_lock_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            door_lock_new_state,
            door_lock_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_door_lock_force_read_attributes_callback) {
      uic_mqtt_dotdot_door_lock_updated_state_t door_lock_force_update = {0};

      if(uic_mqtt_dotdot_door_lock_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            door_lock_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/DoorLock/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/DoorLock/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // WindowCovering cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_window_covering_up_or_open_callback) {


      if ( uic_mqtt_dotdot_window_covering_up_or_open_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("UpOrOpen")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_window_covering_down_or_close_callback) {


      if ( uic_mqtt_dotdot_window_covering_down_or_close_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("DownOrClose")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_window_covering_stop_callback) {


      if ( uic_mqtt_dotdot_window_covering_stop_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("Stop")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_window_covering_go_to_lift_value_callback) {
        uint16_t lift_value_value;
        memset(&lift_value_value, 0x00, sizeof(lift_value_value));
      

      if ( uic_mqtt_dotdot_window_covering_go_to_lift_value_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              lift_value_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GoToLiftValue")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback) {
        uint8_t percentage_lift_value_value;
        memset(&percentage_lift_value_value, 0x00, sizeof(percentage_lift_value_value));
      

      if ( uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              percentage_lift_value_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GoToLiftPercentage")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback) {
        uint16_t tilt_value_value;
        memset(&tilt_value_value, 0x00, sizeof(tilt_value_value));
      

      if ( uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              tilt_value_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GoToTiltValue")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback) {
        uint8_t percentage_tilt_value_value;
        memset(&percentage_tilt_value_value, 0x00, sizeof(percentage_tilt_value_value));
      

      if ( uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              percentage_tilt_value_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GoToTiltPercentage")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_window_covering_write_attributes_callback) {
      uic_mqtt_dotdot_window_covering_state_t window_covering_new_state = {};
      uic_mqtt_dotdot_window_covering_updated_state_t window_covering_new_updated_state = {};

      if(uic_mqtt_dotdot_window_covering_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            window_covering_new_state,
            window_covering_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_window_covering_force_read_attributes_callback) {
      uic_mqtt_dotdot_window_covering_updated_state_t window_covering_force_update = {0};

      if(uic_mqtt_dotdot_window_covering_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            window_covering_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/WindowCovering/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/WindowCovering/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // BarrierControl cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_barrier_control_go_to_percent_callback) {
        uint8_t percent_open_value;
        memset(&percent_open_value, 0x00, sizeof(percent_open_value));
      

      if ( uic_mqtt_dotdot_barrier_control_go_to_percent_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              percent_open_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GoToPercent")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_barrier_control_stop_callback) {


      if ( uic_mqtt_dotdot_barrier_control_stop_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("Stop")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_barrier_control_write_attributes_callback) {
      uic_mqtt_dotdot_barrier_control_state_t barrier_control_new_state = {};
      uic_mqtt_dotdot_barrier_control_updated_state_t barrier_control_new_updated_state = {};

      if(uic_mqtt_dotdot_barrier_control_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            barrier_control_new_state,
            barrier_control_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_barrier_control_force_read_attributes_callback) {
      uic_mqtt_dotdot_barrier_control_updated_state_t barrier_control_force_update = {0};

      if(uic_mqtt_dotdot_barrier_control_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            barrier_control_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/BarrierControl/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/BarrierControl/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // PumpConfigurationAndControl cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback) {
      uic_mqtt_dotdot_pump_configuration_and_control_state_t pump_configuration_and_control_new_state = {};
      uic_mqtt_dotdot_pump_configuration_and_control_updated_state_t pump_configuration_and_control_new_updated_state = {};

      if(uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            pump_configuration_and_control_new_state,
            pump_configuration_and_control_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_callback) {
      uic_mqtt_dotdot_pump_configuration_and_control_updated_state_t pump_configuration_and_control_force_update = {0};

      if(uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            pump_configuration_and_control_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/PumpConfigurationAndControl/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/PumpConfigurationAndControl/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // Thermostat cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback) {
        SetpointRaiseOrLowerMode mode_value;
        memset(&mode_value, 0x00, sizeof(mode_value));
              int8_t amount_value;
        memset(&amount_value, 0x00, sizeof(amount_value));
      

      if ( uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              mode_value,

              amount_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("SetpointRaiseOrLower")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback) {
        uint8_t number_of_transitions_value;
        memset(&number_of_transitions_value, 0x00, sizeof(number_of_transitions_value));
              uint8_t day_of_week_value;
        memset(&day_of_week_value, 0x00, sizeof(day_of_week_value));
              uint8_t mode_value;
        memset(&mode_value, 0x00, sizeof(mode_value));
      

      if ( uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              number_of_transitions_value,

              day_of_week_value,

              mode_value,

              0,
              nullptr

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetWeeklyScheduleResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback) {
        uint8_t number_of_transitions_value;
        memset(&number_of_transitions_value, 0x00, sizeof(number_of_transitions_value));
              uint8_t day_of_week_value;
        memset(&day_of_week_value, 0x00, sizeof(day_of_week_value));
              uint8_t mode_value;
        memset(&mode_value, 0x00, sizeof(mode_value));
      

      if ( uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              number_of_transitions_value,

              day_of_week_value,

              mode_value,

              0,
              nullptr

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("SetWeeklySchedule")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback) {
        uint16_t time_of_day_value;
        memset(&time_of_day_value, 0x00, sizeof(time_of_day_value));
              uint8_t relay_status_value;
        memset(&relay_status_value, 0x00, sizeof(relay_status_value));
              int16_t local_temperature_value;
        memset(&local_temperature_value, 0x00, sizeof(local_temperature_value));
              uint8_t humidity_percentage_value;
        memset(&humidity_percentage_value, 0x00, sizeof(humidity_percentage_value));
              int16_t set_point_value;
        memset(&set_point_value, 0x00, sizeof(set_point_value));
              uint16_t unread_entries_value;
        memset(&unread_entries_value, 0x00, sizeof(unread_entries_value));
      

      if ( uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              time_of_day_value,

              relay_status_value,

              local_temperature_value,

              humidity_percentage_value,

              set_point_value,

              unread_entries_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetRelayStatusLogResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback) {
        uint8_t days_to_return_value;
        memset(&days_to_return_value, 0x00, sizeof(days_to_return_value));
              uint8_t mode_to_return_value;
        memset(&mode_to_return_value, 0x00, sizeof(mode_to_return_value));
      

      if ( uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              days_to_return_value,

              mode_to_return_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetWeeklySchedule")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback) {


      if ( uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ClearWeeklySchedule")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_thermostat_get_relay_status_log_callback) {


      if ( uic_mqtt_dotdot_thermostat_get_relay_status_log_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetRelayStatusLog")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_thermostat_write_attributes_callback) {
      uic_mqtt_dotdot_thermostat_state_t thermostat_new_state = {};
      uic_mqtt_dotdot_thermostat_updated_state_t thermostat_new_updated_state = {};

      if(uic_mqtt_dotdot_thermostat_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            thermostat_new_state,
            thermostat_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_thermostat_force_read_attributes_callback) {
      uic_mqtt_dotdot_thermostat_updated_state_t thermostat_force_update = {0};

      if(uic_mqtt_dotdot_thermostat_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            thermostat_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/Thermostat/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/Thermostat/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // FanControl cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_fan_control_write_attributes_callback) {
      uic_mqtt_dotdot_fan_control_state_t fan_control_new_state = {};
      uic_mqtt_dotdot_fan_control_updated_state_t fan_control_new_updated_state = {};

      if(uic_mqtt_dotdot_fan_control_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            fan_control_new_state,
            fan_control_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_fan_control_force_read_attributes_callback) {
      uic_mqtt_dotdot_fan_control_updated_state_t fan_control_force_update = {0};

      if(uic_mqtt_dotdot_fan_control_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            fan_control_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/FanControl/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/FanControl/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // DehumidificationControl cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_dehumidification_control_write_attributes_callback) {
      uic_mqtt_dotdot_dehumidification_control_state_t dehumidification_control_new_state = {};
      uic_mqtt_dotdot_dehumidification_control_updated_state_t dehumidification_control_new_updated_state = {};

      if(uic_mqtt_dotdot_dehumidification_control_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            dehumidification_control_new_state,
            dehumidification_control_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_dehumidification_control_force_read_attributes_callback) {
      uic_mqtt_dotdot_dehumidification_control_updated_state_t dehumidification_control_force_update = {0};

      if(uic_mqtt_dotdot_dehumidification_control_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            dehumidification_control_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/DehumidificationControl/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/DehumidificationControl/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // ThermostatUserInterfaceConfiguration cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback) {
      uic_mqtt_dotdot_thermostat_user_interface_configuration_state_t thermostat_user_interface_configuration_new_state = {};
      uic_mqtt_dotdot_thermostat_user_interface_configuration_updated_state_t thermostat_user_interface_configuration_new_updated_state = {};

      if(uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            thermostat_user_interface_configuration_new_state,
            thermostat_user_interface_configuration_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_callback) {
      uic_mqtt_dotdot_thermostat_user_interface_configuration_updated_state_t thermostat_user_interface_configuration_force_update = {0};

      if(uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            thermostat_user_interface_configuration_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/ThermostatUserInterfaceConfiguration/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/ThermostatUserInterfaceConfiguration/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // ColorControl cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_color_control_move_to_hue_callback) {
        uint8_t hue_value;
        memset(&hue_value, 0x00, sizeof(hue_value));
              CCDirection direction_value;
        memset(&direction_value, 0x00, sizeof(direction_value));
              uint16_t transition_time_value;
        memset(&transition_time_value, 0x00, sizeof(transition_time_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_color_control_move_to_hue_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              hue_value,

              direction_value,

              transition_time_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("MoveToHue")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_color_control_move_hue_callback) {
        CCMoveMode move_mode_value;
        memset(&move_mode_value, 0x00, sizeof(move_mode_value));
              uint8_t rate_value;
        memset(&rate_value, 0x00, sizeof(rate_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_color_control_move_hue_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              move_mode_value,

              rate_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("MoveHue")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_color_control_step_hue_callback) {
        CCStepMode step_mode_value;
        memset(&step_mode_value, 0x00, sizeof(step_mode_value));
              uint8_t step_size_value;
        memset(&step_size_value, 0x00, sizeof(step_size_value));
              uint8_t transition_time_value;
        memset(&transition_time_value, 0x00, sizeof(transition_time_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_color_control_step_hue_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              step_mode_value,

              step_size_value,

              transition_time_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("StepHue")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_color_control_move_to_saturation_callback) {
        uint8_t saturation_value;
        memset(&saturation_value, 0x00, sizeof(saturation_value));
              uint16_t transition_time_value;
        memset(&transition_time_value, 0x00, sizeof(transition_time_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_color_control_move_to_saturation_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              saturation_value,

              transition_time_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("MoveToSaturation")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_color_control_move_saturation_callback) {
        CCMoveMode move_mode_value;
        memset(&move_mode_value, 0x00, sizeof(move_mode_value));
              uint8_t rate_value;
        memset(&rate_value, 0x00, sizeof(rate_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_color_control_move_saturation_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              move_mode_value,

              rate_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("MoveSaturation")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_color_control_step_saturation_callback) {
        CCStepMode step_mode_value;
        memset(&step_mode_value, 0x00, sizeof(step_mode_value));
              uint8_t step_size_value;
        memset(&step_size_value, 0x00, sizeof(step_size_value));
              uint8_t transition_time_value;
        memset(&transition_time_value, 0x00, sizeof(transition_time_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_color_control_step_saturation_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              step_mode_value,

              step_size_value,

              transition_time_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("StepSaturation")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback) {
        uint8_t hue_value;
        memset(&hue_value, 0x00, sizeof(hue_value));
              uint8_t saturation_value;
        memset(&saturation_value, 0x00, sizeof(saturation_value));
              uint16_t transition_time_value;
        memset(&transition_time_value, 0x00, sizeof(transition_time_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              hue_value,

              saturation_value,

              transition_time_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("MoveToHueAndSaturation")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_color_control_move_to_color_callback) {
        uint16_t colorx_value;
        memset(&colorx_value, 0x00, sizeof(colorx_value));
              uint16_t colory_value;
        memset(&colory_value, 0x00, sizeof(colory_value));
              uint16_t transition_time_value;
        memset(&transition_time_value, 0x00, sizeof(transition_time_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_color_control_move_to_color_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              colorx_value,

              colory_value,

              transition_time_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("MoveToColor")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_color_control_move_color_callback) {
        int16_t ratex_value;
        memset(&ratex_value, 0x00, sizeof(ratex_value));
              int16_t ratey_value;
        memset(&ratey_value, 0x00, sizeof(ratey_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_color_control_move_color_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              ratex_value,

              ratey_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("MoveColor")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_color_control_step_color_callback) {
        int16_t stepx_value;
        memset(&stepx_value, 0x00, sizeof(stepx_value));
              int16_t stepy_value;
        memset(&stepy_value, 0x00, sizeof(stepy_value));
              uint16_t transition_time_value;
        memset(&transition_time_value, 0x00, sizeof(transition_time_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_color_control_step_color_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              stepx_value,

              stepy_value,

              transition_time_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("StepColor")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_color_control_move_to_color_temperature_callback) {
        uint16_t color_temperature_mireds_value;
        memset(&color_temperature_mireds_value, 0x00, sizeof(color_temperature_mireds_value));
              uint16_t transition_time_value;
        memset(&transition_time_value, 0x00, sizeof(transition_time_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_color_control_move_to_color_temperature_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              color_temperature_mireds_value,

              transition_time_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("MoveToColorTemperature")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback) {
        uint16_t enhanced_hue_value;
        memset(&enhanced_hue_value, 0x00, sizeof(enhanced_hue_value));
              CCDirection direction_value;
        memset(&direction_value, 0x00, sizeof(direction_value));
              uint16_t transition_time_value;
        memset(&transition_time_value, 0x00, sizeof(transition_time_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              enhanced_hue_value,

              direction_value,

              transition_time_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("EnhancedMoveToHue")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_color_control_enhanced_move_hue_callback) {
        CCMoveMode move_mode_value;
        memset(&move_mode_value, 0x00, sizeof(move_mode_value));
              uint16_t rate_value;
        memset(&rate_value, 0x00, sizeof(rate_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_color_control_enhanced_move_hue_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              move_mode_value,

              rate_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("EnhancedMoveHue")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_color_control_enhanced_step_hue_callback) {
        CCStepMode step_mode_value;
        memset(&step_mode_value, 0x00, sizeof(step_mode_value));
              uint16_t step_size_value;
        memset(&step_size_value, 0x00, sizeof(step_size_value));
              uint16_t transition_time_value;
        memset(&transition_time_value, 0x00, sizeof(transition_time_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_color_control_enhanced_step_hue_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              step_mode_value,

              step_size_value,

              transition_time_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("EnhancedStepHue")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback) {
        uint16_t enhanced_hue_value;
        memset(&enhanced_hue_value, 0x00, sizeof(enhanced_hue_value));
              uint8_t saturation_value;
        memset(&saturation_value, 0x00, sizeof(saturation_value));
              uint16_t transition_time_value;
        memset(&transition_time_value, 0x00, sizeof(transition_time_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              enhanced_hue_value,

              saturation_value,

              transition_time_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("EnhancedMoveToHueAndSaturation")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_color_control_color_loop_set_callback) {
        uint8_t update_flags_value;
        memset(&update_flags_value, 0x00, sizeof(update_flags_value));
              ColorLoopSetAction action_value;
        memset(&action_value, 0x00, sizeof(action_value));
              CCColorLoopDirection direction_value;
        memset(&direction_value, 0x00, sizeof(direction_value));
              uint16_t time_value;
        memset(&time_value, 0x00, sizeof(time_value));
              uint16_t start_hue_value;
        memset(&start_hue_value, 0x00, sizeof(start_hue_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_color_control_color_loop_set_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              update_flags_value,

              action_value,

              direction_value,

              time_value,

              start_hue_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ColorLoopSet")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_color_control_stop_move_step_callback) {
        uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_color_control_stop_move_step_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("StopMoveStep")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_color_control_move_color_temperature_callback) {
        CCMoveMode move_mode_value;
        memset(&move_mode_value, 0x00, sizeof(move_mode_value));
              uint16_t rate_value;
        memset(&rate_value, 0x00, sizeof(rate_value));
              CCMinMiredsField color_temperature_minimum_mireds_value;
        memset(&color_temperature_minimum_mireds_value, 0x00, sizeof(color_temperature_minimum_mireds_value));
              CCMaxMiredsField color_temperature_maximum_mireds_value;
        memset(&color_temperature_maximum_mireds_value, 0x00, sizeof(color_temperature_maximum_mireds_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_color_control_move_color_temperature_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              move_mode_value,

              rate_value,

              color_temperature_minimum_mireds_value,

              color_temperature_maximum_mireds_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("MoveColorTemperature")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_color_control_step_color_temperature_callback) {
        CCStepMode step_mode_value;
        memset(&step_mode_value, 0x00, sizeof(step_mode_value));
              uint16_t step_size_value;
        memset(&step_size_value, 0x00, sizeof(step_size_value));
              uint16_t transition_time_value;
        memset(&transition_time_value, 0x00, sizeof(transition_time_value));
              CCMinMiredsField color_temperature_minimum_mireds_value;
        memset(&color_temperature_minimum_mireds_value, 0x00, sizeof(color_temperature_minimum_mireds_value));
              CCMaxMiredsField color_temperature_maximum_mireds_value;
        memset(&color_temperature_maximum_mireds_value, 0x00, sizeof(color_temperature_maximum_mireds_value));
              uint8_t options_mask_value;
        memset(&options_mask_value, 0x00, sizeof(options_mask_value));
              uint8_t options_override_value;
        memset(&options_override_value, 0x00, sizeof(options_override_value));
      

      if ( uic_mqtt_dotdot_color_control_step_color_temperature_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              step_mode_value,

              step_size_value,

              transition_time_value,

              color_temperature_minimum_mireds_value,

              color_temperature_maximum_mireds_value,

              options_mask_value,

              options_override_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("StepColorTemperature")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_color_control_write_attributes_callback) {
      uic_mqtt_dotdot_color_control_state_t color_control_new_state = {};
      uic_mqtt_dotdot_color_control_updated_state_t color_control_new_updated_state = {};

      if(uic_mqtt_dotdot_color_control_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            color_control_new_state,
            color_control_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_color_control_force_read_attributes_callback) {
      uic_mqtt_dotdot_color_control_updated_state_t color_control_force_update = {0};

      if(uic_mqtt_dotdot_color_control_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            color_control_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/ColorControl/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/ColorControl/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // BallastConfiguration cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_ballast_configuration_write_attributes_callback) {
      uic_mqtt_dotdot_ballast_configuration_state_t ballast_configuration_new_state = {};
      uic_mqtt_dotdot_ballast_configuration_updated_state_t ballast_configuration_new_updated_state = {};

      if(uic_mqtt_dotdot_ballast_configuration_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            ballast_configuration_new_state,
            ballast_configuration_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_ballast_configuration_force_read_attributes_callback) {
      uic_mqtt_dotdot_ballast_configuration_updated_state_t ballast_configuration_force_update = {0};

      if(uic_mqtt_dotdot_ballast_configuration_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            ballast_configuration_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/BallastConfiguration/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/BallastConfiguration/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // IlluminanceMeasurement cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback) {
      uic_mqtt_dotdot_illuminance_measurement_state_t illuminance_measurement_new_state = {};
      uic_mqtt_dotdot_illuminance_measurement_updated_state_t illuminance_measurement_new_updated_state = {};

      if(uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            illuminance_measurement_new_state,
            illuminance_measurement_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_callback) {
      uic_mqtt_dotdot_illuminance_measurement_updated_state_t illuminance_measurement_force_update = {0};

      if(uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            illuminance_measurement_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/IlluminanceMeasurement/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/IlluminanceMeasurement/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // IlluminanceLevelSensing cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback) {
      uic_mqtt_dotdot_illuminance_level_sensing_state_t illuminance_level_sensing_new_state = {};
      uic_mqtt_dotdot_illuminance_level_sensing_updated_state_t illuminance_level_sensing_new_updated_state = {};

      if(uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            illuminance_level_sensing_new_state,
            illuminance_level_sensing_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_callback) {
      uic_mqtt_dotdot_illuminance_level_sensing_updated_state_t illuminance_level_sensing_force_update = {0};

      if(uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            illuminance_level_sensing_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/IlluminanceLevelSensing/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/IlluminanceLevelSensing/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // TemperatureMeasurement cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_temperature_measurement_write_attributes_callback) {
      uic_mqtt_dotdot_temperature_measurement_state_t temperature_measurement_new_state = {};
      uic_mqtt_dotdot_temperature_measurement_updated_state_t temperature_measurement_new_updated_state = {};

      if(uic_mqtt_dotdot_temperature_measurement_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            temperature_measurement_new_state,
            temperature_measurement_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_temperature_measurement_force_read_attributes_callback) {
      uic_mqtt_dotdot_temperature_measurement_updated_state_t temperature_measurement_force_update = {0};

      if(uic_mqtt_dotdot_temperature_measurement_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            temperature_measurement_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/TemperatureMeasurement/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/TemperatureMeasurement/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // PressureMeasurement cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_pressure_measurement_write_attributes_callback) {
      uic_mqtt_dotdot_pressure_measurement_state_t pressure_measurement_new_state = {};
      uic_mqtt_dotdot_pressure_measurement_updated_state_t pressure_measurement_new_updated_state = {};

      if(uic_mqtt_dotdot_pressure_measurement_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            pressure_measurement_new_state,
            pressure_measurement_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_pressure_measurement_force_read_attributes_callback) {
      uic_mqtt_dotdot_pressure_measurement_updated_state_t pressure_measurement_force_update = {0};

      if(uic_mqtt_dotdot_pressure_measurement_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            pressure_measurement_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/PressureMeasurement/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/PressureMeasurement/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // FlowMeasurement cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_flow_measurement_write_attributes_callback) {
      uic_mqtt_dotdot_flow_measurement_state_t flow_measurement_new_state = {};
      uic_mqtt_dotdot_flow_measurement_updated_state_t flow_measurement_new_updated_state = {};

      if(uic_mqtt_dotdot_flow_measurement_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            flow_measurement_new_state,
            flow_measurement_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_flow_measurement_force_read_attributes_callback) {
      uic_mqtt_dotdot_flow_measurement_updated_state_t flow_measurement_force_update = {0};

      if(uic_mqtt_dotdot_flow_measurement_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            flow_measurement_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/FlowMeasurement/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/FlowMeasurement/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // RelativityHumidity cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_relativity_humidity_write_attributes_callback) {
      uic_mqtt_dotdot_relativity_humidity_state_t relativity_humidity_new_state = {};
      uic_mqtt_dotdot_relativity_humidity_updated_state_t relativity_humidity_new_updated_state = {};

      if(uic_mqtt_dotdot_relativity_humidity_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            relativity_humidity_new_state,
            relativity_humidity_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_relativity_humidity_force_read_attributes_callback) {
      uic_mqtt_dotdot_relativity_humidity_updated_state_t relativity_humidity_force_update = {0};

      if(uic_mqtt_dotdot_relativity_humidity_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            relativity_humidity_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/RelativityHumidity/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/RelativityHumidity/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // OccupancySensing cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback) {
      uic_mqtt_dotdot_occupancy_sensing_state_t occupancy_sensing_new_state = {};
      uic_mqtt_dotdot_occupancy_sensing_updated_state_t occupancy_sensing_new_updated_state = {};

      if(uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            occupancy_sensing_new_state,
            occupancy_sensing_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_callback) {
      uic_mqtt_dotdot_occupancy_sensing_updated_state_t occupancy_sensing_force_update = {0};

      if(uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            occupancy_sensing_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/OccupancySensing/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/OccupancySensing/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // PhMeasurement cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_ph_measurement_write_attributes_callback) {
      uic_mqtt_dotdot_ph_measurement_state_t ph_measurement_new_state = {};
      uic_mqtt_dotdot_ph_measurement_updated_state_t ph_measurement_new_updated_state = {};

      if(uic_mqtt_dotdot_ph_measurement_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            ph_measurement_new_state,
            ph_measurement_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_ph_measurement_force_read_attributes_callback) {
      uic_mqtt_dotdot_ph_measurement_updated_state_t ph_measurement_force_update = {0};

      if(uic_mqtt_dotdot_ph_measurement_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            ph_measurement_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/PhMeasurement/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/PhMeasurement/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // ElectricalConductivityMeasurement cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback) {
      uic_mqtt_dotdot_electrical_conductivity_measurement_state_t electrical_conductivity_measurement_new_state = {};
      uic_mqtt_dotdot_electrical_conductivity_measurement_updated_state_t electrical_conductivity_measurement_new_updated_state = {};

      if(uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            electrical_conductivity_measurement_new_state,
            electrical_conductivity_measurement_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_callback) {
      uic_mqtt_dotdot_electrical_conductivity_measurement_updated_state_t electrical_conductivity_measurement_force_update = {0};

      if(uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            electrical_conductivity_measurement_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/ElectricalConductivityMeasurement/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/ElectricalConductivityMeasurement/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // WindSpeedMeasurement cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback) {
      uic_mqtt_dotdot_wind_speed_measurement_state_t wind_speed_measurement_new_state = {};
      uic_mqtt_dotdot_wind_speed_measurement_updated_state_t wind_speed_measurement_new_updated_state = {};

      if(uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            wind_speed_measurement_new_state,
            wind_speed_measurement_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_callback) {
      uic_mqtt_dotdot_wind_speed_measurement_updated_state_t wind_speed_measurement_force_update = {0};

      if(uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            wind_speed_measurement_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/WindSpeedMeasurement/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/WindSpeedMeasurement/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // CarbonMonoxide cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback) {
      uic_mqtt_dotdot_carbon_monoxide_state_t carbon_monoxide_new_state = {};
      uic_mqtt_dotdot_carbon_monoxide_updated_state_t carbon_monoxide_new_updated_state = {};

      if(uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            carbon_monoxide_new_state,
            carbon_monoxide_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_callback) {
      uic_mqtt_dotdot_carbon_monoxide_updated_state_t carbon_monoxide_force_update = {0};

      if(uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            carbon_monoxide_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/CarbonMonoxide/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/CarbonMonoxide/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // IASZone cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback) {
        ZoneEnrollResponseEnrollResponseCode enroll_response_code_value;
        memset(&enroll_response_code_value, 0x00, sizeof(enroll_response_code_value));
              uint8_t zoneid_value;
        memset(&zoneid_value, 0x00, sizeof(zoneid_value));
      

      if ( uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              enroll_response_code_value,

              zoneid_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ZoneEnrollResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback) {
        uint16_t zone_status_value;
        memset(&zone_status_value, 0x00, sizeof(zone_status_value));
              uint8_t extended_status_value;
        memset(&extended_status_value, 0x00, sizeof(extended_status_value));
              uint8_t zoneid_value;
        memset(&zoneid_value, 0x00, sizeof(zoneid_value));
              uint16_t delay_value;
        memset(&delay_value, 0x00, sizeof(delay_value));
      

      if ( uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              zone_status_value,

              extended_status_value,

              zoneid_value,

              delay_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ZoneStatusChangeNotification")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback) {


      if ( uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("InitiateNormalOperationMode")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback) {
        IasZoneType zone_type_value;
        memset(&zone_type_value, 0x00, sizeof(zone_type_value));
              uint16_t manufacturer_code_value;
        memset(&manufacturer_code_value, 0x00, sizeof(manufacturer_code_value));
      

      if ( uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              zone_type_value,

              manufacturer_code_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ZoneEnrollRequest")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback) {
        uint8_t test_mode_duration_value;
        memset(&test_mode_duration_value, 0x00, sizeof(test_mode_duration_value));
              uint8_t current_zone_sensitivity_level_value;
        memset(&current_zone_sensitivity_level_value, 0x00, sizeof(current_zone_sensitivity_level_value));
      

      if ( uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              test_mode_duration_value,

              current_zone_sensitivity_level_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("InitiateTestMode")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_ias_zone_write_attributes_callback) {
      uic_mqtt_dotdot_ias_zone_state_t ias_zone_new_state = {};
      uic_mqtt_dotdot_ias_zone_updated_state_t ias_zone_new_updated_state = {};

      if(uic_mqtt_dotdot_ias_zone_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            ias_zone_new_state,
            ias_zone_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_ias_zone_force_read_attributes_callback) {
      uic_mqtt_dotdot_ias_zone_updated_state_t ias_zone_force_update = {0};

      if(uic_mqtt_dotdot_ias_zone_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            ias_zone_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/IASZone/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/IASZone/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // IASACE cluster
  // IASWD cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_iaswd_start_warning_callback) {
        uint8_t siren_configuration_value;
        memset(&siren_configuration_value, 0x00, sizeof(siren_configuration_value));
              uint16_t warning_duration_value;
        memset(&warning_duration_value, 0x00, sizeof(warning_duration_value));
              uint8_t strobe_duty_cycle_value;
        memset(&strobe_duty_cycle_value, 0x00, sizeof(strobe_duty_cycle_value));
              IaswdLevel strobe_level_value;
        memset(&strobe_level_value, 0x00, sizeof(strobe_level_value));
      

      if ( uic_mqtt_dotdot_iaswd_start_warning_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              siren_configuration_value,

              warning_duration_value,

              strobe_duty_cycle_value,

              strobe_level_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("StartWarning")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_iaswd_squawk_callback) {
        uint8_t squawk_configuration_value;
        memset(&squawk_configuration_value, 0x00, sizeof(squawk_configuration_value));
      

      if ( uic_mqtt_dotdot_iaswd_squawk_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              squawk_configuration_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("Squawk")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_iaswd_write_attributes_callback) {
      uic_mqtt_dotdot_iaswd_state_t iaswd_new_state = {};
      uic_mqtt_dotdot_iaswd_updated_state_t iaswd_new_updated_state = {};

      if(uic_mqtt_dotdot_iaswd_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            iaswd_new_state,
            iaswd_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_iaswd_force_read_attributes_callback) {
      uic_mqtt_dotdot_iaswd_updated_state_t iaswd_force_update = {0};

      if(uic_mqtt_dotdot_iaswd_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            iaswd_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/IASWD/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/IASWD/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // Metering cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_metering_write_attributes_callback) {
      uic_mqtt_dotdot_metering_state_t metering_new_state = {};
      uic_mqtt_dotdot_metering_updated_state_t metering_new_updated_state = {};

      if(uic_mqtt_dotdot_metering_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            metering_new_state,
            metering_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_metering_force_read_attributes_callback) {
      uic_mqtt_dotdot_metering_updated_state_t metering_force_update = {0};

      if(uic_mqtt_dotdot_metering_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            metering_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/Metering/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/Metering/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // ElectricalMeasurement cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback) {
        uint8_t profile_count_value;
        memset(&profile_count_value, 0x00, sizeof(profile_count_value));
              ProfileIntervalPeriod profile_interval_period_value;
        memset(&profile_interval_period_value, 0x00, sizeof(profile_interval_period_value));
              uint8_t max_number_of_intervals_value;
        memset(&max_number_of_intervals_value, 0x00, sizeof(max_number_of_intervals_value));
      

      if ( uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              profile_count_value,

              profile_interval_period_value,

              max_number_of_intervals_value,

              0,
              nullptr

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetProfileInfoResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback) {


      if ( uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetProfileInfo")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback) {
        UTC start_time_value;
        memset(&start_time_value, 0x00, sizeof(start_time_value));
              GetMeasurementProfileResponseStatus status_value;
        memset(&status_value, 0x00, sizeof(status_value));
              ProfileIntervalPeriod profile_interval_period_value;
        memset(&profile_interval_period_value, 0x00, sizeof(profile_interval_period_value));
              uint8_t number_of_intervals_delivered_value;
        memset(&number_of_intervals_delivered_value, 0x00, sizeof(number_of_intervals_delivered_value));
              uint16_t attribute_id_value;
        memset(&attribute_id_value, 0x00, sizeof(attribute_id_value));
      

      if ( uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              start_time_value,

              status_value,

              profile_interval_period_value,

              number_of_intervals_delivered_value,

              attribute_id_value,

              0,
              nullptr

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetMeasurementProfileResponse")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback) {
        uint16_t attributeid_value;
        memset(&attributeid_value, 0x00, sizeof(attributeid_value));
              UTC start_time_value;
        memset(&start_time_value, 0x00, sizeof(start_time_value));
              uint8_t number_of_intervals_value;
        memset(&number_of_intervals_value, 0x00, sizeof(number_of_intervals_value));
      

      if ( uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              attributeid_value,

              start_time_value,

              number_of_intervals_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("GetMeasurementProfile")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_electrical_measurement_write_attributes_callback) {
      uic_mqtt_dotdot_electrical_measurement_state_t electrical_measurement_new_state = {};
      uic_mqtt_dotdot_electrical_measurement_updated_state_t electrical_measurement_new_updated_state = {};

      if(uic_mqtt_dotdot_electrical_measurement_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            electrical_measurement_new_state,
            electrical_measurement_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_electrical_measurement_force_read_attributes_callback) {
      uic_mqtt_dotdot_electrical_measurement_updated_state_t electrical_measurement_force_update = {0};

      if(uic_mqtt_dotdot_electrical_measurement_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            electrical_measurement_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/ElectricalMeasurement/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/ElectricalMeasurement/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // Diagnostics cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_diagnostics_write_attributes_callback) {
      uic_mqtt_dotdot_diagnostics_state_t diagnostics_new_state = {};
      uic_mqtt_dotdot_diagnostics_updated_state_t diagnostics_new_updated_state = {};

      if(uic_mqtt_dotdot_diagnostics_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            diagnostics_new_state,
            diagnostics_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_diagnostics_force_read_attributes_callback) {
      uic_mqtt_dotdot_diagnostics_updated_state_t diagnostics_force_update = {0};

      if(uic_mqtt_dotdot_diagnostics_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            diagnostics_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/Diagnostics/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/Diagnostics/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // TouchlinkCommissioning cluster
  // ProtocolController-RFTelemetry cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback) {
        const char* sourceunid_value;
        memset(&sourceunid_value, 0x00, sizeof(sourceunid_value));
              const char* destinationunid_value;
        memset(&destinationunid_value, 0x00, sizeof(destinationunid_value));
              bool transmission_successful_value;
        memset(&transmission_successful_value, 0x00, sizeof(transmission_successful_value));
              uint16_t transmission_time_ms_value;
        memset(&transmission_time_ms_value, 0x00, sizeof(transmission_time_ms_value));
              int8_t tx_powerd_bm_value;
        memset(&tx_powerd_bm_value, 0x00, sizeof(tx_powerd_bm_value));
              uint8_t tx_channel_value;
        memset(&tx_channel_value, 0x00, sizeof(tx_channel_value));
              uint8_t routing_attempts_value;
        memset(&routing_attempts_value, 0x00, sizeof(routing_attempts_value));
              bool route_changed_value;
        memset(&route_changed_value, 0x00, sizeof(route_changed_value));
              TxReportTransmissionSpeed transmission_speed_value;
        memset(&transmission_speed_value, 0x00, sizeof(transmission_speed_value));
              int8_t measured_noise_floord_bm_value;
        memset(&measured_noise_floord_bm_value, 0x00, sizeof(measured_noise_floord_bm_value));
              int8_t ackrssi_value;
        memset(&ackrssi_value, 0x00, sizeof(ackrssi_value));
              uint8_t ack_channel_value;
        memset(&ack_channel_value, 0x00, sizeof(ack_channel_value));
              const char* last_route_failed_link_functionalunid_value;
        memset(&last_route_failed_link_functionalunid_value, 0x00, sizeof(last_route_failed_link_functionalunid_value));
              const char* last_route_failed_link_non_functionalunid_value;
        memset(&last_route_failed_link_non_functionalunid_value, 0x00, sizeof(last_route_failed_link_non_functionalunid_value));
              int8_t destination_ack_tx_powerd_bm_value;
        memset(&destination_ack_tx_powerd_bm_value, 0x00, sizeof(destination_ack_tx_powerd_bm_value));
              int8_t destination_ack_measuredrssi_value;
        memset(&destination_ack_measuredrssi_value, 0x00, sizeof(destination_ack_measuredrssi_value));
              int8_t destination_ack_measured_noise_floor_value;
        memset(&destination_ack_measured_noise_floor_value, 0x00, sizeof(destination_ack_measured_noise_floor_value));
      

      if ( uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              sourceunid_value,

              destinationunid_value,

              transmission_successful_value,

              transmission_time_ms_value,

              tx_powerd_bm_value,

              tx_channel_value,

              routing_attempts_value,

              route_changed_value,

              transmission_speed_value,

              measured_noise_floord_bm_value,

              0,
              nullptr,

              0,
              nullptr,

              ackrssi_value,

              ack_channel_value,

              last_route_failed_link_functionalunid_value,

              last_route_failed_link_non_functionalunid_value,

              destination_ack_tx_powerd_bm_value,

              destination_ack_measuredrssi_value,

              destination_ack_measured_noise_floor_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("TxReport")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_callback) {
      uic_mqtt_dotdot_protocol_controller_rf_telemetry_state_t protocol_controller_rf_telemetry_new_state = {};
      uic_mqtt_dotdot_protocol_controller_rf_telemetry_updated_state_t protocol_controller_rf_telemetry_new_updated_state = {};

      if(uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            protocol_controller_rf_telemetry_new_state,
            protocol_controller_rf_telemetry_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_protocol_controller_rf_telemetry_force_read_attributes_callback) {
      uic_mqtt_dotdot_protocol_controller_rf_telemetry_updated_state_t protocol_controller_rf_telemetry_force_update = {0};

      if(uic_mqtt_dotdot_protocol_controller_rf_telemetry_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            protocol_controller_rf_telemetry_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    // No endpoint for this topic
    topic +=  "/ProtocolController/RFTelemetry/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/ProtocolController/RFTelemetry/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // State cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_state_remove_callback) {


      if ( uic_mqtt_dotdot_state_remove_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("Remove")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_state_remove_offline_callback) {


      if ( uic_mqtt_dotdot_state_remove_offline_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("RemoveOffline")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_state_discover_neighbors_callback) {


      if ( uic_mqtt_dotdot_state_discover_neighbors_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("DiscoverNeighbors")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_state_interview_callback) {


      if ( uic_mqtt_dotdot_state_interview_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("Interview")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_state_write_attributes_callback) {
      uic_mqtt_dotdot_state_state_t state_new_state = {};
      uic_mqtt_dotdot_state_updated_state_t state_new_updated_state = {};

      if(uic_mqtt_dotdot_state_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            state_new_state,
            state_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_state_force_read_attributes_callback) {
      uic_mqtt_dotdot_state_updated_state_t state_force_update = {0};

      if(uic_mqtt_dotdot_state_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            state_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    // No endpoint for this topic
    topic +=  "/State/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/State/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // Binding cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_binding_bind_callback) {
        const char* cluster_name_value;
        memset(&cluster_name_value, 0x00, sizeof(cluster_name_value));
              const char* destination_unid_value;
        memset(&destination_unid_value, 0x00, sizeof(destination_unid_value));
              uint8_t destination_ep_value;
        memset(&destination_ep_value, 0x00, sizeof(destination_ep_value));
      

      if ( uic_mqtt_dotdot_binding_bind_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              cluster_name_value,

              destination_unid_value,

              destination_ep_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("Bind")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_binding_unbind_callback) {
        const char* cluster_name_value;
        memset(&cluster_name_value, 0x00, sizeof(cluster_name_value));
              const char* destination_unid_value;
        memset(&destination_unid_value, 0x00, sizeof(destination_unid_value));
              uint8_t destination_ep_value;
        memset(&destination_ep_value, 0x00, sizeof(destination_ep_value));
      

      if ( uic_mqtt_dotdot_binding_unbind_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              cluster_name_value,

              destination_unid_value,

              destination_ep_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("Unbind")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback) {
        const char* cluster_name_value;
        memset(&cluster_name_value, 0x00, sizeof(cluster_name_value));
      

      if ( uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              cluster_name_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("BindToProtocolController")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback) {
        const char* cluster_name_value;
        memset(&cluster_name_value, 0x00, sizeof(cluster_name_value));
      

      if ( uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              cluster_name_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("UnbindFromProtocolController")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_binding_write_attributes_callback) {
      uic_mqtt_dotdot_binding_state_t binding_new_state = {};
      uic_mqtt_dotdot_binding_updated_state_t binding_new_updated_state = {};

      if(uic_mqtt_dotdot_binding_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            binding_new_state,
            binding_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_binding_force_read_attributes_callback) {
      uic_mqtt_dotdot_binding_updated_state_t binding_force_update = {0};

      if(uic_mqtt_dotdot_binding_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            binding_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/Binding/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/Binding/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // SystemMetrics cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_system_metrics_write_attributes_callback) {
      uic_mqtt_dotdot_system_metrics_state_t system_metrics_new_state = {};
      uic_mqtt_dotdot_system_metrics_updated_state_t system_metrics_new_updated_state = {};

      if(uic_mqtt_dotdot_system_metrics_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            system_metrics_new_state,
            system_metrics_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_system_metrics_force_read_attributes_callback) {
      uic_mqtt_dotdot_system_metrics_updated_state_t system_metrics_force_update = {0};

      if(uic_mqtt_dotdot_system_metrics_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            system_metrics_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    // No endpoint for this topic
    topic +=  "/SystemMetrics/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/SystemMetrics/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // ApplicationMonitoring cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_application_monitoring_log_entry_callback) {
        const char* timestamp_value;
        memset(&timestamp_value, 0x00, sizeof(timestamp_value));
              LoggingLevelEnum log_level_value;
        memset(&log_level_value, 0x00, sizeof(log_level_value));
              const char* log_tag_value;
        memset(&log_tag_value, 0x00, sizeof(log_tag_value));
              const char* log_message_value;
        memset(&log_message_value, 0x00, sizeof(log_message_value));
      

      if ( uic_mqtt_dotdot_application_monitoring_log_entry_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              timestamp_value,

              log_level_value,

              log_tag_value,

              log_message_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("LogEntry")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_application_monitoring_write_attributes_callback) {
      uic_mqtt_dotdot_application_monitoring_state_t application_monitoring_new_state = {};
      uic_mqtt_dotdot_application_monitoring_updated_state_t application_monitoring_new_updated_state = {};

      if(uic_mqtt_dotdot_application_monitoring_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            application_monitoring_new_state,
            application_monitoring_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_application_monitoring_force_read_attributes_callback) {
      uic_mqtt_dotdot_application_monitoring_updated_state_t application_monitoring_force_update = {0};

      if(uic_mqtt_dotdot_application_monitoring_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            application_monitoring_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    // No endpoint for this topic
    topic +=  "/ApplicationMonitoring/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/ApplicationMonitoring/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // NameAndLocation cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_name_and_location_write_attributes_callback) {
      uic_mqtt_dotdot_name_and_location_state_t name_and_location_new_state = {};
      uic_mqtt_dotdot_name_and_location_updated_state_t name_and_location_new_updated_state = {};

      if(uic_mqtt_dotdot_name_and_location_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            name_and_location_new_state,
            name_and_location_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_name_and_location_force_read_attributes_callback) {
      uic_mqtt_dotdot_name_and_location_updated_state_t name_and_location_force_update = {0};

      if(uic_mqtt_dotdot_name_and_location_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            name_and_location_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/NameAndLocation/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/NameAndLocation/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // ConfigurationParameters cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback) {
        uint16_t parameter_id_value;
        memset(&parameter_id_value, 0x00, sizeof(parameter_id_value));
      

      if ( uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              parameter_id_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("DiscoverParameter")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback) {


      if ( uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("DefaultResetAllParameters")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_configuration_parameters_set_parameter_callback) {
        uint16_t parameter_id_value;
        memset(&parameter_id_value, 0x00, sizeof(parameter_id_value));
              int64_t value_value;
        memset(&value_value, 0x00, sizeof(value_value));
      

      if ( uic_mqtt_dotdot_configuration_parameters_set_parameter_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              parameter_id_value,

              value_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("SetParameter")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_configuration_parameters_write_attributes_callback) {
      uic_mqtt_dotdot_configuration_parameters_state_t configuration_parameters_new_state = {};
      uic_mqtt_dotdot_configuration_parameters_updated_state_t configuration_parameters_new_updated_state = {};

      if(uic_mqtt_dotdot_configuration_parameters_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            configuration_parameters_new_state,
            configuration_parameters_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_configuration_parameters_force_read_attributes_callback) {
      uic_mqtt_dotdot_configuration_parameters_updated_state_t configuration_parameters_force_update = {0};

      if(uic_mqtt_dotdot_configuration_parameters_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            configuration_parameters_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/ConfigurationParameters/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/ConfigurationParameters/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // AoXLocator cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_aox_locator_iq_report_callback) {
        const char* tag_unid_value;
        memset(&tag_unid_value, 0x00, sizeof(tag_unid_value));
              uint8_t channel_value;
        memset(&channel_value, 0x00, sizeof(channel_value));
              int8_t rssi_value;
        memset(&rssi_value, 0x00, sizeof(rssi_value));
              int32_t sequence_value;
        memset(&sequence_value, 0x00, sizeof(sequence_value));
      

      if ( uic_mqtt_dotdot_aox_locator_iq_report_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              tag_unid_value,

              channel_value,

              rssi_value,

              0,
              nullptr,

              sequence_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("IQReport")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_aox_locator_angle_report_callback) {
        const char* tag_unid_value;
        memset(&tag_unid_value, 0x00, sizeof(tag_unid_value));
              SphericalCoordinates direction_value;
        memset(&direction_value, 0x00, sizeof(direction_value));
              SphericalCoordinates deviation_value;
        memset(&deviation_value, 0x00, sizeof(deviation_value));
              int32_t sequence_value;
        memset(&sequence_value, 0x00, sizeof(sequence_value));
      

      if ( uic_mqtt_dotdot_aox_locator_angle_report_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              tag_unid_value,

              direction_value,

              deviation_value,

              sequence_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("AngleReport")";
      }
    }
    // check if there is callback for each command
    if (uic_mqtt_dotdot_aox_locator_angle_correction_callback) {
        const char* tag_unid_value;
        memset(&tag_unid_value, 0x00, sizeof(tag_unid_value));
              SphericalCoordinates direction_value;
        memset(&direction_value, 0x00, sizeof(direction_value));
              SphericalCoordinates deviation_value;
        memset(&deviation_value, 0x00, sizeof(deviation_value));
              int32_t sequence_value;
        memset(&sequence_value, 0x00, sizeof(sequence_value));
      

      if ( uic_mqtt_dotdot_aox_locator_angle_correction_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
              tag_unid_value,

              direction_value,

              deviation_value,

              sequence_value

          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("AngleCorrection")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_aox_locator_write_attributes_callback) {
      uic_mqtt_dotdot_aox_locator_state_t aox_locator_new_state = {};
      uic_mqtt_dotdot_aox_locator_updated_state_t aox_locator_new_updated_state = {};

      if(uic_mqtt_dotdot_aox_locator_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            aox_locator_new_state,
            aox_locator_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_aox_locator_force_read_attributes_callback) {
      uic_mqtt_dotdot_aox_locator_updated_state_t aox_locator_force_update = {0};

      if(uic_mqtt_dotdot_aox_locator_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            aox_locator_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/AoXLocator/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/AoXLocator/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // AoXPositionEstimation cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback) {
      uic_mqtt_dotdot_aox_position_estimation_state_t aox_position_estimation_new_state = {};
      uic_mqtt_dotdot_aox_position_estimation_updated_state_t aox_position_estimation_new_updated_state = {};

      if(uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            aox_position_estimation_new_state,
            aox_position_estimation_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_aox_position_estimation_force_read_attributes_callback) {
      uic_mqtt_dotdot_aox_position_estimation_updated_state_t aox_position_estimation_force_update = {0};

      if(uic_mqtt_dotdot_aox_position_estimation_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            aox_position_estimation_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    topic +=  "/ep"+ std::to_string(endpoint);
    topic +=  "/AoXPositionEstimation/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/AoXPositionEstimation/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

  // ProtocolController-NetworkManagement cluster
  { // Reset our SupportedCommand stream for each cluster.
    ss.str("");
    first_command = true;
    // check if there is callback for each command
    if (uic_mqtt_dotdot_protocol_controller_network_management_write_callback) {


      if ( uic_mqtt_dotdot_protocol_controller_network_management_write_callback(
              unid,
              endpoint,
              UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
          ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("Write")";
      }
    }
    // Check for a WriteAttributes Callback
    if(uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_callback) {
      uic_mqtt_dotdot_protocol_controller_network_management_state_t protocol_controller_network_management_new_state = {};
      uic_mqtt_dotdot_protocol_controller_network_management_updated_state_t protocol_controller_network_management_new_updated_state = {};

      if(uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            protocol_controller_network_management_new_state,
            protocol_controller_network_management_new_updated_state
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("WriteAttributes")";
      }
    }

    // Check for a ForceReadAttributes Callback
    if(uic_mqtt_dotdot_protocol_controller_network_management_force_read_attributes_callback) {
      uic_mqtt_dotdot_protocol_controller_network_management_updated_state_t protocol_controller_network_management_force_update = {0};

      if(uic_mqtt_dotdot_protocol_controller_network_management_force_read_attributes_callback(
            unid,
            endpoint,
            UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
            protocol_controller_network_management_force_update
        ) == SL_STATUS_OK) {
        if (first_command == false) {
          ss << ", ";
        }
        first_command = false;
        ss << R"("ForceReadAttributes")";
      }
    }

    // Publish supported commands
    std::string topic = "ucl/by-unid/" + std::string(unid);
    // No endpoint for this topic
    topic +=  "/ProtocolController/NetworkManagement/SupportedCommands";
    std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
    if (first_command == false) {
      uic_mqtt_publish(topic.c_str(),
                       payload_str.c_str(),
                       payload_str.length(),
                       true);
    }

    // Make sure we publish some SupportedCommands if any attribute has been
    // published
    if (uic_mqtt_count_topics(topic.c_str()) == 0) {
      std::string attributes_topic = "ucl/by-unid/" + std::string(unid) + "/ep"
                                     + std::to_string(endpoint)
                                     + "/ProtocolController/NetworkManagement/Attributes";
      if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
        uic_mqtt_publish(topic.c_str(),
                         payload_str.c_str(),
                         payload_str.length(),
                         true);
      }
    }

  } // End of scope

}

  // Publishing Cluster Revision
  void uic_mqtt_dotdot_basic_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/Basic/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_power_configuration_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/PowerConfiguration/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_device_temperature_configuration_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/DeviceTemperatureConfiguration/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_identify_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/Identify/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_groups_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/Groups/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_scenes_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/Scenes/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_on_off_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/OnOff/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_level_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/Level/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_alarms_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/Alarms/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_time_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/Time/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_ota_upgrade_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/OTAUpgrade/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_poll_control_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/PollControl/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_shade_configuration_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/ShadeConfiguration/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_door_lock_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/DoorLock/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_window_covering_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/WindowCovering/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_barrier_control_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/BarrierControl/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_pump_configuration_and_control_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_thermostat_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/Thermostat/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_fan_control_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/FanControl/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_dehumidification_control_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/DehumidificationControl/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_thermostat_user_interface_configuration_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/ThermostatUserInterfaceConfiguration/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_color_control_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/ColorControl/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_ballast_configuration_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/BallastConfiguration/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_illuminance_measurement_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/IlluminanceMeasurement/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_illuminance_level_sensing_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/IlluminanceLevelSensing/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_temperature_measurement_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/TemperatureMeasurement/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_pressure_measurement_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/PressureMeasurement/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_flow_measurement_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/FlowMeasurement/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_relativity_humidity_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/RelativityHumidity/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_occupancy_sensing_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/OccupancySensing/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_ph_measurement_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/PhMeasurement/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_electrical_conductivity_measurement_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/ElectricalConductivityMeasurement/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_wind_speed_measurement_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/WindSpeedMeasurement/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_carbon_monoxide_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/CarbonMonoxide/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_ias_zone_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/IASZone/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_iaswd_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/IASWD/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_metering_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/Metering/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_electrical_measurement_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_diagnostics_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/Diagnostics/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_protocol_controller_rf_telemetry_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/ProtocolController/RFTelemetry/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_state_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/State/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_binding_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/Binding/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_system_metrics_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/SystemMetrics/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_application_monitoring_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_name_and_location_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/NameAndLocation/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_configuration_parameters_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/ConfigurationParameters/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_aox_locator_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/AoXLocator/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_aox_position_estimation_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/AoXPositionEstimation/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }
  // Publishing Cluster Revision
  void uic_mqtt_dotdot_protocol_controller_network_management_publish_cluster_revision(const char* base_topic, uint16_t value)
  {
    std::string cluster_topic = std::string(base_topic) + "/ProtocolController/NetworkManagement/Attributes/ClusterRevision";
    // Publish Desired
    std::string pub_topic_des = cluster_topic + "/Desired";
    std::string payload = std::string(R"({"value": )")
      + std::to_string(value) + std::string("}");
    uic_mqtt_publish(pub_topic_des.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
    // Publish Reported
    std::string pub_topic_rep = cluster_topic + "/Reported";
    uic_mqtt_publish(pub_topic_rep.c_str(),
                     payload.c_str(),
                     payload.size(),
                     true);
  }

////////////////////////////////////////////////////////////////////////////////
// Generated Commands publications functions
////////////////////////////////////////////////////////////////////////////////
/**
 * @brief Publishes an incoming/generated ResetToFactoryDefaults command for
 * the Basic cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Basic/GeneratedCommands/ResetToFactoryDefaults
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_basic_publish_generated_reset_to_factory_defaults_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Basic/GeneratedCommands/ResetToFactoryDefaults";

  std::string payload =
    get_json_payload_for_basic_reset_to_factory_defaults_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Identify command for
 * the Identify cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Identify/GeneratedCommands/Identify
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_identify_publish_generated_identify_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_identify_command_identify_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Identify/GeneratedCommands/Identify";

  std::string payload =
    get_json_payload_for_identify_identify_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated IdentifyQueryResponse command for
 * the Identify cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Identify/GeneratedCommands/IdentifyQueryResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_identify_publish_generated_identify_query_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_identify_command_identify_query_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Identify/GeneratedCommands/IdentifyQueryResponse";

  std::string payload =
    get_json_payload_for_identify_identify_query_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated IdentifyQuery command for
 * the Identify cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Identify/GeneratedCommands/IdentifyQuery
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_identify_publish_generated_identify_query_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Identify/GeneratedCommands/IdentifyQuery";

  std::string payload =
    get_json_payload_for_identify_identify_query_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated TriggerEffect command for
 * the Identify cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Identify/GeneratedCommands/TriggerEffect
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_identify_publish_generated_trigger_effect_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_identify_command_trigger_effect_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Identify/GeneratedCommands/TriggerEffect";

  std::string payload =
    get_json_payload_for_identify_trigger_effect_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated AddGroup command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/AddGroup
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_add_group_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_add_group_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/AddGroup";

  std::string payload =
    get_json_payload_for_groups_add_group_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated AddGroupResponse command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/AddGroupResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_add_group_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_add_group_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/AddGroupResponse";

  std::string payload =
    get_json_payload_for_groups_add_group_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ViewGroup command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/ViewGroup
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_view_group_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_view_group_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/ViewGroup";

  std::string payload =
    get_json_payload_for_groups_view_group_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ViewGroupResponse command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/ViewGroupResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_view_group_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_view_group_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/ViewGroupResponse";

  std::string payload =
    get_json_payload_for_groups_view_group_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetGroupMembership command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/GetGroupMembership
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_get_group_membership_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_get_group_membership_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/GetGroupMembership";

  std::string payload =
    get_json_payload_for_groups_get_group_membership_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetGroupMembershipResponse command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/GetGroupMembershipResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_get_group_membership_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_get_group_membership_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/GetGroupMembershipResponse";

  std::string payload =
    get_json_payload_for_groups_get_group_membership_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveGroup command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/RemoveGroup
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_remove_group_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_remove_group_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/RemoveGroup";

  std::string payload =
    get_json_payload_for_groups_remove_group_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveGroupResponse command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/RemoveGroupResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_remove_group_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_remove_group_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/RemoveGroupResponse";

  std::string payload =
    get_json_payload_for_groups_remove_group_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveAllGroups command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/RemoveAllGroups
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_remove_all_groups_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/RemoveAllGroups";

  std::string payload =
    get_json_payload_for_groups_remove_all_groups_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated AddGroupIfIdentifying command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/AddGroupIfIdentifying
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_add_group_if_identifying_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_add_group_if_identifying_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/AddGroupIfIdentifying";

  std::string payload =
    get_json_payload_for_groups_add_group_if_identifying_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated AddScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/AddScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_add_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_add_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/AddScene";

  std::string payload =
    get_json_payload_for_scenes_add_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated AddSceneResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/AddSceneResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_add_scene_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_add_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/AddSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_add_scene_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ViewScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/ViewScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_view_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_view_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/ViewScene";

  std::string payload =
    get_json_payload_for_scenes_view_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ViewSceneResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/ViewSceneResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_view_scene_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_view_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/ViewSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_view_scene_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/RemoveScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_remove_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_remove_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/RemoveScene";

  std::string payload =
    get_json_payload_for_scenes_remove_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveSceneResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/RemoveSceneResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_remove_scene_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_remove_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/RemoveSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_remove_scene_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveAllScenes command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/RemoveAllScenes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_remove_all_scenes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_remove_all_scenes_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/RemoveAllScenes";

  std::string payload =
    get_json_payload_for_scenes_remove_all_scenes_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveAllScenesResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/RemoveAllScenesResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_remove_all_scenes_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_remove_all_scenes_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/RemoveAllScenesResponse";

  std::string payload =
    get_json_payload_for_scenes_remove_all_scenes_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StoreScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/StoreScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_store_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_store_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/StoreScene";

  std::string payload =
    get_json_payload_for_scenes_store_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StoreSceneResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/StoreSceneResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_store_scene_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_store_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/StoreSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_store_scene_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RecallScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/RecallScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_recall_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_recall_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/RecallScene";

  std::string payload =
    get_json_payload_for_scenes_recall_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetSceneMembership command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/GetSceneMembership
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_get_scene_membership_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_get_scene_membership_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/GetSceneMembership";

  std::string payload =
    get_json_payload_for_scenes_get_scene_membership_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetSceneMembershipResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/GetSceneMembershipResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_get_scene_membership_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_get_scene_membership_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/GetSceneMembershipResponse";

  std::string payload =
    get_json_payload_for_scenes_get_scene_membership_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedAddScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/EnhancedAddScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_enhanced_add_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_enhanced_add_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/EnhancedAddScene";

  std::string payload =
    get_json_payload_for_scenes_enhanced_add_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedAddSceneResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/EnhancedAddSceneResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_enhanced_add_scene_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_enhanced_add_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/EnhancedAddSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_enhanced_add_scene_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedViewScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/EnhancedViewScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_enhanced_view_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_enhanced_view_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/EnhancedViewScene";

  std::string payload =
    get_json_payload_for_scenes_enhanced_view_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedViewSceneResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/EnhancedViewSceneResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_enhanced_view_scene_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_enhanced_view_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/EnhancedViewSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_enhanced_view_scene_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated CopyScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/CopyScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_copy_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_copy_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/CopyScene";

  std::string payload =
    get_json_payload_for_scenes_copy_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated CopySceneResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/CopySceneResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_copy_scene_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_copy_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/CopySceneResponse";

  std::string payload =
    get_json_payload_for_scenes_copy_scene_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Off command for
 * the OnOff cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/GeneratedCommands/Off
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_on_off_publish_generated_off_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OnOff/GeneratedCommands/Off";

  std::string payload =
    get_json_payload_for_on_off_off_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated On command for
 * the OnOff cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/GeneratedCommands/On
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_on_off_publish_generated_on_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OnOff/GeneratedCommands/On";

  std::string payload =
    get_json_payload_for_on_off_on_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Toggle command for
 * the OnOff cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/GeneratedCommands/Toggle
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_on_off_publish_generated_toggle_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OnOff/GeneratedCommands/Toggle";

  std::string payload =
    get_json_payload_for_on_off_toggle_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated OffWithEffect command for
 * the OnOff cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/GeneratedCommands/OffWithEffect
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_on_off_publish_generated_off_with_effect_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_on_off_command_off_with_effect_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OnOff/GeneratedCommands/OffWithEffect";

  std::string payload =
    get_json_payload_for_on_off_off_with_effect_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated OnWithRecallGlobalScene command for
 * the OnOff cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/GeneratedCommands/OnWithRecallGlobalScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_on_off_publish_generated_on_with_recall_global_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OnOff/GeneratedCommands/OnWithRecallGlobalScene";

  std::string payload =
    get_json_payload_for_on_off_on_with_recall_global_scene_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated OnWithTimedOff command for
 * the OnOff cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/GeneratedCommands/OnWithTimedOff
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_on_off_publish_generated_on_with_timed_off_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_on_off_command_on_with_timed_off_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OnOff/GeneratedCommands/OnWithTimedOff";

  std::string payload =
    get_json_payload_for_on_off_on_with_timed_off_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveToLevel command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/MoveToLevel
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_move_to_level_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_move_to_level_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/MoveToLevel";

  std::string payload =
    get_json_payload_for_level_move_to_level_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Move command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/Move
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_move_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_move_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/Move";

  std::string payload =
    get_json_payload_for_level_move_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Step command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/Step
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_step_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_step_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/Step";

  std::string payload =
    get_json_payload_for_level_step_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Stop command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/Stop
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_stop_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_stop_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/Stop";

  std::string payload =
    get_json_payload_for_level_stop_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveToLevelWithOnOff command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/MoveToLevelWithOnOff
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_move_to_level_with_on_off_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_move_to_level_with_on_off_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/MoveToLevelWithOnOff";

  std::string payload =
    get_json_payload_for_level_move_to_level_with_on_off_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveWithOnOff command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/MoveWithOnOff
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_move_with_on_off_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_move_with_on_off_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/MoveWithOnOff";

  std::string payload =
    get_json_payload_for_level_move_with_on_off_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StepWithOnOff command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/StepWithOnOff
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_step_with_on_off_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_step_with_on_off_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/StepWithOnOff";

  std::string payload =
    get_json_payload_for_level_step_with_on_off_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StopWithOnOff command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/StopWithOnOff
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_stop_with_on_off_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_stop_with_on_off_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/StopWithOnOff";

  std::string payload =
    get_json_payload_for_level_stop_with_on_off_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveToClosestFrequency command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/MoveToClosestFrequency
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_move_to_closest_frequency_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_move_to_closest_frequency_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/MoveToClosestFrequency";

  std::string payload =
    get_json_payload_for_level_move_to_closest_frequency_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ResetAlarm command for
 * the Alarms cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/GeneratedCommands/ResetAlarm
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_alarms_publish_generated_reset_alarm_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_alarms_command_reset_alarm_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Alarms/GeneratedCommands/ResetAlarm";

  std::string payload =
    get_json_payload_for_alarms_reset_alarm_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Alarm command for
 * the Alarms cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/GeneratedCommands/Alarm
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_alarms_publish_generated_alarm_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_alarms_command_alarm_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Alarms/GeneratedCommands/Alarm";

  std::string payload =
    get_json_payload_for_alarms_alarm_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ResetAllAlarms command for
 * the Alarms cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/GeneratedCommands/ResetAllAlarms
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_alarms_publish_generated_reset_all_alarms_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Alarms/GeneratedCommands/ResetAllAlarms";

  std::string payload =
    get_json_payload_for_alarms_reset_all_alarms_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetAlarmResponse command for
 * the Alarms cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/GeneratedCommands/GetAlarmResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_alarms_publish_generated_get_alarm_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_alarms_command_get_alarm_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Alarms/GeneratedCommands/GetAlarmResponse";

  std::string payload =
    get_json_payload_for_alarms_get_alarm_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetAlarm command for
 * the Alarms cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/GeneratedCommands/GetAlarm
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_alarms_publish_generated_get_alarm_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Alarms/GeneratedCommands/GetAlarm";

  std::string payload =
    get_json_payload_for_alarms_get_alarm_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ResetAlarmLog command for
 * the Alarms cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/GeneratedCommands/ResetAlarmLog
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_alarms_publish_generated_reset_alarm_log_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Alarms/GeneratedCommands/ResetAlarmLog";

  std::string payload =
    get_json_payload_for_alarms_reset_alarm_log_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ImageNotify command for
 * the OTAUpgrade cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OTAUpgrade/GeneratedCommands/ImageNotify
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_generated_image_notify_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ota_upgrade_command_image_notify_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OTAUpgrade/GeneratedCommands/ImageNotify";

  std::string payload =
    get_json_payload_for_ota_upgrade_image_notify_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated QueryNextImageRequest command for
 * the OTAUpgrade cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OTAUpgrade/GeneratedCommands/QueryNextImageRequest
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_generated_query_next_image_request_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ota_upgrade_command_query_next_image_request_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OTAUpgrade/GeneratedCommands/QueryNextImageRequest";

  std::string payload =
    get_json_payload_for_ota_upgrade_query_next_image_request_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated QueryNextImageResponse command for
 * the OTAUpgrade cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OTAUpgrade/GeneratedCommands/QueryNextImageResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_generated_query_next_image_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ota_upgrade_command_query_next_image_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OTAUpgrade/GeneratedCommands/QueryNextImageResponse";

  std::string payload =
    get_json_payload_for_ota_upgrade_query_next_image_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ImageBlockRequest command for
 * the OTAUpgrade cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OTAUpgrade/GeneratedCommands/ImageBlockRequest
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_generated_image_block_request_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ota_upgrade_command_image_block_request_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OTAUpgrade/GeneratedCommands/ImageBlockRequest";

  std::string payload =
    get_json_payload_for_ota_upgrade_image_block_request_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ImagePageRequest command for
 * the OTAUpgrade cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OTAUpgrade/GeneratedCommands/ImagePageRequest
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_generated_image_page_request_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ota_upgrade_command_image_page_request_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OTAUpgrade/GeneratedCommands/ImagePageRequest";

  std::string payload =
    get_json_payload_for_ota_upgrade_image_page_request_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ImageBlockResponse command for
 * the OTAUpgrade cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OTAUpgrade/GeneratedCommands/ImageBlockResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_generated_image_block_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ota_upgrade_command_image_block_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OTAUpgrade/GeneratedCommands/ImageBlockResponse";

  std::string payload =
    get_json_payload_for_ota_upgrade_image_block_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated UpgradeEndRequest command for
 * the OTAUpgrade cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OTAUpgrade/GeneratedCommands/UpgradeEndRequest
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_generated_upgrade_end_request_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ota_upgrade_command_upgrade_end_request_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OTAUpgrade/GeneratedCommands/UpgradeEndRequest";

  std::string payload =
    get_json_payload_for_ota_upgrade_upgrade_end_request_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated UpgradeEndResponse command for
 * the OTAUpgrade cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OTAUpgrade/GeneratedCommands/UpgradeEndResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_generated_upgrade_end_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ota_upgrade_command_upgrade_end_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OTAUpgrade/GeneratedCommands/UpgradeEndResponse";

  std::string payload =
    get_json_payload_for_ota_upgrade_upgrade_end_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated QueryDeviceSpecificFileRequest command for
 * the OTAUpgrade cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OTAUpgrade/GeneratedCommands/QueryDeviceSpecificFileRequest
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_generated_query_device_specific_file_request_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ota_upgrade_command_query_device_specific_file_request_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OTAUpgrade/GeneratedCommands/QueryDeviceSpecificFileRequest";

  std::string payload =
    get_json_payload_for_ota_upgrade_query_device_specific_file_request_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated QueryDeviceSpecificFileResponse command for
 * the OTAUpgrade cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OTAUpgrade/GeneratedCommands/QueryDeviceSpecificFileResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ota_upgrade_publish_generated_query_device_specific_file_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ota_upgrade_command_query_device_specific_file_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OTAUpgrade/GeneratedCommands/QueryDeviceSpecificFileResponse";

  std::string payload =
    get_json_payload_for_ota_upgrade_query_device_specific_file_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated CheckIn command for
 * the PollControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PollControl/GeneratedCommands/CheckIn
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_generated_check_in_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "PollControl/GeneratedCommands/CheckIn";

  std::string payload =
    get_json_payload_for_poll_control_check_in_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated CheckInResponse command for
 * the PollControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PollControl/GeneratedCommands/CheckInResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_generated_check_in_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_poll_control_command_check_in_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "PollControl/GeneratedCommands/CheckInResponse";

  std::string payload =
    get_json_payload_for_poll_control_check_in_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated FastPollStop command for
 * the PollControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PollControl/GeneratedCommands/FastPollStop
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_generated_fast_poll_stop_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "PollControl/GeneratedCommands/FastPollStop";

  std::string payload =
    get_json_payload_for_poll_control_fast_poll_stop_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetLongPollInterval command for
 * the PollControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PollControl/GeneratedCommands/SetLongPollInterval
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_generated_set_long_poll_interval_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_poll_control_command_set_long_poll_interval_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "PollControl/GeneratedCommands/SetLongPollInterval";

  std::string payload =
    get_json_payload_for_poll_control_set_long_poll_interval_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetShortPollInterval command for
 * the PollControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PollControl/GeneratedCommands/SetShortPollInterval
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_generated_set_short_poll_interval_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_poll_control_command_set_short_poll_interval_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "PollControl/GeneratedCommands/SetShortPollInterval";

  std::string payload =
    get_json_payload_for_poll_control_set_short_poll_interval_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated LockDoor command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/LockDoor
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_lock_door_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_lock_door_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/LockDoor";

  std::string payload =
    get_json_payload_for_door_lock_lock_door_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated LockDoorResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/LockDoorResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_lock_door_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_lock_door_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/LockDoorResponse";

  std::string payload =
    get_json_payload_for_door_lock_lock_door_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated UnlockDoor command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/UnlockDoor
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_unlock_door_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_unlock_door_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/UnlockDoor";

  std::string payload =
    get_json_payload_for_door_lock_unlock_door_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated UnlockDoorResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/UnlockDoorResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_unlock_door_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_unlock_door_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/UnlockDoorResponse";

  std::string payload =
    get_json_payload_for_door_lock_unlock_door_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Toggle command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/Toggle
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_toggle_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_toggle_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/Toggle";

  std::string payload =
    get_json_payload_for_door_lock_toggle_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ToggleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ToggleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_toggle_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_toggle_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ToggleResponse";

  std::string payload =
    get_json_payload_for_door_lock_toggle_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated UnlockWithTimeout command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/UnlockWithTimeout
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_unlock_with_timeout_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_unlock_with_timeout_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/UnlockWithTimeout";

  std::string payload =
    get_json_payload_for_door_lock_unlock_with_timeout_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated UnlockWithTimeoutResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/UnlockWithTimeoutResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_unlock_with_timeout_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_unlock_with_timeout_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/UnlockWithTimeoutResponse";

  std::string payload =
    get_json_payload_for_door_lock_unlock_with_timeout_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetLogRecord command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetLogRecord
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_log_record_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_log_record_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetLogRecord";

  std::string payload =
    get_json_payload_for_door_lock_get_log_record_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetLogRecordResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetLogRecordResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_log_record_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_log_record_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetLogRecordResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_log_record_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetPINCode command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetPINCode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_setpin_code_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_setpin_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetPINCode";

  std::string payload =
    get_json_payload_for_door_lock_setpin_code_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetPINCodeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetPINCodeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_setpin_code_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_setpin_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetPINCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_setpin_code_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetPINCode command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetPINCode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_getpin_code_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_getpin_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetPINCode";

  std::string payload =
    get_json_payload_for_door_lock_getpin_code_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetPINCodeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetPINCodeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_getpin_code_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_getpin_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetPINCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_getpin_code_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearPINCode command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearPINCode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clearpin_code_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clearpin_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearPINCode";

  std::string payload =
    get_json_payload_for_door_lock_clearpin_code_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearPINCodeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearPINCodeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clearpin_code_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clearpin_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearPINCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_clearpin_code_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearAllPINCodes command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearAllPINCodes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_allpin_codes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearAllPINCodes";

  std::string payload =
    get_json_payload_for_door_lock_clear_allpin_codes_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearAllPINCodesResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearAllPINCodesResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_allpin_codes_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_allpin_codes_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearAllPINCodesResponse";

  std::string payload =
    get_json_payload_for_door_lock_clear_allpin_codes_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetUserStatus command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetUserStatus
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_user_status_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_user_status_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetUserStatus";

  std::string payload =
    get_json_payload_for_door_lock_set_user_status_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetUserStatusResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetUserStatusResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_user_status_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_user_status_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetUserStatusResponse";

  std::string payload =
    get_json_payload_for_door_lock_set_user_status_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetUserStatus command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetUserStatus
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_user_status_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_user_status_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetUserStatus";

  std::string payload =
    get_json_payload_for_door_lock_get_user_status_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetUserStatusResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetUserStatusResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_user_status_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_user_status_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetUserStatusResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_user_status_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetWeekdaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetWeekdaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_weekday_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_weekday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetWeekdaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_set_weekday_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetWeekdayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetWeekdayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_weekday_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_weekday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetWeekdayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_set_weekday_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetWeekdaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetWeekdaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_weekday_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_weekday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetWeekdaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_get_weekday_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetWeekdayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetWeekdayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_weekday_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_weekday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetWeekdayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_weekday_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearWeekdaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearWeekdaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_weekday_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_weekday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearWeekdaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_clear_weekday_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearWeekdayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearWeekdayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_weekday_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_weekday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearWeekdayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_clear_weekday_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetYearDaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetYearDaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_year_day_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_year_day_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetYearDaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_set_year_day_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetYearDayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetYearDayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_year_day_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_year_day_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetYearDayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_set_year_day_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetYearDaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetYearDaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_year_day_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_year_day_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetYearDaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_get_year_day_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetYearDayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetYearDayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_year_day_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_year_day_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetYearDayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_year_day_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearYearDaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearYearDaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_year_day_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_year_day_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearYearDaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_clear_year_day_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearYearDayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearYearDayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_year_day_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_year_day_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearYearDayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_clear_year_day_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetHolidaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetHolidaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_holiday_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_holiday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetHolidaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_set_holiday_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetHolidayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetHolidayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_holiday_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_holiday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetHolidayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_set_holiday_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetHolidaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetHolidaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_holiday_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_holiday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetHolidaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_get_holiday_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetHolidayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetHolidayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_holiday_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_holiday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetHolidayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_holiday_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearHolidaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearHolidaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_holiday_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_holiday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearHolidaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_clear_holiday_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearHolidayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearHolidayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_holiday_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_holiday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearHolidayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_clear_holiday_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetUserType command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetUserType
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_user_type_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_user_type_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetUserType";

  std::string payload =
    get_json_payload_for_door_lock_set_user_type_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetUserTypeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetUserTypeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_user_type_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_user_type_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetUserTypeResponse";

  std::string payload =
    get_json_payload_for_door_lock_set_user_type_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetUserType command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetUserType
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_user_type_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_user_type_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetUserType";

  std::string payload =
    get_json_payload_for_door_lock_get_user_type_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetUserTypeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetUserTypeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_user_type_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_user_type_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetUserTypeResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_user_type_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetRFIDCode command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetRFIDCode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_setrfid_code_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_setrfid_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetRFIDCode";

  std::string payload =
    get_json_payload_for_door_lock_setrfid_code_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetRFIDCodeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetRFIDCodeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_setrfid_code_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_setrfid_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetRFIDCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_setrfid_code_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetRFIDCode command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetRFIDCode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_getrfid_code_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_getrfid_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetRFIDCode";

  std::string payload =
    get_json_payload_for_door_lock_getrfid_code_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetRFIDCodeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetRFIDCodeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_getrfid_code_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_getrfid_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetRFIDCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_getrfid_code_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearRFIDCode command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearRFIDCode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clearrfid_code_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clearrfid_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearRFIDCode";

  std::string payload =
    get_json_payload_for_door_lock_clearrfid_code_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearRFIDCodeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearRFIDCodeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clearrfid_code_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clearrfid_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearRFIDCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_clearrfid_code_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearAllRFIDCodes command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearAllRFIDCodes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_allrfid_codes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearAllRFIDCodes";

  std::string payload =
    get_json_payload_for_door_lock_clear_allrfid_codes_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearAllRFIDCodesResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearAllRFIDCodesResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_allrfid_codes_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_allrfid_codes_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearAllRFIDCodesResponse";

  std::string payload =
    get_json_payload_for_door_lock_clear_allrfid_codes_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated OperatingEventNotification command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/OperatingEventNotification
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_operating_event_notification_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_operating_event_notification_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/OperatingEventNotification";

  std::string payload =
    get_json_payload_for_door_lock_operating_event_notification_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ProgrammingEventNotification command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ProgrammingEventNotification
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_programming_event_notification_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_programming_event_notification_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ProgrammingEventNotification";

  std::string payload =
    get_json_payload_for_door_lock_programming_event_notification_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated UpOrOpen command for
 * the WindowCovering cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/GeneratedCommands/UpOrOpen
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_generated_up_or_open_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "WindowCovering/GeneratedCommands/UpOrOpen";

  std::string payload =
    get_json_payload_for_window_covering_up_or_open_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated DownOrClose command for
 * the WindowCovering cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/GeneratedCommands/DownOrClose
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_generated_down_or_close_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "WindowCovering/GeneratedCommands/DownOrClose";

  std::string payload =
    get_json_payload_for_window_covering_down_or_close_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Stop command for
 * the WindowCovering cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/GeneratedCommands/Stop
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_generated_stop_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "WindowCovering/GeneratedCommands/Stop";

  std::string payload =
    get_json_payload_for_window_covering_stop_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GoToLiftValue command for
 * the WindowCovering cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/GeneratedCommands/GoToLiftValue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_generated_go_to_lift_value_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_window_covering_command_go_to_lift_value_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "WindowCovering/GeneratedCommands/GoToLiftValue";

  std::string payload =
    get_json_payload_for_window_covering_go_to_lift_value_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GoToLiftPercentage command for
 * the WindowCovering cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/GeneratedCommands/GoToLiftPercentage
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_generated_go_to_lift_percentage_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_window_covering_command_go_to_lift_percentage_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "WindowCovering/GeneratedCommands/GoToLiftPercentage";

  std::string payload =
    get_json_payload_for_window_covering_go_to_lift_percentage_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GoToTiltValue command for
 * the WindowCovering cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/GeneratedCommands/GoToTiltValue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_generated_go_to_tilt_value_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_window_covering_command_go_to_tilt_value_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "WindowCovering/GeneratedCommands/GoToTiltValue";

  std::string payload =
    get_json_payload_for_window_covering_go_to_tilt_value_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GoToTiltPercentage command for
 * the WindowCovering cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/GeneratedCommands/GoToTiltPercentage
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_generated_go_to_tilt_percentage_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_window_covering_command_go_to_tilt_percentage_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "WindowCovering/GeneratedCommands/GoToTiltPercentage";

  std::string payload =
    get_json_payload_for_window_covering_go_to_tilt_percentage_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GoToPercent command for
 * the BarrierControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/BarrierControl/GeneratedCommands/GoToPercent
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_barrier_control_publish_generated_go_to_percent_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_barrier_control_command_go_to_percent_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "BarrierControl/GeneratedCommands/GoToPercent";

  std::string payload =
    get_json_payload_for_barrier_control_go_to_percent_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Stop command for
 * the BarrierControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/BarrierControl/GeneratedCommands/Stop
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_barrier_control_publish_generated_stop_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "BarrierControl/GeneratedCommands/Stop";

  std::string payload =
    get_json_payload_for_barrier_control_stop_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetpointRaiseOrLower command for
 * the Thermostat cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/GeneratedCommands/SetpointRaiseOrLower
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_generated_setpoint_raise_or_lower_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_thermostat_command_setpoint_raise_or_lower_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Thermostat/GeneratedCommands/SetpointRaiseOrLower";

  std::string payload =
    get_json_payload_for_thermostat_setpoint_raise_or_lower_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetWeeklyScheduleResponse command for
 * the Thermostat cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/GeneratedCommands/GetWeeklyScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_generated_get_weekly_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_thermostat_command_get_weekly_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Thermostat/GeneratedCommands/GetWeeklyScheduleResponse";

  std::string payload =
    get_json_payload_for_thermostat_get_weekly_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetWeeklySchedule command for
 * the Thermostat cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/GeneratedCommands/SetWeeklySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_generated_set_weekly_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_thermostat_command_set_weekly_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Thermostat/GeneratedCommands/SetWeeklySchedule";

  std::string payload =
    get_json_payload_for_thermostat_set_weekly_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetRelayStatusLogResponse command for
 * the Thermostat cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/GeneratedCommands/GetRelayStatusLogResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_generated_get_relay_status_log_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_thermostat_command_get_relay_status_log_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Thermostat/GeneratedCommands/GetRelayStatusLogResponse";

  std::string payload =
    get_json_payload_for_thermostat_get_relay_status_log_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetWeeklySchedule command for
 * the Thermostat cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/GeneratedCommands/GetWeeklySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_generated_get_weekly_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_thermostat_command_get_weekly_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Thermostat/GeneratedCommands/GetWeeklySchedule";

  std::string payload =
    get_json_payload_for_thermostat_get_weekly_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearWeeklySchedule command for
 * the Thermostat cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/GeneratedCommands/ClearWeeklySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_generated_clear_weekly_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Thermostat/GeneratedCommands/ClearWeeklySchedule";

  std::string payload =
    get_json_payload_for_thermostat_clear_weekly_schedule_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetRelayStatusLog command for
 * the Thermostat cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/GeneratedCommands/GetRelayStatusLog
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_generated_get_relay_status_log_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Thermostat/GeneratedCommands/GetRelayStatusLog";

  std::string payload =
    get_json_payload_for_thermostat_get_relay_status_log_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveToHue command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveToHue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_to_hue_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_to_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveToHue";

  std::string payload =
    get_json_payload_for_color_control_move_to_hue_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveHue command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveHue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_hue_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveHue";

  std::string payload =
    get_json_payload_for_color_control_move_hue_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StepHue command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/StepHue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_step_hue_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_step_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/StepHue";

  std::string payload =
    get_json_payload_for_color_control_step_hue_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveToSaturation command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveToSaturation
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_to_saturation_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_to_saturation_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveToSaturation";

  std::string payload =
    get_json_payload_for_color_control_move_to_saturation_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveSaturation command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveSaturation
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_saturation_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_saturation_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveSaturation";

  std::string payload =
    get_json_payload_for_color_control_move_saturation_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StepSaturation command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/StepSaturation
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_step_saturation_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_step_saturation_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/StepSaturation";

  std::string payload =
    get_json_payload_for_color_control_step_saturation_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveToHueAndSaturation command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveToHueAndSaturation
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_to_hue_and_saturation_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_to_hue_and_saturation_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveToHueAndSaturation";

  std::string payload =
    get_json_payload_for_color_control_move_to_hue_and_saturation_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveToColor command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveToColor
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_to_color_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_to_color_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveToColor";

  std::string payload =
    get_json_payload_for_color_control_move_to_color_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveColor command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveColor
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_color_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_color_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveColor";

  std::string payload =
    get_json_payload_for_color_control_move_color_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StepColor command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/StepColor
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_step_color_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_step_color_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/StepColor";

  std::string payload =
    get_json_payload_for_color_control_step_color_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveToColorTemperature command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveToColorTemperature
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_to_color_temperature_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_to_color_temperature_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveToColorTemperature";

  std::string payload =
    get_json_payload_for_color_control_move_to_color_temperature_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedMoveToHue command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/EnhancedMoveToHue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_enhanced_move_to_hue_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_enhanced_move_to_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/EnhancedMoveToHue";

  std::string payload =
    get_json_payload_for_color_control_enhanced_move_to_hue_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedMoveHue command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/EnhancedMoveHue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_enhanced_move_hue_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_enhanced_move_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/EnhancedMoveHue";

  std::string payload =
    get_json_payload_for_color_control_enhanced_move_hue_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedStepHue command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/EnhancedStepHue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_enhanced_step_hue_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_enhanced_step_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/EnhancedStepHue";

  std::string payload =
    get_json_payload_for_color_control_enhanced_step_hue_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedMoveToHueAndSaturation command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/EnhancedMoveToHueAndSaturation
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_enhanced_move_to_hue_and_saturation_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_enhanced_move_to_hue_and_saturation_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/EnhancedMoveToHueAndSaturation";

  std::string payload =
    get_json_payload_for_color_control_enhanced_move_to_hue_and_saturation_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ColorLoopSet command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/ColorLoopSet
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_color_loop_set_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_color_loop_set_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/ColorLoopSet";

  std::string payload =
    get_json_payload_for_color_control_color_loop_set_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StopMoveStep command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/StopMoveStep
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_stop_move_step_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_stop_move_step_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/StopMoveStep";

  std::string payload =
    get_json_payload_for_color_control_stop_move_step_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveColorTemperature command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveColorTemperature
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_color_temperature_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_color_temperature_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveColorTemperature";

  std::string payload =
    get_json_payload_for_color_control_move_color_temperature_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StepColorTemperature command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/StepColorTemperature
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_step_color_temperature_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_step_color_temperature_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/StepColorTemperature";

  std::string payload =
    get_json_payload_for_color_control_step_color_temperature_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ZoneEnrollResponse command for
 * the IASZone cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASZone/GeneratedCommands/ZoneEnrollResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_generated_zone_enroll_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ias_zone_command_zone_enroll_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IASZone/GeneratedCommands/ZoneEnrollResponse";

  std::string payload =
    get_json_payload_for_ias_zone_zone_enroll_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ZoneStatusChangeNotification command for
 * the IASZone cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASZone/GeneratedCommands/ZoneStatusChangeNotification
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_generated_zone_status_change_notification_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ias_zone_command_zone_status_change_notification_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IASZone/GeneratedCommands/ZoneStatusChangeNotification";

  std::string payload =
    get_json_payload_for_ias_zone_zone_status_change_notification_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated InitiateNormalOperationMode command for
 * the IASZone cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASZone/GeneratedCommands/InitiateNormalOperationMode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_generated_initiate_normal_operation_mode_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IASZone/GeneratedCommands/InitiateNormalOperationMode";

  std::string payload =
    get_json_payload_for_ias_zone_initiate_normal_operation_mode_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ZoneEnrollRequest command for
 * the IASZone cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASZone/GeneratedCommands/ZoneEnrollRequest
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_generated_zone_enroll_request_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ias_zone_command_zone_enroll_request_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IASZone/GeneratedCommands/ZoneEnrollRequest";

  std::string payload =
    get_json_payload_for_ias_zone_zone_enroll_request_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated InitiateTestMode command for
 * the IASZone cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASZone/GeneratedCommands/InitiateTestMode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_generated_initiate_test_mode_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ias_zone_command_initiate_test_mode_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IASZone/GeneratedCommands/InitiateTestMode";

  std::string payload =
    get_json_payload_for_ias_zone_initiate_test_mode_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StartWarning command for
 * the IASWD cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASWD/GeneratedCommands/StartWarning
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_iaswd_publish_generated_start_warning_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_iaswd_command_start_warning_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IASWD/GeneratedCommands/StartWarning";

  std::string payload =
    get_json_payload_for_iaswd_start_warning_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Squawk command for
 * the IASWD cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASWD/GeneratedCommands/Squawk
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_iaswd_publish_generated_squawk_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_iaswd_command_squawk_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IASWD/GeneratedCommands/Squawk";

  std::string payload =
    get_json_payload_for_iaswd_squawk_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetProfileInfoResponse command for
 * the ElectricalMeasurement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ElectricalMeasurement/GeneratedCommands/GetProfileInfoResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_electrical_measurement_publish_generated_get_profile_info_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_electrical_measurement_command_get_profile_info_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ElectricalMeasurement/GeneratedCommands/GetProfileInfoResponse";

  std::string payload =
    get_json_payload_for_electrical_measurement_get_profile_info_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetProfileInfo command for
 * the ElectricalMeasurement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ElectricalMeasurement/GeneratedCommands/GetProfileInfo
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_electrical_measurement_publish_generated_get_profile_info_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ElectricalMeasurement/GeneratedCommands/GetProfileInfo";

  std::string payload =
    get_json_payload_for_electrical_measurement_get_profile_info_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetMeasurementProfileResponse command for
 * the ElectricalMeasurement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ElectricalMeasurement/GeneratedCommands/GetMeasurementProfileResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_electrical_measurement_publish_generated_get_measurement_profile_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_electrical_measurement_command_get_measurement_profile_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ElectricalMeasurement/GeneratedCommands/GetMeasurementProfileResponse";

  std::string payload =
    get_json_payload_for_electrical_measurement_get_measurement_profile_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetMeasurementProfile command for
 * the ElectricalMeasurement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ElectricalMeasurement/GeneratedCommands/GetMeasurementProfile
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_electrical_measurement_publish_generated_get_measurement_profile_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_electrical_measurement_command_get_measurement_profile_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ElectricalMeasurement/GeneratedCommands/GetMeasurementProfile";

  std::string payload =
    get_json_payload_for_electrical_measurement_get_measurement_profile_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated TxReport command for
 * the ProtocolController-RFTelemetry cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/ProtocolController/RFTelemetry/GeneratedCommands/TxReport
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_protocol_controller_rf_telemetry_publish_generated_tx_report_command(
  const dotdot_unid_t unid,
  const uic_mqtt_dotdot_protocol_controller_rf_telemetry_command_tx_report_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "ProtocolController/RFTelemetry/GeneratedCommands/TxReport";

  std::string payload =
    get_json_payload_for_protocol_controller_rf_telemetry_tx_report_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Remove command for
 * the State cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/State/GeneratedCommands/Remove
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_state_publish_generated_remove_command(
  const dotdot_unid_t unid
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "State/GeneratedCommands/Remove";

  std::string payload =
    get_json_payload_for_state_remove_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveOffline command for
 * the State cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/State/GeneratedCommands/RemoveOffline
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_state_publish_generated_remove_offline_command(
  const dotdot_unid_t unid
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "State/GeneratedCommands/RemoveOffline";

  std::string payload =
    get_json_payload_for_state_remove_offline_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated DiscoverNeighbors command for
 * the State cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/State/GeneratedCommands/DiscoverNeighbors
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_state_publish_generated_discover_neighbors_command(
  const dotdot_unid_t unid
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "State/GeneratedCommands/DiscoverNeighbors";

  std::string payload =
    get_json_payload_for_state_discover_neighbors_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Interview command for
 * the State cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/State/GeneratedCommands/Interview
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_state_publish_generated_interview_command(
  const dotdot_unid_t unid
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "State/GeneratedCommands/Interview";

  std::string payload =
    get_json_payload_for_state_interview_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Bind command for
 * the Binding cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Binding/GeneratedCommands/Bind
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_binding_publish_generated_bind_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_binding_command_bind_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Binding/GeneratedCommands/Bind";

  std::string payload =
    get_json_payload_for_binding_bind_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Unbind command for
 * the Binding cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Binding/GeneratedCommands/Unbind
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_binding_publish_generated_unbind_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_binding_command_unbind_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Binding/GeneratedCommands/Unbind";

  std::string payload =
    get_json_payload_for_binding_unbind_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated BindToProtocolController command for
 * the Binding cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Binding/GeneratedCommands/BindToProtocolController
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_binding_publish_generated_bind_to_protocol_controller_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_binding_command_bind_to_protocol_controller_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Binding/GeneratedCommands/BindToProtocolController";

  std::string payload =
    get_json_payload_for_binding_bind_to_protocol_controller_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated UnbindFromProtocolController command for
 * the Binding cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Binding/GeneratedCommands/UnbindFromProtocolController
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_binding_publish_generated_unbind_from_protocol_controller_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_binding_command_unbind_from_protocol_controller_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Binding/GeneratedCommands/UnbindFromProtocolController";

  std::string payload =
    get_json_payload_for_binding_unbind_from_protocol_controller_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated LogEntry command for
 * the ApplicationMonitoring cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/ApplicationMonitoring/GeneratedCommands/LogEntry
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_application_monitoring_publish_generated_log_entry_command(
  const dotdot_unid_t unid,
  const uic_mqtt_dotdot_application_monitoring_command_log_entry_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "ApplicationMonitoring/GeneratedCommands/LogEntry";

  std::string payload =
    get_json_payload_for_application_monitoring_log_entry_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated DiscoverParameter command for
 * the ConfigurationParameters cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ConfigurationParameters/GeneratedCommands/DiscoverParameter
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_configuration_parameters_publish_generated_discover_parameter_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_configuration_parameters_command_discover_parameter_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ConfigurationParameters/GeneratedCommands/DiscoverParameter";

  std::string payload =
    get_json_payload_for_configuration_parameters_discover_parameter_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated DefaultResetAllParameters command for
 * the ConfigurationParameters cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ConfigurationParameters/GeneratedCommands/DefaultResetAllParameters
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_configuration_parameters_publish_generated_default_reset_all_parameters_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ConfigurationParameters/GeneratedCommands/DefaultResetAllParameters";

  std::string payload =
    get_json_payload_for_configuration_parameters_default_reset_all_parameters_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetParameter command for
 * the ConfigurationParameters cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ConfigurationParameters/GeneratedCommands/SetParameter
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_configuration_parameters_publish_generated_set_parameter_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_configuration_parameters_command_set_parameter_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ConfigurationParameters/GeneratedCommands/SetParameter";

  std::string payload =
    get_json_payload_for_configuration_parameters_set_parameter_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated IQReport command for
 * the AoXLocator cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/AoXLocator/GeneratedCommands/IQReport
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_aox_locator_publish_generated_iq_report_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_aox_locator_command_iq_report_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "AoXLocator/GeneratedCommands/IQReport";

  std::string payload =
    get_json_payload_for_aox_locator_iq_report_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated AngleReport command for
 * the AoXLocator cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/AoXLocator/GeneratedCommands/AngleReport
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_aox_locator_publish_generated_angle_report_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_aox_locator_command_angle_report_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "AoXLocator/GeneratedCommands/AngleReport";

  std::string payload =
    get_json_payload_for_aox_locator_angle_report_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated AngleCorrection command for
 * the AoXLocator cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/AoXLocator/GeneratedCommands/AngleCorrection
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_aox_locator_publish_generated_angle_correction_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_aox_locator_command_angle_correction_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "AoXLocator/GeneratedCommands/AngleCorrection";

  std::string payload =
    get_json_payload_for_aox_locator_angle_correction_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Write command for
 * the ProtocolController-NetworkManagement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/ProtocolController/NetworkManagement/GeneratedCommands/Write
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_protocol_controller_network_management_publish_generated_write_command(
  const dotdot_unid_t unid
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "ProtocolController/NetworkManagement/GeneratedCommands/Write";

  std::string payload =
    get_json_payload_for_protocol_controller_network_management_write_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
