/******************************************************************************
 * # License
 * <b>Copyright 2022 Silicon Laboratories Inc. www.silabs.com</b>
 ******************************************************************************
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 *****************************************************************************/
// This file is generated by ZCL Advanced Platform generator. Please don't edit manually.

#include "dotdot_mqtt_helpers.hpp"

#include <regex>
#include <functional>
#include <limits>

namespace unify
{
std::optional<std::string> unid_from_mqtt_topic(const std::string &topic)
{
  std::regex rgx_unid(R"(by-unid/([^/]*).*)");
  std::smatch match;
  if (std::regex_search(topic, match, rgx_unid)) {
    return match[1];
  }
  return std::nullopt;
}
}  // namespace unify

// Create a map of enums and their name label.
// Functions are declared in dotdot_mqtt.hpp

// Enum to string map for AoXLocatorAntennaMode
const std::map<uint32_t, std::string> aox_locator_antenna_mode_enum_id_to_string_map {
  { 0, "Array 4x4 URA" },
  { 1, "Array 3x3 URA" },
  { 2, "Array 1x4 ULA" },
  { 3, "Array 4x4 DP URA" },
  { 4, "Array COREHW_15x15 DP" },
  { 5, "Array COREHW 12x12 DP" },
};

// String to enum map for AoXLocatorAntennaMode
const std::map<std::string, uint32_t> aox_locator_antenna_mode_enum_string_to_id_map {
  { "Array 4x4 URA", 0 },
  { "Array 3x3 URA", 1 },
  { "Array 1x4 ULA", 2 },
  { "Array 4x4 DP URA", 3 },
  { "Array COREHW_15x15 DP", 4 },
  { "Array COREHW 12x12 DP", 5 },
};

std::string aox_locator_antenna_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = aox_locator_antenna_mode_enum_id_to_string_map.find(value);
  if (it != aox_locator_antenna_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t aox_locator_antenna_mode_get_enum_value_number(const std::string &str)
{
  auto it = aox_locator_antenna_mode_enum_string_to_id_map.find(str);
  if (it != aox_locator_antenna_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for AoXLocatorAoXMode
const std::map<uint32_t, std::string> aox_locator_aox_mode_enum_id_to_string_map {
  { 3, "One Shot Basic" },
  { 4, "One Shot Basic Lightweight" },
  { 5, "One Shot Fast Response" },
  { 6, "One Shot High Accuracy" },
  { 7, "One Shot Basic Azimuth Only" },
  { 8, "One Shot Fast Response Azimuth Only" },
  { 9, "One Shot High Accuracy Azimuth Only" },
  { 10, "Real Time Fast Response" },
  { 11, "Real Time Basic" },
  { 12, "Real Time High Accuracy" },
};

// String to enum map for AoXLocatorAoXMode
const std::map<std::string, uint32_t> aox_locator_aox_mode_enum_string_to_id_map {
  { "One Shot Basic", 3 },
  { "One Shot Basic Lightweight", 4 },
  { "One Shot Fast Response", 5 },
  { "One Shot High Accuracy", 6 },
  { "One Shot Basic Azimuth Only", 7 },
  { "One Shot Fast Response Azimuth Only", 8 },
  { "One Shot High Accuracy Azimuth Only", 9 },
  { "Real Time Fast Response", 10 },
  { "Real Time Basic", 11 },
  { "Real Time High Accuracy", 12 },
};

std::string aox_locator_aox_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = aox_locator_aox_mode_enum_id_to_string_map.find(value);
  if (it != aox_locator_aox_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t aox_locator_aox_mode_get_enum_value_number(const std::string &str)
{
  auto it = aox_locator_aox_mode_enum_string_to_id_map.find(str);
  if (it != aox_locator_aox_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for AoXLocatorCTEMode
const std::map<uint32_t, std::string> aox_locatorcte_mode_enum_id_to_string_map {
  { 0, "Silicon Labs" },
  { 1, "Connection" },
  { 2, "Connectionless" },
};

// String to enum map for AoXLocatorCTEMode
const std::map<std::string, uint32_t> aox_locatorcte_mode_enum_string_to_id_map {
  { "Silicon Labs", 0 },
  { "Connection", 1 },
  { "Connectionless", 2 },
};

std::string aox_locatorcte_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = aox_locatorcte_mode_enum_id_to_string_map.find(value);
  if (it != aox_locatorcte_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t aox_locatorcte_mode_get_enum_value_number(const std::string &str)
{
  auto it = aox_locatorcte_mode_enum_string_to_id_map.find(str);
  if (it != aox_locatorcte_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for AoXLocatorReportingMode
const std::map<uint32_t, std::string> aox_locator_reporting_mode_enum_id_to_string_map {
  { 0, "IQReport" },
  { 1, "AngleReport" },
};

// String to enum map for AoXLocatorReportingMode
const std::map<std::string, uint32_t> aox_locator_reporting_mode_enum_string_to_id_map {
  { "IQReport", 0 },
  { "AngleReport", 1 },
};

std::string aox_locator_reporting_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = aox_locator_reporting_mode_enum_id_to_string_map.find(value);
  if (it != aox_locator_reporting_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t aox_locator_reporting_mode_get_enum_value_number(const std::string &str)
{
  auto it = aox_locator_reporting_mode_enum_string_to_id_map.find(str);
  if (it != aox_locator_reporting_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ArmArmMode
const std::map<uint32_t, std::string> arm_arm_mode_enum_id_to_string_map {
  { 0, "Disarm" },
  { 1, "ArmDayHomeZonesOnly" },
  { 2, "ArmNightSleepZonesOnly" },
  { 3, "ArmAllZones" },
};

// String to enum map for ArmArmMode
const std::map<std::string, uint32_t> arm_arm_mode_enum_string_to_id_map {
  { "Disarm", 0 },
  { "ArmDayHomeZonesOnly", 1 },
  { "ArmNightSleepZonesOnly", 2 },
  { "ArmAllZones", 3 },
};

std::string arm_arm_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = arm_arm_mode_enum_id_to_string_map.find(value);
  if (it != arm_arm_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t arm_arm_mode_get_enum_value_number(const std::string &str)
{
  auto it = arm_arm_mode_enum_string_to_id_map.find(str);
  if (it != arm_arm_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ArmResponseArmNotification
const std::map<uint32_t, std::string> arm_response_arm_notification_enum_id_to_string_map {
  { 0, "AllZonesDisarmed" },
  { 1, "OnlyDayHomeZonesArmed" },
  { 2, "OnlyNightSleepZonesArmed" },
  { 3, "AllZonesArmed" },
  { 4, "InvalidArmDisarmCode" },
  { 5, "NotReadyToArm" },
  { 6, "AlreadyDisarmed" },
};

// String to enum map for ArmResponseArmNotification
const std::map<std::string, uint32_t> arm_response_arm_notification_enum_string_to_id_map {
  { "AllZonesDisarmed", 0 },
  { "OnlyDayHomeZonesArmed", 1 },
  { "OnlyNightSleepZonesArmed", 2 },
  { "AllZonesArmed", 3 },
  { "InvalidArmDisarmCode", 4 },
  { "NotReadyToArm", 5 },
  { "AlreadyDisarmed", 6 },
};

std::string arm_response_arm_notification_get_enum_value_name(
  uint32_t value)
{
  auto it = arm_response_arm_notification_enum_id_to_string_map.find(value);
  if (it != arm_response_arm_notification_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t arm_response_arm_notification_get_enum_value_number(const std::string &str)
{
  auto it = arm_response_arm_notification_enum_string_to_id_map.find(str);
  if (it != arm_response_arm_notification_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for BarrierControlMovingState
const std::map<uint32_t, std::string> barrier_control_moving_state_enum_id_to_string_map {
  { 0, "Stopped" },
  { 1, "Closing" },
  { 2, "Opening" },
};

// String to enum map for BarrierControlMovingState
const std::map<std::string, uint32_t> barrier_control_moving_state_enum_string_to_id_map {
  { "Stopped", 0 },
  { "Closing", 1 },
  { "Opening", 2 },
};

std::string barrier_control_moving_state_get_enum_value_name(
  uint32_t value)
{
  auto it = barrier_control_moving_state_enum_id_to_string_map.find(value);
  if (it != barrier_control_moving_state_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t barrier_control_moving_state_get_enum_value_number(const std::string &str)
{
  auto it = barrier_control_moving_state_enum_string_to_id_map.find(str);
  if (it != barrier_control_moving_state_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for BasicGenericDevice-Class
const std::map<uint32_t, std::string> basic_generic_device_class_enum_id_to_string_map {
  { 0, "Lighting" },
};

// String to enum map for BasicGenericDevice-Class
const std::map<std::string, uint32_t> basic_generic_device_class_enum_string_to_id_map {
  { "Lighting", 0 },
};

std::string basic_generic_device_class_get_enum_value_name(
  uint32_t value)
{
  auto it = basic_generic_device_class_enum_id_to_string_map.find(value);
  if (it != basic_generic_device_class_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t basic_generic_device_class_get_enum_value_number(const std::string &str)
{
  auto it = basic_generic_device_class_enum_string_to_id_map.find(str);
  if (it != basic_generic_device_class_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for BasicGenericDevice-Type
const std::map<uint32_t, std::string> basic_generic_device_type_enum_id_to_string_map {
  { 0, "Incandescent" },
  { 1, "SpotlightHalogen" },
  { 2, "HalogenBulb" },
  { 3, "CFL" },
  { 4, "LinearFluorescent" },
  { 5, "LEDBulb" },
  { 6, "SpotlightLED" },
  { 7, "LEDStrip" },
  { 8, "LEDTube" },
  { 9, "GenericIndoorLuminaireOrLightFixture" },
  { 10, "GenericOutdoorLuminaireOrLightFixture" },
  { 11, "PendantLuminaireOrLightFixture" },
  { 12, "FloorStandingLuminaireOrLightFixture" },
  { 224, "GenericController" },
  { 225, "WallSwitch" },
  { 226, "PortableRemoteController" },
  { 227, "MotionSensorOrLightSensor" },
  { 240, "GenericActuator" },
  { 241, "WallSocket" },
  { 242, "GatewayOrBridge" },
  { 243, "PlugInUnit" },
  { 244, "RetrofitActuator" },
  { 255, "Unspecified" },
};

// String to enum map for BasicGenericDevice-Type
const std::map<std::string, uint32_t> basic_generic_device_type_enum_string_to_id_map {
  { "Incandescent", 0 },
  { "SpotlightHalogen", 1 },
  { "HalogenBulb", 2 },
  { "CFL", 3 },
  { "LinearFluorescent", 4 },
  { "LEDBulb", 5 },
  { "SpotlightLED", 6 },
  { "LEDStrip", 7 },
  { "LEDTube", 8 },
  { "GenericIndoorLuminaireOrLightFixture", 9 },
  { "GenericOutdoorLuminaireOrLightFixture", 10 },
  { "PendantLuminaireOrLightFixture", 11 },
  { "FloorStandingLuminaireOrLightFixture", 12 },
  { "GenericController", 224 },
  { "WallSwitch", 225 },
  { "PortableRemoteController", 226 },
  { "MotionSensorOrLightSensor", 227 },
  { "GenericActuator", 240 },
  { "WallSocket", 241 },
  { "GatewayOrBridge", 242 },
  { "PlugInUnit", 243 },
  { "RetrofitActuator", 244 },
  { "Unspecified", 255 },
};

std::string basic_generic_device_type_get_enum_value_name(
  uint32_t value)
{
  auto it = basic_generic_device_type_enum_id_to_string_map.find(value);
  if (it != basic_generic_device_type_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t basic_generic_device_type_get_enum_value_number(const std::string &str)
{
  auto it = basic_generic_device_type_enum_string_to_id_map.find(str);
  if (it != basic_generic_device_type_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for BasicPhysicalEnvironment
const std::map<uint32_t, std::string> basic_physical_environment_enum_id_to_string_map {
  { 0, "UnspecifiedEnvironment" },
  { 1, "Deprecated" },
  { 2, "Bar" },
  { 3, "Courtyard" },
  { 4, "Bathroom" },
  { 5, "Bedroom" },
  { 6, "BilliardRoom" },
  { 7, "UtilityRoom" },
  { 8, "Cellar" },
  { 9, "StorageCloset" },
  { 10, "Theater" },
  { 11, "Office" },
  { 12, "Deck" },
  { 13, "Den" },
  { 14, "DiningRoom" },
  { 15, "ElectricalRoom" },
  { 16, "Elevator" },
  { 17, "Entry" },
  { 18, "FamilyRoom" },
  { 19, "MainFloor" },
  { 20, "Upstairs" },
  { 21, "Downstairs" },
  { 22, "Basement/LowerLevel" },
  { 23, "Gallery" },
  { 24, "GameRoom" },
  { 25, "Garage" },
  { 26, "Gym" },
  { 27, "Hallway" },
  { 28, "House" },
  { 29, "Kitchen" },
  { 30, "LaundryRoom" },
  { 31, "Library" },
  { 32, "MasterBedroom" },
  { 33, "MudRoom" },
  { 34, "Nursery" },
  { 35, "Pantry" },
  { 36, "SecondaryOffice" },
  { 37, "Outside" },
  { 38, "Pool" },
  { 39, "Porch" },
  { 40, "SewingRoom" },
  { 41, "SittingRoom" },
  { 42, "Stairway" },
  { 43, "Yard" },
  { 44, "Attic" },
  { 45, "HotTub" },
  { 46, "LivingRoom" },
  { 47, "Sauna" },
  { 48, "ShopOrWorkshop" },
  { 49, "GuestBedroom" },
  { 50, "GuestBath" },
  { 51, "PowderRoom" },
  { 52, "BackYard" },
  { 53, "FrontYard" },
  { 54, "Patio" },
  { 55, "Driveway" },
  { 56, "SunRoom" },
  { 57, "SecondaryLivingRoom" },
  { 58, "Spa" },
  { 59, "Whirlpool" },
  { 60, "Shed" },
  { 61, "EquipmentStorage" },
  { 62, "HobbyOrCraftRoom" },
  { 63, "Fountain" },
  { 64, "Pond" },
  { 65, "ReceptionRoom" },
  { 66, "BreakfastRoom" },
  { 67, "Nook" },
  { 68, "Garden" },
  { 69, "Balcony" },
  { 70, "PanicRoom" },
  { 71, "Terrace" },
  { 72, "Roof" },
  { 73, "Toilet" },
  { 74, "ToiletMain" },
  { 75, "OutsideToilet" },
  { 76, "ShowerRoom" },
  { 77, "Study" },
  { 78, "FrontGarden" },
  { 79, "BackGarden" },
  { 80, "Kettle" },
  { 81, "Television" },
  { 82, "Stove" },
  { 83, "Microwave" },
  { 84, "Toaster" },
  { 85, "Vacuum" },
  { 86, "Appliance" },
  { 87, "FrontDoor" },
  { 88, "BackDoor" },
  { 89, "FridgeDoor" },
  { 96, "MedicationCabinetDoor" },
  { 97, "WardrobeDoor" },
  { 98, "FrontCupboardDoor" },
  { 99, "OtherDoor" },
  { 100, "WaitingRoom" },
  { 101, "TriageRoom" },
  { 102, "DoctorsOffice" },
  { 103, "PatientsPrivateRoom" },
  { 104, "ConsultationRoom" },
  { 105, "NurseStation" },
  { 106, "Ward" },
  { 107, "Corridor" },
  { 108, "OperatingTheatre" },
  { 109, "DentalSurgeryRoom" },
  { 110, "MedicalImagingRoom" },
  { 111, "DecontaminationRoom" },
  { 112, "Atrium" },
  { 113, "Mirror" },
  { 255, "UnknownEnvironment" },
};

// String to enum map for BasicPhysicalEnvironment
const std::map<std::string, uint32_t> basic_physical_environment_enum_string_to_id_map {
  { "UnspecifiedEnvironment", 0 },
  { "Deprecated", 1 },
  { "Bar", 2 },
  { "Courtyard", 3 },
  { "Bathroom", 4 },
  { "Bedroom", 5 },
  { "BilliardRoom", 6 },
  { "UtilityRoom", 7 },
  { "Cellar", 8 },
  { "StorageCloset", 9 },
  { "Theater", 10 },
  { "Office", 11 },
  { "Deck", 12 },
  { "Den", 13 },
  { "DiningRoom", 14 },
  { "ElectricalRoom", 15 },
  { "Elevator", 16 },
  { "Entry", 17 },
  { "FamilyRoom", 18 },
  { "MainFloor", 19 },
  { "Upstairs", 20 },
  { "Downstairs", 21 },
  { "Basement/LowerLevel", 22 },
  { "Gallery", 23 },
  { "GameRoom", 24 },
  { "Garage", 25 },
  { "Gym", 26 },
  { "Hallway", 27 },
  { "House", 28 },
  { "Kitchen", 29 },
  { "LaundryRoom", 30 },
  { "Library", 31 },
  { "MasterBedroom", 32 },
  { "MudRoom", 33 },
  { "Nursery", 34 },
  { "Pantry", 35 },
  { "SecondaryOffice", 36 },
  { "Outside", 37 },
  { "Pool", 38 },
  { "Porch", 39 },
  { "SewingRoom", 40 },
  { "SittingRoom", 41 },
  { "Stairway", 42 },
  { "Yard", 43 },
  { "Attic", 44 },
  { "HotTub", 45 },
  { "LivingRoom", 46 },
  { "Sauna", 47 },
  { "ShopOrWorkshop", 48 },
  { "GuestBedroom", 49 },
  { "GuestBath", 50 },
  { "PowderRoom", 51 },
  { "BackYard", 52 },
  { "FrontYard", 53 },
  { "Patio", 54 },
  { "Driveway", 55 },
  { "SunRoom", 56 },
  { "SecondaryLivingRoom", 57 },
  { "Spa", 58 },
  { "Whirlpool", 59 },
  { "Shed", 60 },
  { "EquipmentStorage", 61 },
  { "HobbyOrCraftRoom", 62 },
  { "Fountain", 63 },
  { "Pond", 64 },
  { "ReceptionRoom", 65 },
  { "BreakfastRoom", 66 },
  { "Nook", 67 },
  { "Garden", 68 },
  { "Balcony", 69 },
  { "PanicRoom", 70 },
  { "Terrace", 71 },
  { "Roof", 72 },
  { "Toilet", 73 },
  { "ToiletMain", 74 },
  { "OutsideToilet", 75 },
  { "ShowerRoom", 76 },
  { "Study", 77 },
  { "FrontGarden", 78 },
  { "BackGarden", 79 },
  { "Kettle", 80 },
  { "Television", 81 },
  { "Stove", 82 },
  { "Microwave", 83 },
  { "Toaster", 84 },
  { "Vacuum", 85 },
  { "Appliance", 86 },
  { "FrontDoor", 87 },
  { "BackDoor", 88 },
  { "FridgeDoor", 89 },
  { "MedicationCabinetDoor", 96 },
  { "WardrobeDoor", 97 },
  { "FrontCupboardDoor", 98 },
  { "OtherDoor", 99 },
  { "WaitingRoom", 100 },
  { "TriageRoom", 101 },
  { "DoctorsOffice", 102 },
  { "PatientsPrivateRoom", 103 },
  { "ConsultationRoom", 104 },
  { "NurseStation", 105 },
  { "Ward", 106 },
  { "Corridor", 107 },
  { "OperatingTheatre", 108 },
  { "DentalSurgeryRoom", 109 },
  { "MedicalImagingRoom", 110 },
  { "DecontaminationRoom", 111 },
  { "Atrium", 112 },
  { "Mirror", 113 },
  { "UnknownEnvironment", 255 },
};

std::string basic_physical_environment_get_enum_value_name(
  uint32_t value)
{
  auto it = basic_physical_environment_enum_id_to_string_map.find(value);
  if (it != basic_physical_environment_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t basic_physical_environment_get_enum_value_number(const std::string &str)
{
  auto it = basic_physical_environment_enum_string_to_id_map.find(str);
  if (it != basic_physical_environment_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for BasicPowerSource
const std::map<uint32_t, std::string> basic_power_source_enum_id_to_string_map {
  { 0, "Unknown" },
  { 1, "SinglePhaseMains" },
  { 2, "ThreePhaseMains" },
  { 3, "Battery" },
  { 4, "DCSource" },
  { 5, "EmergencyMainsConstantlyPowered" },
  { 6, "EmergencyMainsAndTransferSwitch" },
  { 128, "UnknownWithBatteryBackup" },
  { 129, "SinglePhaseMainsWithBatteryBackup" },
  { 130, "ThreePhaseMainsWithBatteryBackup" },
  { 131, "BatteryWithBatteryBackup" },
  { 132, "DCSourceWithBatteryBackup" },
  { 133, "EmergencyMainsConstantlyPoweredWithBatteryBackup" },
  { 134, "EmergencyMainsAndTransferSwitchWithBatteryBackup" },
};

// String to enum map for BasicPowerSource
const std::map<std::string, uint32_t> basic_power_source_enum_string_to_id_map {
  { "Unknown", 0 },
  { "SinglePhaseMains", 1 },
  { "ThreePhaseMains", 2 },
  { "Battery", 3 },
  { "DCSource", 4 },
  { "EmergencyMainsConstantlyPowered", 5 },
  { "EmergencyMainsAndTransferSwitch", 6 },
  { "UnknownWithBatteryBackup", 128 },
  { "SinglePhaseMainsWithBatteryBackup", 129 },
  { "ThreePhaseMainsWithBatteryBackup", 130 },
  { "BatteryWithBatteryBackup", 131 },
  { "DCSourceWithBatteryBackup", 132 },
  { "EmergencyMainsConstantlyPoweredWithBatteryBackup", 133 },
  { "EmergencyMainsAndTransferSwitchWithBatteryBackup", 134 },
};

std::string basic_power_source_get_enum_value_name(
  uint32_t value)
{
  auto it = basic_power_source_enum_id_to_string_map.find(value);
  if (it != basic_power_source_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t basic_power_source_get_enum_value_number(const std::string &str)
{
  auto it = basic_power_source_enum_string_to_id_map.find(str);
  if (it != basic_power_source_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for BatterySize
const std::map<uint32_t, std::string> battery_size_enum_id_to_string_map {
  { 0, "NoBattery" },
  { 1, "BuiltIn" },
  { 2, "Other" },
  { 3, "AA" },
  { 4, "AAA" },
  { 5, "C" },
  { 6, "D" },
  { 7, "CR2" },
  { 8, "CR123A" },
  { 255, "Unknown" },
};

// String to enum map for BatterySize
const std::map<std::string, uint32_t> battery_size_enum_string_to_id_map {
  { "NoBattery", 0 },
  { "BuiltIn", 1 },
  { "Other", 2 },
  { "AA", 3 },
  { "AAA", 4 },
  { "C", 5 },
  { "D", 6 },
  { "CR2", 7 },
  { "CR123A", 8 },
  { "Unknown", 255 },
};

std::string battery_size_get_enum_value_name(
  uint32_t value)
{
  auto it = battery_size_enum_id_to_string_map.find(value);
  if (it != battery_size_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t battery_size_get_enum_value_number(const std::string &str)
{
  auto it = battery_size_enum_string_to_id_map.find(str);
  if (it != battery_size_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for BypassResponseZoneIDBypassResult
const std::map<uint32_t, std::string> bypass_response_zoneid_bypass_result_enum_id_to_string_map {
  { 0, "ZoneBypassed" },
  { 1, "ZoneNotBypassed" },
  { 2, "NotAllowed" },
  { 3, "InvalidZoneID" },
  { 4, "UnknownZoneID" },
  { 5, "InvalidArmDisarmCode" },
};

// String to enum map for BypassResponseZoneIDBypassResult
const std::map<std::string, uint32_t> bypass_response_zoneid_bypass_result_enum_string_to_id_map {
  { "ZoneBypassed", 0 },
  { "ZoneNotBypassed", 1 },
  { "NotAllowed", 2 },
  { "InvalidZoneID", 3 },
  { "UnknownZoneID", 4 },
  { "InvalidArmDisarmCode", 5 },
};

std::string bypass_response_zoneid_bypass_result_get_enum_value_name(
  uint32_t value)
{
  auto it = bypass_response_zoneid_bypass_result_enum_id_to_string_map.find(value);
  if (it != bypass_response_zoneid_bypass_result_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t bypass_response_zoneid_bypass_result_get_enum_value_number(const std::string &str)
{
  auto it = bypass_response_zoneid_bypass_result_enum_string_to_id_map.find(str);
  if (it != bypass_response_zoneid_bypass_result_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for CCColorLoopDirection
const std::map<uint32_t, std::string> cc_color_loop_direction_enum_id_to_string_map {
  { 0, "DecrementEnhancedCurrentHue" },
  { 1, "IncrementEnhancedCurrentHue" },
};

// String to enum map for CCColorLoopDirection
const std::map<std::string, uint32_t> cc_color_loop_direction_enum_string_to_id_map {
  { "DecrementEnhancedCurrentHue", 0 },
  { "IncrementEnhancedCurrentHue", 1 },
};

std::string cc_color_loop_direction_get_enum_value_name(
  uint32_t value)
{
  auto it = cc_color_loop_direction_enum_id_to_string_map.find(value);
  if (it != cc_color_loop_direction_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t cc_color_loop_direction_get_enum_value_number(const std::string &str)
{
  auto it = cc_color_loop_direction_enum_string_to_id_map.find(str);
  if (it != cc_color_loop_direction_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for CCDirection
const std::map<uint32_t, std::string> cc_direction_enum_id_to_string_map {
  { 0, "ShortestDistance" },
  { 1, "LongestDistance" },
  { 2, "Up" },
  { 3, "Down" },
};

// String to enum map for CCDirection
const std::map<std::string, uint32_t> cc_direction_enum_string_to_id_map {
  { "ShortestDistance", 0 },
  { "LongestDistance", 1 },
  { "Up", 2 },
  { "Down", 3 },
};

std::string cc_direction_get_enum_value_name(
  uint32_t value)
{
  auto it = cc_direction_enum_id_to_string_map.find(value);
  if (it != cc_direction_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t cc_direction_get_enum_value_number(const std::string &str)
{
  auto it = cc_direction_enum_string_to_id_map.find(str);
  if (it != cc_direction_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for CCMoveMode
const std::map<uint32_t, std::string> cc_move_mode_enum_id_to_string_map {
  { 0, "Stop" },
  { 1, "Up" },
  { 3, "Down" },
};

// String to enum map for CCMoveMode
const std::map<std::string, uint32_t> cc_move_mode_enum_string_to_id_map {
  { "Stop", 0 },
  { "Up", 1 },
  { "Down", 3 },
};

std::string cc_move_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = cc_move_mode_enum_id_to_string_map.find(value);
  if (it != cc_move_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t cc_move_mode_get_enum_value_number(const std::string &str)
{
  auto it = cc_move_mode_enum_string_to_id_map.find(str);
  if (it != cc_move_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for CCStepMode
const std::map<uint32_t, std::string> cc_step_mode_enum_id_to_string_map {
  { 1, "Up" },
  { 3, "Down" },
};

// String to enum map for CCStepMode
const std::map<std::string, uint32_t> cc_step_mode_enum_string_to_id_map {
  { "Up", 1 },
  { "Down", 3 },
};

std::string cc_step_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = cc_step_mode_enum_id_to_string_map.find(value);
  if (it != cc_step_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t cc_step_mode_get_enum_value_number(const std::string &str)
{
  auto it = cc_step_mode_enum_string_to_id_map.find(str);
  if (it != cc_step_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ColorControlColorLoopActive
const std::map<uint32_t, std::string> color_control_color_loop_active_enum_id_to_string_map {
  { 0, "ColorLoopInactive" },
  { 1, "ColorLoopActive" },
};

// String to enum map for ColorControlColorLoopActive
const std::map<std::string, uint32_t> color_control_color_loop_active_enum_string_to_id_map {
  { "ColorLoopInactive", 0 },
  { "ColorLoopActive", 1 },
};

std::string color_control_color_loop_active_get_enum_value_name(
  uint32_t value)
{
  auto it = color_control_color_loop_active_enum_id_to_string_map.find(value);
  if (it != color_control_color_loop_active_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t color_control_color_loop_active_get_enum_value_number(const std::string &str)
{
  auto it = color_control_color_loop_active_enum_string_to_id_map.find(str);
  if (it != color_control_color_loop_active_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ColorControlColorMode
const std::map<uint32_t, std::string> color_control_color_mode_enum_id_to_string_map {
  { 0, "CurrentHueAndCurrentSaturation" },
  { 1, "CurrentXAndCurrentY" },
  { 2, "ColorTemperatureMireds" },
};

// String to enum map for ColorControlColorMode
const std::map<std::string, uint32_t> color_control_color_mode_enum_string_to_id_map {
  { "CurrentHueAndCurrentSaturation", 0 },
  { "CurrentXAndCurrentY", 1 },
  { "ColorTemperatureMireds", 2 },
};

std::string color_control_color_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = color_control_color_mode_enum_id_to_string_map.find(value);
  if (it != color_control_color_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t color_control_color_mode_get_enum_value_number(const std::string &str)
{
  auto it = color_control_color_mode_enum_string_to_id_map.find(str);
  if (it != color_control_color_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ColorControlDriftCompensation
const std::map<uint32_t, std::string> color_control_drift_compensation_enum_id_to_string_map {
  { 0, "None" },
  { 1, "OtherOrUnknown" },
  { 2, "TemperatureMonitoring" },
  { 3, "OpticalLuminanceMonitoringAndFeedback" },
  { 4, "OpticalColorMonitoringAndFeedback" },
};

// String to enum map for ColorControlDriftCompensation
const std::map<std::string, uint32_t> color_control_drift_compensation_enum_string_to_id_map {
  { "None", 0 },
  { "OtherOrUnknown", 1 },
  { "TemperatureMonitoring", 2 },
  { "OpticalLuminanceMonitoringAndFeedback", 3 },
  { "OpticalColorMonitoringAndFeedback", 4 },
};

std::string color_control_drift_compensation_get_enum_value_name(
  uint32_t value)
{
  auto it = color_control_drift_compensation_enum_id_to_string_map.find(value);
  if (it != color_control_drift_compensation_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t color_control_drift_compensation_get_enum_value_number(const std::string &str)
{
  auto it = color_control_drift_compensation_enum_string_to_id_map.find(str);
  if (it != color_control_drift_compensation_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ColorControlEnhancedColorMode
const std::map<uint32_t, std::string> color_control_enhanced_color_mode_enum_id_to_string_map {
  { 0, "CurrentHueAndCurrentSaturation" },
  { 1, "CurrentXAndCurrentY" },
  { 2, "ColorTemperatureMireds" },
  { 3, "EnhancedCurrentHueAndCurrentSaturation" },
};

// String to enum map for ColorControlEnhancedColorMode
const std::map<std::string, uint32_t> color_control_enhanced_color_mode_enum_string_to_id_map {
  { "CurrentHueAndCurrentSaturation", 0 },
  { "CurrentXAndCurrentY", 1 },
  { "ColorTemperatureMireds", 2 },
  { "EnhancedCurrentHueAndCurrentSaturation", 3 },
};

std::string color_control_enhanced_color_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = color_control_enhanced_color_mode_enum_id_to_string_map.find(value);
  if (it != color_control_enhanced_color_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t color_control_enhanced_color_mode_get_enum_value_number(const std::string &str)
{
  auto it = color_control_enhanced_color_mode_enum_string_to_id_map.find(str);
  if (it != color_control_enhanced_color_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ColorLoopSetAction
const std::map<uint32_t, std::string> color_loop_set_action_enum_id_to_string_map {
  { 0, "DeactivateColorLoop" },
  { 1, "ActivateColorLoopFromColorLoopStartEnhancedHue" },
  { 2, "ActivateColorLoopFromEnhancedCurrentHue" },
};

// String to enum map for ColorLoopSetAction
const std::map<std::string, uint32_t> color_loop_set_action_enum_string_to_id_map {
  { "DeactivateColorLoop", 0 },
  { "ActivateColorLoopFromColorLoopStartEnhancedHue", 1 },
  { "ActivateColorLoopFromEnhancedCurrentHue", 2 },
};

std::string color_loop_set_action_get_enum_value_name(
  uint32_t value)
{
  auto it = color_loop_set_action_enum_id_to_string_map.find(value);
  if (it != color_loop_set_action_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t color_loop_set_action_get_enum_value_number(const std::string &str)
{
  auto it = color_loop_set_action_enum_string_to_id_map.find(str);
  if (it != color_loop_set_action_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for CommissioningNetworkKeyType
const std::map<uint32_t, std::string> commissioning_network_key_type_enum_id_to_string_map {
  { 1, "StandardKey" },
};

// String to enum map for CommissioningNetworkKeyType
const std::map<std::string, uint32_t> commissioning_network_key_type_enum_string_to_id_map {
  { "StandardKey", 1 },
};

std::string commissioning_network_key_type_get_enum_value_name(
  uint32_t value)
{
  auto it = commissioning_network_key_type_enum_id_to_string_map.find(value);
  if (it != commissioning_network_key_type_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t commissioning_network_key_type_get_enum_value_number(const std::string &str)
{
  auto it = commissioning_network_key_type_enum_string_to_id_map.find(str);
  if (it != commissioning_network_key_type_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for CommissioningProtocolVersion
const std::map<uint32_t, std::string> commissioning_protocol_version_enum_id_to_string_map {
  { 2, "Zigbee2006OrLater" },
};

// String to enum map for CommissioningProtocolVersion
const std::map<std::string, uint32_t> commissioning_protocol_version_enum_string_to_id_map {
  { "Zigbee2006OrLater", 2 },
};

std::string commissioning_protocol_version_get_enum_value_name(
  uint32_t value)
{
  auto it = commissioning_protocol_version_enum_id_to_string_map.find(value);
  if (it != commissioning_protocol_version_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t commissioning_protocol_version_get_enum_value_number(const std::string &str)
{
  auto it = commissioning_protocol_version_enum_string_to_id_map.find(str);
  if (it != commissioning_protocol_version_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for CommissioningStackProfile
const std::map<uint32_t, std::string> commissioning_stack_profile_enum_id_to_string_map {
  { 1, "ZigbeeStackProfile" },
  { 2, "ZigbeeProStackProfile" },
};

// String to enum map for CommissioningStackProfile
const std::map<std::string, uint32_t> commissioning_stack_profile_enum_string_to_id_map {
  { "ZigbeeStackProfile", 1 },
  { "ZigbeeProStackProfile", 2 },
};

std::string commissioning_stack_profile_get_enum_value_name(
  uint32_t value)
{
  auto it = commissioning_stack_profile_enum_id_to_string_map.find(value);
  if (it != commissioning_stack_profile_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t commissioning_stack_profile_get_enum_value_number(const std::string &str)
{
  auto it = commissioning_stack_profile_enum_string_to_id_map.find(str);
  if (it != commissioning_stack_profile_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for CommissioningStartupControl
const std::map<uint32_t, std::string> commissioning_startup_control_enum_id_to_string_map {
  { 0, "OnANetwork" },
  { 1, "FormNetwork" },
  { 2, "RejoinNetwork" },
  { 3, "JoinUsingMACAssociation" },
};

// String to enum map for CommissioningStartupControl
const std::map<std::string, uint32_t> commissioning_startup_control_enum_string_to_id_map {
  { "OnANetwork", 0 },
  { "FormNetwork", 1 },
  { "RejoinNetwork", 2 },
  { "JoinUsingMACAssociation", 3 },
};

std::string commissioning_startup_control_get_enum_value_name(
  uint32_t value)
{
  auto it = commissioning_startup_control_enum_id_to_string_map.find(value);
  if (it != commissioning_startup_control_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t commissioning_startup_control_get_enum_value_number(const std::string &str)
{
  auto it = commissioning_startup_control_enum_string_to_id_map.find(str);
  if (it != commissioning_startup_control_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for DehumidificationControlDehumidificationLockout
const std::map<uint32_t, std::string> dehumidification_control_dehumidification_lockout_enum_id_to_string_map {
  { 0, "DehumidificationNotAllowed." },
  { 1, "DehumidificationAllowed." },
};

// String to enum map for DehumidificationControlDehumidificationLockout
const std::map<std::string, uint32_t> dehumidification_control_dehumidification_lockout_enum_string_to_id_map {
  { "DehumidificationNotAllowed.", 0 },
  { "DehumidificationAllowed.", 1 },
};

std::string dehumidification_control_dehumidification_lockout_get_enum_value_name(
  uint32_t value)
{
  auto it = dehumidification_control_dehumidification_lockout_enum_id_to_string_map.find(value);
  if (it != dehumidification_control_dehumidification_lockout_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t dehumidification_control_dehumidification_lockout_get_enum_value_number(const std::string &str)
{
  auto it = dehumidification_control_dehumidification_lockout_enum_string_to_id_map.find(str);
  if (it != dehumidification_control_dehumidification_lockout_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for DehumidificationControlRelativeHumidityDisplay
const std::map<uint32_t, std::string> dehumidification_control_relative_humidity_display_enum_id_to_string_map {
  { 0, "NotDisplayed" },
  { 1, "Displayed" },
};

// String to enum map for DehumidificationControlRelativeHumidityDisplay
const std::map<std::string, uint32_t> dehumidification_control_relative_humidity_display_enum_string_to_id_map {
  { "NotDisplayed", 0 },
  { "Displayed", 1 },
};

std::string dehumidification_control_relative_humidity_display_get_enum_value_name(
  uint32_t value)
{
  auto it = dehumidification_control_relative_humidity_display_enum_id_to_string_map.find(value);
  if (it != dehumidification_control_relative_humidity_display_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t dehumidification_control_relative_humidity_display_get_enum_value_number(const std::string &str)
{
  auto it = dehumidification_control_relative_humidity_display_enum_string_to_id_map.find(str);
  if (it != dehumidification_control_relative_humidity_display_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for DehumidificationControlRelativeHumidityMode
const std::map<uint32_t, std::string> dehumidification_control_relative_humidity_mode_enum_id_to_string_map {
  { 0, "MeasuredLocally" },
  { 1, "UpdatedOverTheNetwork" },
};

// String to enum map for DehumidificationControlRelativeHumidityMode
const std::map<std::string, uint32_t> dehumidification_control_relative_humidity_mode_enum_string_to_id_map {
  { "MeasuredLocally", 0 },
  { "UpdatedOverTheNetwork", 1 },
};

std::string dehumidification_control_relative_humidity_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = dehumidification_control_relative_humidity_mode_enum_id_to_string_map.find(value);
  if (it != dehumidification_control_relative_humidity_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t dehumidification_control_relative_humidity_mode_get_enum_value_number(const std::string &str)
{
  auto it = dehumidification_control_relative_humidity_mode_enum_string_to_id_map.find(str);
  if (it != dehumidification_control_relative_humidity_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for DoorLockDoorState
const std::map<uint32_t, std::string> door_lock_door_state_enum_id_to_string_map {
  { 0, "Open" },
  { 1, "Closed" },
  { 2, "ErrorJammed" },
  { 3, "ErrorForcedOpen" },
  { 4, "ErrorUnspecified" },
  { 255, "Undefined" },
};

// String to enum map for DoorLockDoorState
const std::map<std::string, uint32_t> door_lock_door_state_enum_string_to_id_map {
  { "Open", 0 },
  { "Closed", 1 },
  { "ErrorJammed", 2 },
  { "ErrorForcedOpen", 3 },
  { "ErrorUnspecified", 4 },
  { "Undefined", 255 },
};

std::string door_lock_door_state_get_enum_value_name(
  uint32_t value)
{
  auto it = door_lock_door_state_enum_id_to_string_map.find(value);
  if (it != door_lock_door_state_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t door_lock_door_state_get_enum_value_number(const std::string &str)
{
  auto it = door_lock_door_state_enum_string_to_id_map.find(str);
  if (it != door_lock_door_state_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for DoorLockLEDSettings
const std::map<uint32_t, std::string> door_lockled_settings_enum_id_to_string_map {
  { 0, "NeverUseLED" },
  { 1, "UseLEDExceptForAccessAllowed" },
  { 2, "UseLEDForAllEvents" },
};

// String to enum map for DoorLockLEDSettings
const std::map<std::string, uint32_t> door_lockled_settings_enum_string_to_id_map {
  { "NeverUseLED", 0 },
  { "UseLEDExceptForAccessAllowed", 1 },
  { "UseLEDForAllEvents", 2 },
};

std::string door_lockled_settings_get_enum_value_name(
  uint32_t value)
{
  auto it = door_lockled_settings_enum_id_to_string_map.find(value);
  if (it != door_lockled_settings_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t door_lockled_settings_get_enum_value_number(const std::string &str)
{
  auto it = door_lockled_settings_enum_string_to_id_map.find(str);
  if (it != door_lockled_settings_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for DoorLockLockState
const std::map<uint32_t, std::string> door_lock_lock_state_enum_id_to_string_map {
  { 0, "NotFullyLocked" },
  { 1, "Locked" },
  { 2, "Unlocked" },
  { 255, "Undefined" },
};

// String to enum map for DoorLockLockState
const std::map<std::string, uint32_t> door_lock_lock_state_enum_string_to_id_map {
  { "NotFullyLocked", 0 },
  { "Locked", 1 },
  { "Unlocked", 2 },
  { "Undefined", 255 },
};

std::string door_lock_lock_state_get_enum_value_name(
  uint32_t value)
{
  auto it = door_lock_lock_state_enum_id_to_string_map.find(value);
  if (it != door_lock_lock_state_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t door_lock_lock_state_get_enum_value_number(const std::string &str)
{
  auto it = door_lock_lock_state_enum_string_to_id_map.find(str);
  if (it != door_lock_lock_state_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for DoorLockLockType
const std::map<uint32_t, std::string> door_lock_lock_type_enum_id_to_string_map {
  { 0, "DeadBolt" },
  { 1, "Magnetic" },
  { 2, "Other" },
  { 3, "Mortise" },
  { 4, "Rim" },
  { 5, "LatchBolt" },
  { 6, "CylindricalLock" },
  { 7, "TubularLock" },
  { 8, "InterconnectedLock" },
  { 9, "DeadLatch" },
  { 10, "DoorFurniture" },
};

// String to enum map for DoorLockLockType
const std::map<std::string, uint32_t> door_lock_lock_type_enum_string_to_id_map {
  { "DeadBolt", 0 },
  { "Magnetic", 1 },
  { "Other", 2 },
  { "Mortise", 3 },
  { "Rim", 4 },
  { "LatchBolt", 5 },
  { "CylindricalLock", 6 },
  { "TubularLock", 7 },
  { "InterconnectedLock", 8 },
  { "DeadLatch", 9 },
  { "DoorFurniture", 10 },
};

std::string door_lock_lock_type_get_enum_value_name(
  uint32_t value)
{
  auto it = door_lock_lock_type_enum_id_to_string_map.find(value);
  if (it != door_lock_lock_type_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t door_lock_lock_type_get_enum_value_number(const std::string &str)
{
  auto it = door_lock_lock_type_enum_string_to_id_map.find(str);
  if (it != door_lock_lock_type_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for DoorLockSecurityLevel
const std::map<uint32_t, std::string> door_lock_security_level_enum_id_to_string_map {
  { 0, "Network" },
  { 1, "APS" },
};

// String to enum map for DoorLockSecurityLevel
const std::map<std::string, uint32_t> door_lock_security_level_enum_string_to_id_map {
  { "Network", 0 },
  { "APS", 1 },
};

std::string door_lock_security_level_get_enum_value_name(
  uint32_t value)
{
  auto it = door_lock_security_level_enum_id_to_string_map.find(value);
  if (it != door_lock_security_level_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t door_lock_security_level_get_enum_value_number(const std::string &str)
{
  auto it = door_lock_security_level_enum_string_to_id_map.find(str);
  if (it != door_lock_security_level_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for DoorLockSoundVolume
const std::map<uint32_t, std::string> door_lock_sound_volume_enum_id_to_string_map {
  { 0, "SilentMode" },
  { 1, "LowVolume" },
  { 2, "HighVolume" },
};

// String to enum map for DoorLockSoundVolume
const std::map<std::string, uint32_t> door_lock_sound_volume_enum_string_to_id_map {
  { "SilentMode", 0 },
  { "LowVolume", 1 },
  { "HighVolume", 2 },
};

std::string door_lock_sound_volume_get_enum_value_name(
  uint32_t value)
{
  auto it = door_lock_sound_volume_enum_id_to_string_map.find(value);
  if (it != door_lock_sound_volume_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t door_lock_sound_volume_get_enum_value_number(const std::string &str)
{
  auto it = door_lock_sound_volume_enum_string_to_id_map.find(str);
  if (it != door_lock_sound_volume_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for DrlkOperEventSource
const std::map<uint32_t, std::string> drlk_oper_event_source_enum_id_to_string_map {
  { 0, "Keypad" },
  { 1, "RF" },
  { 2, "Manual" },
  { 3, "RFID" },
  { 255, "Indeterminate" },
};

// String to enum map for DrlkOperEventSource
const std::map<std::string, uint32_t> drlk_oper_event_source_enum_string_to_id_map {
  { "Keypad", 0 },
  { "RF", 1 },
  { "Manual", 2 },
  { "RFID", 3 },
  { "Indeterminate", 255 },
};

std::string drlk_oper_event_source_get_enum_value_name(
  uint32_t value)
{
  auto it = drlk_oper_event_source_enum_id_to_string_map.find(value);
  if (it != drlk_oper_event_source_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t drlk_oper_event_source_get_enum_value_number(const std::string &str)
{
  auto it = drlk_oper_event_source_enum_string_to_id_map.find(str);
  if (it != drlk_oper_event_source_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for DrlkOperMode
const std::map<uint32_t, std::string> drlk_oper_mode_enum_id_to_string_map {
  { 0, "Normal" },
  { 1, "Vacation" },
  { 2, "Privacy" },
  { 3, "NoRFLockOrUnlock" },
  { 4, "Passage" },
};

// String to enum map for DrlkOperMode
const std::map<std::string, uint32_t> drlk_oper_mode_enum_string_to_id_map {
  { "Normal", 0 },
  { "Vacation", 1 },
  { "Privacy", 2 },
  { "NoRFLockOrUnlock", 3 },
  { "Passage", 4 },
};

std::string drlk_oper_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = drlk_oper_mode_enum_id_to_string_map.find(value);
  if (it != drlk_oper_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t drlk_oper_mode_get_enum_value_number(const std::string &str)
{
  auto it = drlk_oper_mode_enum_string_to_id_map.find(str);
  if (it != drlk_oper_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for DrlkPassFailStatus
const std::map<uint32_t, std::string> drlk_pass_fail_status_enum_id_to_string_map {
  { 0, "Pass" },
  { 1, "Fail" },
};

// String to enum map for DrlkPassFailStatus
const std::map<std::string, uint32_t> drlk_pass_fail_status_enum_string_to_id_map {
  { "Pass", 0 },
  { "Fail", 1 },
};

std::string drlk_pass_fail_status_get_enum_value_name(
  uint32_t value)
{
  auto it = drlk_pass_fail_status_enum_id_to_string_map.find(value);
  if (it != drlk_pass_fail_status_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t drlk_pass_fail_status_get_enum_value_number(const std::string &str)
{
  auto it = drlk_pass_fail_status_enum_string_to_id_map.find(str);
  if (it != drlk_pass_fail_status_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for DrlkSetCodeStatus
const std::map<uint32_t, std::string> drlk_set_code_status_enum_id_to_string_map {
  { 0, "Success" },
  { 1, "GeneralFailure" },
  { 2, "MemoryFull" },
  { 3, "DuplicateCode" },
};

// String to enum map for DrlkSetCodeStatus
const std::map<std::string, uint32_t> drlk_set_code_status_enum_string_to_id_map {
  { "Success", 0 },
  { "GeneralFailure", 1 },
  { "MemoryFull", 2 },
  { "DuplicateCode", 3 },
};

std::string drlk_set_code_status_get_enum_value_name(
  uint32_t value)
{
  auto it = drlk_set_code_status_enum_id_to_string_map.find(value);
  if (it != drlk_set_code_status_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t drlk_set_code_status_get_enum_value_number(const std::string &str)
{
  auto it = drlk_set_code_status_enum_string_to_id_map.find(str);
  if (it != drlk_set_code_status_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for DrlkSettableUserStatus
const std::map<uint32_t, std::string> drlk_settable_user_status_enum_id_to_string_map {
  { 1, "OccupiedEnabled" },
  { 3, "OccupiedDisabled" },
};

// String to enum map for DrlkSettableUserStatus
const std::map<std::string, uint32_t> drlk_settable_user_status_enum_string_to_id_map {
  { "OccupiedEnabled", 1 },
  { "OccupiedDisabled", 3 },
};

std::string drlk_settable_user_status_get_enum_value_name(
  uint32_t value)
{
  auto it = drlk_settable_user_status_enum_id_to_string_map.find(value);
  if (it != drlk_settable_user_status_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t drlk_settable_user_status_get_enum_value_number(const std::string &str)
{
  auto it = drlk_settable_user_status_enum_string_to_id_map.find(str);
  if (it != drlk_settable_user_status_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for DrlkUserStatus
const std::map<uint32_t, std::string> drlk_user_status_enum_id_to_string_map {
  { 0, "Available" },
  { 1, "OccupiedEnabled" },
  { 3, "OccupiedDisabled" },
  { 255, "NotSupported" },
};

// String to enum map for DrlkUserStatus
const std::map<std::string, uint32_t> drlk_user_status_enum_string_to_id_map {
  { "Available", 0 },
  { "OccupiedEnabled", 1 },
  { "OccupiedDisabled", 3 },
  { "NotSupported", 255 },
};

std::string drlk_user_status_get_enum_value_name(
  uint32_t value)
{
  auto it = drlk_user_status_enum_id_to_string_map.find(value);
  if (it != drlk_user_status_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t drlk_user_status_get_enum_value_number(const std::string &str)
{
  auto it = drlk_user_status_enum_string_to_id_map.find(str);
  if (it != drlk_user_status_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for DrlkUserType
const std::map<uint32_t, std::string> drlk_user_type_enum_id_to_string_map {
  { 0, "UnrestrictedUser" },
  { 1, "YearDayScheduleUser" },
  { 2, "WeekDayScheduleUser" },
  { 3, "MasterUser" },
  { 4, "NonAccessUser" },
  { 255, "NotSupported" },
};

// String to enum map for DrlkUserType
const std::map<std::string, uint32_t> drlk_user_type_enum_string_to_id_map {
  { "UnrestrictedUser", 0 },
  { "YearDayScheduleUser", 1 },
  { "WeekDayScheduleUser", 2 },
  { "MasterUser", 3 },
  { "NonAccessUser", 4 },
  { "NotSupported", 255 },
};

std::string drlk_user_type_get_enum_value_name(
  uint32_t value)
{
  auto it = drlk_user_type_enum_id_to_string_map.find(value);
  if (it != drlk_user_type_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t drlk_user_type_get_enum_value_number(const std::string &str)
{
  auto it = drlk_user_type_enum_string_to_id_map.find(str);
  if (it != drlk_user_type_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for FanControlFanMode
const std::map<uint32_t, std::string> fan_control_fan_mode_enum_id_to_string_map {
  { 0, "Off" },
  { 1, "Low" },
  { 2, "Medium" },
  { 3, "High" },
  { 4, "On" },
  { 5, "Auto" },
  { 6, "Smart" },
};

// String to enum map for FanControlFanMode
const std::map<std::string, uint32_t> fan_control_fan_mode_enum_string_to_id_map {
  { "Off", 0 },
  { "Low", 1 },
  { "Medium", 2 },
  { "High", 3 },
  { "On", 4 },
  { "Auto", 5 },
  { "Smart", 6 },
};

std::string fan_control_fan_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = fan_control_fan_mode_enum_id_to_string_map.find(value);
  if (it != fan_control_fan_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t fan_control_fan_mode_get_enum_value_number(const std::string &str)
{
  auto it = fan_control_fan_mode_enum_string_to_id_map.find(str);
  if (it != fan_control_fan_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for FanControlFanModeSequence
const std::map<uint32_t, std::string> fan_control_fan_mode_sequence_enum_id_to_string_map {
  { 0, "LowMedHigh" },
  { 1, "LowHigh" },
  { 2, "LowMedHighAuto" },
  { 3, "LowHighAuto" },
  { 4, "OnAuto" },
};

// String to enum map for FanControlFanModeSequence
const std::map<std::string, uint32_t> fan_control_fan_mode_sequence_enum_string_to_id_map {
  { "LowMedHigh", 0 },
  { "LowHigh", 1 },
  { "LowMedHighAuto", 2 },
  { "LowHighAuto", 3 },
  { "OnAuto", 4 },
};

std::string fan_control_fan_mode_sequence_get_enum_value_name(
  uint32_t value)
{
  auto it = fan_control_fan_mode_sequence_enum_id_to_string_map.find(value);
  if (it != fan_control_fan_mode_sequence_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t fan_control_fan_mode_sequence_get_enum_value_number(const std::string &str)
{
  auto it = fan_control_fan_mode_sequence_enum_string_to_id_map.find(str);
  if (it != fan_control_fan_mode_sequence_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for GetLogRecordResponseEventType
const std::map<uint32_t, std::string> get_log_record_response_event_type_enum_id_to_string_map {
  { 0, "Operation" },
  { 1, "Programming" },
  { 2, "Alarm" },
};

// String to enum map for GetLogRecordResponseEventType
const std::map<std::string, uint32_t> get_log_record_response_event_type_enum_string_to_id_map {
  { "Operation", 0 },
  { "Programming", 1 },
  { "Alarm", 2 },
};

std::string get_log_record_response_event_type_get_enum_value_name(
  uint32_t value)
{
  auto it = get_log_record_response_event_type_enum_id_to_string_map.find(value);
  if (it != get_log_record_response_event_type_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t get_log_record_response_event_type_get_enum_value_number(const std::string &str)
{
  auto it = get_log_record_response_event_type_enum_string_to_id_map.find(str);
  if (it != get_log_record_response_event_type_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for GetMeasurementProfileResponseStatus
const std::map<uint32_t, std::string> get_measurement_profile_response_status_enum_id_to_string_map {
  { 0, "Success" },
  { 1, "AttributeProfileNotSupported" },
  { 2, "InvalidStartTime" },
  { 3, "MoreIntervalsRequestedThanCanBeReturned" },
  { 4, "NoIntervalsAvailableForTheRequestedTime" },
};

// String to enum map for GetMeasurementProfileResponseStatus
const std::map<std::string, uint32_t> get_measurement_profile_response_status_enum_string_to_id_map {
  { "Success", 0 },
  { "AttributeProfileNotSupported", 1 },
  { "InvalidStartTime", 2 },
  { "MoreIntervalsRequestedThanCanBeReturned", 3 },
  { "NoIntervalsAvailableForTheRequestedTime", 4 },
};

std::string get_measurement_profile_response_status_get_enum_value_name(
  uint32_t value)
{
  auto it = get_measurement_profile_response_status_enum_id_to_string_map.find(value);
  if (it != get_measurement_profile_response_status_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t get_measurement_profile_response_status_get_enum_value_number(const std::string &str)
{
  auto it = get_measurement_profile_response_status_enum_string_to_id_map.find(str);
  if (it != get_measurement_profile_response_status_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for HVACSystemTypeConfigurationCoolingSystemStage
const std::map<uint32_t, std::string> hvac_system_type_configuration_cooling_system_stage_enum_id_to_string_map {
  { 0, "CoolStage1" },
  { 1, "CoolStage2" },
  { 2, "CoolStage3" },
};

// String to enum map for HVACSystemTypeConfigurationCoolingSystemStage
const std::map<std::string, uint32_t> hvac_system_type_configuration_cooling_system_stage_enum_string_to_id_map {
  { "CoolStage1", 0 },
  { "CoolStage2", 1 },
  { "CoolStage3", 2 },
};

std::string hvac_system_type_configuration_cooling_system_stage_get_enum_value_name(
  uint32_t value)
{
  auto it = hvac_system_type_configuration_cooling_system_stage_enum_id_to_string_map.find(value);
  if (it != hvac_system_type_configuration_cooling_system_stage_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t hvac_system_type_configuration_cooling_system_stage_get_enum_value_number(const std::string &str)
{
  auto it = hvac_system_type_configuration_cooling_system_stage_enum_string_to_id_map.find(str);
  if (it != hvac_system_type_configuration_cooling_system_stage_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for HVACSystemTypeConfigurationHeatingFuelSource
const std::map<uint32_t, std::string> hvac_system_type_configuration_heating_fuel_source_enum_id_to_string_map {
  { 0, "ElectricOrB" },
  { 1, "GasOrO" },
};

// String to enum map for HVACSystemTypeConfigurationHeatingFuelSource
const std::map<std::string, uint32_t> hvac_system_type_configuration_heating_fuel_source_enum_string_to_id_map {
  { "ElectricOrB", 0 },
  { "GasOrO", 1 },
};

std::string hvac_system_type_configuration_heating_fuel_source_get_enum_value_name(
  uint32_t value)
{
  auto it = hvac_system_type_configuration_heating_fuel_source_enum_id_to_string_map.find(value);
  if (it != hvac_system_type_configuration_heating_fuel_source_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t hvac_system_type_configuration_heating_fuel_source_get_enum_value_number(const std::string &str)
{
  auto it = hvac_system_type_configuration_heating_fuel_source_enum_string_to_id_map.find(str);
  if (it != hvac_system_type_configuration_heating_fuel_source_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for HVACSystemTypeConfigurationHeatingSystemStage
const std::map<uint32_t, std::string> hvac_system_type_configuration_heating_system_stage_enum_id_to_string_map {
  { 0, "HeatStage1" },
  { 1, "HeatStage2" },
  { 2, "HeatStage3" },
};

// String to enum map for HVACSystemTypeConfigurationHeatingSystemStage
const std::map<std::string, uint32_t> hvac_system_type_configuration_heating_system_stage_enum_string_to_id_map {
  { "HeatStage1", 0 },
  { "HeatStage2", 1 },
  { "HeatStage3", 2 },
};

std::string hvac_system_type_configuration_heating_system_stage_get_enum_value_name(
  uint32_t value)
{
  auto it = hvac_system_type_configuration_heating_system_stage_enum_id_to_string_map.find(value);
  if (it != hvac_system_type_configuration_heating_system_stage_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t hvac_system_type_configuration_heating_system_stage_get_enum_value_number(const std::string &str)
{
  auto it = hvac_system_type_configuration_heating_system_stage_enum_string_to_id_map.find(str);
  if (it != hvac_system_type_configuration_heating_system_stage_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for HVACSystemTypeConfigurationHeatingSystemType
const std::map<uint32_t, std::string> hvac_system_type_configuration_heating_system_type_enum_id_to_string_map {
  { 0, "Conventional" },
  { 1, "HeatPump" },
};

// String to enum map for HVACSystemTypeConfigurationHeatingSystemType
const std::map<std::string, uint32_t> hvac_system_type_configuration_heating_system_type_enum_string_to_id_map {
  { "Conventional", 0 },
  { "HeatPump", 1 },
};

std::string hvac_system_type_configuration_heating_system_type_get_enum_value_name(
  uint32_t value)
{
  auto it = hvac_system_type_configuration_heating_system_type_enum_id_to_string_map.find(value);
  if (it != hvac_system_type_configuration_heating_system_type_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t hvac_system_type_configuration_heating_system_type_get_enum_value_number(const std::string &str)
{
  auto it = hvac_system_type_configuration_heating_system_type_enum_string_to_id_map.find(str);
  if (it != hvac_system_type_configuration_heating_system_type_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for IASZoneZoneState
const std::map<uint32_t, std::string> ias_zone_zone_state_enum_id_to_string_map {
  { 0, "NotEnrolled" },
  { 1, "Enrolled" },
};

// String to enum map for IASZoneZoneState
const std::map<std::string, uint32_t> ias_zone_zone_state_enum_string_to_id_map {
  { "NotEnrolled", 0 },
  { "Enrolled", 1 },
};

std::string ias_zone_zone_state_get_enum_value_name(
  uint32_t value)
{
  auto it = ias_zone_zone_state_enum_id_to_string_map.find(value);
  if (it != ias_zone_zone_state_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t ias_zone_zone_state_get_enum_value_number(const std::string &str)
{
  auto it = ias_zone_zone_state_enum_string_to_id_map.find(str);
  if (it != ias_zone_zone_state_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for IasZoneType
const std::map<uint32_t, std::string> ias_zone_type_enum_id_to_string_map {
  { 0, "StandardCIE" },
  { 13, "MotionSensor" },
  { 21, "ContactSwitch" },
  { 22, "DoorOrWindowHandle" },
  { 40, "FireSensor" },
  { 42, "WaterSensor" },
  { 43, "CarbonMonoxideSensor" },
  { 44, "PersonalEmergencyDevice" },
  { 45, "VibrationOrMovementSensor" },
  { 271, "RemoteControl" },
  { 277, "KeyFob" },
  { 541, "Keypad" },
  { 549, "StandardWarningDevice" },
  { 550, "GlassBreakSensor" },
  { 553, "SecurityRepeater" },
  { 65535, "Invalid" },
};

// String to enum map for IasZoneType
const std::map<std::string, uint32_t> ias_zone_type_enum_string_to_id_map {
  { "StandardCIE", 0 },
  { "MotionSensor", 13 },
  { "ContactSwitch", 21 },
  { "DoorOrWindowHandle", 22 },
  { "FireSensor", 40 },
  { "WaterSensor", 42 },
  { "CarbonMonoxideSensor", 43 },
  { "PersonalEmergencyDevice", 44 },
  { "VibrationOrMovementSensor", 45 },
  { "RemoteControl", 271 },
  { "KeyFob", 277 },
  { "Keypad", 541 },
  { "StandardWarningDevice", 549 },
  { "GlassBreakSensor", 550 },
  { "SecurityRepeater", 553 },
  { "Invalid", 65535 },
};

std::string ias_zone_type_get_enum_value_name(
  uint32_t value)
{
  auto it = ias_zone_type_enum_id_to_string_map.find(value);
  if (it != ias_zone_type_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t ias_zone_type_get_enum_value_number(const std::string &str)
{
  auto it = ias_zone_type_enum_string_to_id_map.find(str);
  if (it != ias_zone_type_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for IasacPanelStatus
const std::map<uint32_t, std::string> iasac_panel_status_enum_id_to_string_map {
  { 0, "PanelDisarmedReadyToArm" },
  { 1, "ArmedStay" },
  { 2, "ArmedNight" },
  { 3, "ArmedAway" },
  { 4, "ExitDelay" },
  { 5, "EntryDelay" },
  { 6, "NotReadyToArm" },
  { 7, "InAlarm" },
  { 8, "ArmingStay" },
  { 9, "ArmingNight" },
  { 10, "ArmingAway" },
};

// String to enum map for IasacPanelStatus
const std::map<std::string, uint32_t> iasac_panel_status_enum_string_to_id_map {
  { "PanelDisarmedReadyToArm", 0 },
  { "ArmedStay", 1 },
  { "ArmedNight", 2 },
  { "ArmedAway", 3 },
  { "ExitDelay", 4 },
  { "EntryDelay", 5 },
  { "NotReadyToArm", 6 },
  { "InAlarm", 7 },
  { "ArmingStay", 8 },
  { "ArmingNight", 9 },
  { "ArmingAway", 10 },
};

std::string iasac_panel_status_get_enum_value_name(
  uint32_t value)
{
  auto it = iasac_panel_status_enum_id_to_string_map.find(value);
  if (it != iasac_panel_status_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t iasac_panel_status_get_enum_value_number(const std::string &str)
{
  auto it = iasac_panel_status_enum_string_to_id_map.find(str);
  if (it != iasac_panel_status_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for IasaceAlarmStatus
const std::map<uint32_t, std::string> iasace_alarm_status_enum_id_to_string_map {
  { 0, "NoAlarm" },
  { 1, "Burgler" },
  { 2, "Fire" },
  { 3, "Emergency" },
  { 4, "PolicePanic" },
  { 5, "FirePanic" },
  { 6, "EmergencyPanic" },
};

// String to enum map for IasaceAlarmStatus
const std::map<std::string, uint32_t> iasace_alarm_status_enum_string_to_id_map {
  { "NoAlarm", 0 },
  { "Burgler", 1 },
  { "Fire", 2 },
  { "Emergency", 3 },
  { "PolicePanic", 4 },
  { "FirePanic", 5 },
  { "EmergencyPanic", 6 },
};

std::string iasace_alarm_status_get_enum_value_name(
  uint32_t value)
{
  auto it = iasace_alarm_status_enum_id_to_string_map.find(value);
  if (it != iasace_alarm_status_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t iasace_alarm_status_get_enum_value_number(const std::string &str)
{
  auto it = iasace_alarm_status_enum_string_to_id_map.find(str);
  if (it != iasace_alarm_status_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for IasaceAudibleNotification
const std::map<uint32_t, std::string> iasace_audible_notification_enum_id_to_string_map {
  { 0, "Mute" },
  { 1, "DefaultSound" },
};

// String to enum map for IasaceAudibleNotification
const std::map<std::string, uint32_t> iasace_audible_notification_enum_string_to_id_map {
  { "Mute", 0 },
  { "DefaultSound", 1 },
};

std::string iasace_audible_notification_get_enum_value_name(
  uint32_t value)
{
  auto it = iasace_audible_notification_enum_id_to_string_map.find(value);
  if (it != iasace_audible_notification_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t iasace_audible_notification_get_enum_value_number(const std::string &str)
{
  auto it = iasace_audible_notification_enum_string_to_id_map.find(str);
  if (it != iasace_audible_notification_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for IaswdLevel
const std::map<uint32_t, std::string> iaswd_level_enum_id_to_string_map {
  { 0, "LowLevel" },
  { 1, "MediumLevel" },
  { 2, "HighLevel" },
  { 3, "VeryHighLevel" },
};

// String to enum map for IaswdLevel
const std::map<std::string, uint32_t> iaswd_level_enum_string_to_id_map {
  { "LowLevel", 0 },
  { "MediumLevel", 1 },
  { "HighLevel", 2 },
  { "VeryHighLevel", 3 },
};

std::string iaswd_level_get_enum_value_name(
  uint32_t value)
{
  auto it = iaswd_level_enum_id_to_string_map.find(value);
  if (it != iaswd_level_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t iaswd_level_get_enum_value_number(const std::string &str)
{
  auto it = iaswd_level_enum_string_to_id_map.find(str);
  if (it != iaswd_level_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for IlluminanceLevelSensingLevelStatus
const std::map<uint32_t, std::string> illuminance_level_sensing_level_status_enum_id_to_string_map {
  { 0, "IlluminanceOnTarget" },
  { 1, "IlluminanceBelowTarget" },
  { 2, "IlluminanceAboveTarget" },
};

// String to enum map for IlluminanceLevelSensingLevelStatus
const std::map<std::string, uint32_t> illuminance_level_sensing_level_status_enum_string_to_id_map {
  { "IlluminanceOnTarget", 0 },
  { "IlluminanceBelowTarget", 1 },
  { "IlluminanceAboveTarget", 2 },
};

std::string illuminance_level_sensing_level_status_get_enum_value_name(
  uint32_t value)
{
  auto it = illuminance_level_sensing_level_status_enum_id_to_string_map.find(value);
  if (it != illuminance_level_sensing_level_status_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t illuminance_level_sensing_level_status_get_enum_value_number(const std::string &str)
{
  auto it = illuminance_level_sensing_level_status_enum_string_to_id_map.find(str);
  if (it != illuminance_level_sensing_level_status_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for IlluminanceLevelSensingLightSensorType
const std::map<uint32_t, std::string> illuminance_level_sensing_light_sensor_type_enum_id_to_string_map {
  { 0, "Photodiode" },
  { 1, "CMOS" },
  { 255, "Unknown" },
};

// String to enum map for IlluminanceLevelSensingLightSensorType
const std::map<std::string, uint32_t> illuminance_level_sensing_light_sensor_type_enum_string_to_id_map {
  { "Photodiode", 0 },
  { "CMOS", 1 },
  { "Unknown", 255 },
};

std::string illuminance_level_sensing_light_sensor_type_get_enum_value_name(
  uint32_t value)
{
  auto it = illuminance_level_sensing_light_sensor_type_enum_id_to_string_map.find(value);
  if (it != illuminance_level_sensing_light_sensor_type_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t illuminance_level_sensing_light_sensor_type_get_enum_value_number(const std::string &str)
{
  auto it = illuminance_level_sensing_light_sensor_type_enum_string_to_id_map.find(str);
  if (it != illuminance_level_sensing_light_sensor_type_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for IlluminanceMeasurementLightSensorType
const std::map<uint32_t, std::string> illuminance_measurement_light_sensor_type_enum_id_to_string_map {
  { 0, "Photodiode" },
  { 1, "CMOS" },
  { 255, "Unknown" },
};

// String to enum map for IlluminanceMeasurementLightSensorType
const std::map<std::string, uint32_t> illuminance_measurement_light_sensor_type_enum_string_to_id_map {
  { "Photodiode", 0 },
  { "CMOS", 1 },
  { "Unknown", 255 },
};

std::string illuminance_measurement_light_sensor_type_get_enum_value_name(
  uint32_t value)
{
  auto it = illuminance_measurement_light_sensor_type_enum_id_to_string_map.find(value);
  if (it != illuminance_measurement_light_sensor_type_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t illuminance_measurement_light_sensor_type_get_enum_value_number(const std::string &str)
{
  auto it = illuminance_measurement_light_sensor_type_enum_string_to_id_map.find(str);
  if (it != illuminance_measurement_light_sensor_type_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ImageNotifyPayloadType
const std::map<uint32_t, std::string> image_notify_payload_type_enum_id_to_string_map {
  { 0, "QueryJitter" },
  { 1, "QueryJitterAndManufacturerCode" },
  { 2, "QueryJitterManufacturerCodeAndImageType" },
  { 3, "QueryJitterManufacturerCodeImageTypeAndNewFileVersion" },
};

// String to enum map for ImageNotifyPayloadType
const std::map<std::string, uint32_t> image_notify_payload_type_enum_string_to_id_map {
  { "QueryJitter", 0 },
  { "QueryJitterAndManufacturerCode", 1 },
  { "QueryJitterManufacturerCodeAndImageType", 2 },
  { "QueryJitterManufacturerCodeImageTypeAndNewFileVersion", 3 },
};

std::string image_notify_payload_type_get_enum_value_name(
  uint32_t value)
{
  auto it = image_notify_payload_type_enum_id_to_string_map.find(value);
  if (it != image_notify_payload_type_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t image_notify_payload_type_get_enum_value_number(const std::string &str)
{
  auto it = image_notify_payload_type_enum_string_to_id_map.find(str);
  if (it != image_notify_payload_type_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for LoggingLevelEnum
const std::map<uint32_t, std::string> logging_level_enum_enum_id_to_string_map {
  { 0, "Debug" },
  { 1, "Info" },
  { 2, "Warning" },
  { 3, "Error" },
  { 4, "Critical" },
};

// String to enum map for LoggingLevelEnum
const std::map<std::string, uint32_t> logging_level_enum_enum_string_to_id_map {
  { "Debug", 0 },
  { "Info", 1 },
  { "Warning", 2 },
  { "Error", 3 },
  { "Critical", 4 },
};

std::string logging_level_enum_get_enum_value_name(
  uint32_t value)
{
  auto it = logging_level_enum_enum_id_to_string_map.find(value);
  if (it != logging_level_enum_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t logging_level_enum_get_enum_value_number(const std::string &str)
{
  auto it = logging_level_enum_enum_string_to_id_map.find(str);
  if (it != logging_level_enum_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for MeteringEnergyCarrierUnitOfMeasure
const std::map<uint32_t, std::string> metering_energy_carrier_unit_of_measure_enum_id_to_string_map {
  { 0, "KilowattHoursOrKilowatts" },
  { 1, "CubicMeterOrCubicMeterPerHour" },
  { 2, "CubicFeetOrCubicFeetPerHour" },
  { 3, "CentumCubicFeetOrCentum" },
  { 4, "USGallonsOrUSGalonsPerHour" },
  { 5, "ImperialGallonsOrImperialGallonsPerhour" },
  { 6, "BTUsOrBTUPerhour" },
  { 7, "LitersOrLitersPerHour" },
  { 8, "kPAGaugein" },
  { 9, "kPAabsolute" },
  { 10, "mcfCubicFeetOr mcfPerHour" },
  { 11, "Unitless" },
  { 12, "MegaJouleMegaJoulePerSecond" },
};

// String to enum map for MeteringEnergyCarrierUnitOfMeasure
const std::map<std::string, uint32_t> metering_energy_carrier_unit_of_measure_enum_string_to_id_map {
  { "KilowattHoursOrKilowatts", 0 },
  { "CubicMeterOrCubicMeterPerHour", 1 },
  { "CubicFeetOrCubicFeetPerHour", 2 },
  { "CentumCubicFeetOrCentum", 3 },
  { "USGallonsOrUSGalonsPerHour", 4 },
  { "ImperialGallonsOrImperialGallonsPerhour", 5 },
  { "BTUsOrBTUPerhour", 6 },
  { "LitersOrLitersPerHour", 7 },
  { "kPAGaugein", 8 },
  { "kPAabsolute", 9 },
  { "mcfCubicFeetOr mcfPerHour", 10 },
  { "Unitless", 11 },
  { "MegaJouleMegaJoulePerSecond", 12 },
};

std::string metering_energy_carrier_unit_of_measure_get_enum_value_name(
  uint32_t value)
{
  auto it = metering_energy_carrier_unit_of_measure_enum_id_to_string_map.find(value);
  if (it != metering_energy_carrier_unit_of_measure_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t metering_energy_carrier_unit_of_measure_get_enum_value_number(const std::string &str)
{
  auto it = metering_energy_carrier_unit_of_measure_enum_string_to_id_map.find(str);
  if (it != metering_energy_carrier_unit_of_measure_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for MeteringMeteringDeviceType
const std::map<uint32_t, std::string> metering_metering_device_type_enum_id_to_string_map {
  { 0, "ElectricMetering" },
  { 1, "GasMetering" },
  { 2, "WaterMetering" },
  { 3, "ThermalMetering" },
  { 4, "PressureMetering" },
  { 5, "HeatMetering" },
  { 6, "CoolingMetering" },
  { 128, "MirroredGasMetering" },
  { 129, "MirroredWaterMetering" },
  { 130, "MirroredThermalMetering" },
  { 131, "MirroredPressureMetering" },
  { 132, "MirroredHeatMetering" },
  { 133, "MirroredCoolingMetering" },
};

// String to enum map for MeteringMeteringDeviceType
const std::map<std::string, uint32_t> metering_metering_device_type_enum_string_to_id_map {
  { "ElectricMetering", 0 },
  { "GasMetering", 1 },
  { "WaterMetering", 2 },
  { "ThermalMetering", 3 },
  { "PressureMetering", 4 },
  { "HeatMetering", 5 },
  { "CoolingMetering", 6 },
  { "MirroredGasMetering", 128 },
  { "MirroredWaterMetering", 129 },
  { "MirroredThermalMetering", 130 },
  { "MirroredPressureMetering", 131 },
  { "MirroredHeatMetering", 132 },
  { "MirroredCoolingMetering", 133 },
};

std::string metering_metering_device_type_get_enum_value_name(
  uint32_t value)
{
  auto it = metering_metering_device_type_enum_id_to_string_map.find(value);
  if (it != metering_metering_device_type_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t metering_metering_device_type_get_enum_value_number(const std::string &str)
{
  auto it = metering_metering_device_type_enum_string_to_id_map.find(str);
  if (it != metering_metering_device_type_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for MeteringSupplyStatus
const std::map<uint32_t, std::string> metering_supply_status_enum_id_to_string_map {
  { 0, "SupplyOFF" },
  { 1, "SupplyOFFOrARMED" },
  { 2, "SupplyON" },
};

// String to enum map for MeteringSupplyStatus
const std::map<std::string, uint32_t> metering_supply_status_enum_string_to_id_map {
  { "SupplyOFF", 0 },
  { "SupplyOFFOrARMED", 1 },
  { "SupplyON", 2 },
};

std::string metering_supply_status_get_enum_value_name(
  uint32_t value)
{
  auto it = metering_supply_status_enum_id_to_string_map.find(value);
  if (it != metering_supply_status_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t metering_supply_status_get_enum_value_number(const std::string &str)
{
  auto it = metering_supply_status_enum_string_to_id_map.find(str);
  if (it != metering_supply_status_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for MeteringTemperatureUnitOfMeasure
const std::map<uint32_t, std::string> metering_temperature_unit_of_measure_enum_id_to_string_map {
  { 0, "DegreesKelvin" },
  { 1, "DegreesCelsius" },
  { 2, "DegreesFahrenheit" },
};

// String to enum map for MeteringTemperatureUnitOfMeasure
const std::map<std::string, uint32_t> metering_temperature_unit_of_measure_enum_string_to_id_map {
  { "DegreesKelvin", 0 },
  { "DegreesCelsius", 1 },
  { "DegreesFahrenheit", 2 },
};

std::string metering_temperature_unit_of_measure_get_enum_value_name(
  uint32_t value)
{
  auto it = metering_temperature_unit_of_measure_enum_id_to_string_map.find(value);
  if (it != metering_temperature_unit_of_measure_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t metering_temperature_unit_of_measure_get_enum_value_number(const std::string &str)
{
  auto it = metering_temperature_unit_of_measure_enum_string_to_id_map.find(str);
  if (it != metering_temperature_unit_of_measure_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for MeteringUnitofMeasure
const std::map<uint32_t, std::string> metering_unitof_measure_enum_id_to_string_map {
  { 0, "KilowattHoursOrKilowatts" },
  { 1, "CubicMeterOrCubicMeterPerHour" },
  { 2, "CubicFeetOrCubicFeetPerHour" },
  { 3, "CentumCubicFeetOrCentum" },
  { 4, "USGallonsOrUSGalonsPerHour" },
  { 5, "ImperialGallonsOrImperialGallonsPerhour" },
  { 6, "BTUsOrBTUPerhour" },
  { 7, "LitersOrLitersPerHour" },
  { 8, "kPAGaugein" },
  { 9, "kPAabsolute" },
  { 10, "mcfCubicFeetOr mcfPerHour" },
  { 11, "Unitless" },
  { 12, "MegaJouleMegaJoulePerSecond" },
};

// String to enum map for MeteringUnitofMeasure
const std::map<std::string, uint32_t> metering_unitof_measure_enum_string_to_id_map {
  { "KilowattHoursOrKilowatts", 0 },
  { "CubicMeterOrCubicMeterPerHour", 1 },
  { "CubicFeetOrCubicFeetPerHour", 2 },
  { "CentumCubicFeetOrCentum", 3 },
  { "USGallonsOrUSGalonsPerHour", 4 },
  { "ImperialGallonsOrImperialGallonsPerhour", 5 },
  { "BTUsOrBTUPerhour", 6 },
  { "LitersOrLitersPerHour", 7 },
  { "kPAGaugein", 8 },
  { "kPAabsolute", 9 },
  { "mcfCubicFeetOr mcfPerHour", 10 },
  { "Unitless", 11 },
  { "MegaJouleMegaJoulePerSecond", 12 },
};

std::string metering_unitof_measure_get_enum_value_name(
  uint32_t value)
{
  auto it = metering_unitof_measure_enum_id_to_string_map.find(value);
  if (it != metering_unitof_measure_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t metering_unitof_measure_get_enum_value_number(const std::string &str)
{
  auto it = metering_unitof_measure_enum_string_to_id_map.find(str);
  if (it != metering_unitof_measure_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for MoveStepMode
const std::map<uint32_t, std::string> move_step_mode_enum_id_to_string_map {
  { 0, "Up" },
  { 1, "Down" },
};

// String to enum map for MoveStepMode
const std::map<std::string, uint32_t> move_step_mode_enum_string_to_id_map {
  { "Up", 0 },
  { "Down", 1 },
};

std::string move_step_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = move_step_mode_enum_id_to_string_map.find(value);
  if (it != move_step_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t move_step_mode_get_enum_value_number(const std::string &str)
{
  auto it = move_step_mode_enum_string_to_id_map.find(str);
  if (it != move_step_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for NM_State
const std::map<uint32_t, std::string> nm_state_enum_id_to_string_map {
  { 0, "idle" },
  { 1, "add node" },
  { 2, "remove node" },
  { 3, "join network" },
  { 4, "leave network" },
  { 5, "network repair" },
  { 6, "network update" },
  { 7, "reset" },
  { 8, "scan mode" },
};

// String to enum map for NM_State
const std::map<std::string, uint32_t> nm_state_enum_string_to_id_map {
  { "idle", 0 },
  { "add node", 1 },
  { "remove node", 2 },
  { "join network", 3 },
  { "leave network", 4 },
  { "network repair", 5 },
  { "network update", 6 },
  { "reset", 7 },
  { "scan mode", 8 },
};

std::string nm_state_get_enum_value_name(
  uint32_t value)
{
  auto it = nm_state_enum_id_to_string_map.find(value);
  if (it != nm_state_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t nm_state_get_enum_value_number(const std::string &str)
{
  auto it = nm_state_enum_string_to_id_map.find(str);
  if (it != nm_state_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for NodeStateNetworkStatus
const std::map<uint32_t, std::string> node_state_network_status_enum_id_to_string_map {
  { 0, "Online functional" },
  { 1, "Online interviewing" },
  { 2, "Online non-functional" },
  { 3, "Unavailable" },
  { 4, "Offline" },
};

// String to enum map for NodeStateNetworkStatus
const std::map<std::string, uint32_t> node_state_network_status_enum_string_to_id_map {
  { "Online functional", 0 },
  { "Online interviewing", 1 },
  { "Online non-functional", 2 },
  { "Unavailable", 3 },
  { "Offline", 4 },
};

std::string node_state_network_status_get_enum_value_name(
  uint32_t value)
{
  auto it = node_state_network_status_enum_id_to_string_map.find(value);
  if (it != node_state_network_status_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t node_state_network_status_get_enum_value_number(const std::string &str)
{
  auto it = node_state_network_status_enum_string_to_id_map.find(str);
  if (it != node_state_network_status_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for NodeStateSecurity
const std::map<uint32_t, std::string> node_state_security_enum_id_to_string_map {
  { 0, "None" },
  { 1, "Z-Wave S0" },
  { 2, "Z-Wave S2 Unauthenticated" },
  { 3, "Z-Wave S2 Authenticated" },
  { 4, "Z-Wave S2 Access Control" },
  { 5, "Zigbee Z3" },
};

// String to enum map for NodeStateSecurity
const std::map<std::string, uint32_t> node_state_security_enum_string_to_id_map {
  { "None", 0 },
  { "Z-Wave S0", 1 },
  { "Z-Wave S2 Unauthenticated", 2 },
  { "Z-Wave S2 Authenticated", 3 },
  { "Z-Wave S2 Access Control", 4 },
  { "Zigbee Z3", 5 },
};

std::string node_state_security_get_enum_value_name(
  uint32_t value)
{
  auto it = node_state_security_enum_id_to_string_map.find(value);
  if (it != node_state_security_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t node_state_security_get_enum_value_number(const std::string &str)
{
  auto it = node_state_security_enum_string_to_id_map.find(str);
  if (it != node_state_security_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for OTADeviceSpecificImageType
const std::map<uint32_t, std::string> ota_device_specific_image_type_enum_id_to_string_map {
  { 65472, "ClientSecurityCredentials" },
  { 65473, "ClientConfiguration" },
  { 65474, "ServerLog" },
  { 65475, "Picture" },
};

// String to enum map for OTADeviceSpecificImageType
const std::map<std::string, uint32_t> ota_device_specific_image_type_enum_string_to_id_map {
  { "ClientSecurityCredentials", 65472 },
  { "ClientConfiguration", 65473 },
  { "ServerLog", 65474 },
  { "Picture", 65475 },
};

std::string ota_device_specific_image_type_get_enum_value_name(
  uint32_t value)
{
  auto it = ota_device_specific_image_type_enum_id_to_string_map.find(value);
  if (it != ota_device_specific_image_type_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t ota_device_specific_image_type_get_enum_value_number(const std::string &str)
{
  auto it = ota_device_specific_image_type_enum_string_to_id_map.find(str);
  if (it != ota_device_specific_image_type_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for OTAUpgradeImageUpgradeStatus
const std::map<uint32_t, std::string> ota_upgrade_image_upgrade_status_enum_id_to_string_map {
  { 0, "Normal" },
  { 1, "DownloadInProgress" },
  { 2, "DownloadComplete" },
  { 3, "WaitingToUpgrade" },
  { 4, "CountDown" },
  { 5, "WaitForMore" },
  { 6, "WaitingToUpgradeViaExternalEvent" },
};

// String to enum map for OTAUpgradeImageUpgradeStatus
const std::map<std::string, uint32_t> ota_upgrade_image_upgrade_status_enum_string_to_id_map {
  { "Normal", 0 },
  { "DownloadInProgress", 1 },
  { "DownloadComplete", 2 },
  { "WaitingToUpgrade", 3 },
  { "CountDown", 4 },
  { "WaitForMore", 5 },
  { "WaitingToUpgradeViaExternalEvent", 6 },
};

std::string ota_upgrade_image_upgrade_status_get_enum_value_name(
  uint32_t value)
{
  auto it = ota_upgrade_image_upgrade_status_enum_id_to_string_map.find(value);
  if (it != ota_upgrade_image_upgrade_status_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t ota_upgrade_image_upgrade_status_get_enum_value_number(const std::string &str)
{
  auto it = ota_upgrade_image_upgrade_status_enum_string_to_id_map.find(str);
  if (it != ota_upgrade_image_upgrade_status_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for OTAUpgradeUpgradeActivationPolicy
const std::map<uint32_t, std::string> ota_upgrade_upgrade_activation_policy_enum_id_to_string_map {
  { 0, "OTAServerActivationAllowed" },
  { 1, "OutOfBandActivationOnly" },
};

// String to enum map for OTAUpgradeUpgradeActivationPolicy
const std::map<std::string, uint32_t> ota_upgrade_upgrade_activation_policy_enum_string_to_id_map {
  { "OTAServerActivationAllowed", 0 },
  { "OutOfBandActivationOnly", 1 },
};

std::string ota_upgrade_upgrade_activation_policy_get_enum_value_name(
  uint32_t value)
{
  auto it = ota_upgrade_upgrade_activation_policy_enum_id_to_string_map.find(value);
  if (it != ota_upgrade_upgrade_activation_policy_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t ota_upgrade_upgrade_activation_policy_get_enum_value_number(const std::string &str)
{
  auto it = ota_upgrade_upgrade_activation_policy_enum_string_to_id_map.find(str);
  if (it != ota_upgrade_upgrade_activation_policy_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for OTAUpgradeUpgradeTimeoutPolicy
const std::map<uint32_t, std::string> ota_upgrade_upgrade_timeout_policy_enum_id_to_string_map {
  { 0, "ApplyUpgradeAfterTimeout" },
  { 1, "DoNotApplyUpgradeAfterTimeout" },
};

// String to enum map for OTAUpgradeUpgradeTimeoutPolicy
const std::map<std::string, uint32_t> ota_upgrade_upgrade_timeout_policy_enum_string_to_id_map {
  { "ApplyUpgradeAfterTimeout", 0 },
  { "DoNotApplyUpgradeAfterTimeout", 1 },
};

std::string ota_upgrade_upgrade_timeout_policy_get_enum_value_name(
  uint32_t value)
{
  auto it = ota_upgrade_upgrade_timeout_policy_enum_id_to_string_map.find(value);
  if (it != ota_upgrade_upgrade_timeout_policy_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t ota_upgrade_upgrade_timeout_policy_get_enum_value_number(const std::string &str)
{
  auto it = ota_upgrade_upgrade_timeout_policy_enum_string_to_id_map.find(str);
  if (it != ota_upgrade_upgrade_timeout_policy_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for OccupancySensingOccupancySensorType
const std::map<uint32_t, std::string> occupancy_sensing_occupancy_sensor_type_enum_id_to_string_map {
  { 0, "PIR" },
  { 1, "Ultrasonic" },
  { 2, "PIRAndUltrasonic" },
  { 3, "PhysicalContact" },
};

// String to enum map for OccupancySensingOccupancySensorType
const std::map<std::string, uint32_t> occupancy_sensing_occupancy_sensor_type_enum_string_to_id_map {
  { "PIR", 0 },
  { "Ultrasonic", 1 },
  { "PIRAndUltrasonic", 2 },
  { "PhysicalContact", 3 },
};

std::string occupancy_sensing_occupancy_sensor_type_get_enum_value_name(
  uint32_t value)
{
  auto it = occupancy_sensing_occupancy_sensor_type_enum_id_to_string_map.find(value);
  if (it != occupancy_sensing_occupancy_sensor_type_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t occupancy_sensing_occupancy_sensor_type_get_enum_value_number(const std::string &str)
{
  auto it = occupancy_sensing_occupancy_sensor_type_enum_string_to_id_map.find(str);
  if (it != occupancy_sensing_occupancy_sensor_type_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for OffWithEffectEffectIdentifier
const std::map<uint32_t, std::string> off_with_effect_effect_identifier_enum_id_to_string_map {
  { 0, "DelayedAllOff" },
  { 1, "DyingLight" },
};

// String to enum map for OffWithEffectEffectIdentifier
const std::map<std::string, uint32_t> off_with_effect_effect_identifier_enum_string_to_id_map {
  { "DelayedAllOff", 0 },
  { "DyingLight", 1 },
};

std::string off_with_effect_effect_identifier_get_enum_value_name(
  uint32_t value)
{
  auto it = off_with_effect_effect_identifier_enum_id_to_string_map.find(value);
  if (it != off_with_effect_effect_identifier_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t off_with_effect_effect_identifier_get_enum_value_number(const std::string &str)
{
  auto it = off_with_effect_effect_identifier_enum_string_to_id_map.find(str);
  if (it != off_with_effect_effect_identifier_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for OnOffStartUpOnOff
const std::map<uint32_t, std::string> on_off_start_up_on_off_enum_id_to_string_map {
  { 0, "SetOnOffTo0" },
  { 1, "SetOnOffTo1" },
  { 2, "TogglePreviousOnOff" },
  { 255, "SetPreviousOnOff" },
};

// String to enum map for OnOffStartUpOnOff
const std::map<std::string, uint32_t> on_off_start_up_on_off_enum_string_to_id_map {
  { "SetOnOffTo0", 0 },
  { "SetOnOffTo1", 1 },
  { "TogglePreviousOnOff", 2 },
  { "SetPreviousOnOff", 255 },
};

std::string on_off_start_up_on_off_get_enum_value_name(
  uint32_t value)
{
  auto it = on_off_start_up_on_off_enum_id_to_string_map.find(value);
  if (it != on_off_start_up_on_off_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t on_off_start_up_on_off_get_enum_value_number(const std::string &str)
{
  auto it = on_off_start_up_on_off_enum_string_to_id_map.find(str);
  if (it != on_off_start_up_on_off_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for OperatingEventNotificationOperationEventCode
const std::map<uint32_t, std::string> operating_event_notification_operation_event_code_enum_id_to_string_map {
  { 0, "UnknownOrMS" },
  { 1, "Lock" },
  { 2, "Unlock" },
  { 3, "LockFailureInvalidPINOrID" },
  { 4, "LockFailureInvalidSchedule" },
  { 5, "UnlockFailureInvalidPINOrID" },
  { 6, "UnlockFailureInvalidSchedule" },
  { 7, "OneTouchLock" },
  { 8, "KeyLock" },
  { 9, "KeyUnlock" },
  { 10, "AutoLock" },
  { 11, "ScheduleLock" },
  { 12, "ScheduleUnlock" },
  { 13, "ManualLock" },
  { 14, "ManualUnlock" },
  { 14, "NonAccessUserOperationalEvent" },
};

// String to enum map for OperatingEventNotificationOperationEventCode
const std::map<std::string, uint32_t> operating_event_notification_operation_event_code_enum_string_to_id_map {
  { "UnknownOrMS", 0 },
  { "Lock", 1 },
  { "Unlock", 2 },
  { "LockFailureInvalidPINOrID", 3 },
  { "LockFailureInvalidSchedule", 4 },
  { "UnlockFailureInvalidPINOrID", 5 },
  { "UnlockFailureInvalidSchedule", 6 },
  { "OneTouchLock", 7 },
  { "KeyLock", 8 },
  { "KeyUnlock", 9 },
  { "AutoLock", 10 },
  { "ScheduleLock", 11 },
  { "ScheduleUnlock", 12 },
  { "ManualLock", 13 },
  { "ManualUnlock", 14 },
  { "NonAccessUserOperationalEvent", 14 },
};

std::string operating_event_notification_operation_event_code_get_enum_value_name(
  uint32_t value)
{
  auto it = operating_event_notification_operation_event_code_enum_id_to_string_map.find(value);
  if (it != operating_event_notification_operation_event_code_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t operating_event_notification_operation_event_code_get_enum_value_number(const std::string &str)
{
  auto it = operating_event_notification_operation_event_code_enum_string_to_id_map.find(str);
  if (it != operating_event_notification_operation_event_code_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for OptionsStartupMode
const std::map<uint32_t, std::string> options_startup_mode_enum_id_to_string_map {
  { 0, "RestartUsingStartupParameters" },
  { 1, "RestartUsingCurrentState" },
};

// String to enum map for OptionsStartupMode
const std::map<std::string, uint32_t> options_startup_mode_enum_string_to_id_map {
  { "RestartUsingStartupParameters", 0 },
  { "RestartUsingCurrentState", 1 },
};

std::string options_startup_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = options_startup_mode_enum_id_to_string_map.find(value);
  if (it != options_startup_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t options_startup_mode_get_enum_value_number(const std::string &str)
{
  auto it = options_startup_mode_enum_string_to_id_map.find(str);
  if (it != options_startup_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ProfileIntervalPeriod
const std::map<uint32_t, std::string> profile_interval_period_enum_id_to_string_map {
  { 0, "Daily" },
  { 1, "60Minutes" },
  { 2, "30Minutes" },
  { 3, "15Minutes" },
  { 4, "10Minutes" },
  { 5, "7dot5Minutes" },
  { 6, "5Minutes" },
  { 7, "2dot5Minutes" },
};

// String to enum map for ProfileIntervalPeriod
const std::map<std::string, uint32_t> profile_interval_period_enum_string_to_id_map {
  { "Daily", 0 },
  { "60Minutes", 1 },
  { "30Minutes", 2 },
  { "15Minutes", 3 },
  { "10Minutes", 4 },
  { "7dot5Minutes", 5 },
  { "5Minutes", 6 },
  { "2dot5Minutes", 7 },
};

std::string profile_interval_period_get_enum_value_name(
  uint32_t value)
{
  auto it = profile_interval_period_enum_id_to_string_map.find(value);
  if (it != profile_interval_period_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t profile_interval_period_get_enum_value_number(const std::string &str)
{
  auto it = profile_interval_period_enum_string_to_id_map.find(str);
  if (it != profile_interval_period_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ProgrammingEventNotificationProgramEventCode
const std::map<uint32_t, std::string> programming_event_notification_program_event_code_enum_id_to_string_map {
  { 0, "UnknownOrMS" },
  { 1, "MasterCodeChanged" },
  { 2, "PINCodeAdded" },
  { 3, "PINCodeDeleted" },
  { 4, "PINCodeChanged" },
  { 5, "RFIDCodeAdded" },
  { 6, "RFIDCodeDeleted" },
};

// String to enum map for ProgrammingEventNotificationProgramEventCode
const std::map<std::string, uint32_t> programming_event_notification_program_event_code_enum_string_to_id_map {
  { "UnknownOrMS", 0 },
  { "MasterCodeChanged", 1 },
  { "PINCodeAdded", 2 },
  { "PINCodeDeleted", 3 },
  { "PINCodeChanged", 4 },
  { "RFIDCodeAdded", 5 },
  { "RFIDCodeDeleted", 6 },
};

std::string programming_event_notification_program_event_code_get_enum_value_name(
  uint32_t value)
{
  auto it = programming_event_notification_program_event_code_enum_id_to_string_map.find(value);
  if (it != programming_event_notification_program_event_code_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t programming_event_notification_program_event_code_get_enum_value_number(const std::string &str)
{
  auto it = programming_event_notification_program_event_code_enum_string_to_id_map.find(str);
  if (it != programming_event_notification_program_event_code_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ProgrammingEventNotificationProgramEventSource
const std::map<uint32_t, std::string> programming_event_notification_program_event_source_enum_id_to_string_map {
  { 0, "Keypad" },
  { 1, "RF" },
  { 3, "RFID" },
  { 255, "Indeterminate" },
};

// String to enum map for ProgrammingEventNotificationProgramEventSource
const std::map<std::string, uint32_t> programming_event_notification_program_event_source_enum_string_to_id_map {
  { "Keypad", 0 },
  { "RF", 1 },
  { "RFID", 3 },
  { "Indeterminate", 255 },
};

std::string programming_event_notification_program_event_source_get_enum_value_name(
  uint32_t value)
{
  auto it = programming_event_notification_program_event_source_enum_id_to_string_map.find(value);
  if (it != programming_event_notification_program_event_source_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t programming_event_notification_program_event_source_get_enum_value_number(const std::string &str)
{
  auto it = programming_event_notification_program_event_source_enum_string_to_id_map.find(str);
  if (it != programming_event_notification_program_event_source_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for PumpControlMode
const std::map<uint32_t, std::string> pump_control_mode_enum_id_to_string_map {
  { 0, "ConstantSpeed" },
  { 1, "ConstantPressure" },
  { 2, "ProportionalPressure" },
  { 3, "ConstantFlow" },
  { 5, "ConstantTemperature" },
  { 7, "Automatic" },
};

// String to enum map for PumpControlMode
const std::map<std::string, uint32_t> pump_control_mode_enum_string_to_id_map {
  { "ConstantSpeed", 0 },
  { "ConstantPressure", 1 },
  { "ProportionalPressure", 2 },
  { "ConstantFlow", 3 },
  { "ConstantTemperature", 5 },
  { "Automatic", 7 },
};

std::string pump_control_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = pump_control_mode_enum_id_to_string_map.find(value);
  if (it != pump_control_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t pump_control_mode_get_enum_value_number(const std::string &str)
{
  auto it = pump_control_mode_enum_string_to_id_map.find(str);
  if (it != pump_control_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for PumpOperationMode
const std::map<uint32_t, std::string> pump_operation_mode_enum_id_to_string_map {
  { 0, "Normal" },
  { 1, "Minimum" },
  { 2, "Maximum" },
  { 3, "Local" },
};

// String to enum map for PumpOperationMode
const std::map<std::string, uint32_t> pump_operation_mode_enum_string_to_id_map {
  { "Normal", 0 },
  { "Minimum", 1 },
  { "Maximum", 2 },
  { "Local", 3 },
};

std::string pump_operation_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = pump_operation_mode_enum_id_to_string_map.find(value);
  if (it != pump_operation_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t pump_operation_mode_get_enum_value_number(const std::string &str)
{
  auto it = pump_operation_mode_enum_string_to_id_map.find(str);
  if (it != pump_operation_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for SHDCFGDirection
const std::map<uint32_t, std::string> shdcfg_direction_enum_id_to_string_map {
  { 0, "Closing" },
  { 1, "Opening" },
};

// String to enum map for SHDCFGDirection
const std::map<std::string, uint32_t> shdcfg_direction_enum_string_to_id_map {
  { "Closing", 0 },
  { "Opening", 1 },
};

std::string shdcfg_direction_get_enum_value_name(
  uint32_t value)
{
  auto it = shdcfg_direction_enum_id_to_string_map.find(value);
  if (it != shdcfg_direction_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t shdcfg_direction_get_enum_value_number(const std::string &str)
{
  auto it = shdcfg_direction_enum_string_to_id_map.find(str);
  if (it != shdcfg_direction_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for SetpointRaiseOrLowerMode
const std::map<uint32_t, std::string> setpoint_raise_or_lower_mode_enum_id_to_string_map {
  { 0, "Heat" },
  { 1, "Cool" },
  { 2, "Both" },
};

// String to enum map for SetpointRaiseOrLowerMode
const std::map<std::string, uint32_t> setpoint_raise_or_lower_mode_enum_string_to_id_map {
  { "Heat", 0 },
  { "Cool", 1 },
  { "Both", 2 },
};

std::string setpoint_raise_or_lower_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = setpoint_raise_or_lower_mode_enum_id_to_string_map.find(value);
  if (it != setpoint_raise_or_lower_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t setpoint_raise_or_lower_mode_get_enum_value_number(const std::string &str)
{
  auto it = setpoint_raise_or_lower_mode_enum_string_to_id_map.find(str);
  if (it != setpoint_raise_or_lower_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ShadeConfigurationMode
const std::map<uint32_t, std::string> shade_configuration_mode_enum_id_to_string_map {
  { 0, "Normal" },
  { 1, "Configure" },
};

// String to enum map for ShadeConfigurationMode
const std::map<std::string, uint32_t> shade_configuration_mode_enum_string_to_id_map {
  { "Normal", 0 },
  { "Configure", 1 },
};

std::string shade_configuration_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = shade_configuration_mode_enum_id_to_string_map.find(value);
  if (it != shade_configuration_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t shade_configuration_mode_get_enum_value_number(const std::string &str)
{
  auto it = shade_configuration_mode_enum_string_to_id_map.find(str);
  if (it != shade_configuration_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for SirenConfigurationStrobe
const std::map<uint32_t, std::string> siren_configuration_strobe_enum_id_to_string_map {
  { 0, "NoStrobe" },
  { 1, "UseStrobe" },
};

// String to enum map for SirenConfigurationStrobe
const std::map<std::string, uint32_t> siren_configuration_strobe_enum_string_to_id_map {
  { "NoStrobe", 0 },
  { "UseStrobe", 1 },
};

std::string siren_configuration_strobe_get_enum_value_name(
  uint32_t value)
{
  auto it = siren_configuration_strobe_enum_id_to_string_map.find(value);
  if (it != siren_configuration_strobe_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t siren_configuration_strobe_get_enum_value_number(const std::string &str)
{
  auto it = siren_configuration_strobe_enum_string_to_id_map.find(str);
  if (it != siren_configuration_strobe_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for SirenConfigurationWarningMode
const std::map<uint32_t, std::string> siren_configuration_warning_mode_enum_id_to_string_map {
  { 0, "Stop" },
  { 1, "Burgler" },
  { 2, "Fire" },
  { 3, "Emergency" },
  { 4, "PolicePanic" },
  { 5, "FirePanic" },
  { 6, "EmergencyPanic" },
};

// String to enum map for SirenConfigurationWarningMode
const std::map<std::string, uint32_t> siren_configuration_warning_mode_enum_string_to_id_map {
  { "Stop", 0 },
  { "Burgler", 1 },
  { "Fire", 2 },
  { "Emergency", 3 },
  { "PolicePanic", 4 },
  { "FirePanic", 5 },
  { "EmergencyPanic", 6 },
};

std::string siren_configuration_warning_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = siren_configuration_warning_mode_enum_id_to_string_map.find(value);
  if (it != siren_configuration_warning_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t siren_configuration_warning_mode_get_enum_value_number(const std::string &str)
{
  auto it = siren_configuration_warning_mode_enum_string_to_id_map.find(str);
  if (it != siren_configuration_warning_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for SquawkConfigurationSquawkMode
const std::map<uint32_t, std::string> squawk_configuration_squawk_mode_enum_id_to_string_map {
  { 0, "SoundForSystemIsArmed" },
  { 1, "SoundForSystemIsDisarmed" },
};

// String to enum map for SquawkConfigurationSquawkMode
const std::map<std::string, uint32_t> squawk_configuration_squawk_mode_enum_string_to_id_map {
  { "SoundForSystemIsArmed", 0 },
  { "SoundForSystemIsDisarmed", 1 },
};

std::string squawk_configuration_squawk_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = squawk_configuration_squawk_mode_enum_id_to_string_map.find(value);
  if (it != squawk_configuration_squawk_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t squawk_configuration_squawk_mode_get_enum_value_number(const std::string &str)
{
  auto it = squawk_configuration_squawk_mode_enum_string_to_id_map.find(str);
  if (it != squawk_configuration_squawk_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for TLKeyIndex
const std::map<uint32_t, std::string> tl_key_index_enum_id_to_string_map {
  { 0, "DevelopmentKey" },
  { 4, "MasterKey" },
  { 15, "CertificationKey" },
};

// String to enum map for TLKeyIndex
const std::map<std::string, uint32_t> tl_key_index_enum_string_to_id_map {
  { "DevelopmentKey", 0 },
  { "MasterKey", 4 },
  { "CertificationKey", 15 },
};

std::string tl_key_index_get_enum_value_name(
  uint32_t value)
{
  auto it = tl_key_index_enum_id_to_string_map.find(value);
  if (it != tl_key_index_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t tl_key_index_get_enum_value_number(const std::string &str)
{
  auto it = tl_key_index_enum_string_to_id_map.find(str);
  if (it != tl_key_index_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for TLStatus
const std::map<uint32_t, std::string> tl_status_enum_id_to_string_map {
  { 0, "Success" },
  { 1, "Failure" },
};

// String to enum map for TLStatus
const std::map<std::string, uint32_t> tl_status_enum_string_to_id_map {
  { "Success", 0 },
  { "Failure", 1 },
};

std::string tl_status_get_enum_value_name(
  uint32_t value)
{
  auto it = tl_status_enum_id_to_string_map.find(value);
  if (it != tl_status_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t tl_status_get_enum_value_number(const std::string &str)
{
  auto it = tl_status_enum_string_to_id_map.find(str);
  if (it != tl_status_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for TLZigbeeInformationLogicalType
const std::map<uint32_t, std::string> tl_zigbee_information_logical_type_enum_id_to_string_map {
  { 0, "Coordinator" },
  { 1, "Router" },
  { 2, "EndDevice" },
};

// String to enum map for TLZigbeeInformationLogicalType
const std::map<std::string, uint32_t> tl_zigbee_information_logical_type_enum_string_to_id_map {
  { "Coordinator", 0 },
  { "Router", 1 },
  { "EndDevice", 2 },
};

std::string tl_zigbee_information_logical_type_get_enum_value_name(
  uint32_t value)
{
  auto it = tl_zigbee_information_logical_type_enum_id_to_string_map.find(value);
  if (it != tl_zigbee_information_logical_type_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t tl_zigbee_information_logical_type_get_enum_value_number(const std::string &str)
{
  auto it = tl_zigbee_information_logical_type_enum_string_to_id_map.find(str);
  if (it != tl_zigbee_information_logical_type_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ThermostatACCapacityFormat
const std::map<uint32_t, std::string> thermostatac_capacity_format_enum_id_to_string_map {
  { 0, "BTUh" },
};

// String to enum map for ThermostatACCapacityFormat
const std::map<std::string, uint32_t> thermostatac_capacity_format_enum_string_to_id_map {
  { "BTUh", 0 },
};

std::string thermostatac_capacity_format_get_enum_value_name(
  uint32_t value)
{
  auto it = thermostatac_capacity_format_enum_id_to_string_map.find(value);
  if (it != thermostatac_capacity_format_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t thermostatac_capacity_format_get_enum_value_number(const std::string &str)
{
  auto it = thermostatac_capacity_format_enum_string_to_id_map.find(str);
  if (it != thermostatac_capacity_format_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ThermostatACCompressorType
const std::map<uint32_t, std::string> thermostatac_compressor_type_enum_id_to_string_map {
  { 1, "T1" },
  { 2, "T2" },
  { 3, "T3" },
};

// String to enum map for ThermostatACCompressorType
const std::map<std::string, uint32_t> thermostatac_compressor_type_enum_string_to_id_map {
  { "T1", 1 },
  { "T2", 2 },
  { "T3", 3 },
};

std::string thermostatac_compressor_type_get_enum_value_name(
  uint32_t value)
{
  auto it = thermostatac_compressor_type_enum_id_to_string_map.find(value);
  if (it != thermostatac_compressor_type_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t thermostatac_compressor_type_get_enum_value_number(const std::string &str)
{
  auto it = thermostatac_compressor_type_enum_string_to_id_map.find(str);
  if (it != thermostatac_compressor_type_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ThermostatACLouverPosition
const std::map<uint32_t, std::string> thermostatac_louver_position_enum_id_to_string_map {
  { 1, "FullyClosed" },
  { 2, "FullyOpen" },
  { 3, "QuarterOpen" },
  { 4, "HalfOpen" },
  { 5, "ThreeQuartersOpen" },
};

// String to enum map for ThermostatACLouverPosition
const std::map<std::string, uint32_t> thermostatac_louver_position_enum_string_to_id_map {
  { "FullyClosed", 1 },
  { "FullyOpen", 2 },
  { "QuarterOpen", 3 },
  { "HalfOpen", 4 },
  { "ThreeQuartersOpen", 5 },
};

std::string thermostatac_louver_position_get_enum_value_name(
  uint32_t value)
{
  auto it = thermostatac_louver_position_enum_id_to_string_map.find(value);
  if (it != thermostatac_louver_position_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t thermostatac_louver_position_get_enum_value_number(const std::string &str)
{
  auto it = thermostatac_louver_position_enum_string_to_id_map.find(str);
  if (it != thermostatac_louver_position_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ThermostatACRefrigerantType
const std::map<uint32_t, std::string> thermostatac_refrigerant_type_enum_id_to_string_map {
  { 1, "R22" },
  { 2, "R410a" },
  { 3, "R407c" },
};

// String to enum map for ThermostatACRefrigerantType
const std::map<std::string, uint32_t> thermostatac_refrigerant_type_enum_string_to_id_map {
  { "R22", 1 },
  { "R410a", 2 },
  { "R407c", 3 },
};

std::string thermostatac_refrigerant_type_get_enum_value_name(
  uint32_t value)
{
  auto it = thermostatac_refrigerant_type_enum_id_to_string_map.find(value);
  if (it != thermostatac_refrigerant_type_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t thermostatac_refrigerant_type_get_enum_value_number(const std::string &str)
{
  auto it = thermostatac_refrigerant_type_enum_string_to_id_map.find(str);
  if (it != thermostatac_refrigerant_type_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ThermostatACType
const std::map<uint32_t, std::string> thermostatac_type_enum_id_to_string_map {
  { 1, "CoolingAndFixedSpeed" },
  { 2, "HeatPumpAndFixedSpeed" },
  { 3, "CoolingAndInverter" },
  { 4, "HeatPumpAndInverter" },
};

// String to enum map for ThermostatACType
const std::map<std::string, uint32_t> thermostatac_type_enum_string_to_id_map {
  { "CoolingAndFixedSpeed", 1 },
  { "HeatPumpAndFixedSpeed", 2 },
  { "CoolingAndInverter", 3 },
  { "HeatPumpAndInverter", 4 },
};

std::string thermostatac_type_get_enum_value_name(
  uint32_t value)
{
  auto it = thermostatac_type_enum_id_to_string_map.find(value);
  if (it != thermostatac_type_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t thermostatac_type_get_enum_value_number(const std::string &str)
{
  auto it = thermostatac_type_enum_string_to_id_map.find(str);
  if (it != thermostatac_type_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ThermostatControlSequenceOfOperation
const std::map<uint32_t, std::string> thermostat_control_sequence_of_operation_enum_id_to_string_map {
  { 0, "CoolingOnly" },
  { 1, "CoolingWithReheat" },
  { 2, "HeatingOnly" },
  { 3, "HeatingWithReheat" },
  { 4, "CoolingAndHeating4Pipes" },
  { 5, "CoolingAndHeating4PipesWithReheat" },
};

// String to enum map for ThermostatControlSequenceOfOperation
const std::map<std::string, uint32_t> thermostat_control_sequence_of_operation_enum_string_to_id_map {
  { "CoolingOnly", 0 },
  { "CoolingWithReheat", 1 },
  { "HeatingOnly", 2 },
  { "HeatingWithReheat", 3 },
  { "CoolingAndHeating4Pipes", 4 },
  { "CoolingAndHeating4PipesWithReheat", 5 },
};

std::string thermostat_control_sequence_of_operation_get_enum_value_name(
  uint32_t value)
{
  auto it = thermostat_control_sequence_of_operation_enum_id_to_string_map.find(value);
  if (it != thermostat_control_sequence_of_operation_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t thermostat_control_sequence_of_operation_get_enum_value_number(const std::string &str)
{
  auto it = thermostat_control_sequence_of_operation_enum_string_to_id_map.find(str);
  if (it != thermostat_control_sequence_of_operation_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ThermostatProgrammingOperationModeProgrammingMode
const std::map<uint32_t, std::string> thermostat_programming_operation_mode_programming_mode_enum_id_to_string_map {
  { 0, "SimpleOrSetpoint" },
  { 1, "Schedule" },
};

// String to enum map for ThermostatProgrammingOperationModeProgrammingMode
const std::map<std::string, uint32_t> thermostat_programming_operation_mode_programming_mode_enum_string_to_id_map {
  { "SimpleOrSetpoint", 0 },
  { "Schedule", 1 },
};

std::string thermostat_programming_operation_mode_programming_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = thermostat_programming_operation_mode_programming_mode_enum_id_to_string_map.find(value);
  if (it != thermostat_programming_operation_mode_programming_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t thermostat_programming_operation_mode_programming_mode_get_enum_value_number(const std::string &str)
{
  auto it = thermostat_programming_operation_mode_programming_mode_enum_string_to_id_map.find(str);
  if (it != thermostat_programming_operation_mode_programming_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ThermostatSetpointChangeSource
const std::map<uint32_t, std::string> thermostat_setpoint_change_source_enum_id_to_string_map {
  { 0, "Manual" },
  { 1, "ScheduleOrInternalProgramming" },
  { 2, "External" },
};

// String to enum map for ThermostatSetpointChangeSource
const std::map<std::string, uint32_t> thermostat_setpoint_change_source_enum_string_to_id_map {
  { "Manual", 0 },
  { "ScheduleOrInternalProgramming", 1 },
  { "External", 2 },
};

std::string thermostat_setpoint_change_source_get_enum_value_name(
  uint32_t value)
{
  auto it = thermostat_setpoint_change_source_enum_id_to_string_map.find(value);
  if (it != thermostat_setpoint_change_source_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t thermostat_setpoint_change_source_get_enum_value_number(const std::string &str)
{
  auto it = thermostat_setpoint_change_source_enum_string_to_id_map.find(str);
  if (it != thermostat_setpoint_change_source_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ThermostatStartOfWeek
const std::map<uint32_t, std::string> thermostat_start_of_week_enum_id_to_string_map {
  { 0, "Sunday" },
  { 1, "Monday" },
  { 2, "Tuesday" },
  { 3, "Wednesday" },
  { 4, "Thursday" },
  { 5, "Friday" },
  { 6, "Saturday" },
};

// String to enum map for ThermostatStartOfWeek
const std::map<std::string, uint32_t> thermostat_start_of_week_enum_string_to_id_map {
  { "Sunday", 0 },
  { "Monday", 1 },
  { "Tuesday", 2 },
  { "Wednesday", 3 },
  { "Thursday", 4 },
  { "Friday", 5 },
  { "Saturday", 6 },
};

std::string thermostat_start_of_week_get_enum_value_name(
  uint32_t value)
{
  auto it = thermostat_start_of_week_enum_id_to_string_map.find(value);
  if (it != thermostat_start_of_week_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t thermostat_start_of_week_get_enum_value_number(const std::string &str)
{
  auto it = thermostat_start_of_week_enum_string_to_id_map.find(str);
  if (it != thermostat_start_of_week_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ThermostatSystemMode
const std::map<uint32_t, std::string> thermostat_system_mode_enum_id_to_string_map {
  { 0, "Off" },
  { 1, "Auto" },
  { 3, "Cool" },
  { 4, "Heat" },
  { 5, "EmergencyHeating" },
  { 6, "Precooling" },
  { 7, "FanOnly" },
  { 8, "Dry" },
  { 9, "Sleep" },
};

// String to enum map for ThermostatSystemMode
const std::map<std::string, uint32_t> thermostat_system_mode_enum_string_to_id_map {
  { "Off", 0 },
  { "Auto", 1 },
  { "Cool", 3 },
  { "Heat", 4 },
  { "EmergencyHeating", 5 },
  { "Precooling", 6 },
  { "FanOnly", 7 },
  { "Dry", 8 },
  { "Sleep", 9 },
};

std::string thermostat_system_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = thermostat_system_mode_enum_id_to_string_map.find(value);
  if (it != thermostat_system_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t thermostat_system_mode_get_enum_value_number(const std::string &str)
{
  auto it = thermostat_system_mode_enum_string_to_id_map.find(str);
  if (it != thermostat_system_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ThermostatTemperatureSetpointHold
const std::map<uint32_t, std::string> thermostat_temperature_setpoint_hold_enum_id_to_string_map {
  { 0, "SetpointHoldOff" },
  { 1, "SetpointHoldOn" },
};

// String to enum map for ThermostatTemperatureSetpointHold
const std::map<std::string, uint32_t> thermostat_temperature_setpoint_hold_enum_string_to_id_map {
  { "SetpointHoldOff", 0 },
  { "SetpointHoldOn", 1 },
};

std::string thermostat_temperature_setpoint_hold_get_enum_value_name(
  uint32_t value)
{
  auto it = thermostat_temperature_setpoint_hold_enum_id_to_string_map.find(value);
  if (it != thermostat_temperature_setpoint_hold_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t thermostat_temperature_setpoint_hold_get_enum_value_number(const std::string &str)
{
  auto it = thermostat_temperature_setpoint_hold_enum_string_to_id_map.find(str);
  if (it != thermostat_temperature_setpoint_hold_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ThermostatThermostatRunningMode
const std::map<uint32_t, std::string> thermostat_thermostat_running_mode_enum_id_to_string_map {
  { 0, "Off" },
  { 3, "Cool" },
  { 4, "Heat" },
};

// String to enum map for ThermostatThermostatRunningMode
const std::map<std::string, uint32_t> thermostat_thermostat_running_mode_enum_string_to_id_map {
  { "Off", 0 },
  { "Cool", 3 },
  { "Heat", 4 },
};

std::string thermostat_thermostat_running_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = thermostat_thermostat_running_mode_enum_id_to_string_map.find(value);
  if (it != thermostat_thermostat_running_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t thermostat_thermostat_running_mode_get_enum_value_number(const std::string &str)
{
  auto it = thermostat_thermostat_running_mode_enum_string_to_id_map.find(str);
  if (it != thermostat_thermostat_running_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ThermostatUserInterfaceConfigurationKeypadLockout
const std::map<uint32_t, std::string> thermostat_user_interface_configuration_keypad_lockout_enum_id_to_string_map {
  { 0, "None" },
  { 1, "Level1" },
  { 2, "Level2" },
  { 3, "Level3" },
  { 4, "Level4" },
  { 5, "Level5" },
};

// String to enum map for ThermostatUserInterfaceConfigurationKeypadLockout
const std::map<std::string, uint32_t> thermostat_user_interface_configuration_keypad_lockout_enum_string_to_id_map {
  { "None", 0 },
  { "Level1", 1 },
  { "Level2", 2 },
  { "Level3", 3 },
  { "Level4", 4 },
  { "Level5", 5 },
};

std::string thermostat_user_interface_configuration_keypad_lockout_get_enum_value_name(
  uint32_t value)
{
  auto it = thermostat_user_interface_configuration_keypad_lockout_enum_id_to_string_map.find(value);
  if (it != thermostat_user_interface_configuration_keypad_lockout_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t thermostat_user_interface_configuration_keypad_lockout_get_enum_value_number(const std::string &str)
{
  auto it = thermostat_user_interface_configuration_keypad_lockout_enum_string_to_id_map.find(str);
  if (it != thermostat_user_interface_configuration_keypad_lockout_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ThermostatUserInterfaceConfigurationScheduleProgrammingVisibility
const std::map<uint32_t, std::string> thermostat_user_interface_configuration_schedule_programming_visibility_enum_id_to_string_map {
  { 0, "LocalEnabled" },
  { 1, "LocalDisabled" },
};

// String to enum map for ThermostatUserInterfaceConfigurationScheduleProgrammingVisibility
const std::map<std::string, uint32_t> thermostat_user_interface_configuration_schedule_programming_visibility_enum_string_to_id_map {
  { "LocalEnabled", 0 },
  { "LocalDisabled", 1 },
};

std::string thermostat_user_interface_configuration_schedule_programming_visibility_get_enum_value_name(
  uint32_t value)
{
  auto it = thermostat_user_interface_configuration_schedule_programming_visibility_enum_id_to_string_map.find(value);
  if (it != thermostat_user_interface_configuration_schedule_programming_visibility_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t thermostat_user_interface_configuration_schedule_programming_visibility_get_enum_value_number(const std::string &str)
{
  auto it = thermostat_user_interface_configuration_schedule_programming_visibility_enum_string_to_id_map.find(str);
  if (it != thermostat_user_interface_configuration_schedule_programming_visibility_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ThermostatUserInterfaceConfigurationTemperatureDisplayMode
const std::map<uint32_t, std::string> thermostat_user_interface_configuration_temperature_display_mode_enum_id_to_string_map {
  { 0, "Celsius" },
  { 1, "Fahrenheit" },
};

// String to enum map for ThermostatUserInterfaceConfigurationTemperatureDisplayMode
const std::map<std::string, uint32_t> thermostat_user_interface_configuration_temperature_display_mode_enum_string_to_id_map {
  { "Celsius", 0 },
  { "Fahrenheit", 1 },
};

std::string thermostat_user_interface_configuration_temperature_display_mode_get_enum_value_name(
  uint32_t value)
{
  auto it = thermostat_user_interface_configuration_temperature_display_mode_enum_id_to_string_map.find(value);
  if (it != thermostat_user_interface_configuration_temperature_display_mode_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t thermostat_user_interface_configuration_temperature_display_mode_get_enum_value_number(const std::string &str)
{
  auto it = thermostat_user_interface_configuration_temperature_display_mode_enum_string_to_id_map.find(str);
  if (it != thermostat_user_interface_configuration_temperature_display_mode_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for TriggerEffectEffectIdentifier
const std::map<uint32_t, std::string> trigger_effect_effect_identifier_enum_id_to_string_map {
  { 0, "Blink" },
  { 1, "Breathe" },
  { 2, "Okay" },
  { 11, "ChannelChange" },
  { 254, "FinishEffect" },
  { 255, "StopEffect" },
};

// String to enum map for TriggerEffectEffectIdentifier
const std::map<std::string, uint32_t> trigger_effect_effect_identifier_enum_string_to_id_map {
  { "Blink", 0 },
  { "Breathe", 1 },
  { "Okay", 2 },
  { "ChannelChange", 11 },
  { "FinishEffect", 254 },
  { "StopEffect", 255 },
};

std::string trigger_effect_effect_identifier_get_enum_value_name(
  uint32_t value)
{
  auto it = trigger_effect_effect_identifier_enum_id_to_string_map.find(value);
  if (it != trigger_effect_effect_identifier_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t trigger_effect_effect_identifier_get_enum_value_number(const std::string &str)
{
  auto it = trigger_effect_effect_identifier_enum_string_to_id_map.find(str);
  if (it != trigger_effect_effect_identifier_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for TriggerEffectEffectVariant
const std::map<uint32_t, std::string> trigger_effect_effect_variant_enum_id_to_string_map {
  { 0, "Default" },
};

// String to enum map for TriggerEffectEffectVariant
const std::map<std::string, uint32_t> trigger_effect_effect_variant_enum_string_to_id_map {
  { "Default", 0 },
};

std::string trigger_effect_effect_variant_get_enum_value_name(
  uint32_t value)
{
  auto it = trigger_effect_effect_variant_enum_id_to_string_map.find(value);
  if (it != trigger_effect_effect_variant_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t trigger_effect_effect_variant_get_enum_value_number(const std::string &str)
{
  auto it = trigger_effect_effect_variant_enum_string_to_id_map.find(str);
  if (it != trigger_effect_effect_variant_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for TxReportTransmissionSpeed
const std::map<uint32_t, std::string> tx_report_transmission_speed_enum_id_to_string_map {
  { 0, "Z-Wave-9600-bits-per-second" },
  { 1, "Z-Wave-40-kbits-per-second" },
  { 2, "Z-Wave-100-kbits-per-second" },
  { 3, "Z-WaveLongRange-100-kbits-per-second" },
  { 254, "Other" },
  { 255, "Unknown" },
};

// String to enum map for TxReportTransmissionSpeed
const std::map<std::string, uint32_t> tx_report_transmission_speed_enum_string_to_id_map {
  { "Z-Wave-9600-bits-per-second", 0 },
  { "Z-Wave-40-kbits-per-second", 1 },
  { "Z-Wave-100-kbits-per-second", 2 },
  { "Z-WaveLongRange-100-kbits-per-second", 3 },
  { "Other", 254 },
  { "Unknown", 255 },
};

std::string tx_report_transmission_speed_get_enum_value_name(
  uint32_t value)
{
  auto it = tx_report_transmission_speed_enum_id_to_string_map.find(value);
  if (it != tx_report_transmission_speed_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t tx_report_transmission_speed_get_enum_value_number(const std::string &str)
{
  auto it = tx_report_transmission_speed_enum_string_to_id_map.find(str);
  if (it != tx_report_transmission_speed_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for WindowCoveringWindowCoveringType
const std::map<uint32_t, std::string> window_covering_window_covering_type_enum_id_to_string_map {
  { 0, "Rollershade" },
  { 1, "Rollershade2Motor" },
  { 2, "RollershadeExterior" },
  { 3, "RollershadeExterior2Motor" },
  { 4, "Drapery" },
  { 5, "Awning" },
  { 6, "Shutter" },
  { 7, "TiltBlindTiltOnly" },
  { 8, "TiltBlindLiftAndTilt" },
  { 9, "ProjectorScreen" },
};

// String to enum map for WindowCoveringWindowCoveringType
const std::map<std::string, uint32_t> window_covering_window_covering_type_enum_string_to_id_map {
  { "Rollershade", 0 },
  { "Rollershade2Motor", 1 },
  { "RollershadeExterior", 2 },
  { "RollershadeExterior2Motor", 3 },
  { "Drapery", 4 },
  { "Awning", 5 },
  { "Shutter", 6 },
  { "TiltBlindTiltOnly", 7 },
  { "TiltBlindLiftAndTilt", 8 },
  { "ProjectorScreen", 9 },
};

std::string window_covering_window_covering_type_get_enum_value_name(
  uint32_t value)
{
  auto it = window_covering_window_covering_type_enum_id_to_string_map.find(value);
  if (it != window_covering_window_covering_type_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t window_covering_window_covering_type_get_enum_value_number(const std::string &str)
{
  auto it = window_covering_window_covering_type_enum_string_to_id_map.find(str);
  if (it != window_covering_window_covering_type_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for ZoneEnrollResponseEnrollResponseCode
const std::map<uint32_t, std::string> zone_enroll_response_enroll_response_code_enum_id_to_string_map {
  { 0, "Success" },
  { 1, "NotSupported" },
  { 2, "NoEnrollPermit" },
  { 3, "TooManyZones" },
};

// String to enum map for ZoneEnrollResponseEnrollResponseCode
const std::map<std::string, uint32_t> zone_enroll_response_enroll_response_code_enum_string_to_id_map {
  { "Success", 0 },
  { "NotSupported", 1 },
  { "NoEnrollPermit", 2 },
  { "TooManyZones", 3 },
};

std::string zone_enroll_response_enroll_response_code_get_enum_value_name(
  uint32_t value)
{
  auto it = zone_enroll_response_enroll_response_code_enum_id_to_string_map.find(value);
  if (it != zone_enroll_response_enroll_response_code_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t zone_enroll_response_enroll_response_code_get_enum_value_number(const std::string &str)
{
  auto it = zone_enroll_response_enroll_response_code_enum_string_to_id_map.find(str);
  if (it != zone_enroll_response_enroll_response_code_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for attributeReportingStatus
const std::map<uint32_t, std::string> attribute_reporting_status_enum_id_to_string_map {
  { 0, "Pending" },
  { 1, "Complete" },
};

// String to enum map for attributeReportingStatus
const std::map<std::string, uint32_t> attribute_reporting_status_enum_string_to_id_map {
  { "Pending", 0 },
  { "Complete", 1 },
};

std::string attribute_reporting_status_get_enum_value_name(
  uint32_t value)
{
  auto it = attribute_reporting_status_enum_id_to_string_map.find(value);
  if (it != attribute_reporting_status_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t attribute_reporting_status_get_enum_value_number(const std::string &str)
{
  auto it = attribute_reporting_status_enum_string_to_id_map.find(str);
  if (it != attribute_reporting_status_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for zclStatus
const std::map<uint32_t, std::string> zcl_status_enum_id_to_string_map {
  { 0, "SUCCESS" },
  { 1, "FAILURE" },
  { 126, "NOT_AUTHORIZED" },
  { 128, "MALFORMED_COMMAND" },
  { 129, "UNSUP_CLUSTER_COMMAND" },
  { 130, "UNSUP_GENERAL_COMMAND" },
  { 131, "UNSUP_MANUF_CLUSTER_COMMAND" },
  { 132, "UNSUP_MANUF_GENERAL_COMMAND" },
  { 133, "INVALID_FIELD" },
  { 134, "UNSUPPORTED_ATTRIBUTE" },
  { 135, "INVALID_VALUE" },
  { 136, "READ_ONLY" },
  { 137, "INSUFFICIENT_SPACE" },
  { 138, "DUPLICATE_EXISTS" },
  { 139, "NOT_FOUND" },
  { 140, "UNREPORTABLE_ATTRIBUTE" },
  { 141, "INVALID_DATA_TYPE" },
  { 142, "INVALID_SELECTOR" },
  { 143, "WRITE_ONLY" },
  { 144, "INCONSISTENT_STARTUP_STATE" },
  { 145, "DEFINED_OUT_OF_BAND" },
  { 146, "INCONSISTENT" },
  { 147, "ACTION_DENIED" },
  { 148, "TIMEOUT" },
  { 149, "ABORT" },
  { 150, "INVALID_IMAGE" },
  { 151, "WAIT_FOR_DATA" },
  { 152, "NO_IMAGE_AVAILABLE" },
  { 153, "REQUIRE_MORE_IMAGE" },
  { 154, "NOTIFICATION_PENDING" },
  { 192, "HARDWARE_FAILURE" },
  { 193, "SOFTWARE_FAILURE" },
  { 194, "CALIBRATION_ERROR" },
  { 195, "UNSUPPORTED_CLUSTER" },
  { 196, "LIMIT_REACHED" },
};

// String to enum map for zclStatus
const std::map<std::string, uint32_t> zcl_status_enum_string_to_id_map {
  { "SUCCESS", 0 },
  { "FAILURE", 1 },
  { "NOT_AUTHORIZED", 126 },
  { "MALFORMED_COMMAND", 128 },
  { "UNSUP_CLUSTER_COMMAND", 129 },
  { "UNSUP_GENERAL_COMMAND", 130 },
  { "UNSUP_MANUF_CLUSTER_COMMAND", 131 },
  { "UNSUP_MANUF_GENERAL_COMMAND", 132 },
  { "INVALID_FIELD", 133 },
  { "UNSUPPORTED_ATTRIBUTE", 134 },
  { "INVALID_VALUE", 135 },
  { "READ_ONLY", 136 },
  { "INSUFFICIENT_SPACE", 137 },
  { "DUPLICATE_EXISTS", 138 },
  { "NOT_FOUND", 139 },
  { "UNREPORTABLE_ATTRIBUTE", 140 },
  { "INVALID_DATA_TYPE", 141 },
  { "INVALID_SELECTOR", 142 },
  { "WRITE_ONLY", 143 },
  { "INCONSISTENT_STARTUP_STATE", 144 },
  { "DEFINED_OUT_OF_BAND", 145 },
  { "INCONSISTENT", 146 },
  { "ACTION_DENIED", 147 },
  { "TIMEOUT", 148 },
  { "ABORT", 149 },
  { "INVALID_IMAGE", 150 },
  { "WAIT_FOR_DATA", 151 },
  { "NO_IMAGE_AVAILABLE", 152 },
  { "REQUIRE_MORE_IMAGE", 153 },
  { "NOTIFICATION_PENDING", 154 },
  { "HARDWARE_FAILURE", 192 },
  { "SOFTWARE_FAILURE", 193 },
  { "CALIBRATION_ERROR", 194 },
  { "UNSUPPORTED_CLUSTER", 195 },
  { "LIMIT_REACHED", 196 },
};

std::string zcl_status_get_enum_value_name(
  uint32_t value)
{
  auto it = zcl_status_enum_id_to_string_map.find(value);
  if (it != zcl_status_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t zcl_status_get_enum_value_number(const std::string &str)
{
  auto it = zcl_status_enum_string_to_id_map.find(str);
  if (it != zcl_status_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// Enum to string map for zclType
const std::map<uint32_t, std::string> zcl_type_enum_id_to_string_map {
  { 0, "nodata" },
  { 8, "data8" },
  { 9, "data16" },
  { 10, "data24" },
  { 11, "data32" },
  { 12, "data40" },
  { 13, "data48" },
  { 14, "data56" },
  { 15, "data64" },
  { 16, "bool" },
  { 24, "map8" },
  { 25, "map16" },
  { 26, "map24" },
  { 27, "map32" },
  { 28, "map40" },
  { 29, "map48" },
  { 30, "map56" },
  { 31, "map64" },
  { 32, "uint8" },
  { 33, "uint16" },
  { 34, "uint24" },
  { 35, "uint32" },
  { 36, "uint40" },
  { 37, "uint48" },
  { 38, "uint56" },
  { 39, "uint64" },
  { 40, "int8" },
  { 41, "int16" },
  { 42, "int24" },
  { 43, "int32" },
  { 44, "int40" },
  { 45, "int48" },
  { 46, "int56" },
  { 47, "int64" },
  { 48, "enum8" },
  { 49, "enum16" },
  { 56, "semi" },
  { 57, "single" },
  { 58, "double" },
  { 65, "octstr" },
  { 66, "string" },
  { 67, "octstr16" },
  { 68, "string16" },
  { 72, "array" },
  { 76, "struct" },
  { 80, "set" },
  { 81, "bag" },
  { 224, "ToD" },
  { 225, "date" },
  { 226, "UTC" },
  { 232, "clusterId" },
  { 233, "attribId" },
  { 234, "bacOID" },
  { 240, "EUI64" },
  { 241, "key128" },
  { 255, "unk" },
};

// String to enum map for zclType
const std::map<std::string, uint32_t> zcl_type_enum_string_to_id_map {
  { "nodata", 0 },
  { "data8", 8 },
  { "data16", 9 },
  { "data24", 10 },
  { "data32", 11 },
  { "data40", 12 },
  { "data48", 13 },
  { "data56", 14 },
  { "data64", 15 },
  { "bool", 16 },
  { "map8", 24 },
  { "map16", 25 },
  { "map24", 26 },
  { "map32", 27 },
  { "map40", 28 },
  { "map48", 29 },
  { "map56", 30 },
  { "map64", 31 },
  { "uint8", 32 },
  { "uint16", 33 },
  { "uint24", 34 },
  { "uint32", 35 },
  { "uint40", 36 },
  { "uint48", 37 },
  { "uint56", 38 },
  { "uint64", 39 },
  { "int8", 40 },
  { "int16", 41 },
  { "int24", 42 },
  { "int32", 43 },
  { "int40", 44 },
  { "int48", 45 },
  { "int56", 46 },
  { "int64", 47 },
  { "enum8", 48 },
  { "enum16", 49 },
  { "semi", 56 },
  { "single", 57 },
  { "double", 58 },
  { "octstr", 65 },
  { "string", 66 },
  { "octstr16", 67 },
  { "string16", 68 },
  { "array", 72 },
  { "struct", 76 },
  { "set", 80 },
  { "bag", 81 },
  { "ToD", 224 },
  { "date", 225 },
  { "UTC", 226 },
  { "clusterId", 232 },
  { "attribId", 233 },
  { "bacOID", 234 },
  { "EUI64", 240 },
  { "key128", 241 },
  { "unk", 255 },
};

std::string zcl_type_get_enum_value_name(
  uint32_t value)
{
  auto it = zcl_type_enum_id_to_string_map.find(value);
  if (it != zcl_type_enum_id_to_string_map.end()){
    return it->second;
  }

  // No known name value is set for this field.
  // Set it to a string version of the value.
  return std::to_string(value);
}

uint32_t zcl_type_get_enum_value_number(const std::string &str)
{
  auto it = zcl_type_enum_string_to_id_map.find(str);
  if (it != zcl_type_enum_string_to_id_map.end()){
    return it->second;
  }

  // No known numeric value is set for this string.
  // Return UINT32_MAX to indicate an error.
  return std::numeric_limits<uint32_t>::max();
}

// C Wrapper
extern "C" {
char *aox_locator_antenna_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", aox_locator_antenna_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t aox_locator_antenna_mode_get_enum_value_number_c(const char *str)
{
  return aox_locator_antenna_mode_get_enum_value_number(std::string(str));
}
char *aox_locator_aox_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", aox_locator_aox_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t aox_locator_aox_mode_get_enum_value_number_c(const char *str)
{
  return aox_locator_aox_mode_get_enum_value_number(std::string(str));
}
char *aox_locatorcte_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", aox_locatorcte_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t aox_locatorcte_mode_get_enum_value_number_c(const char *str)
{
  return aox_locatorcte_mode_get_enum_value_number(std::string(str));
}
char *aox_locator_reporting_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", aox_locator_reporting_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t aox_locator_reporting_mode_get_enum_value_number_c(const char *str)
{
  return aox_locator_reporting_mode_get_enum_value_number(std::string(str));
}
char *arm_arm_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", arm_arm_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t arm_arm_mode_get_enum_value_number_c(const char *str)
{
  return arm_arm_mode_get_enum_value_number(std::string(str));
}
char *arm_response_arm_notification_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", arm_response_arm_notification_get_enum_value_name(value).c_str());
  return result;
}

uint32_t arm_response_arm_notification_get_enum_value_number_c(const char *str)
{
  return arm_response_arm_notification_get_enum_value_number(std::string(str));
}
char *barrier_control_moving_state_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", barrier_control_moving_state_get_enum_value_name(value).c_str());
  return result;
}

uint32_t barrier_control_moving_state_get_enum_value_number_c(const char *str)
{
  return barrier_control_moving_state_get_enum_value_number(std::string(str));
}
char *basic_generic_device_class_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", basic_generic_device_class_get_enum_value_name(value).c_str());
  return result;
}

uint32_t basic_generic_device_class_get_enum_value_number_c(const char *str)
{
  return basic_generic_device_class_get_enum_value_number(std::string(str));
}
char *basic_generic_device_type_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", basic_generic_device_type_get_enum_value_name(value).c_str());
  return result;
}

uint32_t basic_generic_device_type_get_enum_value_number_c(const char *str)
{
  return basic_generic_device_type_get_enum_value_number(std::string(str));
}
char *basic_physical_environment_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", basic_physical_environment_get_enum_value_name(value).c_str());
  return result;
}

uint32_t basic_physical_environment_get_enum_value_number_c(const char *str)
{
  return basic_physical_environment_get_enum_value_number(std::string(str));
}
char *basic_power_source_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", basic_power_source_get_enum_value_name(value).c_str());
  return result;
}

uint32_t basic_power_source_get_enum_value_number_c(const char *str)
{
  return basic_power_source_get_enum_value_number(std::string(str));
}
char *battery_size_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", battery_size_get_enum_value_name(value).c_str());
  return result;
}

uint32_t battery_size_get_enum_value_number_c(const char *str)
{
  return battery_size_get_enum_value_number(std::string(str));
}
char *bypass_response_zoneid_bypass_result_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", bypass_response_zoneid_bypass_result_get_enum_value_name(value).c_str());
  return result;
}

uint32_t bypass_response_zoneid_bypass_result_get_enum_value_number_c(const char *str)
{
  return bypass_response_zoneid_bypass_result_get_enum_value_number(std::string(str));
}
char *cc_color_loop_direction_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", cc_color_loop_direction_get_enum_value_name(value).c_str());
  return result;
}

uint32_t cc_color_loop_direction_get_enum_value_number_c(const char *str)
{
  return cc_color_loop_direction_get_enum_value_number(std::string(str));
}
char *cc_direction_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", cc_direction_get_enum_value_name(value).c_str());
  return result;
}

uint32_t cc_direction_get_enum_value_number_c(const char *str)
{
  return cc_direction_get_enum_value_number(std::string(str));
}
char *cc_move_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", cc_move_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t cc_move_mode_get_enum_value_number_c(const char *str)
{
  return cc_move_mode_get_enum_value_number(std::string(str));
}
char *cc_step_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", cc_step_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t cc_step_mode_get_enum_value_number_c(const char *str)
{
  return cc_step_mode_get_enum_value_number(std::string(str));
}
char *color_control_color_loop_active_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", color_control_color_loop_active_get_enum_value_name(value).c_str());
  return result;
}

uint32_t color_control_color_loop_active_get_enum_value_number_c(const char *str)
{
  return color_control_color_loop_active_get_enum_value_number(std::string(str));
}
char *color_control_color_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", color_control_color_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t color_control_color_mode_get_enum_value_number_c(const char *str)
{
  return color_control_color_mode_get_enum_value_number(std::string(str));
}
char *color_control_drift_compensation_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", color_control_drift_compensation_get_enum_value_name(value).c_str());
  return result;
}

uint32_t color_control_drift_compensation_get_enum_value_number_c(const char *str)
{
  return color_control_drift_compensation_get_enum_value_number(std::string(str));
}
char *color_control_enhanced_color_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", color_control_enhanced_color_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t color_control_enhanced_color_mode_get_enum_value_number_c(const char *str)
{
  return color_control_enhanced_color_mode_get_enum_value_number(std::string(str));
}
char *color_loop_set_action_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", color_loop_set_action_get_enum_value_name(value).c_str());
  return result;
}

uint32_t color_loop_set_action_get_enum_value_number_c(const char *str)
{
  return color_loop_set_action_get_enum_value_number(std::string(str));
}
char *commissioning_network_key_type_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", commissioning_network_key_type_get_enum_value_name(value).c_str());
  return result;
}

uint32_t commissioning_network_key_type_get_enum_value_number_c(const char *str)
{
  return commissioning_network_key_type_get_enum_value_number(std::string(str));
}
char *commissioning_protocol_version_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", commissioning_protocol_version_get_enum_value_name(value).c_str());
  return result;
}

uint32_t commissioning_protocol_version_get_enum_value_number_c(const char *str)
{
  return commissioning_protocol_version_get_enum_value_number(std::string(str));
}
char *commissioning_stack_profile_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", commissioning_stack_profile_get_enum_value_name(value).c_str());
  return result;
}

uint32_t commissioning_stack_profile_get_enum_value_number_c(const char *str)
{
  return commissioning_stack_profile_get_enum_value_number(std::string(str));
}
char *commissioning_startup_control_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", commissioning_startup_control_get_enum_value_name(value).c_str());
  return result;
}

uint32_t commissioning_startup_control_get_enum_value_number_c(const char *str)
{
  return commissioning_startup_control_get_enum_value_number(std::string(str));
}
char *dehumidification_control_dehumidification_lockout_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", dehumidification_control_dehumidification_lockout_get_enum_value_name(value).c_str());
  return result;
}

uint32_t dehumidification_control_dehumidification_lockout_get_enum_value_number_c(const char *str)
{
  return dehumidification_control_dehumidification_lockout_get_enum_value_number(std::string(str));
}
char *dehumidification_control_relative_humidity_display_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", dehumidification_control_relative_humidity_display_get_enum_value_name(value).c_str());
  return result;
}

uint32_t dehumidification_control_relative_humidity_display_get_enum_value_number_c(const char *str)
{
  return dehumidification_control_relative_humidity_display_get_enum_value_number(std::string(str));
}
char *dehumidification_control_relative_humidity_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", dehumidification_control_relative_humidity_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t dehumidification_control_relative_humidity_mode_get_enum_value_number_c(const char *str)
{
  return dehumidification_control_relative_humidity_mode_get_enum_value_number(std::string(str));
}
char *door_lock_door_state_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", door_lock_door_state_get_enum_value_name(value).c_str());
  return result;
}

uint32_t door_lock_door_state_get_enum_value_number_c(const char *str)
{
  return door_lock_door_state_get_enum_value_number(std::string(str));
}
char *door_lockled_settings_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", door_lockled_settings_get_enum_value_name(value).c_str());
  return result;
}

uint32_t door_lockled_settings_get_enum_value_number_c(const char *str)
{
  return door_lockled_settings_get_enum_value_number(std::string(str));
}
char *door_lock_lock_state_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", door_lock_lock_state_get_enum_value_name(value).c_str());
  return result;
}

uint32_t door_lock_lock_state_get_enum_value_number_c(const char *str)
{
  return door_lock_lock_state_get_enum_value_number(std::string(str));
}
char *door_lock_lock_type_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", door_lock_lock_type_get_enum_value_name(value).c_str());
  return result;
}

uint32_t door_lock_lock_type_get_enum_value_number_c(const char *str)
{
  return door_lock_lock_type_get_enum_value_number(std::string(str));
}
char *door_lock_security_level_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", door_lock_security_level_get_enum_value_name(value).c_str());
  return result;
}

uint32_t door_lock_security_level_get_enum_value_number_c(const char *str)
{
  return door_lock_security_level_get_enum_value_number(std::string(str));
}
char *door_lock_sound_volume_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", door_lock_sound_volume_get_enum_value_name(value).c_str());
  return result;
}

uint32_t door_lock_sound_volume_get_enum_value_number_c(const char *str)
{
  return door_lock_sound_volume_get_enum_value_number(std::string(str));
}
char *drlk_oper_event_source_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", drlk_oper_event_source_get_enum_value_name(value).c_str());
  return result;
}

uint32_t drlk_oper_event_source_get_enum_value_number_c(const char *str)
{
  return drlk_oper_event_source_get_enum_value_number(std::string(str));
}
char *drlk_oper_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", drlk_oper_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t drlk_oper_mode_get_enum_value_number_c(const char *str)
{
  return drlk_oper_mode_get_enum_value_number(std::string(str));
}
char *drlk_pass_fail_status_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", drlk_pass_fail_status_get_enum_value_name(value).c_str());
  return result;
}

uint32_t drlk_pass_fail_status_get_enum_value_number_c(const char *str)
{
  return drlk_pass_fail_status_get_enum_value_number(std::string(str));
}
char *drlk_set_code_status_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", drlk_set_code_status_get_enum_value_name(value).c_str());
  return result;
}

uint32_t drlk_set_code_status_get_enum_value_number_c(const char *str)
{
  return drlk_set_code_status_get_enum_value_number(std::string(str));
}
char *drlk_settable_user_status_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", drlk_settable_user_status_get_enum_value_name(value).c_str());
  return result;
}

uint32_t drlk_settable_user_status_get_enum_value_number_c(const char *str)
{
  return drlk_settable_user_status_get_enum_value_number(std::string(str));
}
char *drlk_user_status_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", drlk_user_status_get_enum_value_name(value).c_str());
  return result;
}

uint32_t drlk_user_status_get_enum_value_number_c(const char *str)
{
  return drlk_user_status_get_enum_value_number(std::string(str));
}
char *drlk_user_type_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", drlk_user_type_get_enum_value_name(value).c_str());
  return result;
}

uint32_t drlk_user_type_get_enum_value_number_c(const char *str)
{
  return drlk_user_type_get_enum_value_number(std::string(str));
}
char *fan_control_fan_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", fan_control_fan_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t fan_control_fan_mode_get_enum_value_number_c(const char *str)
{
  return fan_control_fan_mode_get_enum_value_number(std::string(str));
}
char *fan_control_fan_mode_sequence_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", fan_control_fan_mode_sequence_get_enum_value_name(value).c_str());
  return result;
}

uint32_t fan_control_fan_mode_sequence_get_enum_value_number_c(const char *str)
{
  return fan_control_fan_mode_sequence_get_enum_value_number(std::string(str));
}
char *get_log_record_response_event_type_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", get_log_record_response_event_type_get_enum_value_name(value).c_str());
  return result;
}

uint32_t get_log_record_response_event_type_get_enum_value_number_c(const char *str)
{
  return get_log_record_response_event_type_get_enum_value_number(std::string(str));
}
char *get_measurement_profile_response_status_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", get_measurement_profile_response_status_get_enum_value_name(value).c_str());
  return result;
}

uint32_t get_measurement_profile_response_status_get_enum_value_number_c(const char *str)
{
  return get_measurement_profile_response_status_get_enum_value_number(std::string(str));
}
char *hvac_system_type_configuration_cooling_system_stage_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", hvac_system_type_configuration_cooling_system_stage_get_enum_value_name(value).c_str());
  return result;
}

uint32_t hvac_system_type_configuration_cooling_system_stage_get_enum_value_number_c(const char *str)
{
  return hvac_system_type_configuration_cooling_system_stage_get_enum_value_number(std::string(str));
}
char *hvac_system_type_configuration_heating_fuel_source_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", hvac_system_type_configuration_heating_fuel_source_get_enum_value_name(value).c_str());
  return result;
}

uint32_t hvac_system_type_configuration_heating_fuel_source_get_enum_value_number_c(const char *str)
{
  return hvac_system_type_configuration_heating_fuel_source_get_enum_value_number(std::string(str));
}
char *hvac_system_type_configuration_heating_system_stage_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", hvac_system_type_configuration_heating_system_stage_get_enum_value_name(value).c_str());
  return result;
}

uint32_t hvac_system_type_configuration_heating_system_stage_get_enum_value_number_c(const char *str)
{
  return hvac_system_type_configuration_heating_system_stage_get_enum_value_number(std::string(str));
}
char *hvac_system_type_configuration_heating_system_type_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", hvac_system_type_configuration_heating_system_type_get_enum_value_name(value).c_str());
  return result;
}

uint32_t hvac_system_type_configuration_heating_system_type_get_enum_value_number_c(const char *str)
{
  return hvac_system_type_configuration_heating_system_type_get_enum_value_number(std::string(str));
}
char *ias_zone_zone_state_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", ias_zone_zone_state_get_enum_value_name(value).c_str());
  return result;
}

uint32_t ias_zone_zone_state_get_enum_value_number_c(const char *str)
{
  return ias_zone_zone_state_get_enum_value_number(std::string(str));
}
char *ias_zone_type_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", ias_zone_type_get_enum_value_name(value).c_str());
  return result;
}

uint32_t ias_zone_type_get_enum_value_number_c(const char *str)
{
  return ias_zone_type_get_enum_value_number(std::string(str));
}
char *iasac_panel_status_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", iasac_panel_status_get_enum_value_name(value).c_str());
  return result;
}

uint32_t iasac_panel_status_get_enum_value_number_c(const char *str)
{
  return iasac_panel_status_get_enum_value_number(std::string(str));
}
char *iasace_alarm_status_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", iasace_alarm_status_get_enum_value_name(value).c_str());
  return result;
}

uint32_t iasace_alarm_status_get_enum_value_number_c(const char *str)
{
  return iasace_alarm_status_get_enum_value_number(std::string(str));
}
char *iasace_audible_notification_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", iasace_audible_notification_get_enum_value_name(value).c_str());
  return result;
}

uint32_t iasace_audible_notification_get_enum_value_number_c(const char *str)
{
  return iasace_audible_notification_get_enum_value_number(std::string(str));
}
char *iaswd_level_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", iaswd_level_get_enum_value_name(value).c_str());
  return result;
}

uint32_t iaswd_level_get_enum_value_number_c(const char *str)
{
  return iaswd_level_get_enum_value_number(std::string(str));
}
char *illuminance_level_sensing_level_status_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", illuminance_level_sensing_level_status_get_enum_value_name(value).c_str());
  return result;
}

uint32_t illuminance_level_sensing_level_status_get_enum_value_number_c(const char *str)
{
  return illuminance_level_sensing_level_status_get_enum_value_number(std::string(str));
}
char *illuminance_level_sensing_light_sensor_type_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", illuminance_level_sensing_light_sensor_type_get_enum_value_name(value).c_str());
  return result;
}

uint32_t illuminance_level_sensing_light_sensor_type_get_enum_value_number_c(const char *str)
{
  return illuminance_level_sensing_light_sensor_type_get_enum_value_number(std::string(str));
}
char *illuminance_measurement_light_sensor_type_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", illuminance_measurement_light_sensor_type_get_enum_value_name(value).c_str());
  return result;
}

uint32_t illuminance_measurement_light_sensor_type_get_enum_value_number_c(const char *str)
{
  return illuminance_measurement_light_sensor_type_get_enum_value_number(std::string(str));
}
char *image_notify_payload_type_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", image_notify_payload_type_get_enum_value_name(value).c_str());
  return result;
}

uint32_t image_notify_payload_type_get_enum_value_number_c(const char *str)
{
  return image_notify_payload_type_get_enum_value_number(std::string(str));
}
char *logging_level_enum_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", logging_level_enum_get_enum_value_name(value).c_str());
  return result;
}

uint32_t logging_level_enum_get_enum_value_number_c(const char *str)
{
  return logging_level_enum_get_enum_value_number(std::string(str));
}
char *metering_energy_carrier_unit_of_measure_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", metering_energy_carrier_unit_of_measure_get_enum_value_name(value).c_str());
  return result;
}

uint32_t metering_energy_carrier_unit_of_measure_get_enum_value_number_c(const char *str)
{
  return metering_energy_carrier_unit_of_measure_get_enum_value_number(std::string(str));
}
char *metering_metering_device_type_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", metering_metering_device_type_get_enum_value_name(value).c_str());
  return result;
}

uint32_t metering_metering_device_type_get_enum_value_number_c(const char *str)
{
  return metering_metering_device_type_get_enum_value_number(std::string(str));
}
char *metering_supply_status_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", metering_supply_status_get_enum_value_name(value).c_str());
  return result;
}

uint32_t metering_supply_status_get_enum_value_number_c(const char *str)
{
  return metering_supply_status_get_enum_value_number(std::string(str));
}
char *metering_temperature_unit_of_measure_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", metering_temperature_unit_of_measure_get_enum_value_name(value).c_str());
  return result;
}

uint32_t metering_temperature_unit_of_measure_get_enum_value_number_c(const char *str)
{
  return metering_temperature_unit_of_measure_get_enum_value_number(std::string(str));
}
char *metering_unitof_measure_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", metering_unitof_measure_get_enum_value_name(value).c_str());
  return result;
}

uint32_t metering_unitof_measure_get_enum_value_number_c(const char *str)
{
  return metering_unitof_measure_get_enum_value_number(std::string(str));
}
char *move_step_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", move_step_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t move_step_mode_get_enum_value_number_c(const char *str)
{
  return move_step_mode_get_enum_value_number(std::string(str));
}
char *nm_state_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", nm_state_get_enum_value_name(value).c_str());
  return result;
}

uint32_t nm_state_get_enum_value_number_c(const char *str)
{
  return nm_state_get_enum_value_number(std::string(str));
}
char *node_state_network_status_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", node_state_network_status_get_enum_value_name(value).c_str());
  return result;
}

uint32_t node_state_network_status_get_enum_value_number_c(const char *str)
{
  return node_state_network_status_get_enum_value_number(std::string(str));
}
char *node_state_security_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", node_state_security_get_enum_value_name(value).c_str());
  return result;
}

uint32_t node_state_security_get_enum_value_number_c(const char *str)
{
  return node_state_security_get_enum_value_number(std::string(str));
}
char *ota_device_specific_image_type_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", ota_device_specific_image_type_get_enum_value_name(value).c_str());
  return result;
}

uint32_t ota_device_specific_image_type_get_enum_value_number_c(const char *str)
{
  return ota_device_specific_image_type_get_enum_value_number(std::string(str));
}
char *ota_upgrade_image_upgrade_status_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", ota_upgrade_image_upgrade_status_get_enum_value_name(value).c_str());
  return result;
}

uint32_t ota_upgrade_image_upgrade_status_get_enum_value_number_c(const char *str)
{
  return ota_upgrade_image_upgrade_status_get_enum_value_number(std::string(str));
}
char *ota_upgrade_upgrade_activation_policy_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", ota_upgrade_upgrade_activation_policy_get_enum_value_name(value).c_str());
  return result;
}

uint32_t ota_upgrade_upgrade_activation_policy_get_enum_value_number_c(const char *str)
{
  return ota_upgrade_upgrade_activation_policy_get_enum_value_number(std::string(str));
}
char *ota_upgrade_upgrade_timeout_policy_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", ota_upgrade_upgrade_timeout_policy_get_enum_value_name(value).c_str());
  return result;
}

uint32_t ota_upgrade_upgrade_timeout_policy_get_enum_value_number_c(const char *str)
{
  return ota_upgrade_upgrade_timeout_policy_get_enum_value_number(std::string(str));
}
char *occupancy_sensing_occupancy_sensor_type_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", occupancy_sensing_occupancy_sensor_type_get_enum_value_name(value).c_str());
  return result;
}

uint32_t occupancy_sensing_occupancy_sensor_type_get_enum_value_number_c(const char *str)
{
  return occupancy_sensing_occupancy_sensor_type_get_enum_value_number(std::string(str));
}
char *off_with_effect_effect_identifier_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", off_with_effect_effect_identifier_get_enum_value_name(value).c_str());
  return result;
}

uint32_t off_with_effect_effect_identifier_get_enum_value_number_c(const char *str)
{
  return off_with_effect_effect_identifier_get_enum_value_number(std::string(str));
}
char *on_off_start_up_on_off_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", on_off_start_up_on_off_get_enum_value_name(value).c_str());
  return result;
}

uint32_t on_off_start_up_on_off_get_enum_value_number_c(const char *str)
{
  return on_off_start_up_on_off_get_enum_value_number(std::string(str));
}
char *operating_event_notification_operation_event_code_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", operating_event_notification_operation_event_code_get_enum_value_name(value).c_str());
  return result;
}

uint32_t operating_event_notification_operation_event_code_get_enum_value_number_c(const char *str)
{
  return operating_event_notification_operation_event_code_get_enum_value_number(std::string(str));
}
char *options_startup_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", options_startup_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t options_startup_mode_get_enum_value_number_c(const char *str)
{
  return options_startup_mode_get_enum_value_number(std::string(str));
}
char *profile_interval_period_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", profile_interval_period_get_enum_value_name(value).c_str());
  return result;
}

uint32_t profile_interval_period_get_enum_value_number_c(const char *str)
{
  return profile_interval_period_get_enum_value_number(std::string(str));
}
char *programming_event_notification_program_event_code_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", programming_event_notification_program_event_code_get_enum_value_name(value).c_str());
  return result;
}

uint32_t programming_event_notification_program_event_code_get_enum_value_number_c(const char *str)
{
  return programming_event_notification_program_event_code_get_enum_value_number(std::string(str));
}
char *programming_event_notification_program_event_source_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", programming_event_notification_program_event_source_get_enum_value_name(value).c_str());
  return result;
}

uint32_t programming_event_notification_program_event_source_get_enum_value_number_c(const char *str)
{
  return programming_event_notification_program_event_source_get_enum_value_number(std::string(str));
}
char *pump_control_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", pump_control_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t pump_control_mode_get_enum_value_number_c(const char *str)
{
  return pump_control_mode_get_enum_value_number(std::string(str));
}
char *pump_operation_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", pump_operation_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t pump_operation_mode_get_enum_value_number_c(const char *str)
{
  return pump_operation_mode_get_enum_value_number(std::string(str));
}
char *shdcfg_direction_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", shdcfg_direction_get_enum_value_name(value).c_str());
  return result;
}

uint32_t shdcfg_direction_get_enum_value_number_c(const char *str)
{
  return shdcfg_direction_get_enum_value_number(std::string(str));
}
char *setpoint_raise_or_lower_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", setpoint_raise_or_lower_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t setpoint_raise_or_lower_mode_get_enum_value_number_c(const char *str)
{
  return setpoint_raise_or_lower_mode_get_enum_value_number(std::string(str));
}
char *shade_configuration_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", shade_configuration_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t shade_configuration_mode_get_enum_value_number_c(const char *str)
{
  return shade_configuration_mode_get_enum_value_number(std::string(str));
}
char *siren_configuration_strobe_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", siren_configuration_strobe_get_enum_value_name(value).c_str());
  return result;
}

uint32_t siren_configuration_strobe_get_enum_value_number_c(const char *str)
{
  return siren_configuration_strobe_get_enum_value_number(std::string(str));
}
char *siren_configuration_warning_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", siren_configuration_warning_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t siren_configuration_warning_mode_get_enum_value_number_c(const char *str)
{
  return siren_configuration_warning_mode_get_enum_value_number(std::string(str));
}
char *squawk_configuration_squawk_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", squawk_configuration_squawk_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t squawk_configuration_squawk_mode_get_enum_value_number_c(const char *str)
{
  return squawk_configuration_squawk_mode_get_enum_value_number(std::string(str));
}
char *tl_key_index_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", tl_key_index_get_enum_value_name(value).c_str());
  return result;
}

uint32_t tl_key_index_get_enum_value_number_c(const char *str)
{
  return tl_key_index_get_enum_value_number(std::string(str));
}
char *tl_status_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", tl_status_get_enum_value_name(value).c_str());
  return result;
}

uint32_t tl_status_get_enum_value_number_c(const char *str)
{
  return tl_status_get_enum_value_number(std::string(str));
}
char *tl_zigbee_information_logical_type_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", tl_zigbee_information_logical_type_get_enum_value_name(value).c_str());
  return result;
}

uint32_t tl_zigbee_information_logical_type_get_enum_value_number_c(const char *str)
{
  return tl_zigbee_information_logical_type_get_enum_value_number(std::string(str));
}
char *thermostatac_capacity_format_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", thermostatac_capacity_format_get_enum_value_name(value).c_str());
  return result;
}

uint32_t thermostatac_capacity_format_get_enum_value_number_c(const char *str)
{
  return thermostatac_capacity_format_get_enum_value_number(std::string(str));
}
char *thermostatac_compressor_type_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", thermostatac_compressor_type_get_enum_value_name(value).c_str());
  return result;
}

uint32_t thermostatac_compressor_type_get_enum_value_number_c(const char *str)
{
  return thermostatac_compressor_type_get_enum_value_number(std::string(str));
}
char *thermostatac_louver_position_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", thermostatac_louver_position_get_enum_value_name(value).c_str());
  return result;
}

uint32_t thermostatac_louver_position_get_enum_value_number_c(const char *str)
{
  return thermostatac_louver_position_get_enum_value_number(std::string(str));
}
char *thermostatac_refrigerant_type_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", thermostatac_refrigerant_type_get_enum_value_name(value).c_str());
  return result;
}

uint32_t thermostatac_refrigerant_type_get_enum_value_number_c(const char *str)
{
  return thermostatac_refrigerant_type_get_enum_value_number(std::string(str));
}
char *thermostatac_type_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", thermostatac_type_get_enum_value_name(value).c_str());
  return result;
}

uint32_t thermostatac_type_get_enum_value_number_c(const char *str)
{
  return thermostatac_type_get_enum_value_number(std::string(str));
}
char *thermostat_control_sequence_of_operation_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", thermostat_control_sequence_of_operation_get_enum_value_name(value).c_str());
  return result;
}

uint32_t thermostat_control_sequence_of_operation_get_enum_value_number_c(const char *str)
{
  return thermostat_control_sequence_of_operation_get_enum_value_number(std::string(str));
}
char *thermostat_programming_operation_mode_programming_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", thermostat_programming_operation_mode_programming_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t thermostat_programming_operation_mode_programming_mode_get_enum_value_number_c(const char *str)
{
  return thermostat_programming_operation_mode_programming_mode_get_enum_value_number(std::string(str));
}
char *thermostat_setpoint_change_source_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", thermostat_setpoint_change_source_get_enum_value_name(value).c_str());
  return result;
}

uint32_t thermostat_setpoint_change_source_get_enum_value_number_c(const char *str)
{
  return thermostat_setpoint_change_source_get_enum_value_number(std::string(str));
}
char *thermostat_start_of_week_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", thermostat_start_of_week_get_enum_value_name(value).c_str());
  return result;
}

uint32_t thermostat_start_of_week_get_enum_value_number_c(const char *str)
{
  return thermostat_start_of_week_get_enum_value_number(std::string(str));
}
char *thermostat_system_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", thermostat_system_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t thermostat_system_mode_get_enum_value_number_c(const char *str)
{
  return thermostat_system_mode_get_enum_value_number(std::string(str));
}
char *thermostat_temperature_setpoint_hold_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", thermostat_temperature_setpoint_hold_get_enum_value_name(value).c_str());
  return result;
}

uint32_t thermostat_temperature_setpoint_hold_get_enum_value_number_c(const char *str)
{
  return thermostat_temperature_setpoint_hold_get_enum_value_number(std::string(str));
}
char *thermostat_thermostat_running_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", thermostat_thermostat_running_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t thermostat_thermostat_running_mode_get_enum_value_number_c(const char *str)
{
  return thermostat_thermostat_running_mode_get_enum_value_number(std::string(str));
}
char *thermostat_user_interface_configuration_keypad_lockout_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", thermostat_user_interface_configuration_keypad_lockout_get_enum_value_name(value).c_str());
  return result;
}

uint32_t thermostat_user_interface_configuration_keypad_lockout_get_enum_value_number_c(const char *str)
{
  return thermostat_user_interface_configuration_keypad_lockout_get_enum_value_number(std::string(str));
}
char *thermostat_user_interface_configuration_schedule_programming_visibility_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", thermostat_user_interface_configuration_schedule_programming_visibility_get_enum_value_name(value).c_str());
  return result;
}

uint32_t thermostat_user_interface_configuration_schedule_programming_visibility_get_enum_value_number_c(const char *str)
{
  return thermostat_user_interface_configuration_schedule_programming_visibility_get_enum_value_number(std::string(str));
}
char *thermostat_user_interface_configuration_temperature_display_mode_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", thermostat_user_interface_configuration_temperature_display_mode_get_enum_value_name(value).c_str());
  return result;
}

uint32_t thermostat_user_interface_configuration_temperature_display_mode_get_enum_value_number_c(const char *str)
{
  return thermostat_user_interface_configuration_temperature_display_mode_get_enum_value_number(std::string(str));
}
char *trigger_effect_effect_identifier_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", trigger_effect_effect_identifier_get_enum_value_name(value).c_str());
  return result;
}

uint32_t trigger_effect_effect_identifier_get_enum_value_number_c(const char *str)
{
  return trigger_effect_effect_identifier_get_enum_value_number(std::string(str));
}
char *trigger_effect_effect_variant_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", trigger_effect_effect_variant_get_enum_value_name(value).c_str());
  return result;
}

uint32_t trigger_effect_effect_variant_get_enum_value_number_c(const char *str)
{
  return trigger_effect_effect_variant_get_enum_value_number(std::string(str));
}
char *tx_report_transmission_speed_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", tx_report_transmission_speed_get_enum_value_name(value).c_str());
  return result;
}

uint32_t tx_report_transmission_speed_get_enum_value_number_c(const char *str)
{
  return tx_report_transmission_speed_get_enum_value_number(std::string(str));
}
char *window_covering_window_covering_type_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", window_covering_window_covering_type_get_enum_value_name(value).c_str());
  return result;
}

uint32_t window_covering_window_covering_type_get_enum_value_number_c(const char *str)
{
  return window_covering_window_covering_type_get_enum_value_number(std::string(str));
}
char *zone_enroll_response_enroll_response_code_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", zone_enroll_response_enroll_response_code_get_enum_value_name(value).c_str());
  return result;
}

uint32_t zone_enroll_response_enroll_response_code_get_enum_value_number_c(const char *str)
{
  return zone_enroll_response_enroll_response_code_get_enum_value_number(std::string(str));
}
char *attribute_reporting_status_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", attribute_reporting_status_get_enum_value_name(value).c_str());
  return result;
}

uint32_t attribute_reporting_status_get_enum_value_number_c(const char *str)
{
  return attribute_reporting_status_get_enum_value_number(std::string(str));
}
char *zcl_status_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", zcl_status_get_enum_value_name(value).c_str());
  return result;
}

uint32_t zcl_status_get_enum_value_number_c(const char *str)
{
  return zcl_status_get_enum_value_number(std::string(str));
}
char *zcl_type_get_enum_value_name_c(
  uint32_t value, char *result, size_t max_result_size)
{
  snprintf(result, max_result_size, "%s", zcl_type_get_enum_value_name(value).c_str());
  return result;
}

uint32_t zcl_type_get_enum_value_number_c(const char *str)
{
  return zcl_type_get_enum_value_number(std::string(str));
}

const char * unid_from_mqtt_topic_c(const char *topic, char *result, size_t max_result_size) {
  auto res = unify::unid_from_mqtt_topic(std::string(topic));
  if (res == std::nullopt) {
    return NULL;
  }
  snprintf(result, max_result_size, "%s", res.value().c_str());
    return result;
}
}