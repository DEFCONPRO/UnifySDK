/* automatically generated by rust-bindgen 0.59.1 */

pub const ATTRIBUTE_STORE_MAXIMUM_VALUE_LENGTH: u32 = 255;
pub const CLOCK_SECOND: u32 = 1000;
pub type sl_status_t = u32;
pub type datastore_attribute_id_t = u32;
pub type size_t = ::std::os::raw::c_ulong;
pub type attribute_store_type_t = u32;
pub type attribute_store_node_t = datastore_attribute_id_t;
#[repr(u32)]
#[doc = " @brief Attribute Store type to indicate the modification type"]
#[doc = " that triggered a callback"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum attribute_store_change_t {
    ATTRIBUTE_CREATED = 0,
    ATTRIBUTE_UPDATED = 1,
    ATTRIBUTE_DELETED = 2,
}
#[doc = " @brief Attribute store callback type for tree node updates"]
pub type attribute_store_node_update_callback_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: attribute_store_node_t, arg2: attribute_store_change_t),
>;
#[repr(u32)]
#[doc = " @brief This is the value state of a value."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum attribute_store_node_value_state_t {
    #[doc = "< This is the value reported by the node or actual value."]
    REPORTED_ATTRIBUTE = 0,
    #[doc = "< This is the value to be applied to the node."]
    DESIRED_ATTRIBUTE = 1,
    #[doc = "< Retrieve the desired value if it exists if not then provide the reported attribute only used for readding."]
    DESIRED_OR_REPORTED_ATTRIBUTE = 2,
}
extern "C" {
    #[doc = " @brief Retrieve the root node of the tree."]
    #[doc = ""]
    #[doc = " @returns NULL                    If the tree is not initialized, or there is"]
    #[doc = "                                  no root node"]
    #[doc = " @returns attribute_store_node_t  handle for the root node"]
    pub fn attribute_store_get_root() -> attribute_store_node_t;
}
extern "C" {
    #[doc = " @brief Add a new node in the current attribute store."]
    #[doc = ""]
    #[doc = " @param type        The type to assign to the new node."]
    #[doc = "                    MUST be different than ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE"]
    #[doc = " @param parent_node Parent node for the node to add."]
    #[doc = ""]
    #[doc = " @returns attribute_store_node_t handle for the newly created node"]
    #[doc = " @returns ATTRIBUTE_STORE_INVALID_NODE in case of error"]
    pub fn attribute_store_add_node(
        type_: attribute_store_type_t,
        parent_node: attribute_store_node_t,
    ) -> attribute_store_node_t;
}
extern "C" {
    #[doc = " @brief Delete a node and all its children from the attribute store."]
    #[doc = ""]
    #[doc = " @param node The identifier of the node to delete."]
    #[doc = " @note The root node cannot be deleted. If passed as argument,"]
    #[doc = "        only its children will be deleted."]
    #[doc = " @returns SL_STATUS_OK if the node and its children were deleted successfully"]
    #[doc = "          or if it was not in the attribute store anyway"]
    #[doc = " @returns SL_STATUS_FAIL if an error happened."]
    #[doc = " @returns SL_STATUS_NOT_INITIALIZED if the attribute store is not initialized"]
    pub fn attribute_store_delete_node(node: attribute_store_node_t) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Get the node handle of the parent of a node."]
    #[doc = ""]
    #[doc = " @param node         The tree handle of the node for which"]
    #[doc = "                     the parent identifier will be returned"]
    #[doc = " @returns ATTRIBUTE_STORE_INVALID_NODE If the node has no parent or does not exist."]
    #[doc = " @returns attribute_store_node_t       handle for the parent node on success"]
    pub fn attribute_store_get_node_parent(node: attribute_store_node_t) -> attribute_store_node_t;
}
extern "C" {
    #[doc = " @brief Traverse up the tree from a node and finds the first parent with a given type."]
    #[doc = ""]
    #[doc = " @param node              The Attribute Store node for which the parents"]
    #[doc = "                          will be searched for the given type"]
    #[doc = " @param parent_type       The type of the parent that we search"]
    #[doc = ""]
    #[doc = " @returns ATTRIBUTE_STORE_INVALID_NODE If the node has no (distant) parent with the given type."]
    #[doc = " @returns attribute_store_node_t       handle for the parent node on success"]
    pub fn attribute_store_get_first_parent_with_type(
        node: attribute_store_node_t,
        parent_type: attribute_store_type_t,
    ) -> attribute_store_node_t;
}
extern "C" {
    #[doc = " @brief Set the attribute value of a node in the current attribute store tree."]
    #[doc = ""]
    #[doc = " @param node        The node handle for which the value"]
    #[doc = "                    must be updated."]
    #[doc = " @param value_state The attribute_store_node_value_state_t"]
    #[doc = "                    value state to write for the node."]
    #[doc = "                    (Desired or Reported)"]
    #[doc = " @param value       A uint8_t pointer to an array containing"]
    #[doc = "                    the data to be written for the node. This array"]
    #[doc = "                    may contain up to 255 bytes."]
    #[doc = " @param value_size  The number of bytes to read from the value pointer."]
    #[doc = ""]
    #[doc = " @returns SL_STATUS_OK         If the tree node value has been set correctly."]
    #[doc = " @returns SL_STATUS_FAIL       If the value state is not understood."]
    #[doc = " @returns SL_STATUS_NOT_INITIALIZED if the attribute store is not initialized"]
    #[doc = "                                    properly"]
    pub fn attribute_store_set_node_attribute_value(
        node: attribute_store_node_t,
        value_state: attribute_store_node_value_state_t,
        value: *const u8,
        value_size: u8,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Get the attribute value of a node."]
    #[doc = ""]
    #[doc = " @param node        The node handle of the node for which"]
    #[doc = "                    attribute value is to be retrieved"]
    #[doc = " @param value_state The attribute_store_node_value_state_t"]
    #[doc = "                    value state to retrieve from the node."]
    #[doc = "                    (Desired or Reported)"]
    #[doc = " @param value       A uint8_t pointer to an array for which the"]
    #[doc = "                    value/value state will be written to. This array"]
    #[doc = "                    should be able to contain 255 bytes."]
    #[doc = " @param value_size  Pointer to an uint8_t variable where the size"]
    #[doc = "                    of the value/payload written to the value pointer"]
    #[doc = "                    will be written."]
    #[doc = ""]
    #[doc = " @returns SL_STATUS_OK        If the attribute value of the node was successfully"]
    #[doc = "                              written to the pointers value/value_size"]
    #[doc = " @returns SL_STATUS_FAIL      If an error occurred"]
    #[doc = " @returns SL_STATUS_NOT_INITIALIZED if the attribute store is not initialized"]
    #[doc = "                                    properly"]
    pub fn attribute_store_get_node_attribute_value(
        node: attribute_store_node_t,
        value_state: attribute_store_node_value_state_t,
        value: *mut u8,
        value_size: *mut u8,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Get the type of a node."]
    #[doc = ""]
    #[doc = " @param node The node handle of the node for which"]
    #[doc = "             the type is to be returned"]
    #[doc = " @returns attribute_store_type_t The assigned type for the node"]
    #[doc = " @returns ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE if the node does not exist"]
    pub fn attribute_store_get_node_type(node: attribute_store_node_t) -> attribute_store_type_t;
}
extern "C" {
    #[doc = " @brief Get the node handle of a child of a node."]
    #[doc = ""]
    #[doc = " @param node        The tree handle of the node for which"]
    #[doc = "                    the child handle will be returned"]
    #[doc = " @param child_index Value to indicate which child to find."]
    #[doc = "                    0 will match the first child,"]
    #[doc = "                    1 the second child, etc."]
    #[doc = " @returns attribute_store_node_t handle for the child node"]
    #[doc = "                                 at the indicated index."]
    #[doc = " @returns ATTRIBUTE_STORE_INVALID_NODE If the child index does not exist"]
    #[doc = "          (i.e. there are less children than the child index)."]
    #[doc = "          or if node itself does not exist"]
    pub fn attribute_store_get_node_child(
        node: attribute_store_node_t,
        child_index: u32,
    ) -> attribute_store_node_t;
}
extern "C" {
    #[doc = " @brief Get the number of children of the given node."]
    #[doc = ""]
    #[doc = " @param node        The tree handle of the node for which"]
    #[doc = "                    the child handle will be returned"]
    #[doc = " @returns int       Number of children"]
    pub fn attribute_store_get_node_child_count(node: attribute_store_node_t) -> size_t;
}
extern "C" {
    #[doc = " @brief Get the node handle of a child of a node with a certain type."]
    #[doc = ""]
    #[doc = " @param node          The node handle of the node for which"]
    #[doc = "                      the child identifier will be written"]
    #[doc = " @param child_type    The attribute store type of the child."]
    #[doc = " @param child_index   Value to indicate which child to find."]
    #[doc = "                      0 will match the first child (with that type),"]
    #[doc = "                      1 the second child (with that type), etc."]
    #[doc = " @returns attribute_store_node_t handle for the child node at the indicated index"]
    #[doc = "                                 with the type."]
    #[doc = " @returns ATTRIBUTE_STORE_INVALID_NODE if the child index does not exist."]
    #[doc = "               (i.e. there are less children with that type than the child index)."]
    #[doc = "               or if node itself does not exist"]
    pub fn attribute_store_get_node_child_by_type(
        node: attribute_store_node_t,
        child_type: attribute_store_type_t,
        child_index: u32,
    ) -> attribute_store_node_t;
}
extern "C" {
    #[doc = " @brief Get the node handle of a child of a node with a certain type and value."]
    #[doc = ""]
    #[doc = " @param node          The node handle of the node for which"]
    #[doc = "                      the child identifier will be written"]
    #[doc = " @param child_type    The attribute type of the child."]
    #[doc = " @param value_state   The attribute_store_node_value_state_t"]
    #[doc = "                      value state to compare for the child."]
    #[doc = "                      (Desired or Reported)"]
    #[doc = " @param value         A uint8_t pointer to an array for which the"]
    #[doc = "                      value/value state will be compared."]
    #[doc = " @param value_size    The number of bytes to compare from the"]
    #[doc = "                      value pointer."]
    #[doc = " @param child_index   Value to indicate which child to find."]
    #[doc = "                      0 will match the first child (with that type and value),"]
    #[doc = "                      1 the second child (with that type and value), etc."]
    #[doc = " @returns attribute_store_node_t handle for the child node at the indicated index"]
    #[doc = "                                 with the type and value."]
    #[doc = " @returns ATTRIBUTE_STORE_INVALID_NODE if the child index does not exist."]
    #[doc = "          (i.e. there are less children with that type and value than the"]
    #[doc = "          child index). or if node itself does not exist"]
    #[doc = ""]
    pub fn attribute_store_get_node_child_by_value(
        node: attribute_store_node_t,
        child_type: attribute_store_type_t,
        value_state: attribute_store_node_value_state_t,
        value: *const u8,
        value_size: u8,
        child_index: u32,
    ) -> attribute_store_node_t;
}
extern "C" {
    #[doc = " @brief Register a callback function to any node change."]
    #[doc = ""]
    #[doc = " WARNING: Do not use this function, unless you are a component"]
    #[doc = " that really wants to know about almost all updates in the attribute"]
    #[doc = " store. See \\ref attribute_store_register_callback_by_type and"]
    #[doc = " \\ref attribute_store_register_callback_by_type_and_state"]
    #[doc = ""]
    #[doc = " @param callback_function The function to invoke when the node's"]
    #[doc = "                          value is updated."]
    #[doc = " @returns SL_STATUS_OK    If the callback was registered successfully."]
    pub fn attribute_store_register_callback(
        callback_function: attribute_store_node_update_callback_t,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Register a callback function to any node with a given type."]
    #[doc = ""]
    #[doc = " @param callback_function The function to invoke when the node's"]
    #[doc = "                          value is updated."]
    #[doc = " @param type              The attribute node type for which a"]
    #[doc = "                          callback will be registered."]
    #[doc = " @returns SL_STATUS_OK    If the callback was registered successfully."]
    pub fn attribute_store_register_callback_by_type(
        callback_function: attribute_store_node_update_callback_t,
        type_: attribute_store_type_t,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Register a callback function to any node with a given"]
    #[doc = " type for a given value_state update"]
    #[doc = ""]
    #[doc = " @param callback_function The function to invoke when the node's"]
    #[doc = "                          value is updated."]
    #[doc = " @param type              The attribute node type for which a"]
    #[doc = "                          callback will be registered."]
    #[doc = " @param value_state       The value-state that will trigger a"]
    #[doc = "                          callback when it's modified."]
    #[doc = " @returns SL_STATUS_OK    If the callback was registered successfully."]
    pub fn attribute_store_register_callback_by_type_and_state(
        callback_function: attribute_store_node_update_callback_t,
        type_: attribute_store_type_t,
        value_state: attribute_store_node_value_state_t,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Verify whether a node is in the Attribute Store."]
    #[doc = ""]
    #[doc = " @param   node  The identifier of the node to verify if"]
    #[doc = "                it is present in the Attribute Store"]
    #[doc = " @returns true  if the Node ID is in the Attribute Store"]
    #[doc = " @returns false if the Node ID is in the Attribute Store"]
    pub fn attribute_store_node_exists(node: attribute_store_node_t) -> bool;
}
extern "C" {
    #[doc = " @brief Invoking update of callbacks for the given node and all children nodes"]
    #[doc = ""]
    #[doc = " WARNING: Callbacks registered by DESIRED_ATTRIBUTE or"]
    #[doc = " DESIRED_OR_REPORTED_ATTRIBUTE will not be invoked."]
    #[doc = ""]
    #[doc = " @param   node  The identifier of the node to update"]
    #[doc = "                and all its children"]
    #[doc = ""]
    #[doc = " @returns SL_STATUS_OK if all nodes callbacks was successfully updated"]
    #[doc = " @returns SL_STATUS_FAIL if invoking update callbacks on any node fails"]
    pub fn attribute_store_refresh_node_and_children_callbacks(
        node: attribute_store_node_t,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Log the content of the Attribute Store tree using \\ref sl_log."]
    pub fn attribute_store_log();
}
extern "C" {
    #[doc = " @brief Log the content of the Attribute Store tree using \\ref sl_log"]
    #[doc = " from a given node."]
    #[doc = " @param node          The node handle of the node for which the tree"]
    #[doc = "                      will be printed out."]
    #[doc = " @param log_children  bool value indicating if children should be"]
    #[doc = "                      printed out as well."]
    pub fn attribute_store_log_node(node: attribute_store_node_t, log_children: bool);
}
extern "C" {
    #[doc = " @brief Register a name for a attribute typid."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = " @param name"]
    pub fn attribute_store_register_attribute(
        id: attribute_store_type_t,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Get the type name of an attribute"]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = " @return const char* Name"]
    pub fn attribute_store_name_by_type(
        id: attribute_store_type_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Lookup the type of an attribute by its name"]
    #[doc = ""]
    #[doc = " @param name Name to look up"]
    #[doc = " @return attribute_store_type_t resulting type, if name is not found 0xffffffff is returned."]
    pub fn attribute_store_type_by_name(
        name: *const ::std::os::raw::c_char,
    ) -> attribute_store_type_t;
}
extern "C" {
    #[doc = " @brief Initialize the Attribute store."]
    #[doc = ""]
    #[doc = " This component depends on the following components:"]
    #[doc = " - @ref sl_log"]
    #[doc = " - @ref datastore"]
    #[doc = ""]
    #[doc = " @returns SL_STATUS_OK on success"]
    #[doc = " @returns SL_STATUS_FAIL on failure"]
    pub fn attribute_store_init() -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Clears up the Attribute Store from all its content."]
    #[doc = ""]
    #[doc = " @returns 0 on success"]
    pub fn attribute_store_teardown() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Indicate whether a value is defined in the attribute store."]
    #[doc = ""]
    #[doc = " @param node        The Attribute store node under"]
    #[doc = "                    which the value must be retrieved"]
    #[doc = " @param value_state The value_state to retrieve"]
    #[doc = ""]
    #[doc = " @returns true  If the value is defined (its size > 0)"]
    #[doc = " @returns false If the value is undefined (its size == 0)"]
    pub fn attribute_store_is_value_defined(
        node: attribute_store_node_t,
        value_state: attribute_store_node_value_state_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Indicate whether reported and desired values are matched in the attribute store."]
    #[doc = ""]
    #[doc = " @param node        The Attribute store node under"]
    #[doc = "                    which the value must be retrieved"]
    #[doc = ""]
    #[doc = " @returns true  If the values are matched"]
    #[doc = " @returns false If the value are unmatched"]
    pub fn attribute_store_is_value_matched(node: attribute_store_node_t) -> bool;
}
extern "C" {
    #[doc = " @brief Set the Desired value to the same as the Reported value."]
    #[doc = ""]
    #[doc = " @param node        The Attribute store node for which DESIRED"]
    #[doc = "                    must be aligned to REPORTED"]
    #[doc = ""]
    #[doc = " @returns sl_status_t"]
    pub fn attribute_store_set_desired_as_reported(node: attribute_store_node_t) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Set the Reported value to the same as the Desired value."]
    #[doc = ""]
    #[doc = " @param node        The Attribute store node for which REPORTED"]
    #[doc = "                    must be aligned to DESIRED"]
    #[doc = ""]
    #[doc = " @returns sl_status_t"]
    pub fn attribute_store_set_reported_as_desired(node: attribute_store_node_t) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Set the Reported value to \"undefined\" (0 size no value)"]
    #[doc = ""]
    #[doc = " @param node        The Attribute store node for which REPORTED"]
    #[doc = "                    must be set to nothing"]
    pub fn attribute_store_undefine_reported(node: attribute_store_node_t);
}
extern "C" {
    #[doc = " @brief Set the Reported value of an Attribute Store node"]
    #[doc = ""]
    #[doc = " @param node        The Attribute store node for which REPORTED"]
    #[doc = "                    must be updated"]
    #[doc = " @param value       A pointer to a variable containing"]
    #[doc = "                    the data to be written for the node."]
    #[doc = " @param value_size  The number of bytes to read from the value pointer."]
    #[doc = ""]
    #[doc = " @returns sl_status_t returned by @ref attribute_store_set_node_attribute_value"]
    pub fn attribute_store_set_reported(
        node: attribute_store_node_t,
        value: *const ::std::os::raw::c_void,
        value_size: u8,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Reads the reported value of an attribute store node"]
    #[doc = ""]
    #[doc = " @param node          The Attribute store node under"]
    #[doc = "                      which the value must be retrieved"]
    #[doc = " @param value         Pointer where to copy the value"]
    #[doc = " @param expected_size  The size of the pointer of read_value"]
    #[doc = ""]
    #[doc = " @returns SL_STATUS_OK    if the read value has the expected size and"]
    #[doc = "                          has been copied to the pointer."]
    #[doc = " @returns SL_STATUS_FAIL  if the value is undefined, has not the expected"]
    #[doc = "                          size or has not been copied to the pointer."]
    pub fn attribute_store_get_reported(
        node: attribute_store_node_t,
        value: *mut ::std::os::raw::c_void,
        expected_size: size_t,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Safely copies a String in the Attribute Store"]
    #[doc = ""]
    #[doc = " @param node          The Attribute store node under"]
    #[doc = "                      which the value must be written"]
    #[doc = " @param string        C char array containing a String"]
    #[doc = ""]
    #[doc = " @returns sl_status_t returned by @ref attribute_store_set_node_attribute_value"]
    pub fn attribute_store_set_reported_string(
        node: attribute_store_node_t,
        string: *const ::std::os::raw::c_char,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Set the Desired value to \"undefined\" (0 size no value)"]
    #[doc = ""]
    #[doc = " @param node        The Attribute store node for which DESIRED"]
    #[doc = "                    must be set to nothing"]
    pub fn attribute_store_undefine_desired(node: attribute_store_node_t);
}
extern "C" {
    #[doc = " @brief Set the Desired value of an Attribute Store node"]
    #[doc = ""]
    #[doc = " @param node        The Attribute store node for which DESIRED"]
    #[doc = "                    must be updated"]
    #[doc = " @param value       A pointer to a variable containing"]
    #[doc = "                    the data to be written for the node."]
    #[doc = " @param value_size  The number of bytes to read from the value pointer."]
    #[doc = ""]
    #[doc = " @returns sl_status_t returned by @ref attribute_store_set_node_attribute_value"]
    pub fn attribute_store_set_desired(
        node: attribute_store_node_t,
        value: *const ::std::os::raw::c_void,
        value_size: u8,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Reads the desired value of an attribute store node"]
    #[doc = ""]
    #[doc = " @param node          The Attribute store node under"]
    #[doc = "                      which the value must be retrieved"]
    #[doc = " @param value         Pointer where to copy the value"]
    #[doc = " @param expected_size  The size of the pointer of read_value"]
    #[doc = ""]
    #[doc = " @returns SL_STATUS_OK    if the read value has the expected size and"]
    #[doc = "                          has been copied to the pointer."]
    #[doc = " @returns SL_STATUS_FAIL  if the value is undefined, has not the expected"]
    #[doc = "                          size or has not been copied to the pointer."]
    pub fn attribute_store_get_desired(
        node: attribute_store_node_t,
        value: *mut ::std::os::raw::c_void,
        expected_size: size_t,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Copy the value from a node to another."]
    #[doc = ""]
    #[doc = " @param source_node       The node that contains a value to be copied to"]
    #[doc = "                          another node."]
    #[doc = " @param destination_node  The node that the source_node's value will be copied"]
    #[doc = "                          into."]
    #[doc = " @param value_state       The value state to be copied from source_node to"]
    #[doc = "                          destination_node"]
    #[doc = ""]
    #[doc = " @returns SL_STATUS_OK if the value_state value was copied from source_node"]
    #[doc = "                       to destination_node. Empty value copy will be considered"]
    #[doc = "                        successful."]
    #[doc = " @returns SL_STATUS_NOT_FOUND if one of the attribute store nodes does not exist"]
    #[doc = " @returns SL_FAIL if the value cannot be copied"]
    #[doc = ""]
    pub fn attribute_store_copy_value(
        source_node: attribute_store_node_t,
        destination_node: attribute_store_node_t,
        value_state: attribute_store_node_value_state_t,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Read an arbitrary sized value from the attribute store"]
    #[doc = " and writes it to a pointer."]
    #[doc = ""]
    #[doc = " @param node          The Attribute store node under"]
    #[doc = "                      which the value must be retrieved"]
    #[doc = " @param value_state   The value_state to retrieve"]
    #[doc = " @param read_value    A pointer where to copy the read"]
    #[doc = "                      value from the attribute store."]
    #[doc = " @param expected_size  The size of the pointer of read_value"]
    #[doc = ""]
    #[doc = " @returns SL_STATUS_OK    if the read value has the expected size and"]
    #[doc = "                          has been copied to the pointer."]
    #[doc = " @returns SL_STATUS_FAIL  if the value is undefined, has not the expected"]
    #[doc = "                          size or has not been copied to the pointer."]
    pub fn attribute_store_read_value(
        node: attribute_store_node_t,
        value_state: attribute_store_node_value_state_t,
        read_value: *mut ::std::os::raw::c_void,
        expected_size: size_t,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Sets the value of the first child of a node with a given type."]
    #[doc = " and writes its reported value."]
    #[doc = ""]
    #[doc = " If there is no child of the given type for the parent, it will be created."]
    #[doc = ""]
    #[doc = " @param parent        The Attribute store node under"]
    #[doc = "                      which the child's reported value must be written"]
    #[doc = " @param type          The type of the child"]
    #[doc = " @param value         A pointer to a variable containing"]
    #[doc = "                      the data to be written for the node."]
    #[doc = " @param value_size    The number of bytes to read from the value pointer."]
    #[doc = ""]
    #[doc = " @returns sl_status_t returned by @ref attribute_store_set_node_attribute_value"]
    #[doc = ""]
    pub fn attribute_store_set_child_reported(
        parent: attribute_store_node_t,
        type_: attribute_store_type_t,
        value: *const ::std::os::raw::c_void,
        value_size: u8,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Set the value of the first child with a given type."]
    #[doc = ""]
    #[doc = " This function sets the value of the first attribute child"]
    #[doc = " matching a given type."]
    #[doc = ""]
    #[doc = " @param parent Parent node of children"]
    #[doc = " @param type   Type of child"]
    #[doc = " @param state  The value_state"]
    #[doc = " @param value  Value"]
    #[doc = " @return sl_status_t"]
    pub fn attribute_store_set_uint32_child_by_type(
        parent: attribute_store_node_t,
        type_: attribute_store_type_t,
        state: attribute_store_node_value_state_t,
        value: u32,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " See @ref attribute_store_set_uint32_child_by_type"]
    #[doc = " @param parent Parent node of children"]
    #[doc = " @param type   Type of child"]
    #[doc = " @param state  The value_state"]
    #[doc = " @param value  Value"]
    #[doc = " @return sl_status_t"]
    pub fn attribute_store_set_uint8_child_by_type(
        parent: attribute_store_node_t,
        type_: attribute_store_type_t,
        state: attribute_store_node_value_state_t,
        value: u8,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Visit all nodes in the tree."]
    #[doc = ""]
    #[doc = " This function visits all tree nodes going from the top and down."]
    #[doc = " It will continue to the node children if the status returned by"]
    #[doc = " the function is SL_STATUS_OK. If the function returns SL_STATUS_ABORT,"]
    #[doc = " no more nodes are visited. Otherwise, siblings will be visited."]
    #[doc = ""]
    #[doc = " @param top First node to be visited"]
    #[doc = " @param func function to execute"]
    #[doc = " @param depth The current depth of the top node."]
    pub fn attribute_store_walk_tree(
        top: attribute_store_node_t,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: attribute_store_node_t,
                arg2: ::std::os::raw::c_int,
            ) -> sl_status_t,
        >,
        depth: ::std::os::raw::c_int,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Add multiple nodes to a parent if they are not already present."]
    #[doc = ""]
    #[doc = " This is a helper function that will add  a list of nodes to the parent"]
    #[doc = " if they are not already present."]
    #[doc = ""]
    #[doc = " @param parent_node Parent node for the nodes to add."]
    #[doc = " @param attributes array of attribute types"]
    #[doc = " @param count number of attributes to add."]
    pub fn attribute_store_add_if_missing(
        parent_node: attribute_store_node_t,
        attributes: *const attribute_store_type_t,
        count: u32,
    );
}
pub type clock_time_t = ::std::os::raw::c_ulong;
#[doc = " @brief Function prototype callback functions."]
pub type attribute_timeout_callback_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: attribute_store_node_t)>;
extern "C" {
    #[doc = " @brief Sets a callback to be called after a duration for an attribute."]
    #[doc = ""]
    #[doc = " There can be only one node/callback_function combination active at a time."]
    #[doc = " It means that for example, calling the API in the following sequence:"]
    #[doc = " - attribute_timeout_set_callback(1,100,&function1);"]
    #[doc = " - attribute_timeout_set_callback(1,1000,&function1);"]
    #[doc = ""]
    #[doc = " Will lead to only 1 call of function1 in 1000ms from now."]
    #[doc = ""]
    #[doc = " As another example, calling the API in the following sequence:"]
    #[doc = " - attribute_timeout_set_callback(1,100,&function1);"]
    #[doc = " - attribute_timeout_set_callback(1,1000,&function2);"]
    #[doc = " - attribute_timeout_set_callback(2,1000,&function2);"]
    #[doc = ""]
    #[doc = " Will lead to 3 function calls:"]
    #[doc = " - function1(1) in 100ms"]
    #[doc = " - function2(1) in 1000ms"]
    #[doc = " - function2(2) in 1000ms"]
    #[doc = ""]
    #[doc = " @param node               The attribute store node to inspect after the duration."]
    #[doc = " @param duration           The time in ms for the duration to wait."]
    #[doc = " @param callback_function  The function to invoke for the attribute node inspection."]
    #[doc = ""]
    #[doc = " @returns SL_STATUS_OK if the timer is started and the callback will be invoked."]
    #[doc = "          SL_STATUS_FAIL in case of error."]
    pub fn attribute_timeout_set_callback(
        node: attribute_store_node_t,
        duration: clock_time_t,
        callback_function: attribute_timeout_callback_t,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Cancels a callback to be called after a duration for an attribute."]
    #[doc = ""]
    #[doc = " @param node               The attribute store node to inspect after the duration."]
    #[doc = " @param callback_function  The function to invoke for the attribute node inspection."]
    #[doc = ""]
    #[doc = " @returns SL_STATUS_OK, indicating that the callback function will not be called."]
    #[doc = "          SL_STATUS_NOT_FOUND if this callback was not active for the node."]
    pub fn attribute_timeout_cancel_callback(
        node: attribute_store_node_t,
        callback_function: attribute_timeout_callback_t,
    ) -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Initializes the UIC attribute timeouts component"]
    #[doc = ""]
    #[doc = " @returns SL_STATUS_OK on success, any other value otherwise"]
    pub fn attribute_timeouts_init() -> sl_status_t;
}
extern "C" {
    #[doc = " @brief Teardown the UIC attribute timeouts component"]
    #[doc = " @returns 0 on success."]
    pub fn attribute_timeouts_teardown() -> ::std::os::raw::c_int;
}
