{
	// Place your zpc workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
  // }
  "ZPC Header": {
    "scope": "c,cpp",
    "prefix": "zpc",
    "body":[
"/******************************************************************************",
" * # License",
" * <b>Copyright ${CURRENT_YEAR} Silicon Laboratories Inc. www.silabs.com</b>",
" ******************************************************************************",
" * The licensor of this software is Silicon Laboratories Inc. Your use of this",
" * software is governed by the terms of Silicon Labs Master Software License",
" * Agreement (MSLA) available at",
" * www.silabs.com/about-us/legal/master-software-license-agreement. This",
" * software is distributed to you in Source Code format and is governed by the",
" * sections of the MSLA applicable to Source Code.",
" *",
" *****************************************************************************/",
"",
"/**",
" * @file ${TM_FILENAME}",
" * @brief TODO: Write brief for ${TM_FILENAME_BASE}",
" *",
" * TODO: Write component description for ${TM_FILENAME_BASE}",
" *",
" * @{",
" */",
" ",
"#ifndef ${TM_FILENAME/(.*)\\.(.*)/${1:/upcase}_${2:/upcase}/}",
"#define ${TM_FILENAME/(.*)\\.(.*)/${1:/upcase}_${2:/upcase}/}",
"",
"#ifdef __cplusplus",
"extern \"C\" {",
"#endif",
"",
"#ifdef __cplusplus",
"}",
"#endif",
"",
"#endif  //${TM_FILENAME/(.*)\\.(.*)/${1:/upcase}_${2:/upcase}/}",
"/** @} end ${TM_FILENAME_BASE} */",
""
    ],
    "description": "ZPC C Header"
  },

  "ZPC Source": {
    "prefix": "zpc",
    "scope": "c,cpp",
    "body":[
"/******************************************************************************",
" * # License",
" * <b>Copyright ${CURRENT_YEAR} Silicon Laboratories Inc. www.silabs.com</b>",
" ******************************************************************************",
" * The licensor of this software is Silicon Laboratories Inc. Your use of this",
" * software is governed by the terms of Silicon Labs Master Software License",
" * Agreement (MSLA) available at",
" * www.silabs.com/about-us/legal/master-software-license-agreement. This",
" * software is distributed to you in Source Code format and is governed by the",
" * sections of the MSLA applicable to Source Code.",
" *",
" *****************************************************************************/",
"#include \"${TM_FILENAME_BASE}.h\"",   ],
    "description": "ZPC C Source"
  },

  "Contiki Process": {
    "scope": "c,cpp",
    "prefix": "zpc",
    "body":[
      "PROCESS(${1:${TM_FILENAME_BASE}_process}, \"$1\");",
      "",
      "PROCESS_THREAD($1, ev, data)",
      "{",
      "",
      "  PROCESS_BEGIN();",
      " while (1) {",
      "   if (ev == PROCESS_EVENT_INIT) {",
      "    } else if (ev == PROCESS_EVENT_EXIT) {",
      "    }",
      "    PROCESS_WAIT_EVENT();",
      "  }",
      "  PROCESS_END()",
      "}"
    ],
    "description": "Add Contiki process"
  },

  "Unity Test": {
    "prefix": "zpc",
    "scope": "c,cpp",
    "body":[
      "/******************************************************************************",
      " * # License",
      " * <b>Copyright ${CURRENT_YEAR} Silicon Laboratories Inc. www.silabs.com</b>",
      " ******************************************************************************",
      " * The licensor of this software is Silicon Laboratories Inc. Your use of this",
      " * software is governed by the terms of Silicon Labs Master Software License",
      " * Agreement (MSLA) available at",
      " * www.silabs.com/about-us/legal/master-software-license-agreement. This",
      " * software is distributed to you in Source Code format and is governed by the",
      " * sections of the MSLA applicable to Source Code.",
      " *",
      " *****************************************************************************/",
      "#include \"unity.h\"",

      "/// Setup the test suite (called once before all test_xxx functions are called)",
      "void suiteSetUp() {}",
      "",
      "/// Teardown the test suite (called once after all test_xxx functions are called)",
      "int suiteTearDown(int num_failures)",
      "{",
      "return num_failures;",
      "}",
      "",
      "/// Called before each and every test",
      "void setUp() {}",
      "",
      "void test_${TM_FILENAME_BASE}(){}"
    ],
    "description": "Unity Test"
  },

  "Command Class handler C file": {
    "prefix": "zpc",
    "scope": "c,cpp",
    "body":[
      "/******************************************************************************",
      "* # License",
      "* <b>Copyright ${CURRENT_YEAR}  Silicon Laboratories Inc. www.silabs.com</b>",
      "******************************************************************************",
      "* The licensor of this software is Silicon Laboratories Inc. Your use of this",
      "* software is governed by the terms of Silicon Labs Master Software License",
      "* Agreement (MSLA) available at",
      "* www.silabs.com/about-us/legal/master-software-license-agreement. This",
      "* software is distributed to you in Source Code format and is governed by the",
      "* sections of the MSLA applicable to Source Code.",
      "*",
      "*****************************************************************************/",
      "",
      "// Includes from this component",
      "#include \"${TM_FILENAME_BASE}.h\"",
      "",
      "// Generic includes",
      "#include <assert.h>",
      "#include <stdbool.h>",
      "",
      "// Includes from other components",
      "#include \"ZW_classcmd.h\"",
      "#include \"zwave_command_handler.h\"",
      "#include \"zwave_controller_connection_info.h\"",
      "#include \"zwave_controller_utils.h\"",
      "#include \"zwave_rx.h\"",
      "",
      "#include \"attribute_store.h\"",
      "#include \"attribute_store_helper.h\"",
      "#include \"attribute_store_network_helper.h\"",
      "#include \"attribute_resolver.h\"",
      "",
      "#include \"zwave_unid.h\"",
      "",
      "#include \"sl_log.h\"",
      "#define LOG_TAG \"${TM_FILENAME_BASE}\"",
      "",
      "",
      "///////////////////////////////////////////////////////////////////////////////",
      "// Private helper functions",
      "///////////////////////////////////////////////////////////////////////////////",
      "",
      "",
      "///////////////////////////////////////////////////////////////////////////////",
      "// Command Handler functions",
      "///////////////////////////////////////////////////////////////////////////////",
      "static sl_status_t",
      " ${TM_FILENAME_BASE}_handle_xxx_command(",
      "   const zwave_controller_connection_info_t *connection_info,",
      "   const uint8_t *frame_data,",
      "   uint16_t frame_length)",
      "{",
      " if (frame_length < xxx ) {",
      "   // Frame too short?? Just ignore it and return SUCCESS to supervision",
      "   // Since it is a report.",
      "   return SL_STATUS_OK;",
      " }",
      "",
      " // Find the NodeID in the attribute store.",
      " attribute_store_node_t node_id_node",
      "   = attribute_store_network_helper_get_zwave_node_id_node(",
      "     connection_info->remote.node_id);",
      "",
      " // Save the data from this command",
      " xxx",
      "",
      " return SL_STATUS_OK;",
      "}",
      "",
      "",
      "static sl_status_t ${TM_FILENAME_BASE}_handler(",
      " const zwave_controller_connection_info_t *connection_info,",
      " const zwave_rx_receive_options_t *rx_options,",
      " const uint8_t *frame_data,",
      " uint16_t frame_length)",
      "{",
      " if (frame_length < 2) {",
      "   return SL_STATUS_NOT_SUPPORTED;",
      " }",
      "",
      " if (frame_data[0] != xxx) {",
      "   return SL_STATUS_NOT_SUPPORTED;",
      " }",
      "",
      " switch (frame_data[1]) {",
      "   case xxx:",
      "     return ${TM_FILENAME_BASE}_handle_xxx_command(",
      "       connection_info,",
      "       frame_data,",
      "       frame_length);",
      "",
      "   default:",
      "     return SL_STATUS_NOT_SUPPORTED;",
      " }",
      "}",
      "",
      "///////////////////////////////////////////////////////////////////////////////",
      "// Attribute resolution functions",
      "///////////////////////////////////////////////////////////////////////////////",
      "static sl_status_t ${TM_FILENAME_BASE}_get(",
      " attribute_store_node_t node, uint8_t *frame, uint16_t *frame_len)",
      "{",
      " // Create a frame for the attribute resolver",
      " xxx",
      "",
      " *frame_len = sizeof(xxx);",
      " return SL_STATUS_OK;",
      "}",
      "",
      "///////////////////////////////////////////////////////////////////////////////",
      "// Attribute update callbacks",
      "///////////////////////////////////////////////////////////////////////////////",
      "static void ${TM_FILENAME_BASE}_on_version_attribute_update(",
      " attribute_store_node_t updated_node, attribute_store_change_t change)",
      "{",
      " if (change == ATTRIBUTE_DELETED) {",
      "   return;",
      " }",
      "",
      " // Check that we have the right type of attribute.",
      " assert(ATTRIBUTE_COMMAND_CLASS_xxx_VERSION",
      "        == attribute_store_get_node_type(updated_node));",
      "",
      " uint8_t supporting_node_version = 0;",
      " attribute_store_read_value(updated_node,",
      "                            REPORTED_ATTRIBUTE,",
      "                            &supporting_node_version,",
      "                            sizeof(supporting_node_version));",
      "",
      " if (supporting_node_version == 0) {",
      "   // Wait for the version to be known.",
      "   return;",
      " }",
      "",
      " // Now we know we have a supporting node.",
      " // Check that the minimum attributes are created",
      " attribute_store_node_t endpoint_node",
      "   = attribute_store_get_node_parent(updated_node);",
      "",
      " // Let the rest of the command class perform the job.",
      " attribute_store_type_t attribute_list[]",
      "   = {xxx};",
      " attribute_store_add_if_missing(endpoint_node,",
      "                                attribute_list,",
      "                                COUNT_OF(attribute_list));",
      "}",
      "",
      "///////////////////////////////////////////////////////////////////////////////",
      "// Public interface functions",
      "///////////////////////////////////////////////////////////////////////////////",
      "sl_status_t ${TM_FILENAME_BASE}_init()",
      "{",
      "",
      " // Register our handler to the Z-Wave CC framework:",
      " zwave_command_handler_t handler;",
      " handler.handler = ${TM_FILENAME_BASE}_handler;",
      " handler.minimal_scheme",
      "   = ZWAVE_CONTROLLER_ENCAPSULATION_NETWORK_SCHEME;",
      " handler.command_class = COMMAND_CLASS_xxx;",
      " handler.version       = xxx;",
      " handler.support       = false;",
      " handler.control       = false;",
      "",
      " zwave_command_handler_register_handler(handler);",
      "",
      " return SL_STATUS_OK;",
      "}"
    ],
    "description": "Command Class handler C file"
  },


}